<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.122.0">
    <meta name="generator" content="Relearn 5.23.2+tip">
    <meta name="description" content="啊啊啊啊">
    <meta name="author" content="Sören Weber">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="https://example.com/images/hero.png">
    <meta name="twitter:title" content="Learn OpenGL :: Hugo Relearn Theme">
    <meta name="twitter:description" content="啊啊啊啊">
    <meta property="og:title" content="Learn OpenGL :: Hugo Relearn Theme">
    <meta property="og:description" content="啊啊啊啊">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://example.com/computer_graphics/classic_tutorial/opengl_tutorial/learn_opengl/index.html">
    <meta property="og:image" content="https://example.com/images/hero.png">
    <meta property="og:site_name" content="Hugo Relearn Theme">
    <title>Learn OpenGL :: Hugo Relearn Theme</title>
    <link href="../../../../computer_graphics/classic_tutorial/opengl_tutorial/learn_opengl/index.xml" rel="alternate" type="application/rss+xml" title="Learn OpenGL :: Hugo Relearn Theme">
    <link href="../../../../computer_graphics/classic_tutorial/opengl_tutorial/learn_opengl/index.print.html" rel="alternate" type="text/html" title="Learn OpenGL :: Hugo Relearn Theme"><link rel="icon" href="../../../../images/favicon.ico">
    <!-- https://github.com/filamentgroup/loadCSS/blob/master/README.md#how-to-use -->
    <link href="../../../../css/fontawesome-all.min.css?1708235000" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../../../../css/fontawesome-all.min.css?1708235000" rel="stylesheet"></noscript>
    <link href="../../../../css/nucleus.css?1708235000" rel="stylesheet">
    <link href="../../../../css/auto-complete.css?1708235000" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../../../../css/auto-complete.css?1708235000" rel="stylesheet"></noscript>
    <link href="../../../../css/perfect-scrollbar.min.css?1708235000" rel="stylesheet">
    <link href="../../../../css/fonts.css?1708235000" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../../../../css/fonts.css?1708235000" rel="stylesheet"></noscript>
    <link href="../../../../css/theme.css?1708235000" rel="stylesheet">
    <link href="../../../../css/theme-auto.css?1708235000" rel="stylesheet" id="R-variant-style">
    <link href="../../../../css/variant.css?1708235000" rel="stylesheet">
    <link href="../../../../css/print.css?1708235000" rel="stylesheet" media="print">
    <link href="../../../../css/ie.css?1708235000" rel="stylesheet">
    <script src="../../../../js/url.js?1708235000"></script>
    <script src="../../../../js/variant.js?1708235000"></script>
    <script>
      // hack to let hugo tell us how to get to the root when using relativeURLs, it needs to be called *url= for it to do its magic:
      // https://github.com/gohugoio/hugo/blob/145b3fcce35fbac25c7033c91c1b7ae6d1179da8/transform/urlreplacers/absurlreplacer.go#L72
      window.index_js_url="../../../../index.search.js";
      var root_url="../../../../";
      var baseUri=root_url.replace(/\/$/, '');
      window.relearn = window.relearn || {};
      window.relearn.baseUriFull='https:\/\/example.com/';
      // variant stuff
      window.variants && variants.init( [ 'auto', 'relearn-light', 'relearn-dark', 'zen-light', 'zen-dark', 'neon', 'learn', 'blue', 'green', 'red' ] );
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
    </script>
    <style>
      #R-body img.bg-white {
        background-color: white;
      }
    </style>
  </head>
  <body class="mobile-support html" data-url="../../../../computer_graphics/classic_tutorial/opengl_tutorial/learn_opengl/index.html">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide">
              <button class="topbar-control" onclick="toggleNav()" type="button" title="Menu (CTRL&#43;ALT&#43;n)">
                <i class="fa-fw fas fa-bars"></i>
              </button>
            </div>
            <div class="topbar-button topbar-button-toc" data-content-empty="hide" data-width-s="show" data-width-m="show" data-width-l="show">
              <button class="topbar-control" onclick="toggleTopbarFlyout(this)" type="button" title="Table of Contents (CTRL&#43;ALT&#43;t)">
                <i class="fa-fw fas fa-list-alt"></i>
              </button>
              <div class="topbar-content">
                <div class="topbar-content-wrapper">
<nav class="TableOfContents">
  <ul>
    <li><a href="#前言">前言</a></li>
    <li><a href="#目录">目录</a></li>
    <li><a href="#introduction">Introduction</a>
      <ul>
        <li><a href="#prerequisites">Prerequisites</a></li>
        <li><a href="#structure">Structure</a></li>
        <li><a href="#boxes">Boxes</a></li>
        <li><a href="#code">Code</a></li>
        <li><a href="#color-hints">Color hints</a></li>
        <li><a href="#opengl-function-references">OpenGL Function references</a></li>
      </ul>
    </li>
    <li><a href="#getting-started">Getting started</a>
      <ul>
        <li><a href="#opengl">OpenGL</a></li>
        <li><a href="#creating-a-window">Creating a window</a></li>
        <li><a href="#hello-window">Hello Window</a></li>
        <li><a href="#hello-triangle">Hello Triangle</a></li>
        <li><a href="#shaders">Shaders</a></li>
        <li><a href="#textures">Textures</a></li>
        <li><a href="#transformations">Transformations</a></li>
        <li><a href="#coordinate-systems">Coordinate Systems</a></li>
        <li><a href="#camera">Camera</a></li>
        <li><a href="#review">Review</a></li>
      </ul>
    </li>
    <li><a href="#lighting">Lighting</a>
      <ul>
        <li><a href="#colors">Colors</a></li>
        <li><a href="#basic-lighting">Basic Lighting</a></li>
        <li><a href="#materials">Materials</a></li>
        <li><a href="#lighting-maps">Lighting maps</a></li>
        <li><a href="#light-casters">Light casters</a></li>
        <li><a href="#multiple-lights">Multiple lights</a></li>
        <li><a href="#review-1">Review</a></li>
      </ul>
    </li>
    <li><a href="#model-loading">Model Loading</a>
      <ul>
        <li><a href="#assimp">Assimp</a></li>
        <li><a href="#mesh">Mesh</a></li>
        <li><a href="#model">Model</a></li>
      </ul>
    </li>
    <li><a href="#advanced-opengl">Advanced OpenGL</a>
      <ul>
        <li><a href="#depth-testing">Depth testing</a></li>
        <li><a href="#stencil-testing">Stencil testing</a></li>
        <li><a href="#bleanding">Bleanding</a></li>
        <li><a href="#face-culling">Face culling</a></li>
        <li><a href="#framebuffers">Framebuffers</a></li>
        <li><a href="#cubemaps">Cubemaps</a></li>
        <li><a href="#advanced-data">Advanced Data</a></li>
        <li><a href="#advanced-glsl">Advanced GLSL</a></li>
        <li><a href="#geometry-shader">Geometry Shader</a></li>
        <li><a href="#instancing">Instancing</a></li>
        <li><a href="#anti-aliasing">Anti Aliasing</a></li>
      </ul>
    </li>
    <li><a href="#advanced-lighting">Advanced Lighting</a>
      <ul>
        <li><a href="#advanced-lighting-1">Advanced Lighting</a></li>
        <li><a href="#gamma-correction">Gamma Correction</a></li>
        <li><a href="#shadows">Shadows</a></li>
        <li><a href="#normal-mapping">Normal Mapping</a></li>
        <li><a href="#parallax-mapping">Parallax Mapping</a></li>
        <li><a href="#hdr">HDR</a></li>
        <li><a href="#bloom">Bloom</a></li>
        <li><a href="#deferred-shading">Deferred Shading</a></li>
        <li><a href="#ssao">SSAO</a></li>
      </ul>
    </li>
    <li><a href="#pbr">PBR</a>
      <ul>
        <li><a href="#theory">Theory</a></li>
        <li><a href="#lighting-1">Lighting</a></li>
        <li><a href="#ibl">IBL</a></li>
      </ul>
    </li>
    <li><a href="#in-practice-1">In Practice</a>
      <ul>
        <li><a href="#debugging">Debugging</a></li>
        <li><a href="#text-rendering">Text Rendering</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li></li>
        <li><a href="#2d-game">2D Game</a></li>
      </ul>
    </li>
    <li><a href="#guest-articles">Guest Articles</a>
      <ul>
        <li><a href="#2020">2020</a></li>
        <li><a href="#2022">2022</a></li>
      </ul>
    </li>
  </ul>
</nav>
                </div>
              </div>
            </div>
          </div>
          <ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype="http://schema.org/BreadcrumbList"><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../index.html"><span itemprop="name">主页</span></a><meta itemprop="position" content="1">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../computer_graphics/index.html"><span itemprop="name">计算机图形学</span></a><meta itemprop="position" content="2">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../computer_graphics/classic_tutorial/index.html"><span itemprop="name">经典教程</span></a><meta itemprop="position" content="3">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../computer_graphics/classic_tutorial/opengl_tutorial/index.html"><span itemprop="name">OpenGL教程</span></a><meta itemprop="position" content="4">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><span itemprop="name">Learn OpenGL</span><meta itemprop="position" content="5"></li>
          </ol>
          <div class="topbar-area topbar-area-end" data-area="end">
            <div class="topbar-button topbar-button-print" data-content-empty="disable" data-width-s="area-more" data-width-m="show" data-width-l="show">
              <a class="topbar-control" href="../../../../computer_graphics/classic_tutorial/opengl_tutorial/learn_opengl/index.print.html" title="Print whole chapter (CTRL&#43;ALT&#43;p)">
                <i class="fa-fw fas fa-print"></i>
              </a>
            </div>
            <div class="topbar-button topbar-button-prev" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show">
              <a class="topbar-control" href="../../../../computer_graphics/classic_tutorial/opengl_tutorial/index.html" title="OpenGL教程 (🡐)">
                <i class="fa-fw fas fa-chevron-left"></i>
              </a>
            </div>
            <div class="topbar-button topbar-button-next" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show">
              <a class="topbar-control" href="../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/index.html" title="OGL dev 教程 (🡒)">
                <i class="fa-fw fas fa-chevron-right"></i>
              </a>
            </div>
            <div class="topbar-button topbar-button-more" data-content-empty="hide" data-width-s="show" data-width-m="show" data-width-l="show">
              <button class="topbar-control" onclick="toggleTopbarFlyout(this)" type="button" title="More">
                <i class="fa-fw fas fa-ellipsis-v"></i>
              </button>
              <div class="topbar-content">
                <div class="topbar-content-wrapper">
                  <div class="topbar-area topbar-area-more" data-area="more">
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable default" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="default">
            <header class="headline">
            </header>
<h1 id="learn-opengl">Learn OpenGL</h1>

<h2 id="前言">前言</h2>
<p>这是我第一个接触到 OpenGL 入门教程（<a href="https://learnopengl.com/Introduction" target="_blank">官方网址</a>），该教程还有<a href="https://learnopengl-cn.github.io/" target="_blank">中文版</a>的。非常适合入门学习，示例代码都很完整，拷贝下来直接就能运行。并且该教程中还有完整的游戏示例，比较吸引人。此教程也被作者制成电子书了，方便在阅读设备上学习。</p>
<h2 id="目录">目录</h2>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#getting-started">Getting started</a>
<ul>
<li><a href="#opengl">OpenGL</a></li>
<li><a href="#creating-a-window">Creating a window</a></li>
<li><a href="#hello-window">Hello Window</a></li>
<li><a href="#hello-triangle">Hello Triangle</a></li>
<li><a href="#shaders">Shaders</a></li>
<li><a href="#textures">Textures</a></li>
<li><a href="#transformations">Transformations</a></li>
<li><a href="#coordinate-systems">Coordinate Systems</a></li>
<li><a href="#camera">Camera</a></li>
<li><a href="#review">Review</a></li>
</ul>
</li>
<li><a href="#lighting">Lighting</a>
<ul>
<li><a href="#colors">Colors</a></li>
<li><a href="#basic-lighting">Basic Lighting</a></li>
<li><a href="#materials">Materials</a></li>
<li><a href="#lighting-maps">Lighting maps</a></li>
<li><a href="#light-casters">Light casters</a></li>
<li><a href="#multiple-lights">Multiple lights</a></li>
<li><a href="#review-1">Review</a></li>
</ul>
</li>
<li><a href="#model-loading">Model Loading</a>
<ul>
<li><a href="#assimp">Assimp</a></li>
<li><a href="#mesh">Mesh</a></li>
<li><a href="#model">Model</a></li>
</ul>
</li>
<li><a href="#advanced-opengl">Advanced OpenGL</a>
<ul>
<li><a href="#depth-testing">Depth testing</a></li>
<li><a href="#stencil-testing">Stencil testing</a></li>
<li><a href="#bleanding">Bleanding</a></li>
<li><a href="#face-culling">Face culling</a></li>
<li><a href="#framebuffers">Framebuffers</a></li>
<li><a href="#cubemaps">Cubemaps</a></li>
<li><a href="#advanced-data">Advanced Data</a></li>
<li><a href="#advanced-glsl">Advanced GLSL</a></li>
<li><a href="#geometry-shader">Geometry Shader</a></li>
<li><a href="#instancing">Instancing</a></li>
<li><a href="#anti-aliasing">Anti Aliasing</a></li>
</ul>
</li>
<li><a href="#advanced-lighting">Advanced Lighting</a>
<ul>
<li><a href="#advanced-lighting-1">Advanced Lighting</a></li>
<li><a href="#gamma-correction">Gamma Correction</a></li>
<li><a href="#shadows">Shadows</a></li>
<li><a href="#normal-mapping">Normal Mapping</a></li>
<li><a href="#parallax-mapping">Parallax Mapping</a></li>
<li><a href="#hdr">HDR</a></li>
<li><a href="#bloom">Bloom</a></li>
<li><a href="#deferred-shading">Deferred Shading</a></li>
<li><a href="#ssao">SSAO</a></li>
</ul>
</li>
<li><a href="#pbr">PBR</a>
<ul>
<li><a href="#theory">Theory</a></li>
<li><a href="#lighting-1">Lighting</a></li>
<li><a href="#ibl">IBL</a></li>
</ul>
</li>
<li><a href="#in-practice-1">In Practice</a>
<ul>
<li><a href="#debugging">Debugging</a></li>
<li><a href="#text-rendering">Text Rendering</a></li>
<li><a href="#2d-game">2D Game</a></li>
</ul>
</li>
<li><a href="#guest-articles">Guest Articles</a>
<ul>
<li><a href="#2020">2020</a></li>
<li>2021</li>
<li>2022</li>
</ul>
</li>
</ul>
<h2 id="introduction">Introduction</h2>
<p>Since you came here you probably want to learn the inner workings of computer graphics and do all the stuff the cool kids do by yourself. Doing things by yourself is extremely fun and resourceful and gives you a great understanding of graphics programming. However, there are a few items that need to be taken into consideration before starting your journey.</p>
<h3 id="prerequisites">Prerequisites</h3>
<p>Since OpenGL is a graphics API and not a platform of its own, it requires a language to operate in and the language of choice is <code>C++</code>. Therefore a decent knowledge of the <code>C++</code> programming language is required for these chapters. However, I will try to explain most of the concepts used, including advanced <code>C++</code> topics where required so it is not required to be an expert in <code>C++</code>, but you should be able to write more than just a <code>'Hello World'</code> program. If you don&rsquo;t have much experience with <code>C++</code> I can recommend the free tutorials at <a href="http://www.learncpp.com/" target="_blank">www.learncpp.com</a>.</p>
<p>Also, we will be using some math (linear algebra, geometry, and trigonometry) along the way and I will try to explain all the required concepts of the math required. However, I&rsquo;m not a mathematician by heart so even though my explanations may be easy to understand, they will most likely be incomplete. So where necessary I will provide pointers to good resources that explain the material in a more complete fashion. Don&rsquo;t be scared about the mathematical knowledge required before starting your journey into OpenGL; almost all the concepts can be understood with a basic mathematical background and I will try to keep the mathematics to a minimum where possible. Most of the functionality doesn&rsquo;t even require you to understand all the math as long as you know how to use it.</p>
<h3 id="structure">Structure</h3>
<p>LearnOpenGL is broken down into a number of general sections. Each section contains several chapters that each explain different concepts in large detail. Each of the chapters can be found at the menu to your left. The concepts are taught in a linear fashion (so it is advised to start from the top to the bottom, unless otherwise instructed) where each chapter explains the background theory and the practical aspects.</p>
<p>To make the concepts easier to follow, and give them some added structure, the book contains <em>boxes</em>, <em>code blocks</em>, <em>color hints</em> and <em>function references</em>.</p>
<h3 id="boxes">Boxes</h3>
<p><note><strong>Green</strong> boxes encompasses some notes or useful features/hints about OpenGL or the subject at hand.</note></p>
<p><warning><strong>Red</strong> boxes will contain warnings or other features you have to be extra careful with.</warning></p>
<h3 id="code">Code</h3>
<p>You will find plenty of small pieces of code in the website that are located in dark-gray boxes with syntax-highlighted code as you can see below:</p>
<div class="wrap-code highlight"><pre tabindex="0"><code>// This box contains code </code></pre></div><p>Since these provide only snippets of code, wherever necessary I will provide a link to the entire source code required for a given subject.</p>
<h3 id="color-hints">Color hints</h3>
<p>Some words are displayed with a different color to make it extra clear these words portray a special meaning:</p>
<ul>
<li>Definition: green words specify a definition i.e. an important aspect/name of something you&rsquo;re likely to hear more often.</li>
<li>Program structure: red words specify function names or class names.</li>
<li>Variables: blue words specify variables including all OpenGL constants.</li>
</ul>
<h3 id="opengl-function-references">OpenGL Function references</h3>
<p>A particularly well appreciated feature of LearnOpenGL is the ability to review most of OpenGL&rsquo;s functions wherever they show up in the content. Whenever a function is found in the content that is documented at the website, the function will show up with a slightly noticeable underline. You can hover the mouse over the function and after a small interval, a pop-up window will show relevant information about this function including a nice overview of what the function actually does. Hover your mouse over glEnable to see it in action.</p>
<p>Now that you got a bit of a feel of the structure of the site, hop over to the Getting Started section to start your journey in OpenGL!</p>
<h2 id="getting-started">Getting started</h2>
<h3 id="opengl">OpenGL</h3>
<p>Before starting our journey we should first define what OpenGL actually is. OpenGL is mainly considered an API (an Application Programming Interface) that provides us with a large set of functions that we can use to manipulate graphics and images. However, OpenGL by itself is not an API, but merely a specification, developed and maintained by the <a href="http://www.khronos.org/" target="_blank">Khronos Group</a>.</p>
<p><img src="./assets/opengl.jpg" class="right medium" /></p>
<p>The OpenGL specification specifies exactly what the result/output of each function should be and how it should perform. It is then up to the developers <em>implementing</em> this specification to come up with a solution of how this function should operate. Since the OpenGL specification does not give us implementation details, the actual developed versions of OpenGL are allowed to have different implementations, as long as their results comply with the specification (and are thus the same to the user).</p>
<p>The people developing the actual OpenGL libraries are usually the graphics card manufacturers. Each graphics card that you buy supports specific versions of OpenGL which are the versions of OpenGL developed specifically for that card (series). When using an Apple system the OpenGL library is maintained by Apple themselves and under Linux there exists a combination of graphic suppliers&rsquo; versions and hobbyists&rsquo; adaptations of these libraries. This also means that whenever OpenGL is showing weird behavior that it shouldn&rsquo;t, this is most likely the fault of the graphics cards manufacturers (or whoever developed/maintained the library).</p>
<p><note>Since most implementations are built by graphics card manufacturers, whenever there is a bug in the implementation this is usually solved by updating your video card drivers; those drivers include the newest versions of OpenGL that your card supports. This is one of the reasons why it&rsquo;s always advised to occasionally update your graphic drivers.</note></p>
<p>Khronos publicly hosts all specification documents for all the OpenGL versions. The interested reader can find the OpenGL specification of version 3.3 (which is what we&rsquo;ll be using) <a href="https://www.opengl.org/registry/doc/glspec33.core.20100311.withchanges.pdf" target="_blank">here</a> (<a href="https://pan.baidu.com/s/1EIluizOxwLdMDbslwaKdow" target="_blank">网盘分享</a>) which is a good read if you want to delve into the details of OpenGL (note how they mostly just describe results and not implementations). The specifications also provide a great reference for finding the <strong>exact</strong> workings of its functions.</p>
<h4 id="core-profile-vs-immediate-mode">Core-profile vs Immediate mode</h4>
<p>In the old days, using OpenGL meant developing in immediate mode (often referred to as the fixed function pipeline) which was an easy-to-use method for drawing graphics. Most of the functionality of OpenGL was hidden inside the library and developers did not have much control over how OpenGL does its calculations. Developers eventually got hungry for more flexibility and over time the specifications became more flexible as a result; developers gained more control over their graphics. The immediate mode is really easy to use and understand, but it is also extremely inefficient. For that reason the specification started to deprecate immediate mode functionality from version 3.2 onwards and started motivating developers to develop in OpenGL&rsquo;s core-profile mode, which is a division of OpenGL&rsquo;s specification that removed all old deprecated functionality.</p>
<p>When using OpenGL&rsquo;s core-profile, OpenGL forces us to use modern practices. Whenever we try to use one of OpenGL&rsquo;s deprecated functions, OpenGL raises an error and stops drawing. The advantage of learning the modern approach is that it is very flexible and efficient. However, it&rsquo;s also more difficult to learn. The immediate mode abstracted quite a lot from the <strong>actual</strong> operations OpenGL performed and while it was easy to learn, it was hard to grasp how OpenGL actually operates. The modern approach requires the developer to truly understand OpenGL and graphics programming and while it is a bit difficult, it allows for much more flexibility, more efficiency and most importantly: a much better understanding of graphics programming.</p>
<p>This is also the reason why this book is geared at core-profile OpenGL version 3.3. Although it is more difficult, it is greatly worth the effort.</p>
<p>As of today, higher versions of OpenGL are available to choose from (at the time of writing 4.6) at which you may ask: why do I want to learn OpenGL 3.3 when OpenGL 4.6 is out? The answer to that question is relatively simple. All future versions of OpenGL starting from 3.3 add extra useful features to OpenGL without changing OpenGL&rsquo;s core mechanics; the newer versions just introduce slightly more efficient or more useful ways to accomplish the same tasks. The result is that all concepts and techniques remain the same over the modern OpenGL versions so it is perfectly valid to learn OpenGL 3.3. Whenever you&rsquo;re ready and/or more experienced you can easily use specific functionality from more recent OpenGL versions.</p>
<p><warning>When using functionality from the most recent version of OpenGL, only the most modern graphics cards will be able to run your application. This is often why most developers generally target lower versions of OpenGL and optionally enable higher version functionality.</warning></p>
<p>In some chapters you&rsquo;ll find more modern features which are noted down as such.</p>
<h4 id="extensions">Extensions</h4>
<p>A great feature of OpenGL is its support of extensions. Whenever a graphics company comes up with a new technique or a new large optimization for rendering this is often found in an extension implemented in the drivers. If the hardware an application runs on supports such an extension the developer can use the functionality provided by the extension for more advanced or efficient graphics. This way, a graphics developer can still use these new rendering techniques without having to wait for OpenGL to include the functionality in its future versions, simply by checking if the extension is supported by the graphics card. Often, when an extension is popular or very useful it eventually becomes part of future OpenGL versions.</p>
<p>The developer has to query whether any of these extensions are available before using them (or use an OpenGL extension library). This allows the developer to do things better or more efficient, based on whether an extension is available:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">if</span><span class="p">(</span><span class="n">GL_ARB_extension_name</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="c1">// Do cool new and modern stuff supported by hardware
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="k">else</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl">    <span class="c1">// Extension not supported: do it the old way
</span></span></span><span class="line"><span class="ln">8</span><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></div><p>With OpenGL version 3.3 we rarely need an extension for most techniques, but wherever it is necessary proper instructions are provided.</p>
<h4 id="state-machine">State machine</h4>
<p>OpenGL is by itself a large state machine: a collection of variables that define how OpenGL should currently operate. The state of OpenGL is commonly referred to as the OpenGL context. When using OpenGL, we often change its state by setting some options, manipulating some buffers and then render using the current context.</p>
<p>Whenever we tell OpenGL that we now want to draw lines instead of triangles for example, we change the state of OpenGL by changing some context variable that sets how OpenGL should draw. As soon as we change the context by telling OpenGL it should draw lines, the next drawing commands will now draw lines instead of triangles.</p>
<p>When working in OpenGL we will come across several state-changing functions that change the context and several state-using functions that perform some operations based on the current state of OpenGL. As long as you keep in mind that OpenGL is basically one large state machine, most of its functionality will make more sense.</p>
<h4 id="objects">Objects</h4>
<p>The OpenGL libraries are written in C and allows for many derivations in other languages, but in its core it remains a C-library. Since many of C&rsquo;s language-constructs do not translate that well to other higher-level languages, OpenGL was developed with several abstractions in mind. One of those abstractions are objects in OpenGL.</p>
<p>An object in OpenGL is a collection of options that represents a subset of OpenGL&rsquo;s state. For example, we could have an object that represents the settings of the drawing window; we could then set its size, how many colors it supports and so on. One could visualize an object as a C-like struct:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">struct</span> <span class="nc">object_name</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">    <span class="kt">float</span>  <span class="n">option1</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="kt">int</span>    <span class="n">option2</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="kt">char</span><span class="p">[]</span> <span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="p">};</span></span></span></code></pre></div><p>Whenever we want to use objects it generally looks something like this (with OpenGL&rsquo;s context visualized as a large struct):</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="c1">// The State of OpenGL
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">OpenGL_Context</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">  	<span class="p">...</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">  	<span class="n">object_name</span><span class="o">*</span> <span class="n">object_Window_Target</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">  	<span class="p">...</span>  	
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="p">};</span></span></span></code></pre></div><div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="c1">// create object
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1"></span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">objectId</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">glGenObject</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">objectId</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1">// bind/assign object to context
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="c1"></span><span class="n">glBindObject</span><span class="p">(</span><span class="n">GL_WINDOW_TARGET</span><span class="p">,</span> <span class="n">objectId</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="c1">// set options of object currently bound to GL_WINDOW_TARGET
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1"></span><span class="n">glSetObjectOption</span><span class="p">(</span><span class="n">GL_WINDOW_TARGET</span><span class="p">,</span> <span class="n">GL_OPTION_WINDOW_WIDTH</span><span class="p">,</span>  <span class="mi">800</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="n">glSetObjectOption</span><span class="p">(</span><span class="n">GL_WINDOW_TARGET</span><span class="p">,</span> <span class="n">GL_OPTION_WINDOW_HEIGHT</span><span class="p">,</span> <span class="mi">600</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1">// set context target back to default
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1"></span><span class="n">glBindObject</span><span class="p">(</span><span class="n">GL_WINDOW_TARGET</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span></span></span></code></pre></div><p>This little piece of code is a workflow you&rsquo;ll frequently see when working with OpenGL. We first create an object and store a reference to it as an id (the real object&rsquo;s data is stored behind the scenes). Then we bind the object (using its id) to the target location of the context (the location of the example window object target is defined as GL_WINDOW_TARGET). Next we set the window options and finally we un-bind the object by setting the current object id of the window target to <code>0</code>. The options we set are stored in the object referenced by objectId and restored as soon as we bind the object back to GL_WINDOW_TARGET.</p>
<p><warning>The code samples provided so far are only approximations of how OpenGL operates; throughout the book you will come across enough actual examples.</warning></p>
<p>The great thing about using these objects is that we can define more than one object in our application, set their options and whenever we start an operation that uses OpenGL&rsquo;s state, we bind the object with our preferred settings. There are objects for example that act as container objects for 3D model data (a house or a character) and whenever we want to draw one of them, we bind the object containing the model data that we want to draw (we first created and set options for these objects). Having several objects allows us to specify many models and whenever we want to draw a specific model, we simply bind the corresponding object before drawing without setting all their options again.</p>
<h4 id="lets-get-started">Let&rsquo;s get started</h4>
<p>You now learned a bit about OpenGL as a specification and a library, how OpenGL approximately operates under the hood and a few custom tricks that OpenGL uses. Don&rsquo;t worry if you didn&rsquo;t get all of it; throughout the book we&rsquo;ll walk through each step and you&rsquo;ll see enough examples to really get a grasp of OpenGL.</p>
<h4 id="additional-resources">Additional resources</h4>
<ul>
<li><a href="https://www.opengl.org/" target="_blank">opengl.org</a>: official website of OpenGL.</li>
<li><a href="https://www.opengl.org/registry/" target="_blank">OpenGL registry</a>: hosts the OpenGL specifications and extensions for all OpenGL versions.</li>
</ul>
<h3 id="creating-a-window">Creating a window</h3>
<p>The first thing we need to do before we start creating stunning graphics is to create an OpenGL context and an application window to draw in. However, those operations are specific per operating system and OpenGL purposefully tries to abstract itself from these operations. This means we have to create a window, define a context, and handle user input all by ourselves.</p>
<p>Luckily, there are quite a few libraries out there that provide the functionality we seek, some specifically aimed at OpenGL. Those libraries save us all the operation-system specific work and give us a window and an OpenGL context to render in. Some of the more popular libraries are GLUT, SDL, SFML and GLFW. On LearnOpenGL we will be using <strong>GLFW</strong>. Feel free to use any of the other libraries, the setup for most is similar to GLFW&rsquo;s setup.</p>
<h4 id="glfw">GLFW</h4>
<p>GLFW is a library, written in C, specifically targeted at OpenGL. GLFW gives us the bare necessities required for rendering goodies to the screen. It allows us to create an OpenGL context, define window parameters, and handle user input, which is plenty enough for our purposes.</p>
<p>The focus of this and the next chapter is to get GLFW up and running, making sure it properly creates an OpenGL context and that it displays a simple window for us to mess around in. This chapter takes a step-by-step approach in retrieving, building and linking the GLFW library. We&rsquo;ll use Microsoft Visual Studio 2019 IDE as of this writing (note that the process is the same on the more recent visual studio versions). If you&rsquo;re not using Visual Studio (or an older version) don&rsquo;t worry, the process will be similar on most other IDEs.</p>
<h4 id="building-glfw">Building GLFW</h4>
<p>GLFW can be obtained from their webpage&rsquo;s <a href="http://www.glfw.org/download.html" target="_blank">download</a> page. GLFW already has pre-compiled binaries and header files for Visual Studio 2012 up to 2019, but for completeness&rsquo; sake we will compile GLFW ourselves from the source code. This is to give you a feel for the process of compiling open-source libraries yourself as not every library will have pre-compiled binaries available. So let&rsquo;s download the <em>Source package</em>.</p>
<p><warning>We&rsquo;ll be building all libraries as 64-bit binaries so make sure to get the 64-bit binaries if you&rsquo;re using their pre-compiled binaries.</warning></p>
<p>Once you&rsquo;ve downloaded the source package, extract it and open its content. We are only interested in a few items:</p>
<ul>
<li>The resulting library from compilation.</li>
<li>The <strong>include</strong> folder.</li>
</ul>
<p>Compiling the library from the source code guarantees that the resulting library is perfectly tailored for your CPU/OS, a luxury pre-compiled binaries don&rsquo;t always provide (sometimes, pre-compiled binaries are not available for your system). The problem with providing source code to the open world however is that not everyone uses the same IDE or build system for developing their application, which means the project/solution files provided may not be compatible with other people&rsquo;s setup. So people then have to setup their own project/solution with the given .c/.cpp and .h/.hpp files, which is cumbersome. Exactly for those reasons there is a tool called CMake.</p>
<h4 id="cmake">CMake</h4>
<p>CMake is a tool that can generate project/solution files of the user&rsquo;s choice (e.g. Visual Studio, Code::Blocks, Eclipse) from a collection of source code files using pre-defined CMake scripts. This allows us to generate a Visual Studio 2019 project file from GLFW&rsquo;s source package which we can use to compile the library. First we need to download and install CMake which can be downloaded on their <a href="http://www.cmake.org/cmake/resources/software.html" target="_blank">download</a> page.</p>
<p>Once CMake is installed you can choose to run CMake from the command line or through their GUI. Since we&rsquo;re not trying to overcomplicate things we&rsquo;re going to use the GUI. CMake requires a source code folder and a destination folder for the binaries. For the source code folder we&rsquo;re going to choose the root folder of the downloaded GLFW source package and for the build folder we&rsquo;re creating a new directory <em>build</em> and then select that directory.</p>
<p><a href="#R-image-81963e8b2368786d4995e83db5ba0503" class="lightbox-link"><img src="./assets/cmake.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-81963e8b2368786d4995e83db5ba0503"><img src="./assets/cmake.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Once the source and destination folders have been set, click the <code>Configure</code> button so CMake can read the required settings and the source code. We then have to choose the generator for the project and since we&rsquo;re using Visual Studio 2019 we will choose the <code>Visual Studio 16</code> option (Visual Studio 2019 is also known as Visual Studio 16). CMake will then display the possible build options to configure the resulting library. We can leave them to their default values and click <code>Configure</code> again to store the settings. Once the settings have been set, we click <code>Generate</code> and the resulting project files will be generated in your <code>build</code> folder.</p>
<h5 id="compilation">Compilation</h5>
<p>In the <code>build</code> folder a file named <code>GLFW.sln</code> can now be found and we open it with Visual Studio 2019. Since CMake generated a project file that already contains the proper configuration settings we only have to build the solution. CMake should&rsquo;ve automatically configured the solution so it compiles to a 64-bit library; now hit build solution. This will give us a compiled library file that can be found in <code>build/src/Debug</code> named <code>glfw3.lib</code>.</p>
<p>Once we generated the library we need to make sure the IDE knows where to find the library and the include files for our OpenGL program. There are two common approaches in doing this:</p>
<ol>
<li>We find the <code>/lib</code> and <code>/include</code> folders of the IDE/compiler and add the content of GLFW&rsquo;s <code>include</code> folder to the IDE&rsquo;s <code>/include</code> folder and similarly add <code>glfw3.lib</code> to the IDE&rsquo;s <code>/lib</code> folder. This works, but it&rsquo;s is not the recommended approach. It&rsquo;s hard to keep track of your library and include files and a new installation of your IDE/compiler results in you having to do this process all over again.</li>
<li>Another approach (and recommended) is to create a new set of directories at a location of your choice that contains all the header files/libraries from third party libraries to which you can refer to from your IDE/compiler. You could, for instance, create a single folder that contains a <code>Libs</code> and <code>Include</code> folder where we store all our library and header files respectively for OpenGL projects. Now all the third party libraries are organized within a single location (that can be shared across multiple computers). The requirement is, however, that each time we create a new project we have to tell the IDE where to find those directories.</li>
</ol>
<p>Once the required files are stored at a location of your choice, we can start creating our first OpenGL GLFW project.</p>
<h4 id="our-first-project">Our first project</h4>
<p>First, let&rsquo;s open up Visual Studio and create a new project. Choose C++ if multiple options are given and take the <code>Empty Project</code> (don&rsquo;t forget to give your project a suitable name). Since we&rsquo;re going to be doing everything in 64-bit and the project defaults to 32-bit, we&rsquo;ll need to change the dropdown at the top next to Debug from x86 to x64:</p>
<p><a href="#R-image-d4308639f8ea31b62f195058c593b5a6" class="lightbox-link"><img src="./assets/x64.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d4308639f8ea31b62f195058c593b5a6"><img src="./assets/x64.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Once that&rsquo;s done, we now have a workspace to create our very first OpenGL application!</p>
<h4 id="linking">Linking</h4>
<p>In order for the project to use GLFW we need to link the library with our project. This can be done by specifying we want to use <code>glfw3.lib</code> in the linker settings, but our project does not yet know where to find <code>glfw3.lib</code> since we store our third party libraries in a different directory. We thus need to add this directory to the project first.</p>
<p>We can tell the IDE to take this directory into account when it needs to look for library and include files. Right-click the project name in the solution explorer and then go to <code>VC++ Directories</code> as seen in the image below:</p>
<p><a href="#R-image-36e1f23666846ad5f5d6a091c16a8b23" class="lightbox-link"><img src="./assets/vc_directories.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-36e1f23666846ad5f5d6a091c16a8b23"><img src="./assets/vc_directories.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>From there on out you can add your own directories to let the project know where to search. This can be done by manually inserting it into the text or clicking the appropriate location string and selecting the <code>&lt;Edit..&gt;</code> option. Do this for both the <code>Library Directories</code> and <code>Include Directories</code>:</p>
<p><a href="#R-image-72e77e90a82d53eaef77641fb710077b" class="lightbox-link"><img src="./assets/include_directories.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-72e77e90a82d53eaef77641fb710077b"><img src="./assets/include_directories.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Here you can add as many extra directories as you&rsquo;d like and from that point on the IDE will also search those directorie when searching for library and header files. As soon as your <code>Include</code> folder from GLFW is included, you will be able to find all the header files for GLFW by including <code>&lt;GLFW/..&gt;</code>. The same applies for the library directories.</p>
<p>Since VS can now find all the required files we can finally link GLFW to the project by going to the <code>Linker</code> tab and <code>Input</code>:</p>
<p><a href="#R-image-b03b3ef988b15befa0a8b0408bee0ae6" class="lightbox-link"><img src="./assets/linker_input.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b03b3ef988b15befa0a8b0408bee0ae6"><img src="./assets/linker_input.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>To then link to a library you&rsquo;d have to specify the name of the library to the linker. Since the library name is <code>glfw3.lib</code>, we add that to the <code>Additional Dependencies</code> field (either manually or using the <code>&lt;Edit..&gt;</code> option) and from that point on GLFW will be linked when we compile. In addition to GLFW we should also add a link entry to the OpenGL library, but this may differ per operating system:</p>
<h5 id="opengl-library-on-windows">OpenGL library on Windows</h5>
<p>If you&rsquo;re on Windows the OpenGL library <code>opengl32.lib</code> comes with the Microsoft SDK, which is installed by default when you install Visual Studio. Since this chapter uses the VS compiler and is on windows we add <code>opengl32.lib</code> to the linker settings. Note that the 64-bit equivalent of the OpenGL library is called <code>opengl32.lib</code>, just like the 32-bit equivalent, which is a bit of an unfortunate name.</p>
<h5 id="opengl-library-on-linux">OpenGL library on Linux</h5>
<p>On Linux systems you need to link to the <code>libGL.so</code> library by adding <code>-lGL</code> to your linker settings. If you can&rsquo;t find the library you probably need to install any of the Mesa, NVidia or AMD dev packages.</p>
<p>Then, once you&rsquo;ve added both the GLFW and OpenGL library to the linker settings you can include the header files for GLFW as follows:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;GLFW/glfw3.h&gt;</span></span></span></code></pre></div><p><note>For Linux users compiling with GCC, the following command line options may help you compile the project: <code>-lglfw3 -lGL -lX11 -lpthread -lXrandr -lXi -ldl</code>. Not correctly linking the corresponding libraries will generate many <em>undefined reference</em> errors.</note></p>
<p>This concludes the setup and configuration of GLFW.</p>
<h4 id="glad">GLAD</h4>
<p>We&rsquo;re still not quite there yet, since there is one other thing we still need to do. Because OpenGL is only really a standard/specification it is up to the driver manufacturer to implement the specification to a driver that the specific graphics card supports. Since there are many different versions of OpenGL drivers, the location of most of its functions is not known at compile-time and needs to be queried at run-time. It is then the task of the developer to retrieve the location of the functions he/she needs and store them in function pointers for later use. Retrieving those locations is <a href="https://www.khronos.org/opengl/wiki/Load_OpenGL_Functions" target="_blank">OS-specific</a>. In Windows it looks something like this:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="c1">// define the function&#39;s prototype
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="nf">void</span> <span class="p">(</span><span class="o">*</span><span class="n">GL_GENBUFFERS</span><span class="p">)</span> <span class="p">(</span><span class="n">GLsizei</span><span class="p">,</span> <span class="n">GLuint</span><span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="c1">// find the function and assign it to a function pointer
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="c1"></span><span class="n">GL_GENBUFFERS</span> <span class="n">glGenBuffers</span>  <span class="o">=</span> <span class="p">(</span><span class="n">GL_GENBUFFERS</span><span class="p">)</span><span class="n">wglGetProcAddress</span><span class="p">(</span><span class="s">&#34;glGenBuffers&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="c1">// function can now be called as normal
</span></span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="c1"></span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">buffer</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="n">glGenBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buffer</span><span class="p">);</span></span></span></code></pre></div><p>As you can see the code looks complex and it&rsquo;s a cumbersome process to do this for each function you may need that is not yet declared. Thankfully, there are libraries for this purpose as well where <strong>GLAD</strong> is a popular and up-to-date library.</p>
<h5 id="setting-up-glad">Setting up GLAD</h5>
<p>GLAD is an <a href="https://github.com/Dav1dde/glad" target="_blank">open source</a> library that manages all that cumbersome work we talked about. GLAD has a slightly different configuration setup than most common open source libraries. GLAD uses a <a href="http://glad.dav1d.de/" target="_blank">web service</a> where we can tell GLAD for which version of OpenGL we&rsquo;d like to define and load all relevant OpenGL functions according to that version.</p>
<p>Go to the GLAD <a href="http://glad.dav1d.de/" target="_blank">web service</a>, make sure the language is set to C++, and in the API section select an OpenGL version of at least 3.3 (which is what we&rsquo;ll be using; higher versions are fine as well). Also make sure the profile is set to <em>Core</em> and that the <em>Generate a loader</em> option is ticked. Ignore the extensions (for now) and click <em>Generate</em> to produce the resulting library files.</p>
<p><warning>Make sure you use the GLAD1 version from: <a href="https://glad.dav1d.de/" target="_blank">https://glad.dav1d.de/</a> as linked above. There&rsquo;s also a GLAD2 version that won&rsquo;t compile here.</warning></p>
<p>GLAD by now should have provided you a zip file containing two include folders, and a single <code>glad.c</code> file. Copy both include folders (<code>glad</code> and <code>KHR</code>) into your include(s) directoy (or add an extra item pointing to these folders), and add the <code>glad.c</code> file to your project.</p>
<p>After the previous steps, you should be able to add the following include directive above your file:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;glad/glad.h&gt;</span><span class="cp"> </span></span></span></code></pre></div><p>Hitting the compile button shouldn&rsquo;t give you any errors, at which point we&rsquo;re set to go for the <a href="https://learnopengl.com/Getting-started/Hello-Window" target="_blank">next</a> chapter where we&rsquo;ll discuss how we can actually use GLFW and GLAD to configure an OpenGL context and spawn a window. Be sure to check that all your include and library directories are correct and that the library names in the linker settings match the corresponding libraries.</p>
<h4 id="additional-resources-1">Additional resources</h4>
<ul>
<li><a href="http://www.glfw.org/docs/latest/window_guide.html" target="_blank">GLFW: Window Guide</a>: official GLFW guide on setting up and configuring a GLFW window.</li>
<li><a href="http://www.opengl-tutorial.org/miscellaneous/building-your-own-c-application/" target="_blank">Building applications</a>: provides great info about the compilation/linking process of your application and a large list of possible errors (plus solutions) that may come up.</li>
<li><a href="http://wiki.codeblocks.org/index.php?title=Using_GLFW_with_Code::Blocks" target="_blank">GLFW with Code::Blocks</a>: building GLFW in Code::Blocks IDE.</li>
<li><a href="http://www.cmake.org/runningcmake/" target="_blank">Running CMake</a>: short overview of how to run CMake on both Windows and Linux.</li>
<li><a href="https://learnopengl.com/demo/autotools_tutorial.txt" target="_blank">Writing a build system under Linux</a>: an autotools tutorial by Wouter Verholst on how to write a build system in Linux.</li>
<li><a href="https://github.com/Polytonic/Glitter" target="_blank">Polytonic/Glitter</a>: a simple boilerplate project that comes pre-configured with all relevant libraries; great for if you want a sample project without the hassle of having to compile all the libraries yourself.</li>
</ul>
<h3 id="hello-window">Hello Window</h3>
<p>Let&rsquo;s see if we can get GLFW up and running. First, create a <code>.cpp</code> file and add the following includes to the top of your newly created file.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;glad/glad.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;GLFW/glfw3.h&gt;</span></span></span></code></pre></div><p><warning>Be sure to include GLAD before GLFW. The include file for GLAD includes the required OpenGL headers behind the scenes (like <code>GL/gl.h</code>) so be sure to include GLAD before other header files that require OpenGL (like GLFW).</warning></p>
<p>Next, we create the main function where we will instantiate the GLFW window:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="n">glfwInit</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="n">glfwWindowHint</span><span class="p">(</span><span class="n">GLFW_CONTEXT_VERSION_MAJOR</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="n">glfwWindowHint</span><span class="p">(</span><span class="n">GLFW_CONTEXT_VERSION_MINOR</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="n">glfwWindowHint</span><span class="p">(</span><span class="n">GLFW_OPENGL_PROFILE</span><span class="p">,</span> <span class="n">GLFW_OPENGL_CORE_PROFILE</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="c1">//glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="c1"></span>  
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>In the main function we first initialize GLFW with glfwInit, after which we can configure GLFW using glfwWindowHint. The first argument of glfwWindowHint tells us what option we want to configure, where we can select the option from a large enum of possible options prefixed with <code>GLFW_</code>. The second argument is an integer that sets the value of our option. A list of all the possible options and its corresponding values can be found at <a href="http://www.glfw.org/docs/latest/window.html#window_hints" target="_blank">GLFW&rsquo;s window handling</a> documentation. If you try to run the application now and it gives a lot of <em>undefined reference</em> errors it means you didn&rsquo;t successfully link the GLFW library.</p>
<p>Since the focus of this book is on OpenGL version 3.3 we&rsquo;d like to tell GLFW that 3.3 is the OpenGL version we want to use. This way GLFW can make the proper arrangements when creating the OpenGL context. This ensures that when a user does not have the proper OpenGL version GLFW fails to run. We set the major and minor version both to <code>3</code>. We also tell GLFW we want to explicitly use the core-profile. Telling GLFW we want to use the core-profile means we&rsquo;ll get access to a smaller subset of OpenGL features without backwards-compatible features we no longer need. Note that on Mac OS X you need to add <code>glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);</code> to your initialization code for it to work.</p>
<p><note>Make sure you have OpenGL versions 3.3 or higher installed on your system/hardware otherwise the application will crash or display undefined behavior. To find the OpenGL version on your machine either call <strong>glxinfo</strong> on Linux machines or use a utility like the <a href="http://download.cnet.com/OpenGL-Extensions-Viewer/3000-18487_4-34442.html" target="_blank">OpenGL Extension Viewer</a> for Windows. If your supported version is lower try to check if your video card supports OpenGL 3.3+ (otherwise it&rsquo;s really old) and/or update your drivers.</note></p>
<p>Next we&rsquo;re required to create a window object. This window object holds all the windowing data and is required by most of GLFW&rsquo;s other functions.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">GLFWwindow</span><span class="o">*</span> <span class="n">window</span> <span class="o">=</span> <span class="n">glfwCreateWindow</span><span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">,</span> <span class="s">&#34;LearnOpenGL&#34;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">window</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Failed to create GLFW window&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">    <span class="n">glfwTerminate</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">8</span><span class="cl"><span class="n">glfwMakeContextCurrent</span><span class="p">(</span><span class="n">window</span><span class="p">);</span></span></span></code></pre></div><p>The glfwCreateWindow function requires the window width and height as its first two arguments respectively. The third argument allows us to create a name for the window; for now we call it <code>&quot;LearnOpenGL&quot;</code> but you&rsquo;re allowed to name it however you like. We can ignore the last 2 parameters. The function returns a GLFWwindow object that we&rsquo;ll later need for other GLFW operations. After that we tell GLFW to make the context of our window the main context on the current thread.</p>
<h4 id="glad-1">GLAD</h4>
<p>In the previous chapter we mentioned that GLAD manages function pointers for OpenGL so we want to initialize GLAD before we call any OpenGL function:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gladLoadGLLoader</span><span class="p">((</span><span class="n">GLADloadproc</span><span class="p">)</span><span class="n">glfwGetProcAddress</span><span class="p">))</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Failed to initialize GLAD&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>We pass GLAD the function to load the address of the OpenGL function pointers which is OS-specific. GLFW gives us glfwGetProcAddress that defines the correct function based on which OS we&rsquo;re compiling for.</p>
<h4 id="viewport">Viewport</h4>
<p>Before we can start rendering we have to do one last thing. We have to tell OpenGL the size of the rendering window so OpenGL knows how we want to display the data and coordinates with respect to the window. We can set those <em>dimensions</em> via the glViewport function:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glViewport</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">);</span></span></span></code></pre></div><p>The first two parameters of glViewport set the location of the lower left corner of the window. The third and fourth parameter set the width and height of the rendering window in pixels, which we set equal to GLFW&rsquo;s window size.</p>
<p>We could actually set the viewport dimensions at values smaller than GLFW&rsquo;s dimensions; then all the OpenGL rendering would be displayed in a smaller window and we could for example display other elements outside the OpenGL viewport.</p>
<p><note>Behind the scenes OpenGL uses the data specified via glViewport to transform the 2D coordinates it processed to coordinates on your screen. For example, a processed point of location <code>(-0.5,0.5)</code> would (as its final transformation) be mapped to <code>(200,450)</code> in screen coordinates. Note that processed coordinates in OpenGL are between -1 and 1 so we effectively map from the range (-1 to 1) to (0, 800) and (0, 600).</note></p>
<p>However, the moment a user resizes the window the viewport should be adjusted as well. We can register a callback function on the window that gets called each time the window is resized. This resize callback function has the following prototype:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">void</span> <span class="nf">framebuffer_size_callback</span><span class="p">(</span><span class="n">GLFWwindow</span><span class="o">*</span> <span class="n">window</span><span class="p">,</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">);</span>  
</span></span></code></pre></div><p>The framebuffer size function takes a GLFWwindow as its first argument and two integers indicating the new window dimensions. Whenever the window changes in size, GLFW calls this function and fills in the proper arguments for you to process.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">void</span> <span class="nf">framebuffer_size_callback</span><span class="p">(</span><span class="n">GLFWwindow</span><span class="o">*</span> <span class="n">window</span><span class="p">,</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="n">glViewport</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="p">}</span> 
</span></span></code></pre></div><p>We do have to tell GLFW we want to call this function on every window resize by registering it:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glfwSetFramebufferSizeCallback</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">framebuffer_size_callback</span><span class="p">);</span>  
</span></span></code></pre></div><p>When the window is first displayed framebuffer_size_callback gets called as well with the resulting window dimensions. For retina displays width and height will end up significantly higher than the original input values.</p>
<p>There are many callbacks functions we can set to register our own functions. For example, we can make a callback function to process joystick input changes, process error messages etc. We register the callback functions after we&rsquo;ve created the window and before the render loop is initiated.</p>
<h4 id="ready-your-engines">Ready your engines</h4>
<p>We don&rsquo;t want the application to draw a single image and then immediately quit and close the window. We want the application to keep drawing images and handling user input until the program has been explicitly told to stop. For this reason we have to create a while loop, that we now call the render loop, that keeps on running until we tell GLFW to stop. The following code shows a very simple render loop:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">glfwWindowShouldClose</span><span class="p">(</span><span class="n">window</span><span class="p">))</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="n">glfwSwapBuffers</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="n">glfwPollEvents</span><span class="p">();</span>    
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>The glfwWindowShouldClose function checks at the start of each loop iteration if GLFW has been instructed to close. If so, the function returns <code>true</code> and the render loop stops running, after which we can close the application.
The glfwPollEvents function checks if any events are triggered (like keyboard input or mouse movement events), updates the window state, and calls the corresponding functions (which we can register via callback methods). The glfwSwapBuffers will swap the color buffer (a large 2D buffer that contains color values for each pixel in GLFW&rsquo;s window) that is used to render to during this render iteration and show it as output to the screen.</p>
<p><note><strong>Double buffer</strong>
When an application draws in a single buffer the resulting image may display flickering issues. This is because the resulting output image is not drawn in an instant, but drawn pixel by pixel and usually from left to right and top to bottom. Because this image is not displayed at an instant to the user while still being rendered to, the result may contain artifacts. To circumvent these issues, windowing applications apply a double buffer for rendering. The <strong>front</strong> buffer contains the final output image that is shown at the screen, while all the rendering commands draw to the <strong>back</strong> buffer. As soon as all the rendering commands are finished we <strong>swap</strong> the back buffer to the front buffer so the image can be displayed without still being rendered to, removing all the aforementioned artifacts.</note></p>
<h4 id="one-last-thing">One last thing</h4>
<p>As soon as we exit the render loop we would like to properly clean/delete all of GLFW&rsquo;s resources that were allocated. We can do this via the glfwTerminate function that we call at the end of the main function.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glfwTerminate</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="k">return</span> <span class="mi">0</span><span class="p">;</span></span></span></code></pre></div><p>This will clean up all the resources and properly exit the application. Now try to compile your application and if everything went well you should see the following output:</p>
<p><a href="#R-image-4aac940effa2aabb858946049af31984" class="lightbox-link"><img src="./assets/hellowindow.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-4aac940effa2aabb858946049af31984"><img src="./assets/hellowindow.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>If it&rsquo;s a very dull and boring black image, you did things right! If you didn&rsquo;t get the right image or you&rsquo;re confused as to how everything fits together, check the full source code <a href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/1.1.hello_window/hello_window.cpp" target="_blank">here</a> (and if it started flashing different colors, keep reading).</p>
<p>If you have issues compiling the application, first make sure all your linker options are set correctly and that you properly included the right directories in your IDE (as explained in the previous chapter). Also make sure your code is correct; you can verify it by comparing it with the full source code.</p>
<h4 id="input">Input</h4>
<p>We also want to have some form of input control in GLFW and we can achieve this with several of GLFW&rsquo;s input functions. We&rsquo;ll be using GLFW&rsquo;s glfwGetKey function that takes the window as input together with a key. The function returns whether this key is currently being pressed. We&rsquo;re creating a processInput function to keep all input code organized:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">void</span> <span class="nf">processInput</span><span class="p">(</span><span class="n">GLFWwindow</span> <span class="o">*</span><span class="n">window</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">glfwGetKey</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">GLFW_KEY_ESCAPE</span><span class="p">)</span> <span class="o">==</span> <span class="n">GLFW_PRESS</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">        <span class="n">glfwSetWindowShouldClose</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>Here we check whether the user has pressed the escape key (if it&rsquo;s not pressed, glfwGetKey returns GLFW_RELEASE). If the user did press the escape key, we close GLFW by setting its WindowShouldClose property to <code>true</code> using glfwSetwindowShouldClose. The next condition check of the main <code>while</code> loop will then fail and the application closes.</p>
<p>We then call processInput every iteration of the render loop:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">glfwWindowShouldClose</span><span class="p">(</span><span class="n">window</span><span class="p">))</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="n">processInput</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">
</span></span><span class="line"><span class="ln">5</span><span class="cl">    <span class="n">glfwSwapBuffers</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">    <span class="n">glfwPollEvents</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>This gives us an easy way to check for specific key presses and react accordingly every frame. An iteration of the render loop is more commonly called a frame.</p>
<h4 id="rendering">Rendering</h4>
<p>We want to place all the rendering commands in the render loop, since we want to execute all the rendering commands each iteration or frame of the loop. This would look a bit like this:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="c1">// render loop
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1"></span><span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">glfwWindowShouldClose</span><span class="p">(</span><span class="n">window</span><span class="p">))</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="c1">// input
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="c1"></span>    <span class="n">processInput</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="c1">// rendering commands here
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="c1"></span>    <span class="p">...</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="c1">// check and call events and swap the buffers
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="c1"></span>    <span class="n">glfwPollEvents</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="n">glfwSwapBuffers</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>Just to test if things actually work we want to clear the screen with a color of our choice. At the start of frame we want to clear the screen. Otherwise we would still see the results from the previous frame (this could be the effect you&rsquo;re looking for, but usually you don&rsquo;t). We can clear the screen&rsquo;s color buffer using glClear where we pass in buffer bits to specify which buffer we would like to clear. The possible bits we can set are GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT and GL_STENCIL_BUFFER_BIT. Right now we only care about the color values so we only clear the color buffer.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glClearColor</span><span class="p">(</span><span class="mf">0.2f</span><span class="p">,</span> <span class="mf">0.3f</span><span class="p">,</span> <span class="mf">0.3f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glClear</span><span class="p">(</span><span class="n">GL_COLOR_BUFFER_BIT</span><span class="p">);</span></span></span></code></pre></div><p>Note that we also specify the color to clear the screen with using glClearColor. Whenever we call glClear and clear the color buffer, the entire color buffer will be filled with the color as configured by glClearColor. This will result in a dark green-blueish color.</p>
<p><note>As you may recall from the <em>OpenGL</em> chapter, the glClearColor function is a <em>state-setting</em> function and glClear is a <em>state-using</em> function in that it uses the current state to retrieve the clearing color from.</note></p>
<p><a href="#R-image-ee842037904ba2c1c705ee53751bcadc" class="lightbox-link"><img src="./assets/hellowindow2.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-ee842037904ba2c1c705ee53751bcadc"><img src="./assets/hellowindow2.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>The full source code of the application can be found <a href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/1.2.hello_window_clear/hello_window_clear.cpp" target="_blank">here</a>.</p>
<p>So right now we got everything ready to fill the render loop with lots of rendering calls, but that&rsquo;s for the <a href="https://learnopengl.com/Getting-started/Hello-Triangle" target="_blank">next</a> chapter. I think we&rsquo;ve been rambling long enough here.</p>
<h3 id="hello-triangle">Hello Triangle</h3>
<p>In OpenGL everything is in 3D space, but the screen or window is a 2D array of pixels so a large part of OpenGL&rsquo;s work is about transforming all 3D coordinates to 2D pixels that fit on your screen. The process of transforming 3D coordinates to 2D pixels is managed by the graphics pipeline of OpenGL. The graphics pipeline can be divided into two large parts: the first transforms your 3D coordinates into 2D coordinates and the second part transforms the 2D coordinates into actual colored pixels. In this chapter we&rsquo;ll briefly discuss the graphics pipeline and how we can use it to our advantage to create fancy pixels.</p>
<p>The graphics pipeline takes as input a set of 3D coordinates and transforms these to colored 2D pixels on your screen. The graphics pipeline can be divided into several steps where each step requires the output of the previous step as its input. All of these steps are highly specialized (they have one specific function) and can easily be executed in parallel. Because of their parallel nature, graphics cards of today have thousands of small processing cores to quickly process your data within the graphics pipeline. The processing cores run small programs on the GPU for each step of the pipeline. These small programs are called shaders.</p>
<p>Some of these shaders are configurable by the developer which allows us to write our own shaders to replace the existing default shaders. This gives us much more fine-grained control over specific parts of the pipeline and because they run on the GPU, they can also save us valuable CPU time. Shaders are written in the OpenGL Shading Language (GLSL) and we&rsquo;ll delve more into that in the next chapter.</p>
<p>Below you&rsquo;ll find an abstract representation of all the stages of the graphics pipeline. Note that the blue sections represent sections where we can inject our own shaders.</p>
<p><a href="#R-image-9afe43e5babaeb2f5cd3fcd3fcd95071" class="lightbox-link"><img src="./assets/pipeline.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-9afe43e5babaeb2f5cd3fcd3fcd95071"><img src="./assets/pipeline.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>As you can see, the graphics pipeline contains a large number of sections that each handle one specific part of converting your vertex data to a fully rendered pixel. We will briefly explain each part of the pipeline in a simplified way to give you a good overview of how the pipeline operates.</p>
<p>As input to the graphics pipeline we pass in a list of three 3D coordinates that should form a triangle in an array here called <code>Vertex Data</code>; this vertex data is a collection of vertices. A vertex is a collection of data per 3D coordinate. This vertex&rsquo;s data is represented using vertex attributes that can contain any data we&rsquo;d like, but for simplicity&rsquo;s sake let&rsquo;s assume that each vertex consists of just a 3D position and some color value.</p>
<p><note>In order for OpenGL to know what to make of your collection of coordinates and color values OpenGL requires you to hint what kind of render types you want to form with the data. Do we want the data rendered as a collection of points, a collection of triangles or perhaps just one long line? Those hints are called primitives and are given to OpenGL while calling any of the drawing commands. Some of these hints are GL_POINTS, GL_TRIANGLES and GL_LINE_STRIP.</note></p>
<p>The first part of the pipeline is the vertex shader that takes as input a single vertex. The main purpose of the vertex shader is to transform 3D coordinates into different 3D coordinates (more on that later) and the vertex shader allows us to do some basic processing on the vertex attributes.</p>
<p>The output of the vertex shader stage is optionally passed to the geometry shader. The geometry shader takes as input a collection of vertices that form a primitive and has the ability to generate other shapes by emitting new vertices to form new (or other) primitive(s). In this example case, it generates a second triangle out of the given shape.</p>
<p>The primitive assembly stage takes as input all the vertices (or vertex if GL_POINTS is chosen) from the vertex (or geometry) shader that form one or more primitives and assembles all the point(s) in the primitive shape given; in this case two triangles.</p>
<p>The output of the primitive assembly stage is then passed on to the rasterization stage where it maps the resulting primitive(s) to the corresponding pixels on the final screen, resulting in fragments for the fragment shader to use. Before the fragment shaders run, clipping is performed. Clipping discards all fragments that are outside your view, increasing performance.</p>
<p><note>A fragment in OpenGL is all the data required for OpenGL to render a single pixel.</note></p>
<p>The main purpose of the fragment shader is to calculate the final color of a pixel and this is usually the stage where all the advanced OpenGL effects occur. Usually the fragment shader contains data about the 3D scene that it can use to calculate the final pixel color (like lights, shadows, color of the light and so on).</p>
<p>After all the corresponding color values have been determined, the final object will then pass through one more stage that we call the alpha test and blending stage. This stage checks the corresponding depth (and stencil) value (we&rsquo;ll get to those later) of the fragment and uses those to check if the resulting fragment is in front or behind other objects and should be discarded accordingly. The stage also checks for alpha values (alpha values define the opacity of an object) and blends the objects accordingly. So even if a pixel output color is calculated in the fragment shader, the final pixel color could still be something entirely different when rendering multiple triangles.</p>
<p>As you can see, the graphics pipeline is quite a complex whole and contains many configurable parts. However, for almost all the cases we only have to work with the vertex and fragment shader. The geometry shader is optional and usually left to its default shader. There is also the tessellation stage and transform feedback loop that we haven&rsquo;t depicted here, but that&rsquo;s something for later.</p>
<p>In modern OpenGL we are <strong>required</strong> to define at least a vertex and fragment shader of our own (there are no default vertex/fragment shaders on the GPU). For this reason it is often quite difficult to start learning modern OpenGL since a great deal of knowledge is required before being able to render your first triangle. Once you do get to finally render your triangle at the end of this chapter you will end up knowing a lot more about graphics programming.</p>
<h4 id="vertex-input">Vertex input</h4>
<p>To start drawing something we have to first give OpenGL some input vertex data. OpenGL is a 3D graphics library so all coordinates that we specify in OpenGL are in 3D (<code>x</code>, <code>y</code> and <code>z</code> coordinate). OpenGL doesn&rsquo;t simply transform <strong>all</strong> your 3D coordinates to 2D pixels on your screen; OpenGL only processes 3D coordinates when they&rsquo;re in a specific range between <code>-1.0</code> and <code>1.0</code> on all 3 axes (<code>x</code>, <code>y</code> and <code>z</code>). All coordinates within this so called normalized device coordinates range will end up visible on your screen (and all coordinates outside this region won&rsquo;t).</p>
<p>Because we want to render a single triangle we want to specify a total of three vertices with each vertex having a 3D position. We define them in normalized device coordinates (the visible region of OpenGL) in a <code>float</code> array:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">float</span> <span class="n">vertices</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">    <span class="o">-</span><span class="mf">0.5f</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">     <span class="mf">0.5f</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">     <span class="mf">0.0f</span><span class="p">,</span>  <span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.0f</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="p">};</span>  
</span></span></code></pre></div><p>Because OpenGL works in 3D space we render a 2D triangle with each vertex having a <code>z</code> coordinate of <code>0.0</code>. This way the <em>depth</em> of the triangle remains the same making it look like it&rsquo;s 2D.</p>
<p><note><strong>Normalized Device Coordinates (NDC)</strong><br><br> Once your vertex coordinates have been processed in the vertex shader, they should be in normalized device coordinates which is a small space where the <code>x</code>, <code>y</code> and <code>z</code> values vary from <code>-1.0</code> to <code>1.0</code>. Any coordinates that fall outside this range will be discarded/clipped and won&rsquo;t be visible on your screen. Below you can see the triangle we specified within normalized device coordinates (ignoring the <code>z</code> axis):<br><br><a href="#R-image-30aeeb19aaceefc860696f653fb6cd8d" class="lightbox-link"><img src="./assets/ndc.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-30aeeb19aaceefc860696f653fb6cd8d"><img src="./assets/ndc.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a><br>Unlike usual screen coordinates the positive y-axis points in the up-direction and the <code>(0,0)</code> coordinates are at the center of the graph, instead of top-left. Eventually you want all the (transformed) coordinates to end up in this coordinate space, otherwise they won&rsquo;t be visible.<br><br>Your NDC coordinates will then be transformed to screen-space coordinates via the viewport transform using the data you provided with glViewport. The resulting screen-space coordinates are then transformed to fragments as inputs to your fragment shader.</note></p>
<p>With the vertex data defined we&rsquo;d like to send it as input to the first process of the graphics pipeline: the vertex shader. This is done by creating memory on the GPU where we store the vertex data, configure how OpenGL should interpret the memory and specify how to send the data to the graphics card. The vertex shader then processes as much vertices as we tell it to from its memory.</p>
<p>We manage this memory via so called vertex buffer objects (VBO) that can store a large number of vertices in the GPU&rsquo;s memory. The advantage of using those buffer objects is that we can send large batches of data all at once to the graphics card, and keep it there if there&rsquo;s enough memory left, without having to send data one vertex at a time. Sending data to the graphics card from the CPU is relatively slow, so wherever we can we try to send as much data as possible at once. Once the data is in the graphics card&rsquo;s memory the vertex shader has almost instant access to the vertices making it extremely fast</p>
<p>A vertex buffer object is our first occurrence of an OpenGL object as we&rsquo;ve discussed in the <a href="https://learnopengl.com/Getting-Started/OpenGL" target="_blank">OpenGL</a> chapter. Just like any object in OpenGL, this buffer has a unique ID corresponding to that buffer, so we can generate one with a buffer ID using the glGenBuffers function:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">VBO</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glGenBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">VBO</span><span class="p">);</span>  
</span></span></code></pre></div><p>OpenGL has many types of buffer objects and the buffer type of a vertex buffer object is GL_ARRAY_BUFFER. OpenGL allows us to bind to several buffers at once as long as they have a different buffer type. We can bind the newly created buffer to the GL_ARRAY_BUFFER target with the glBindBuffer function:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">VBO</span><span class="p">);</span>  
</span></span></code></pre></div><p>From that point on any buffer calls we make (on the GL_ARRAY_BUFFER target) will be used to configure the currently bound buffer, which is VBO. Then we can make a call to the glBufferData function that copies the previously defined vertex data into the buffer&rsquo;s memory:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vertices</span><span class="p">),</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">GL_STATIC_DRAW</span><span class="p">);</span></span></span></code></pre></div><p>glBufferData is a function specifically targeted to copy user-defined data into the currently bound buffer. Its first argument is the type of the buffer we want to copy data into: the vertex buffer object currently bound to the GL_ARRAY_BUFFER target. The second argument specifies the size of the data (in bytes) we want to pass to the buffer; a simple <code>sizeof</code> of the vertex data suffices. The third parameter is the actual data we want to send.</p>
<p>The fourth parameter specifies how we want the graphics card to manage the given data. This can take 3 forms:</p>
<ul>
<li>GL_STREAM_DRAW: the data is set only once and used by the GPU at most a few times.</li>
<li>GL_STATIC_DRAW: the data is set only once and used many times.</li>
<li>GL_DYNAMIC_DRAW: the data is changed a lot and used many times.</li>
</ul>
<p>The position data of the triangle does not change, is used a lot, and stays the same for every render call so its usage type should best be GL_STATIC_DRAW. If, for instance, one would have a buffer with data that is likely to change frequently, a usage type of GL_DYNAMIC_DRAW ensures the graphics card will place the data in memory that allows for faster writes.</p>
<p>As of now we stored the vertex data within memory on the graphics card as managed by a vertex buffer object named VBO. Next we want to create a vertex and fragment shader that actually processes this data, so let&rsquo;s start building those.</p>
<h4 id="vertex-shader">Vertex shader</h4>
<p>The vertex shader is one of the shaders that are programmable by people like us. Modern OpenGL requires that we at least set up a vertex and fragment shader if we want to do some rendering so we will briefly introduce shaders and configure two very simple shaders for drawing our first triangle. In the next chapter we&rsquo;ll discuss shaders in more detail.</p>
<p>The first thing we need to do is write the vertex shader in the shader language GLSL (OpenGL Shading Language) and then compile this shader so we can use it in our application. Below you&rsquo;ll find the source code of a very basic vertex shader in GLSL:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="cp"></span><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">aPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">aPos</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">aPos</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">aPos</span><span class="p">.</span><span class="n">z</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>As you can see, GLSL looks similar to C. Each shader begins with a declaration of its version. Since OpenGL 3.3 and higher the version numbers of GLSL match the version of OpenGL (GLSL version 420 corresponds to OpenGL version 4.2 for example). We also explicitly mention we&rsquo;re using core profile functionality.</p>
<p>Next we declare all the input vertex attributes in the vertex shader with the <code>in</code> keyword. Right now we only care about position data so we only need a single vertex attribute. GLSL has a vector datatype that contains 1 to 4 floats based on its postfix digit. Since each vertex has a 3D coordinate we create a <code>vec3</code> input variable with the name aPos. We also specifically set the location of the input variable via <code>layout (location = 0)</code> and you&rsquo;ll later see that why we&rsquo;re going to need that location.</p>
<p><note><strong>Vector</strong><br>In graphics programming we use the mathematical concept of a vector quite often, since it neatly represents positions/directions in any space and has useful mathematical properties. A vector in GLSL has a maximum size of 4 and each of its values can be retrieved via <code>vec.x</code>, <code>vec.y</code>, <code>vec.z</code> and <code>vec.w</code> respectively where each of them represents a coordinate in space. Note that the <code>vec.w</code> component is not used as a position in space (we&rsquo;re dealing with 3D, not 4D) but is used for something called perspective division. We&rsquo;ll discuss vectors in much greater depth in a later chapter.</note></p>
<p>To set the output of the vertex shader we have to assign the position data to the predefined gl_Position variable which is a <code>vec4</code> behind the scenes. At the end of the main function, whatever we set gl_Position to will be used as the output of the vertex shader. Since our input is a vector of size 3 we have to cast this to a vector of size 4. We can do this by inserting the <code>vec3</code> values inside the constructor of <code>vec4</code> and set its <code>w</code> component to <code>1.0f</code> (we will explain why in a later chapter).</p>
<p>The current vertex shader is probably the most simple vertex shader we can imagine because we did no processing whatsoever on the input data and simply forwarded it to the shader&rsquo;s output. In real applications the input data is usually not already in normalized device coordinates so we first have to transform the input data to coordinates that fall within OpenGL&rsquo;s visible region.</p>
<h4 id="compiling-a-shader">Compiling a shader</h4>
<p>We take the source code for the vertex shader and store it in a const C string at the top of the code file for now:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">vertexShaderSource</span> <span class="o">=</span> <span class="s">&#34;#version 330 core</span><span class="se">\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">    <span class="s">&#34;layout (location = 0) in vec3 aPos;</span><span class="se">\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="s">&#34;void main()</span><span class="se">\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="s">&#34;{</span><span class="se">\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">    <span class="s">&#34;   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);</span><span class="se">\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">    <span class="s">&#34;}</span><span class="se">\0</span><span class="s">&#34;</span><span class="p">;</span></span></span></code></pre></div><p>In order for OpenGL to use the shader it has to dynamically compile it at run-time from its source code. The first thing we need to do is create a shader object, again referenced by an ID. So we store the vertex shader as an <code>unsigned int</code> and create the shader with glCreateShader:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">vertexShader</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">vertexShader</span> <span class="o">=</span> <span class="n">glCreateShader</span><span class="p">(</span><span class="n">GL_VERTEX_SHADER</span><span class="p">);</span></span></span></code></pre></div><p>We provide the type of shader we want to create as an argument to glCreateShader. Since we&rsquo;re creating a vertex shader we pass in GL_VERTEX_SHADER.</p>
<p>Next we attach the shader source code to the shader object and compile the shader:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glShaderSource</span><span class="p">(</span><span class="n">vertexShader</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vertexShaderSource</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glCompileShader</span><span class="p">(</span><span class="n">vertexShader</span><span class="p">);</span></span></span></code></pre></div><p>The glShaderSource function takes the shader object to compile to as its first argument. The second argument specifies how many strings we&rsquo;re passing as source code, which is only one. The third parameter is the actual source code of the vertex shader and we can leave the 4th parameter to <code>NULL</code>.</p>
<p><note>You probably want to check if compilation was successful after the call to glCompileShader and if not, what errors were found so you can fix those. Checking for compile-time errors is accomplished as follows:</note></p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">int</span>  <span class="n">success</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="kt">char</span> <span class="n">infoLog</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">glGetShaderiv</span><span class="p">(</span><span class="n">vertexShader</span><span class="p">,</span> <span class="n">GL_COMPILE_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">success</span><span class="p">);</span></span></span></code></pre></div><p><note>First we define an integer to indicate success and a storage container for the error messages (if any). Then we check if compilation was successful with glGetShaderiv. If compilation failed, we should retrieve the error message with glGetShaderInfoLog and print the error message.</note></p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">success</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="n">glGetShaderInfoLog</span><span class="p">(</span><span class="n">vertexShader</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">infoLog</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;ERROR::SHADER::VERTEX::COMPILATION_FAILED</span><span class="se">\n</span><span class="s">&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">infoLog</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>If no errors were detected while compiling the vertex shader it is now compiled.</p>
<h4 id="fragment-shader">Fragment shader</h4>
<p>The fragment shader is the second and final shader we&rsquo;re going to create for rendering a triangle. The fragment shader is all about calculating the color output of your pixels. To keep things simple the fragment shader will always output an orange-ish color.</p>
<p><note>Colors in computer graphics are represented as an array of 4 values: the red, green, blue and alpha (opacity) component, commonly abbreviated to RGBA. When defining a color in OpenGL or GLSL we set the strength of each component to a value between <code>0.0</code> and <code>1.0</code>. If, for example, we would set red to <code>1.0</code> and green to <code>1.0</code> we would get a mixture of both colors and get the color yellow. Given those 3 color components we can generate over 16 million different colors!</note></p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="cp"></span><span class="n">out</span> <span class="n">vec4</span> <span class="n">FragColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">    <span class="n">FragColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.2f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="p">}</span> 
</span></span></code></pre></div><p>The fragment shader only requires one output variable and that is a vector of size 4 that defines the final color output that we should calculate ourselves. We can declare output values with the <code>out</code> keyword, that we here promptly named FragColor. Next we simply assign a <code>vec4</code> to the color output as an orange color with an alpha value of <code>1.0</code> (<code>1.0</code> being completely opaque).</p>
<p>The process for compiling a fragment shader is similar to the vertex shader, although this time we use the GL_FRAGMENT_SHADER constant as the shader type:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fragmentShader</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">fragmentShader</span> <span class="o">=</span> <span class="n">glCreateShader</span><span class="p">(</span><span class="n">GL_FRAGMENT_SHADER</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">glShaderSource</span><span class="p">(</span><span class="n">fragmentShader</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fragmentShaderSource</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="n">glCompileShader</span><span class="p">(</span><span class="n">fragmentShader</span><span class="p">);</span></span></span></code></pre></div><p>Both the shaders are now compiled and the only thing left to do is link both shader objects into a shader program that we can use for rendering. Make sure to check for compile errors here as well!</p>
<h5 id="shader-program">Shader program</h5>
<p>A shader program object is the final linked version of multiple shaders combined. To use the recently compiled shaders we have to link them to a shader program object and then activate this shader program when rendering objects. The activated shader program&rsquo;s shaders will be used when we issue render calls.</p>
<p>When linking the shaders into a program it links the outputs of each shader to the inputs of the next shader. This is also where you&rsquo;ll get linking errors if your outputs and inputs do not match.</p>
<p>Creating a program object is easy:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">shaderProgram</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">shaderProgram</span> <span class="o">=</span> <span class="n">glCreateProgram</span><span class="p">();</span></span></span></code></pre></div><p>The glCreateProgram function creates a program and returns the ID reference to the newly created program object. Now we need to attach the previously compiled shaders to the program object and then link them with glLinkProgram:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glAttachShader</span><span class="p">(</span><span class="n">shaderProgram</span><span class="p">,</span> <span class="n">vertexShader</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glAttachShader</span><span class="p">(</span><span class="n">shaderProgram</span><span class="p">,</span> <span class="n">fragmentShader</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">glLinkProgram</span><span class="p">(</span><span class="n">shaderProgram</span><span class="p">);</span></span></span></code></pre></div><p>The code should be pretty self-explanatory, we attach the shaders to the program and link them via glLinkProgram.</p>
<p><note>Just like shader compilation we can also check if linking a shader program failed and retrieve the corresponding log. However, instead of using glGetShaderiv and glGetShaderInfoLog we now use:</note></p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glGetProgramiv</span><span class="p">(</span><span class="n">shaderProgram</span><span class="p">,</span> <span class="n">GL_LINK_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">success</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">success</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="n">glGetProgramInfoLog</span><span class="p">(</span><span class="n">shaderProgram</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">infoLog</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>The result is a program object that we can activate by calling glUseProgram with the newly created program object as its argument:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glUseProgram</span><span class="p">(</span><span class="n">shaderProgram</span><span class="p">);</span></span></span></code></pre></div><p>Every shader and rendering call after glUseProgram will now use this program object (and thus the shaders).</p>
<p>Oh yeah, and don&rsquo;t forget to delete the shader objects once we&rsquo;ve linked them into the program object; we no longer need them anymore:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glDeleteShader</span><span class="p">(</span><span class="n">vertexShader</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glDeleteShader</span><span class="p">(</span><span class="n">fragmentShader</span><span class="p">);</span>  
</span></span></code></pre></div><p>Right now we sent the input vertex data to the GPU and instructed the GPU how it should process the vertex data within a vertex and fragment shader. We&rsquo;re almost there, but not quite yet. OpenGL does not yet know how it should interpret the vertex data in memory and how it should connect the vertex data to the vertex shader&rsquo;s attributes. We&rsquo;ll be nice and tell OpenGL how to do that.</p>
<h4 id="linking-vertex-attributes">Linking Vertex Attributes</h4>
<p>The vertex shader allows us to specify any input we want in the form of vertex attributes and while this allows for great flexibility, it does mean we have to manually specify what part of our input data goes to which vertex attribute in the vertex shader. This means we have to specify how OpenGL should interpret the vertex data before rendering.</p>
<p>Our vertex buffer data is formatted as follows:</p>
<p><a href="#R-image-a0bcf4dfb2f44dfb0d1edceeeae2de5d" class="lightbox-link"><img src="./assets/vertex_attribute_pointer.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a0bcf4dfb2f44dfb0d1edceeeae2de5d"><img src="./assets/vertex_attribute_pointer.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<ul>
<li>The position data is stored as 32-bit (4 byte) floating point values.</li>
<li>Each position is composed of 3 of those values.</li>
<li>There is no space (or other values) between each set of 3 values. The values are tightly packed in the array.</li>
<li>The first value in the data is at the beginning of the buffer.</li>
</ul>
<p>With this knowledge we can tell OpenGL how it should interpret the vertex data (per vertex attribute) using glVertexAttribPointer:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>  
</span></span></code></pre></div><p>The function glVertexAttribPointer has quite a few parameters so let&rsquo;s carefully walk through them:</p>
<ul>
<li>The first parameter specifies which vertex attribute we want to configure. Remember that we specified the location of the position vertex attribute in the vertex shader with <code>layout (location = 0)</code>. This sets the location of the vertex attribute to <code>0</code> and since we want to pass data to this vertex attribute, we pass in <code>0</code>.</li>
<li>The next argument specifies the size of the vertex attribute. The vertex attribute is a <code>vec3</code> so it is composed of <code>3</code> values.</li>
<li>The third argument specifies the type of the data which is GL_FLOAT (a <code>vec*</code> in GLSL consists of floating point values).</li>
<li>The next argument specifies if we want the data to be normalized. If we&rsquo;re inputting integer data types (int, byte) and we&rsquo;ve set this to GL_TRUE, the integer data is normalized to <code>0</code> (or <code>-1</code> for signed data) and <code>1</code> when converted to float. This is not relevant for us so we&rsquo;ll leave this at GL_FALSE.</li>
<li>The fifth argument is known as the stride and tells us the space between consecutive vertex attributes. Since the next set of position data is located exactly 3 times the size of a <code>float</code> away we specify that value as the stride. Note that since we know that the array is tightly packed (there is no space between the next vertex attribute value) we could&rsquo;ve also specified the stride as <code>0</code> to let OpenGL determine the stride (this only works when values are tightly packed). Whenever we have more vertex attributes we have to carefully define the spacing between each vertex attribute but we&rsquo;ll get to see more examples of that later on.</li>
<li>The last parameter is of type <code>void*</code> and thus requires that weird cast. This is the offset of where the position data begins in the buffer. Since the position data is at the start of the data array this value is just <code>0</code>. We will explore this parameter in more detail later on</li>
</ul>
<p><note>Each vertex attribute takes its data from memory managed by a VBO and which VBO it takes its data from (you can have multiple VBOs) is determined by the VBO currently bound to GL_ARRAY_BUFFER when calling glVertexAttribPointer. Since the previously defined VBO is still bound before calling glVertexAttribPointer vertex attribute <code>0</code> is now associated with its vertex data.</note></p>
<p>Now that we specified how OpenGL should interpret the vertex data we should also enable the vertex attribute with glEnableVertexAttribArray giving the vertex attribute location as its argument; vertex attributes are disabled by default. From that point on we have everything set up: we initialized the vertex data in a buffer using a vertex buffer object, set up a vertex and fragment shader and told OpenGL how to link the vertex data to the vertex shader&rsquo;s vertex attributes. Drawing an object in OpenGL would now look something like this:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="c1">// 0. copy our vertices array in a buffer for OpenGL to use
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1"></span><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">VBO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vertices</span><span class="p">),</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">GL_STATIC_DRAW</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1">// 1. then set the vertex attributes pointers
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="c1"></span><span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1">// 2. use our shader program when we want to render an object
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="c1"></span><span class="n">glUseProgram</span><span class="p">(</span><span class="n">shaderProgram</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1">// 3. now draw the object 
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1"></span><span class="n">someOpenGLFunctionThatDrawsOurTriangle</span><span class="p">();</span>   
</span></span></code></pre></div><p>We have to repeat this process every time we want to draw an object. It may not look like that much, but imagine if we have over 5 vertex attributes and perhaps 100s of different objects (which is not uncommon). Binding the appropriate buffer objects and configuring all vertex attributes for each of those objects quickly becomes a cumbersome process. What if there was some way we could store all these state configurations into an object and simply bind this object to restore its state?</p>
<h5 id="vertex-array-object">Vertex Array Object</h5>
<p>A vertex array object (also known as VAO) can be bound just like a vertex buffer object and any subsequent vertex attribute calls from that point on will be stored inside the VAO. This has the advantage that when configuring vertex attribute pointers you only have to make those calls once and whenever we want to draw the object, we can just bind the corresponding VAO. This makes switching between different vertex data and attribute configurations as easy as binding a different VAO. All the state we just set is stored inside the VAO.</p>
<p><warning>Core OpenGL <strong>requires</strong> that we use a VAO so it knows what to do with our vertex inputs. If we fail to bind a VAO, OpenGL will most likely refuse to draw anything.</warning></p>
<p>A vertex array object stores the following:</p>
<ul>
<li>Calls to glEnableVertexAttribArray or glDisableVertexAttribArray.</li>
<li>Vertex attribute configurations via glVertexAttribPointer.</li>
<li>Vertex buffer objects associated with vertex attributes by calls to glVertexAttribPointer.</li>
</ul>
<p><a href="#R-image-1c6cc4cbca78b90fd5e5cddf00500058" class="lightbox-link"><img src="./assets/vertex_array_objects.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-1c6cc4cbca78b90fd5e5cddf00500058"><img src="./assets/vertex_array_objects.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>The process to generate a VAO looks similar to that of a VBO:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">VAO</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glGenVertexArrays</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">VAO</span><span class="p">);</span>  
</span></span></code></pre></div><p>To use a VAO all you have to do is bind the VAO using glBindVertexArray. From that point on we should bind/configure the corresponding VBO(s) and attribute pointer(s) and then unbind the VAO for later use. As soon as we want to draw an object, we simply bind the VAO with the preferred settings before drawing the object and that is it. In code this would look a bit like this:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="c1">// ..:: Initialization code (done once (unless your object frequently changes)) :: ..
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1">// 1. bind Vertex Array Object
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="c1"></span><span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">VAO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1">// 2. copy our vertices array in a buffer for OpenGL to use
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="c1"></span><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">VBO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vertices</span><span class="p">),</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">GL_STATIC_DRAW</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1">// 3. then set our vertex attributes pointers
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="c1"></span><span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">10</span><span class="cl">
</span></span><span class="line"><span class="ln">11</span><span class="cl">  
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="p">[...]</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="c1">// ..:: Drawing code (in render loop) :: ..
</span></span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="c1">// 4. draw the object
</span></span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="c1"></span><span class="n">glUseProgram</span><span class="p">(</span><span class="n">shaderProgram</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">VAO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="n">someOpenGLFunctionThatDrawsOurTriangle</span><span class="p">();</span>   
</span></span></code></pre></div><p>And that is it! Everything we did the last few million pages led up to this moment, a VAO that stores our vertex attribute configuration and which VBO to use. Usually when you have multiple objects you want to draw, you first generate/configure all the VAOs (and thus the required VBO and attribute pointers) and store those for later use. The moment we want to draw one of our objects, we take the corresponding VAO, bind it, then draw the object and unbind the VAO again.</p>
<h5 id="the-triangle-weve-all-been-waiting-for">The triangle we&rsquo;ve all been waiting for</h5>
<p>To draw our objects of choice, OpenGL provides us with the glDrawArrays function that draws primitives using the currently active shader, the previously defined vertex attribute configuration and with the VBO&rsquo;s vertex data (indirectly bound via the VAO).</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glUseProgram</span><span class="p">(</span><span class="n">shaderProgram</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">VAO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">glDrawArrays</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span></span></span></code></pre></div><p>The glDrawArrays function takes as its first argument the OpenGL primitive type we would like to draw. Since I said at the start we wanted to draw a triangle, and I don&rsquo;t like lying to you, we pass in GL_TRIANGLES. The second argument specifies the starting index of the vertex array we&rsquo;d like to draw; we just leave this at <code>0</code>. The last argument specifies how many vertices we want to draw, which is <code>3</code> (we only render 1 triangle from our data, which is exactly 3 vertices long).</p>
<p>Now try to compile the code and work your way backwards if any errors popped up. As soon as your application compiles, you should see the following result:</p>
<p><a href="#R-image-43b45b8a6d06acd183855e71980d6945" class="lightbox-link"><img src="./assets/hellotriangle.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-43b45b8a6d06acd183855e71980d6945"><img src="./assets/hellotriangle.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>The source code for the complete program can be found <a href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/2.1.hello_triangle/hello_triangle.cpp" target="_blank">here</a> .</p>
<p>If your output does not look the same you probably did something wrong along the way so check the complete source code and see if you missed anything.</p>
<h4 id="element-buffer-objects">Element Buffer Objects</h4>
<p>There is one last thing we&rsquo;d like to discuss when rendering vertices and that is element buffer objects abbreviated to EBO. To explain how element buffer objects work it&rsquo;s best to give an example: suppose we want to draw a rectangle instead of a triangle. We can draw a rectangle using two triangles (OpenGL mainly works with triangles). This will generate the following set of vertices:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">float</span> <span class="n">vertices</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    <span class="c1">// first triangle
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="c1"></span>     <span class="mf">0.5f</span><span class="p">,</span>  <span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span>  <span class="c1">// top right
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1"></span>     <span class="mf">0.5f</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span>  <span class="c1">// bottom right
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="c1"></span>    <span class="o">-</span><span class="mf">0.5f</span><span class="p">,</span>  <span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span>  <span class="c1">// top left 
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="c1"></span>    <span class="c1">// second triangle
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1"></span>     <span class="mf">0.5f</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span>  <span class="c1">// bottom right
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="c1"></span>    <span class="o">-</span><span class="mf">0.5f</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span>  <span class="c1">// bottom left
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1"></span>    <span class="o">-</span><span class="mf">0.5f</span><span class="p">,</span>  <span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.0f</span>   <span class="c1">// top left
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1"></span><span class="p">};</span> 
</span></span></code></pre></div><p>As you can see, there is some overlap on the vertices specified. We specify <code>bottom right</code> and <code>top left</code> twice! This is an overhead of 50% since the same rectangle could also be specified with only 4 vertices, instead of 6. This will only get worse as soon as we have more complex models that have over 1000s of triangles where there will be large chunks that overlap. What would be a better solution is to store only the unique vertices and then specify the order at which we want to draw these vertices in. In that case we would only have to store 4 vertices for the rectangle, and then just specify at which order we&rsquo;d like to draw them. Wouldn&rsquo;t it be great if OpenGL provided us with a feature like that?</p>
<p>Thankfully, element buffer objects work exactly like that. An EBO is a buffer, just like a vertex buffer object, that stores indices that OpenGL uses to decide what vertices to draw. This so called indexed drawing is exactly the solution to our problem. To get started we first have to specify the (unique) vertices and the indices to draw them as a rectangle:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">float</span> <span class="n">vertices</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">     <span class="mf">0.5f</span><span class="p">,</span>  <span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span>  <span class="c1">// top right
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="c1"></span>     <span class="mf">0.5f</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span>  <span class="c1">// bottom right
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1"></span>    <span class="o">-</span><span class="mf">0.5f</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span>  <span class="c1">// bottom left
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="c1"></span>    <span class="o">-</span><span class="mf">0.5f</span><span class="p">,</span>  <span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.0f</span>   <span class="c1">// top left 
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">indices</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>  <span class="c1">// note that we start from 0!
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="c1"></span>    <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span>   <span class="c1">// first triangle
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1"></span>    <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span>    <span class="c1">// second triangle
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1"></span><span class="p">};</span>  
</span></span></code></pre></div><p>You can see that, when using indices, we only need 4 vertices instead of 6. Next we need to create the element buffer object:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">EBO</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glGenBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">EBO</span><span class="p">);</span></span></span></code></pre></div><p>Similar to the VBO we bind the EBO and copy the indices into the buffer with glBufferData. Also, just like the VBO we want to place those calls between a bind and an unbind call, although this time we specify GL_ELEMENT_ARRAY_BUFFER as the buffer type.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ELEMENT_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">EBO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ELEMENT_ARRAY_BUFFER</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">indices</span><span class="p">),</span> <span class="n">indices</span><span class="p">,</span> <span class="n">GL_STATIC_DRAW</span><span class="p">);</span> 
</span></span></code></pre></div><p>Note that we&rsquo;re now giving GL_ELEMENT_ARRAY_BUFFER as the buffer target. The last thing left to do is replace the glDrawArrays call with glDrawElements to indicate we want to render the triangles from an index buffer. When using glDrawElements we&rsquo;re going to draw using indices provided in the element buffer object currently bound:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ELEMENT_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">EBO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glDrawElements</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">GL_UNSIGNED_INT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span></span></span></code></pre></div><p>The first argument specifies the mode we want to draw in, similar to glDrawArrays. The second argument is the count or number of elements we&rsquo;d like to draw. We specified 6 indices so we want to draw 6 vertices in total. The third argument is the type of the indices which is of type GL_UNSIGNED_INT. The last argument allows us to specify an offset in the EBO (or pass in an index array, but that is when you&rsquo;re not using element buffer objects), but we&rsquo;re just going to leave this at 0.</p>
<p>The glDrawElements function takes its indices from the EBO currently bound to the GL_ELEMENT_ARRAY_BUFFER target. This means we have to bind the corresponding EBO each time we want to render an object with indices which again is a bit cumbersome. It just so happens that a vertex array object also keeps track of element buffer object bindings. The last element buffer object that gets bound while a VAO is bound, is stored as the VAO&rsquo;s element buffer object. Binding to a VAO then also automatically binds that EBO.</p>
<p><a href="#R-image-f1cbfb976d09cf5627ab7b70cad1b5cc" class="lightbox-link"><img src="./assets/vertex_array_objects_ebo.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f1cbfb976d09cf5627ab7b70cad1b5cc"><img src="./assets/vertex_array_objects_ebo.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><warning>A VAO stores the glBindBuffer calls when the target is GL_ELEMENT_ARRAY_BUFFER. This also means it stores its unbind calls so make sure you don&rsquo;t unbind the element array buffer before unbinding your VAO, otherwise it doesn&rsquo;t have an EBO configured.</warning></p>
<p>The resulting initialization and drawing code now looks something like this:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="c1">// ..:: Initialization code :: ..
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1">// 1. bind Vertex Array Object
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="c1"></span><span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">VAO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1">// 2. copy our vertices array in a vertex buffer for OpenGL to use
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="c1"></span><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">VBO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vertices</span><span class="p">),</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">GL_STATIC_DRAW</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1">// 3. copy our index array in a element buffer for OpenGL to use
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="c1"></span><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ELEMENT_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">EBO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ELEMENT_ARRAY_BUFFER</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">indices</span><span class="p">),</span> <span class="n">indices</span><span class="p">,</span> <span class="n">GL_STATIC_DRAW</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1">// 4. then set the vertex attributes pointers
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="c1"></span><span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">13</span><span class="cl">
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="p">[...]</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">  
</span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="c1">// ..:: Drawing code (in render loop) :: ..
</span></span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="c1"></span><span class="n">glUseProgram</span><span class="p">(</span><span class="n">shaderProgram</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">VAO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="n">glDrawElements</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">GL_UNSIGNED_INT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="n">glBindVertexArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span></span></span></code></pre></div><p>Running the program should give an image as depicted below. The left image should look familiar and the right image is the rectangle drawn in wireframe mode. The wireframe rectangle shows that the rectangle indeed consists of two triangles.</p>
<p><a href="#R-image-fc8fda66ea4f571d427c7548d2e53ef2" class="lightbox-link"><img src="./assets/hellotriangle2.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-fc8fda66ea4f571d427c7548d2e53ef2"><img src="./assets/hellotriangle2.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><note><strong>Wireframe mode</strong><br>To draw your triangles in wireframe mode, you can configure how OpenGL draws its primitives via <code>glPolygonMode(GL_FRONT_AND_BACK, GL_LINE)</code>. The first argument says we want to apply it to the front and back of all triangles and the second line tells us to draw them as lines. Any subsequent drawing calls will render the triangles in wireframe mode until we set it back to its default using <code>glPolygonMode(GL_FRONT_AND_BACK, GL_FILL)</code>.</note></p>
<p>If you have any errors, work your way backwards and see if you missed anything. You can find the complete source code <a href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/2.2.hello_triangle_indexed/hello_triangle_indexed.cpp" target="_blank">here</a>.</p>
<p>If you managed to draw a triangle or a rectangle just like we did then congratulations, you managed to make it past one of the hardest parts of modern OpenGL: drawing your first triangle. This is a difficult part since there is a large chunk of knowledge required before being able to draw your first triangle. Thankfully, we now made it past that barrier and the upcoming chapters will hopefully be much easier to understand.</p>
<h4 id="additional-resources-2">Additional resources</h4>
<ul>
<li><a href="http://antongerdelan.net/opengl/hellotriangle.html" target="_blank">antongerdelan.net/hellotriangle</a>: Anton Gerdelan&rsquo;s take on rendering the first triangle.</li>
<li><a href="https://open.gl/drawing" target="_blank">open.gl/drawing</a>: Alexander Overvoorde&rsquo;s take on rendering the first triangle.</li>
<li><a href="http://antongerdelan.net/opengl/vertexbuffers.html" target="_blank">antongerdelan.net/vertexbuffers</a>: some extra insights into vertex buffer objects.</li>
<li><a href="https://learnopengl.com/In-Practice/Debugging" target="_blank">learnopengl.com/In-Practice/Debugging</a>: there are a lot of steps involved in this chapter; if you&rsquo;re stuck it may be worthwhile to read a bit on debugging in OpenGL (up until the debug output section).</li>
</ul>
<h4 id="exercises">Exercises</h4>
<p>To really get a good grasp of the concepts discussed a few exercises were set up. It is advised to work through them before continuing to the next subject to make sure you get a good grasp of what&rsquo;s going on.</p>
<ol>
<li>Try to draw 2 triangles next to each other using glDrawArrays by adding more vertices to your data: <a href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/2.3.hello_triangle_exercise1/hello_triangle_exercise1.cpp" target="_blank">solution</a>.</li>
<li>Now create the same 2 triangles using two different VAOs and VBOs for their data: <a href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/2.4.hello_triangle_exercise2/hello_triangle_exercise2.cpp" target="_blank">solution</a>.</li>
<li>Create two shader programs where the second program uses a different fragment shader that outputs the color yellow; draw both triangles again where one outputs the color yellow: <a href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/2.5.hello_triangle_exercise3/hello_triangle_exercise3.cpp" target="_blank">solution</a>.</li>
</ol>
<h3 id="shaders">Shaders</h3>
<p>As mentioned in the <a href="https://learnopengl.com/Getting-started/Hello-Triangle" target="_blank">Hello Triangle</a> chapter, shaders are little programs that rest on the GPU. These programs are run for each specific section of the graphics pipeline. In a basic sense, shaders are nothing more than programs transforming inputs to outputs. Shaders are also very isolated programs in that they&rsquo;re not allowed to communicate with each other; the only communication they have is via their inputs and outputs.</p>
<p>In the previous chapter we briefly touched the surface of shaders and how to properly use them. We will now explain shaders, and specifically the OpenGL Shading Language, in a more general fashion.</p>
<h4 id="glsl">GLSL</h4>
<p>Shaders are written in the C-like language GLSL. GLSL is tailored for use with graphics and contains useful features specifically targeted at vector and matrix manipulation.</p>
<p>Shaders always begin with a version declaration, followed by a list of input and output variables, uniforms and its main function. Each shader&rsquo;s entry point is at its main function where we process any input variables and output the results in its output variables. Don&rsquo;t worry if you don&rsquo;t know what uniforms are, we&rsquo;ll get to those shortly.</p>
<p>A shader typically has the following structure:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version version_number
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">in</span> <span class="n">type</span> <span class="n">in_variable_name</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">in</span> <span class="n">type</span> <span class="n">in_variable_name</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">out</span> <span class="n">type</span> <span class="n">out_variable_name</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="n">uniform</span> <span class="n">type</span> <span class="n">uniform_name</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">  <span class="c1">// process input(s) and do some weird graphics stuff
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="c1"></span>  <span class="p">...</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">  <span class="c1">// output processed stuff to output variable
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="c1"></span>  <span class="n">out_variable_name</span> <span class="o">=</span> <span class="n">weird_stuff_we_processed</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>When we&rsquo;re talking specifically about the vertex shader each input variable is also known as a vertex attribute. There is a maximum number of vertex attributes we&rsquo;re allowed to declare limited by the hardware. OpenGL guarantees there are always at least 16 4-component vertex attributes available, but some hardware may allow for more which you can retrieve by querying GL_MAX_VERTEX_ATTRIBS:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">int</span> <span class="n">nrAttributes</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glGetIntegerv</span><span class="p">(</span><span class="n">GL_MAX_VERTEX_ATTRIBS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nrAttributes</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Maximum nr of vertex attributes supported: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">nrAttributes</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span></span></span></code></pre></div><p>This often returns the minimum of <code>16</code> which should be more than enough for most purposes.</p>
<h4 id="types">Types</h4>
<p>GLSL has, like any other programming language, data types for specifying what kind of variable we want to work with. GLSL has most of the default basic types we know from languages like C: <code>int</code>, <code>float</code>, <code>double</code>, <code>uint</code> and <code>bool</code>. GLSL also features two container types that we&rsquo;ll be using a lot, namely <code>vectors</code> and <code>matrices</code>. We&rsquo;ll discuss matrices in a later chapter.</p>
<h5 id="vectors">Vectors</h5>
<p>A vector in GLSL is a 2,3 or 4 component container for any of the basic types just mentioned. They can take the following form (<code>n</code> represents the number of components):</p>
<ul>
<li><code>vecn</code>: the default vector of <code>n</code> floats.</li>
<li><code>bvecn</code>: a vector of <code>n</code> booleans.</li>
<li><code>ivecn</code>: a vector of <code>n</code> integers.</li>
<li><code>uvecn</code>: a vector of <code>n</code> unsigned integers.</li>
<li><code>dvecn</code>: a vector of <code>n</code> double components.</li>
</ul>
<p>Most of the time we will be using the basic <code>vecn</code> since floats are sufficient for most of our purposes.</p>
<p>Components of a vector can be accessed via <code>vec.x</code> where <code>x</code> is the first component of the vector. You can use <code>.x</code>, <code>.y</code>, <code>.z</code> and <code>.w</code> to access their first, second, third and fourth component respectively. GLSL also allows you to use <code>rgba</code> for colors or <code>stpq</code> for texture coordinates, accessing the same components.</p>
<p>The vector datatype allows for some interesting and flexible component selection called swizzling. Swizzling allows us to use syntax like this:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">vec2</span> <span class="n">someVec</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">vec4</span> <span class="n">differentVec</span> <span class="o">=</span> <span class="n">someVec</span><span class="p">.</span><span class="n">xyxx</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">vec3</span> <span class="n">anotherVec</span> <span class="o">=</span> <span class="n">differentVec</span><span class="p">.</span><span class="n">zyw</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="n">vec4</span> <span class="n">otherVec</span> <span class="o">=</span> <span class="n">someVec</span><span class="p">.</span><span class="n">xxxx</span> <span class="o">+</span> <span class="n">anotherVec</span><span class="p">.</span><span class="n">yxzy</span><span class="p">;</span></span></span></code></pre></div><p>You can use any combination of up to 4 letters to create a new vector (of the same type) as long as the original vector has those components; it is not allowed to access the <code>.z</code> component of a <code>vec2</code> for example. We can also pass vectors as arguments to different vector constructor calls, reducing the number of arguments required:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">vec2</span> <span class="n">vect</span> <span class="o">=</span> <span class="n">vec2</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">vec4</span> <span class="n">result</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">vect</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">vec4</span> <span class="n">otherResult</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">xyz</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span></span></span></code></pre></div><p>Vectors are thus a flexible datatype that we can use for all kinds of input and output. Throughout the book you&rsquo;ll see plenty of examples of how we can creatively manage vectors.</p>
<h4 id="ins-and-outs">Ins and outs</h4>
<p>Shaders are nice little programs on their own, but they are part of a whole and for that reason we want to have inputs and outputs on the individual shaders so that we can move stuff around. GLSL defined the <code>in</code> and <code>out</code> keywords specifically for that purpose. Each shader can specify inputs and outputs using those keywords and wherever an output variable matches with an input variable of the next shader stage they&rsquo;re passed along. The vertex and fragment shader differ a bit though.</p>
<p>The vertex shader <strong>should</strong> receive some form of input otherwise it would be pretty ineffective. The vertex shader differs in its input, in that it receives its input straight from the vertex data. To define how the vertex data is organized we specify the input variables with location metadata so we can configure the vertex attributes on the CPU. We&rsquo;ve seen this in the previous chapter as <code>layout (location = 0)</code>. The vertex shader thus requires an extra layout specification for its inputs so we can link it with the vertex data.</p>
<p><note>It is also possible to omit the <code>layout (location = 0)</code> specifier and query for the attribute locations in your OpenGL code via glGetAttribLocation, but I&rsquo;d prefer to set them in the vertex shader. It is easier to understand and saves you (and OpenGL) some work.</note></p>
<p>The other exception is that the fragment shader requires a <code>vec4</code> color output variable, since the fragment shaders needs to generate a final output color. If you fail to specify an output color in your fragment shader, the color buffer output for those fragments will be undefined (which usually means OpenGL will render them either black or white).</p>
<p>So if we want to send data from one shader to the other we&rsquo;d have to declare an output in the sending shader and a similar input in the receiving shader. When the types and the names are equal on both sides OpenGL will link those variables together and then it is possible to send data between shaders (this is done when linking a program object). To show you how this works in practice we&rsquo;re going to alter the shaders from the previous chapter to let the vertex shader decide the color for the fragment shader.</p>
<p><strong>Vertex shader</strong></p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mo">0</span><span class="p">)</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">aPos</span><span class="p">;</span> <span class="c1">// the position variable has attribute position 0</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="k">out</span> <span class="k">vec4</span> <span class="n">vertexColor</span><span class="p">;</span> <span class="c1">// specify a color output to the fragment shader</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="k">void</span> <span class="n">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="n">gl_Position</span> <span class="o">=</span> <span class="k">vec4</span><span class="p">(</span><span class="n">aPos</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span> <span class="c1">// see how we directly give a vec3 to vec4&#39;s constructor</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="n">vertexColor</span> <span class="o">=</span> <span class="k">vec4</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span> <span class="c1">// set the output variable to a dark-red color</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p><strong>Fragment shader</strong></p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="ln">1</span><span class="cl"><span class="cp">#version 330 core</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="k">out</span> <span class="k">vec4</span> <span class="n">FragColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">  
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="k">in</span> <span class="k">vec4</span> <span class="n">vertexColor</span><span class="p">;</span> <span class="c1">// the input variable from the vertex shader (same name and same type)  </span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="k">void</span> <span class="n">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">8</span><span class="cl">    <span class="n">FragColor</span> <span class="o">=</span> <span class="n">vertexColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">9</span><span class="cl"><span class="p">}</span> </span></span></code></pre></div><p>You can see we declared a vertexColor variable as a <code>vec4</code> output that we set in the vertex shader and we declare a similar vertexColor input in the fragment shader. Since they both have the same type and name, the vertexColor in the fragment shader is linked to the vertexColor in the vertex shader. Because we set the color to a dark-red color in the vertex shader, the resulting fragments should be dark-red as well. The following image shows the output:</p>
<p><a href="#R-image-57259bae895635f6d6ef1e2677155c19" class="lightbox-link"><img src="./assets/shaders.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-57259bae895635f6d6ef1e2677155c19"><img src="./assets/shaders.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>There we go! We just managed to send a value from the vertex shader to the fragment shader. Let&rsquo;s spice it up a bit and see if we can send a color from our application to the fragment shader!</p>
<h4 id="uniforms">Uniforms</h4>
<p>Uniforms are another way to pass data from our application on the CPU to the shaders on the GPU. Uniforms are however slightly different compared to vertex attributes. First of all, uniforms are global. Global, meaning that a uniform variable is unique per shader program object, and can be accessed from any shader at any stage in the shader program. Second, whatever you set the uniform value to, uniforms will keep their values until they&rsquo;re either reset or updated.</p>
<p>To declare a uniform in GLSL we simply add the <code>uniform</code> keyword to a shader with a type and a name. From that point on we can use the newly declared uniform in the shader. Let&rsquo;s see if this time we can set the color of the triangle via a uniform:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="ln">1</span><span class="cl"><span class="cp">#version 330 core</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="k">out</span> <span class="k">vec4</span> <span class="n">FragColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">  
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="k">uniform</span> <span class="k">vec4</span> <span class="n">ourColor</span><span class="p">;</span> <span class="c1">// we set this variable in the OpenGL code.</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="k">void</span> <span class="n">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">8</span><span class="cl">    <span class="n">FragColor</span> <span class="o">=</span> <span class="n">ourColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">9</span><span class="cl"><span class="p">}</span> </span></span></code></pre></div><p>We declared a uniform <code>vec4</code> ourColor in the fragment shader and set the fragment&rsquo;s output color to the content of this uniform value. Since uniforms are global variables, we can define them in any shader stage we&rsquo;d like so no need to go through the vertex shader again to get something to the fragment shader. We&rsquo;re not using this uniform in the vertex shader so there&rsquo;s no need to define it there.</p>
<p><warning>If you declare a uniform that isn&rsquo;t used anywhere in your GLSL code the compiler will silently remove the variable from the compiled version which is the cause for several frustrating errors; keep this in mind!</warning></p>
<p>The uniform is currently empty; we haven&rsquo;t added any data to the uniform yet so let&rsquo;s try that. We first need to find the index/location of the uniform attribute in our shader. Once we have the index/location of the uniform, we can update its values. Instead of passing a single color to the fragment shader, let&rsquo;s spice things up by gradually changing color over time:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">float</span> <span class="n">timeValue</span> <span class="o">=</span> <span class="n">glfwGetTime</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="kt">float</span> <span class="n">greenValue</span> <span class="o">=</span> <span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">timeValue</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0f</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5f</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="kt">int</span> <span class="n">vertexColorLocation</span> <span class="o">=</span> <span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shaderProgram</span><span class="p">,</span> <span class="s">&#34;ourColor&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="n">glUseProgram</span><span class="p">(</span><span class="n">shaderProgram</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="n">glUniform4f</span><span class="p">(</span><span class="n">vertexColorLocation</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="n">greenValue</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">);</span></span></span></code></pre></div><p>First, we retrieve the running time in seconds via glfwGetTime(). Then we vary the color in the range of <code>0.0</code> - <code>1.0</code> by using the sin function and store the result in greenValue.</p>
<p>Then we query for the location of the ourColor uniform using glGetUniformLocation. We supply the shader program and the name of the uniform (that we want to retrieve the location from) to the query function. If glGetUniformLocation returns <code>-1</code>, it could not find the location. Lastly we can set the uniform value using the glUniform4f function. Note that finding the uniform location does not require you to use the shader program first, but updating a uniform <strong>does</strong> require you to first use the program (by calling glUseProgram), because it sets the uniform on the currently active shader program.</p>
<p><note>Because OpenGL is in its core a C library it does not have native support for function overloading, so wherever a function can be called with different types OpenGL defines new functions for each type required; glUniform is a perfect example of this. The function requires a specific postfix for the type of the uniform you want to set. A few of the possible postfixes are:<br>   • <code>f</code>: the function expects a <code>float</code> as its value.<br>   • <code>i</code>: the function expects an <code>int</code> as its value.<br>   • <code>ui</code>: the function expects an <code>unsigned int</code> as its value.<br>   • <code>3f</code>: the function expects 3 <code>float</code>s as its value.<br>   • <code>fv</code>: the function expects a <code>float</code> vector/array as its value.<br>Whenever you want to configure an option of OpenGL simply pick the overloaded function that corresponds with your type. In our case we want to set 4 floats of the uniform individually so we pass our data via glUniform4f (note that we also could&rsquo;ve used the <code>fv</code> version).</note></p>
<p>Now that we know how to set the values of uniform variables, we can use them for rendering. If we want the color to gradually change, we want to update this uniform every frame, otherwise the triangle would maintain a single solid color if we only set it once. So we calculate the greenValue and update the uniform each render iteration:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">glfwWindowShouldClose</span><span class="p">(</span><span class="n">window</span><span class="p">))</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="c1">// input
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1"></span>    <span class="n">processInput</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="c1">// render
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1"></span>    <span class="c1">// clear the colorbuffer
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="c1"></span>    <span class="n">glClearColor</span><span class="p">(</span><span class="mf">0.2f</span><span class="p">,</span> <span class="mf">0.3f</span><span class="p">,</span> <span class="mf">0.3f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="n">glClear</span><span class="p">(</span><span class="n">GL_COLOR_BUFFER_BIT</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="c1">// be sure to activate the shader
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="c1"></span>    <span class="n">glUseProgram</span><span class="p">(</span><span class="n">shaderProgram</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">  
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="c1">// update the uniform color
</span></span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="c1"></span>    <span class="kt">float</span> <span class="n">timeValue</span> <span class="o">=</span> <span class="n">glfwGetTime</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="kt">float</span> <span class="n">greenValue</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">timeValue</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0f</span> <span class="o">+</span> <span class="mf">0.5f</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">    <span class="kt">int</span> <span class="n">vertexColorLocation</span> <span class="o">=</span> <span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shaderProgram</span><span class="p">,</span> <span class="s">&#34;ourColor&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">    <span class="n">glUniform4f</span><span class="p">(</span><span class="n">vertexColorLocation</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="n">greenValue</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">
</span></span><span class="line"><span class="ln">20</span><span class="cl">    <span class="c1">// now render the triangle
</span></span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="c1"></span>    <span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">VAO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">    <span class="n">glDrawArrays</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">  
</span></span><span class="line"><span class="ln">24</span><span class="cl">    <span class="c1">// swap buffers and poll IO events
</span></span></span><span class="line"><span class="ln">25</span><span class="cl"><span class="c1"></span>    <span class="n">glfwSwapBuffers</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl">    <span class="n">glfwPollEvents</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>The code is a relatively straightforward adaptation of the previous code. This time, we update a uniform value each frame before drawing the triangle. If you update the uniform correctly you should see the color of your triangle gradually change from green to black and back to green.</p>
<p><video src="assets/shaders.mp4" width="600" height="450" controls="" preload="auto"></video></p>
<p>Check out the source code <a href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/3.1.shaders_uniform/shaders_uniform.cpp" target="_blank">here</a> if you&rsquo;re stuck.</p>
<p>As you can see, uniforms are a useful tool for setting attributes that may change every frame, or for interchanging data between your application and your shaders, but what if we want to set a color for each vertex? In that case we&rsquo;d have to declare as many uniforms as we have vertices. A better solution would be to include more data in the vertex attributes which is what we&rsquo;re going to do now.</p>
<h4 id="more-attributes">More attributes!</h4>
<p>We saw in the previous chapter how we can fill a VBO, configure vertex attribute pointers and store it all in a VAO. This time, we also want to add color data to the vertex data. We&rsquo;re going to add color data as 3 <code>float</code>s to the vertices array. We assign a red, green and blue color to each of the corners of our triangle respectively:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">float</span> <span class="n">vertices</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">    <span class="c1">// positions         // colors
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="c1"></span>     <span class="mf">0.5f</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span>  <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span>   <span class="c1">// bottom right
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="c1"></span>    <span class="o">-</span><span class="mf">0.5f</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span>  <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span>   <span class="c1">// bottom left
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="c1"></span>     <span class="mf">0.0f</span><span class="p">,</span>  <span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span>  <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">1.0f</span>    <span class="c1">// top 
</span></span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="c1"></span><span class="p">};</span>   
</span></span></code></pre></div><p>Since we now have more data to send to the vertex shader, it is necessary to adjust the vertex shader to also receive our color value as a vertex attribute input. Note that we set the location of the aColor attribute to 1 with the layout specifier:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">aPos</span><span class="p">;</span>   <span class="c1">// the position variable has attribute position 0
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="c1"></span><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">aColor</span><span class="p">;</span> <span class="c1">// the color variable has attribute position 1
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1"></span>  
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">out</span> <span class="n">vec3</span> <span class="n">ourColor</span><span class="p">;</span> <span class="c1">// output a color to the fragment shader
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">aPos</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="n">ourColor</span> <span class="o">=</span> <span class="n">aColor</span><span class="p">;</span> <span class="c1">// set ourColor to the input color we got from the vertex data
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="c1"></span><span class="p">}</span>  
</span></span></code></pre></div><p>Since we no longer use a uniform for the fragment&rsquo;s color, but now use the ourColor output variable we&rsquo;ll have to change the fragment shader as well:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="cp"></span><span class="n">out</span> <span class="n">vec4</span> <span class="n">FragColor</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">in</span> <span class="n">vec3</span> <span class="n">ourColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">  
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl">    <span class="n">FragColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">ourColor</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">8</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>Because we added another vertex attribute and updated the VBO&rsquo;s memory we have to re-configure the vertex attribute pointers. The updated data in the VBO&rsquo;s memory now looks a bit like this:</p>
<p><a href="#R-image-c15b0f84439c0539390cb6ab1c4e2cc8" class="lightbox-link"><img src="./assets/vertex_attribute_pointer_interleaved.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c15b0f84439c0539390cb6ab1c4e2cc8"><img src="./assets/vertex_attribute_pointer_interleaved.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Knowing the current layout we can update the vertex format with glVertexAttribPointer:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="c1">// position attribute
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="c1"></span><span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="mi">6</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="c1">// color attribute
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="c1"></span><span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="mi">6</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)(</span><span class="mi">3</span><span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)));</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span></span></span></code></pre></div><p>The first few arguments of glVertexAttribPointer are relatively straightforward. This time we are configuring the vertex attribute on attribute location <code>1</code>. The color values have a size of <code>3</code> <code>float</code>s and we do not normalize the values.</p>
<p>Since we now have two vertex attributes we have to re-calculate the <em>stride</em> value. To get the next attribute value (e.g. the next <code>x</code> component of the position vector) in the data array we have to move <code>6</code> <code>float</code>s to the right, three for the position values and three for the color values. This gives us a stride value of 6 times the size of a <code>float</code> in bytes (= <code>24</code> bytes).
Also, this time we have to specify an offset. For each vertex, the position vertex attribute is first so we declare an offset of <code>0</code>. The color attribute starts after the position data so the offset is <code>3 * sizeof(float)</code> in bytes (= <code>12</code> bytes).</p>
<p>Running the application should result in the following image:</p>
<p><a href="#R-image-0d1cc3169c81fe8611602a36f61e5e40" class="lightbox-link"><img src="./assets/shaders3.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-0d1cc3169c81fe8611602a36f61e5e40"><img src="./assets/shaders3.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Check out the source code <a href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/3.2.shaders_interpolation/shaders_interpolation.cpp" target="_blank">here</a> if you&rsquo;re stuck.</p>
<p>The image may not be exactly what you would expect, since we only supplied 3 colors, not the huge color palette we&rsquo;re seeing right now. This is all the result of something called fragment interpolation in the fragment shader. When rendering a triangle the rasterization stage usually results in a lot more fragments than vertices originally specified. The rasterizer then determines the positions of each of those fragments based on where they reside on the triangle shape.
Based on these positions, it interpolates all the fragment shader&rsquo;s input variables. Say for example we have a line where the upper point has a green color and the lower point a blue color. If the fragment shader is run at a fragment that resides around a position at <code>70%</code> of the line, its resulting color input attribute would then be a linear combination of green and blue; to be more precise: <code>30%</code> blue and <code>70%</code> green.</p>
<p>This is exactly what happened at the triangle. We have 3 vertices and thus 3 colors, and judging from the triangle&rsquo;s pixels it probably contains around 50000 fragments, where the fragment shader interpolated the colors among those pixels. If you take a good look at the colors you&rsquo;ll see it all makes sense: red to blue first gets to purple and then to blue. Fragment interpolation is applied to all the fragment shader&rsquo;s input attributes.</p>
<h4 id="our-own-shader-class">Our own shader class</h4>
<p>Writing, compiling and managing shaders can be quite cumbersome. As a final touch on the shader subject we&rsquo;re going to make our life a bit easier by building a shader class that reads shaders from disk, compiles and links them, checks for errors and is easy to use. This also gives you a bit of an idea how we can encapsulate some of the knowledge we learned so far into useful abstract objects.</p>
<p>We will create the shader class entirely in a header file, mainly for learning purposes and portability. Let&rsquo;s start by adding the required includes and by defining the class structure:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#ifndef SHADER_H
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp">#define SHADER_H
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;glad/glad.h&gt;</span><span class="cp"> </span><span class="c1">// include glad to get all the required OpenGL headers
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="c1"></span>  
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;fstream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sstream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="cp"></span>  
</span></span><span class="line"><span class="ln">11</span><span class="cl">
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="k">class</span> <span class="nc">Shader</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="c1">// the program ID
</span></span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ID</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">  
</span></span><span class="line"><span class="ln">18</span><span class="cl">    <span class="c1">// constructor reads and builds the shader
</span></span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="c1"></span>    <span class="n">Shader</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">vertexPath</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">fragmentPath</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">    <span class="c1">// use/activate the shader
</span></span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="nf">use</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">    <span class="c1">// utility uniform functions
</span></span></span><span class="line"><span class="ln">23</span><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="nf">setBool</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">name</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">value</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">24</span><span class="cl">    <span class="kt">void</span> <span class="nf">setInt</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>   
</span></span><span class="line"><span class="ln">25</span><span class="cl">    <span class="kt">void</span> <span class="nf">setFloat</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">name</span><span class="p">,</span> <span class="kt">float</span> <span class="n">value</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl">  
</span></span><span class="line"><span class="ln">28</span><span class="cl"><span class="cp">#endif</span></span></span></code></pre></div><p><note>We used several preprocessor directives at the top of the header file. Using these little lines of code informs your compiler to only include and compile this header file if it hasn&rsquo;t been included yet, even if multiple files include the shader header. This prevents linking conflicts.</note></p>
<p>The shader class holds the ID of the shader program. Its constructor requires the file paths of the source code of the vertex and fragment shader respectively that we can store on disk as simple text files. To add a little extra we also add several utility functions to ease our lives a little: use activates the shader program, and all set&hellip; functions query a uniform location and set its value.</p>
<h4 id="reading-from-file">Reading from file</h4>
<p>We&rsquo;re using C++ filestreams to read the content from the file into several <code>string</code> objects:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">Shader</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">vertexPath</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">fragmentPath</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="c1">// 1. retrieve the vertex/fragment source code from filePath
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">vertexCode</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">fragmentCode</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">ifstream</span> <span class="n">vShaderFile</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">ifstream</span> <span class="n">fShaderFile</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="c1">// ensure ifstream objects can throw exceptions:
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1"></span>    <span class="n">vShaderFile</span><span class="p">.</span><span class="n">exceptions</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ifstream</span><span class="o">::</span><span class="n">failbit</span> <span class="o">|</span> <span class="n">std</span><span class="o">::</span><span class="n">ifstream</span><span class="o">::</span><span class="n">badbit</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="n">fShaderFile</span><span class="p">.</span><span class="n">exceptions</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ifstream</span><span class="o">::</span><span class="n">failbit</span> <span class="o">|</span> <span class="n">std</span><span class="o">::</span><span class="n">ifstream</span><span class="o">::</span><span class="n">badbit</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="k">try</span> 
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">        <span class="c1">// open files
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="c1"></span>        <span class="n">vShaderFile</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="n">vertexPath</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">        <span class="n">fShaderFile</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="n">fragmentPath</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">stringstream</span> <span class="n">vShaderStream</span><span class="p">,</span> <span class="n">fShaderStream</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">        <span class="c1">// read file&#39;s buffer contents into streams
</span></span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="c1"></span>        <span class="n">vShaderStream</span> <span class="o">&lt;&lt;</span> <span class="n">vShaderFile</span><span class="p">.</span><span class="n">rdbuf</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">        <span class="n">fShaderStream</span> <span class="o">&lt;&lt;</span> <span class="n">fShaderFile</span><span class="p">.</span><span class="n">rdbuf</span><span class="p">();</span>		
</span></span><span class="line"><span class="ln">20</span><span class="cl">        <span class="c1">// close file handlers
</span></span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="c1"></span>        <span class="n">vShaderFile</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">        <span class="n">fShaderFile</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">        <span class="c1">// convert stream into string
</span></span></span><span class="line"><span class="ln">24</span><span class="cl"><span class="c1"></span>        <span class="n">vertexCode</span>   <span class="o">=</span> <span class="n">vShaderStream</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl">        <span class="n">fragmentCode</span> <span class="o">=</span> <span class="n">fShaderStream</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>		
</span></span><span class="line"><span class="ln">26</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl">    <span class="k">catch</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ifstream</span><span class="o">::</span><span class="n">failure</span> <span class="n">e</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">28</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln">29</span><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;ERROR::SHADER::FILE_NOT_SUCCESFULLY_READ&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">30</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">31</span><span class="cl">    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">vShaderCode</span> <span class="o">=</span> <span class="n">vertexCode</span><span class="p">.</span><span class="n">c_str</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">32</span><span class="cl">    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">fShaderCode</span> <span class="o">=</span> <span class="n">fragmentCode</span><span class="p">.</span><span class="n">c_str</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">33</span><span class="cl">    <span class="p">[...]</span></span></span></code></pre></div><p>Next we need to compile and link the shaders. Note that we&rsquo;re also reviewing if compilation/linking failed and if so, print the compile-time errors. This is extremely useful when debugging (you are going to need those error logs eventually):</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="c1">// 2. compile shaders
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1"></span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">vertex</span><span class="p">,</span> <span class="n">fragment</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="kt">int</span> <span class="n">success</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="kt">char</span> <span class="n">infoLog</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">   
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="c1">// vertex Shader
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1"></span><span class="n">vertex</span> <span class="o">=</span> <span class="n">glCreateShader</span><span class="p">(</span><span class="n">GL_VERTEX_SHADER</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="n">glShaderSource</span><span class="p">(</span><span class="n">vertex</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vShaderCode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="n">glCompileShader</span><span class="p">(</span><span class="n">vertex</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1">// print compile errors if any
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="c1"></span><span class="n">glGetShaderiv</span><span class="p">(</span><span class="n">vertex</span><span class="p">,</span> <span class="n">GL_COMPILE_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">success</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">success</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="n">glGetShaderInfoLog</span><span class="p">(</span><span class="n">vertex</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">infoLog</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;ERROR::SHADER::VERTEX::COMPILATION_FAILED</span><span class="se">\n</span><span class="s">&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">infoLog</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">  
</span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="c1">// similiar for Fragment Shader
</span></span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="c1"></span><span class="p">[...]</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">  
</span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="c1">// shader Program
</span></span></span><span class="line"><span class="ln">22</span><span class="cl"><span class="c1"></span><span class="n">ID</span> <span class="o">=</span> <span class="n">glCreateProgram</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl"><span class="n">glAttachShader</span><span class="p">(</span><span class="n">ID</span><span class="p">,</span> <span class="n">vertex</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl"><span class="n">glAttachShader</span><span class="p">(</span><span class="n">ID</span><span class="p">,</span> <span class="n">fragment</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl"><span class="n">glLinkProgram</span><span class="p">(</span><span class="n">ID</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl"><span class="c1">// print linking errors if any
</span></span></span><span class="line"><span class="ln">27</span><span class="cl"><span class="c1"></span><span class="n">glGetProgramiv</span><span class="p">(</span><span class="n">ID</span><span class="p">,</span> <span class="n">GL_LINK_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">success</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">28</span><span class="cl"><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">success</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">29</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">30</span><span class="cl">    <span class="n">glGetProgramInfoLog</span><span class="p">(</span><span class="n">ID</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">infoLog</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">31</span><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;ERROR::SHADER::PROGRAM::LINKING_FAILED</span><span class="se">\n</span><span class="s">&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">infoLog</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">32</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">33</span><span class="cl">  
</span></span><span class="line"><span class="ln">34</span><span class="cl"><span class="c1">// delete the shaders as they&#39;re linked into our program now and no longer necessary
</span></span></span><span class="line"><span class="ln">35</span><span class="cl"><span class="c1"></span><span class="n">glDeleteShader</span><span class="p">(</span><span class="n">vertex</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">36</span><span class="cl"><span class="n">glDeleteShader</span><span class="p">(</span><span class="n">fragment</span><span class="p">);</span></span></span></code></pre></div><p>The use function is straightforward:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">void</span> <span class="nf">use</span><span class="p">()</span> 
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="n">glUseProgram</span><span class="p">(</span><span class="n">ID</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>Similarly for any of the uniform setter functions:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="nf">setBool</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">name</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">value</span><span class="p">)</span> <span class="k">const</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>         
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="n">glUniform1i</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">ID</span><span class="p">,</span> <span class="n">name</span><span class="p">.</span><span class="n">c_str</span><span class="p">()),</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">value</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="kt">void</span> <span class="nf">setInt</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="k">const</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="n">glUniform1i</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">ID</span><span class="p">,</span> <span class="n">name</span><span class="p">.</span><span class="n">c_str</span><span class="p">()),</span> <span class="n">value</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="kt">void</span> <span class="nf">setFloat</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">name</span><span class="p">,</span> <span class="kt">float</span> <span class="n">value</span><span class="p">)</span> <span class="k">const</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="n">glUniform1f</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">ID</span><span class="p">,</span> <span class="n">name</span><span class="p">.</span><span class="n">c_str</span><span class="p">()),</span> <span class="n">value</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="p">}</span> 
</span></span></code></pre></div><p>And there we have it, a completed <a href="https://learnopengl.com/code_viewer_gh.php?code=includes/learnopengl/shader_s.h" target="_blank">shader class</a>. Using the shader class is fairly easy; we create a shader object once and from that point on simply start using it:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">Shader</span> <span class="nf">ourShader</span><span class="p">(</span><span class="s">&#34;path/to/shaders/shader.vs&#34;</span><span class="p">,</span> <span class="s">&#34;path/to/shaders/shader.fs&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">[...]</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="k">while</span><span class="p">(...)</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">    <span class="n">ourShader</span><span class="p">.</span><span class="n">use</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">    <span class="n">ourShader</span><span class="p">.</span><span class="n">setFloat</span><span class="p">(</span><span class="s">&#34;someUniform&#34;</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl">    <span class="n">DrawStuff</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">8</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>Here we stored the vertex and fragment shader source code in two files called <code>shader.vs</code> and <code>shader.fs</code>. You&rsquo;re free to name your shader files however you like; I personally find the extensions <code>.vs</code> and <code>.fs</code> quite intuitive.</p>
<p>You can find the source code <a href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/3.3.shaders_class/shaders_class.cpp" target="_blank">here</a> using our newly created <a href="https://learnopengl.com/code_viewer_gh.php?code=includes/learnopengl/shader_s.h" target="_blank">shader class</a>. Note that you can click the shader file paths to find the shaders&rsquo; source code.</p>
<h4 id="exercises-1">Exercises</h4>
<ol>
<li>Adjust the vertex shader so that the triangle is upside down: <a href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/3.4.shaders_exercise1/shaders_exercise1.cpp" target="_blank">solution</a>.</li>
<li>Specify a horizontal offset via a uniform and move the triangle to the right side of the screen in the vertex shader using this offset value: <a href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/3.5.shaders_exercise2/shaders_exercise2.cpp" target="_blank">solution</a>.</li>
<li>Output the vertex position to the fragment shader using the <code>out</code> keyword and set the fragment&rsquo;s color equal to this vertex position (see how even the vertex position values are interpolated across the triangle). Once you managed to do this; try to answer the following question: why is the bottom-left side of our triangle black?: <a href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/3.6.shaders_exercise3/shaders_exercise3.cpp" target="_blank">solution</a>.</li>
</ol>
<h3 id="textures">Textures</h3>
<p>We learned that to add more detail to our objects we can use colors for each vertex to create some interesting images. However, to get a fair bit of realism we&rsquo;d have to have many vertices so we could specify a lot of colors. This takes up a considerable amount of extra overhead, since each model needs a lot more vertices and for each vertex a color attribute as well.</p>
<p>What artists and programmers generally prefer is to use a texture. A texture is a 2D image (even 1D and 3D textures exist) used to add detail to an object; think of a texture as a piece of paper with a nice brick image (for example) on it neatly folded over your 3D house so it looks like your house has a stone exterior. Because we can insert a lot of detail in a single image, we can give the illusion the object is extremely detailed without having to specify extra vertices.</p>
<p><note>Next to images, textures can also be used to store a large collection of arbitrary data to send to the shaders, but we&rsquo;ll leave that for a different topic.</note></p>
<p>Below you&rsquo;ll see a texture image of a <a href="./assets/wall.jpg">brick wall</a> mapped to the triangle from the previous chapter.</p>
<p><a href="#R-image-1064b8e52308c979d47305a7a08effe1" class="lightbox-link"><img src="./assets/textures.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-1064b8e52308c979d47305a7a08effe1"><img src="./assets/textures.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>In order to map a texture to the triangle we need to tell each vertex of the triangle which part of the texture it corresponds to. Each vertex should thus have a texture coordinate associated with them that specifies what part of the texture image to sample from. Fragment interpolation then does the rest for the other fragments.</p>
<p>Texture coordinates range from <code>0</code> to <code>1</code> in the <code>x</code> and <code>y</code> axis (remember that we use 2D texture images). Retrieving the texture color using texture coordinates is called sampling. Texture coordinates start at <code>(0,0)</code> for the lower left corner of a texture image to <code>(1,1)</code> for the upper right corner of a texture image. The following image shows how we map texture coordinates to the triangle:</p>
<p><a href="#R-image-2946427098585269a1b6e5830d12edc8" class="lightbox-link"><img src="./assets/tex_coords.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-2946427098585269a1b6e5830d12edc8"><img src="./assets/tex_coords.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>We specify 3 texture coordinate points for the triangle. We want the bottom-left side of the triangle to correspond with the bottom-left side of the texture so we use the <code>(0,0)</code> texture coordinate for the triangle&rsquo;s bottom-left vertex. The same applies to the bottom-right side with a <code>(1,0)</code> texture coordinate. The top of the triangle should correspond with the top-center of the texture image so we take <code>(0.5,1.0)</code> as its texture coordinate. We only have to pass 3 texture coordinates to the vertex shader, which then passes those to the fragment shader that neatly interpolates all the texture coordinates for each fragment.</p>
<p>The resulting texture coordinates would then look like this:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">float</span> <span class="n">texCoords</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">    <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span>  <span class="c1">// lower-left corner  
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="c1"></span>    <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span>  <span class="c1">// lower-right corner
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="c1"></span>    <span class="mf">0.5f</span><span class="p">,</span> <span class="mf">1.0f</span>   <span class="c1">// top-center corner
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="c1"></span><span class="p">};</span></span></span></code></pre></div><p>Texture sampling has a loose interpretation and can be done in many different ways. It is thus our job to tell OpenGL how it should <em>sample</em> its textures.</p>
<h4 id="texture-wrapping">Texture Wrapping</h4>
<p>Texture coordinates usually range from <code>(0,0)</code> to <code>(1,1)</code> but what happens if we specify coordinates outside this range? The default behavior of OpenGL is to repeat the texture images (we basically ignore the integer part of the floating point texture coordinate), but there are more options OpenGL offers:</p>
<ul>
<li>GL_REPEAT: The default behavior for textures. Repeats the texture image.</li>
<li>GL_MIRRORED_REPEAT: Same as GL_REPEAT but mirrors the image with each repeat.</li>
<li>GL_CLAMP_TO_EDGE: Clamps the coordinates between <code>0</code> and <code>1</code>. The result is that higher coordinates become clamped to the edge, resulting in a stretched edge pattern.</li>
<li>GL_CLAMP_TO_BORDER: Coordinates outside the range are now given a user-specified border color.</li>
</ul>
<p>Each of the options have a different visual output when using texture coordinates outside the default range. Let&rsquo;s see what these look like on a sample texture image (original image by Hólger Rezende):</p>
<p><a href="#R-image-909f2ec5915a7f74348091b9733a953d" class="lightbox-link"><img src="./assets/texture_wrapping.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-909f2ec5915a7f74348091b9733a953d"><img src="./assets/texture_wrapping.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Each of the aforementioned options can be set per coordinate axis (<code>s</code>, <code>t</code> (and <code>r</code> if you&rsquo;re using 3D textures) equivalent to <code>x</code>,<code>y</code>,<code>z</code>) with the glTexParameter* function:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_S</span><span class="p">,</span> <span class="n">GL_MIRRORED_REPEAT</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_T</span><span class="p">,</span> <span class="n">GL_MIRRORED_REPEAT</span><span class="p">);</span></span></span></code></pre></div><p>The first argument specifies the texture target; we&rsquo;re working with 2D textures so the texture target is GL_TEXTURE_2D. The second argument requires us to tell what option we want to set and for which texture axis; we want to configure it for both the <code>S</code> and <code>T</code> axis. The last argument requires us to pass in the texture wrapping mode we&rsquo;d like and in this case OpenGL will set its texture wrapping option on the currently active texture with GL_MIRRORED_REPEAT.</p>
<p>If we choose the GL_CLAMP_TO_BORDER option we should also specify a border color. This is done using the <code>fv</code> equivalent of the glTexParameter function with GL_TEXTURE_BORDER_COLOR as its option where we pass in a float array of the border&rsquo;s color value:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">float</span> <span class="n">borderColor</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">1.0f</span> <span class="p">};</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glTexParameterfv</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_BORDER_COLOR</span><span class="p">,</span> <span class="n">borderColor</span><span class="p">);</span>  
</span></span></code></pre></div><h4 id="texture-filtering">Texture Filtering</h4>
<p>Texture coordinates do not depend on resolution but can be any floating point value, thus OpenGL has to figure out which texture pixel (also known as a texel ) to map the texture coordinate to. This becomes especially important if you have a very large object and a low resolution texture. You probably guessed by now that OpenGL has options for this texture filtering as well. There are several options available but for now we&rsquo;ll discuss the most important options: GL_NEAREST and GL_LINEAR.</p>
<p>GL_NEAREST (also known as nearest neighbor or point filtering) is the default texture filtering method of OpenGL. When set to GL_NEAREST, OpenGL selects the texel that center is closest to the texture coordinate. Below you can see 4 pixels where the cross represents the exact texture coordinate. The upper-left texel has its center closest to the texture coordinate and is therefore chosen as the sampled color:</p>
<p><a href="#R-image-02750991107cb656e45a6441e75ebf13" class="lightbox-link"><img src="./assets/filter_nearest.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-02750991107cb656e45a6441e75ebf13"><img src="./assets/filter_nearest.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>GL_LINEAR (also known as (bi)linear filtering) takes an interpolated value from the texture coordinate&rsquo;s neighboring texels, approximating a color between the texels. The smaller the distance from the texture coordinate to a texel&rsquo;s center, the more that texel&rsquo;s color contributes to the sampled color. Below we can see that a mixed color of the neighboring pixels is returned:</p>
<p><a href="#R-image-138c471cbcecbc601549ade553da0642" class="lightbox-link"><img src="./assets/filter_linear.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-138c471cbcecbc601549ade553da0642"><img src="./assets/filter_linear.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>But what is the visual effect of such a texture filtering method? Let&rsquo;s see how these methods work when using a texture with a low resolution on a large object (texture is therefore scaled upwards and individual texels are noticeable):</p>
<p><a href="#R-image-59e837b7de6b5d464eaae7201c0689a2" class="lightbox-link"><img src="./assets/texture_filtering.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-59e837b7de6b5d464eaae7201c0689a2"><img src="./assets/texture_filtering.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>GL_NEAREST results in blocked patterns where we can clearly see the pixels that form the texture while GL_LINEAR produces a smoother pattern where the individual pixels are less visible. GL_LINEAR produces a more realistic output, but some developers prefer a more 8-bit look and as a result pick the GL_NEAREST option.</p>
<p>Texture filtering can be set for magnifying and minifying operations (when scaling up or downwards) so you could for example use nearest neighbor filtering when textures are scaled downwards and linear filtering for upscaled textures. We thus have to specify the filtering method for both options via glTexParameter*. The code should look similar to setting the wrapping method:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MIN_FILTER</span><span class="p">,</span> <span class="n">GL_NEAREST</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MAG_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR</span><span class="p">);</span></span></span></code></pre></div><h5 id="mipmaps">Mipmaps</h5>
<p>Imagine we had a large room with thousands of objects, each with an attached texture. There will be objects far away that have the same high resolution texture attached as the objects close to the viewer. Since the objects are far away and probably only produce a few fragments, OpenGL has difficulties retrieving the right color value for its fragment from the high resolution texture, since it has to pick a texture color for a fragment that spans a large part of the texture. This will produce visible artifacts on small objects, not to mention the waste of memory bandwidth using high resolution textures on small objects.</p>
<p>To solve this issue OpenGL uses a concept called mipmaps that is basically a collection of texture images where each subsequent texture is twice as small compared to the previous one. The idea behind mipmaps should be easy to understand: after a certain distance threshold from the viewer, OpenGL will use a different mipmap texture that best suits the distance to the object. Because the object is far away, the smaller resolution will not be noticeable to the user. OpenGL is then able to sample the correct texels, and there&rsquo;s less cache memory involved when sampling that part of the mipmaps. Let&rsquo;s take a closer look at what a mipmapped texture looks like:</p>
<p><a href="#R-image-96851c47db51c7725c55c539772a9e6e" class="lightbox-link"><img src="./assets/mipmaps.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-96851c47db51c7725c55c539772a9e6e"><img src="./assets/mipmaps.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Creating a collection of mipmapped textures for each texture image is cumbersome to do manually, but luckily OpenGL is able to do all the work for us with a single call to glGenerateMipmap after we&rsquo;ve created a texture.</p>
<p>When switching between mipmaps levels during rendering OpenGL may show some artifacts like sharp edges visible between the two mipmap layers. Just like normal texture filtering, it is also possible to filter between mipmap levels using NEAREST and LINEAR filtering for switching between mipmap levels. To specify the filtering method between mipmap levels we can replace the original filtering methods with one of the following four options:</p>
<ul>
<li>GL_NEAREST_MIPMAP_NEAREST: takes the nearest mipmap to match the pixel size and uses nearest neighbor interpolation for texture sampling.</li>
<li>GL_LINEAR_MIPMAP_NEAREST: takes the nearest mipmap level and samples that level using linear interpolation.</li>
<li>GL_NEAREST_MIPMAP_LINEAR: linearly interpolates between the two mipmaps that most closely match the size of a pixel and samples the interpolated level via nearest neighbor interpolation.</li>
<li>GL_LINEAR_MIPMAP_LINEAR: linearly interpolates between the two closest mipmaps and samples the interpolated level via linear interpolation.</li>
</ul>
<p>Just like texture filtering we can set the filtering method to one of the 4 aforementioned methods using glTexParameteri:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MIN_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR_MIPMAP_LINEAR</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MAG_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR</span><span class="p">);</span></span></span></code></pre></div><p>A common mistake is to set one of the mipmap filtering options as the magnification filter. This doesn&rsquo;t have any effect since mipmaps are primarily used for when textures get downscaled: texture magnification doesn&rsquo;t use mipmaps and giving it a mipmap filtering option will generate an OpenGL GL_INVALID_ENUM error code.</p>
<h4 id="loading-and-creating-textures">Loading and creating textures</h4>
<p>The first thing we need to do to actually use textures is to load them into our application. Texture images can be stored in dozens of file formats, each with their own structure and ordering of data, so how do we get those images in our application? One solution would be to choose a file format we&rsquo;d like to use, say <code>.PNG</code> and write our own image loader to convert the image format into a large array of bytes. While it&rsquo;s not very hard to write your own image loader, it&rsquo;s still cumbersome and what if you want to support more file formats? You&rsquo;d then have to write an image loader for each format you want to support.</p>
<p>Another solution, and probably a good one, is to use an image-loading library that supports several popular formats and does all the hard work for us. A library like <code>stb_image.h</code>.</p>
<h5 id="stb_imageh">stb_image.h</h5>
<p><code>stb_image.h</code> is a very popular single header image loading library by <a href="https://github.com/nothings" target="_blank">Sean Barrett</a> that is able to load most popular file formats and is easy to integrate in your project(s). <code>stb_image.h</code> can be downloaded from <a href="https://github.com/nothings/stb/blob/master/stb_image.h" target="_blank">here</a>. Simply download the single header file, add it to your project as <code>stb_image.h</code>, and create an additional C++ file with the following code:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="cp">#define STB_IMAGE_IMPLEMENTATION
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;stb_image.h&#34;</span></span></span></code></pre></div><p>By defining STB_IMAGE_IMPLEMENTATION the preprocessor modifies the header file such that it only contains the relevant definition source code, effectively turning the header file into a <code>.cpp</code> file, and that&rsquo;s about it. Now simply include <code>stb_image.h</code> somewhere in your program and compile.</p>
<p>For the following texture sections we&rsquo;re going to use an image of a <a href="https://learnopengl.com/img/textures/container.jpg" target="_blank">wooden container</a>. To load an image using <code>stb_image.h</code> we use its stbi_load function:</p>
<div class="wrap-code highlight"><pre tabindex="0"><code>int width, height, nrChannels;
unsigned char *data = stbi_load(&#34;container.jpg&#34;, &amp;width, &amp;height, &amp;nrChannels, 0); </code></pre></div><p>The function first takes as input the location of an image file. It then expects you to give three <code>ints</code> as its second, third and fourth argument that <code>stb_image.h</code> will fill with the resulting image&rsquo;s <em>width</em>, <em>height</em> and <em>number</em> of color channels. We need the image&rsquo;s width and height for generating textures later on.</p>
<h4 id="generating-a-texture">Generating a texture</h4>
<p>Like any of the previous objects in OpenGL, textures are referenced with an ID; let&rsquo;s create one:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">texture</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glGenTextures</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">texture</span><span class="p">);</span>  
</span></span></code></pre></div><p>The glGenTextures function first takes as input how many textures we want to generate and stores them in a <code>unsigned int</code> array given as its second argument (in our case just a single <code>unsigned int</code>). Just like other objects we need to bind it so any subsequent texture commands will configure the currently bound texture:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">texture</span><span class="p">);</span>  
</span></span></code></pre></div><p>Now that the texture is bound, we can start generating a texture using the previously loaded image data. Textures are generated with glTexImage2D:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glTexImage2D</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGB</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGB</span><span class="p">,</span> <span class="n">GL_UNSIGNED_BYTE</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glGenerateMipmap</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">);</span></span></span></code></pre></div><p>This is a large function with quite a few parameters so we&rsquo;ll walk through them step-by-step:</p>
<ul>
<li>The first argument specifies the texture target; setting this to GL_TEXTURE_2D means this operation will generate a texture on the currently bound texture object at the same target (so any textures bound to targets GL_TEXTURE_1D or GL_TEXTURE_3D will not be affected).</li>
<li>The second argument specifies the mipmap level for which we want to create a texture for if you want to set each mipmap level manually, but we&rsquo;ll leave it at the base level which is <code>0</code>.</li>
<li>The third argument tells OpenGL in what kind of format we want to store the texture. Our image has only <code>RGB</code> values so we&rsquo;ll store the texture with <code>RGB</code> values as well.</li>
<li>The 4th and 5th argument sets the width and height of the resulting texture. We stored those earlier when loading the image so we&rsquo;ll use the corresponding variables.</li>
<li>The next argument should always be <code>0</code> (some legacy stuff).</li>
<li>The 7th and 8th argument specify the format and datatype of the source image. We loaded the image with <code>RGB</code> values and stored them as <code>char</code>s (bytes) so we&rsquo;ll pass in the corresponding values.</li>
<li>The last argument is the actual image data.</li>
</ul>
<p>Once glTexImage2D is called, the currently bound texture object now has the texture image attached to it. However, currently it only has the base-level of the texture image loaded and if we want to use mipmaps we have to specify all the different images manually (by continually incrementing the second argument) or, we could call glGenerateMipmap after generating the texture. This will automatically generate all the required mipmaps for the currently bound texture.</p>
<p>After we&rsquo;re done generating the texture and its corresponding mipmaps, it is good practice to free the image memory:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">stbi_image_free</span><span class="p">(</span><span class="n">data</span><span class="p">);</span></span></span></code></pre></div><p>The whole process of generating a texture thus looks something like this:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">texture</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="n">glGenTextures</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">texture</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">texture</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1">// set the texture wrapping/filtering options (on the currently bound texture object)
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="c1"></span><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_S</span><span class="p">,</span> <span class="n">GL_REPEAT</span><span class="p">);</span>	
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_T</span><span class="p">,</span> <span class="n">GL_REPEAT</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MIN_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR_MIPMAP_LINEAR</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MAG_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1">// load and generate the texture
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">nrChannels</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">stbi_load</span><span class="p">(</span><span class="s">&#34;container.jpg&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">width</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">height</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nrChannels</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="n">glTexImage2D</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGB</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGB</span><span class="p">,</span> <span class="n">GL_UNSIGNED_BYTE</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="n">glGenerateMipmap</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="k">else</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Failed to load texture&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="n">stbi_image_free</span><span class="p">(</span><span class="n">data</span><span class="p">);</span></span></span></code></pre></div><h4 id="applying-textures">Applying textures</h4>
<p>For the upcoming sections we will use the rectangle shape drawn with glDrawElements from the final part of the <a href="https://learnopengl.com/Getting-started/Hello-Triangle" target="_blank">Hello Triangle</a> chapter. We need to inform OpenGL how to sample the texture so we&rsquo;ll have to update the vertex data with the texture coordinates:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">float</span> <span class="n">vertices</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">    <span class="c1">// positions          // colors           // texture coords
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="c1"></span>     <span class="mf">0.5f</span><span class="p">,</span>  <span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span>   <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span>   <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span>   <span class="c1">// top right
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="c1"></span>     <span class="mf">0.5f</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span>   <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span>   <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span>   <span class="c1">// bottom right
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="c1"></span>    <span class="o">-</span><span class="mf">0.5f</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span>   <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span>   <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span>   <span class="c1">// bottom left
</span></span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="c1"></span>    <span class="o">-</span><span class="mf">0.5f</span><span class="p">,</span>  <span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span>   <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span>   <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">1.0f</span>    <span class="c1">// top left 
</span></span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="c1"></span><span class="p">};</span></span></span></code></pre></div><p>Since we&rsquo;ve added an extra vertex attribute we again have to notify OpenGL of the new vertex format:</p>
<p><a href="#R-image-75494d0903d4a99482c41d2c59d9ccea" class="lightbox-link"><img src="./assets/vertex_attribute_pointer_interleaved_textures.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-75494d0903d4a99482c41d2c59d9ccea"><img src="./assets/vertex_attribute_pointer_interleaved_textures.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="mi">8</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)(</span><span class="mi">6</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)));</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>  
</span></span></code></pre></div><p>Note that we have to adjust the stride parameter of the previous two vertex attributes to <code>8 * sizeof(float)</code> as well.</p>
<p>Next we need to alter the vertex shader to accept the texture coordinates as a vertex attribute and then forward the coordinates to the fragment shader:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">aPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">aColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec2</span> <span class="n">aTexCoord</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">out</span> <span class="n">vec3</span> <span class="n">ourColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="n">out</span> <span class="n">vec2</span> <span class="n">TexCoord</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">aPos</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="n">ourColor</span> <span class="o">=</span> <span class="n">aColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="n">TexCoord</span> <span class="o">=</span> <span class="n">aTexCoord</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>The fragment shader should then accept the <code>TexCoord</code> output variable as an input variable.</p>
<p>The fragment shader should also have access to the texture object, but how do we pass the texture object to the fragment shader? GLSL has a built-in data-type for texture objects called a sampler that takes as a postfix the texture type we want e.g. <code>sampler1D</code>, <code>sampler3D</code> or in our case <code>sampler2D</code>. We can then add a texture to the fragment shader by simply declaring a <code>uniform sampler2D</code> that we later assign our texture to.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">out</span> <span class="n">vec4</span> <span class="n">FragColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">in</span> <span class="n">vec3</span> <span class="n">ourColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">in</span> <span class="n">vec2</span> <span class="n">TexCoord</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">ourTexture</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="n">FragColor</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">ourTexture</span><span class="p">,</span> <span class="n">TexCoord</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>To sample the color of a texture we use GLSL&rsquo;s built-in texture function that takes as its first argument a texture sampler and as its second argument the corresponding texture coordinates. The texture function then samples the corresponding color value using the texture parameters we set earlier. The output of this fragment shader is then the (filtered) color of the texture at the (interpolated) texture coordinate.</p>
<p>All that&rsquo;s left to do now is to bind the texture before calling glDrawElements and it will then automatically assign the texture to the fragment shader&rsquo;s sampler:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">texture</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">VAO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">glDrawElements</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">GL_UNSIGNED_INT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span></span></span></code></pre></div><p>If you did everything right you should see the following image:</p>
<p><a href="#R-image-f53b348d3734fbd99d6a059ec9ebf354" class="lightbox-link"><img src="./assets/textures2.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f53b348d3734fbd99d6a059ec9ebf354"><img src="./assets/textures2.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>If your rectangle is completely white or black you probably made an error along the way. Check your shader logs and try to compare your code with the application&rsquo;s <a href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/4.1.textures/textures.cpp" target="_blank">source code</a>.</p>
<p><warning>If your texture code doesn&rsquo;t work or shows up as completely black, continue reading and work your way to the last example that <strong>should</strong> work. On some drivers it is <strong>required</strong> to assign a texture unit to each sampler uniform, which is something we&rsquo;ll discuss further in this chapter.</warning></p>
<p>To get a little funky we can also mix the resulting texture color with the vertex colors. We simply multiply the resulting texture color with the vertex color in the fragment shader to mix both colors:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">FragColor</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">ourTexture</span><span class="p">,</span> <span class="n">TexCoord</span><span class="p">)</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">ourColor</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span> 
</span></span></code></pre></div><p>The result should be a mixture of the vertex&rsquo;s color and the texture&rsquo;s color:</p>
<p><a href="#R-image-e349e5ad14ba70308b6a32b563c674ea" class="lightbox-link"><img src="./assets/textures_funky.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-e349e5ad14ba70308b6a32b563c674ea"><img src="./assets/textures_funky.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>I guess you could say our container likes to disco.</p>
<h4 id="texture-units">Texture Units</h4>
<p>You probably wondered why the <code>sampler2D</code> variable is a uniform if we didn&rsquo;t even assign it some value with glUniform. Using glUniform1i we can actually assign a <em>location</em> value to the texture sampler so we can set multiple textures at once in a fragment shader. This location of a texture is more commonly known as a texture unit. The default texture unit for a texture is <code>0</code> which is the default active texture unit so we didn&rsquo;t need to assign a location in the previous section; note that not all graphics drivers assign a default texture unit so the previous section may not have rendered for you.</p>
<p>The main purpose of texture units is to allow us to use more than 1 texture in our shaders. By assigning texture units to the samplers, we can bind to multiple textures at once as long as we activate the corresponding texture unit first. Just like glBindTexture we can activate texture units using glActiveTexture passing in the texture unit we&rsquo;d like to use:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glActiveTexture</span><span class="p">(</span><span class="n">GL_TEXTURE0</span><span class="p">);</span> <span class="c1">// activate the texture unit first before binding texture
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="c1"></span><span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">texture</span><span class="p">);</span></span></span></code></pre></div><p>After activating a texture unit, a subsequent glBindTexture call will bind that texture to the currently active texture unit. Texture unit GL_TEXTURE0 is always by default activated, so we didn&rsquo;t have to activate any texture units in the previous example when using glBindTexture.</p>
<p><note>OpenGL should have a at least a minimum of 16 texture units for you to use which you can activate using GL_TEXTURE0 to GL_TEXTURE15. They are defined in order so we could also get GL_TEXTURE8 via GL_TEXTURE0 + 8 for example, which is useful when we&rsquo;d have to loop over several texture units.</note></p>
<p>We still however need to edit the fragment shader to accept another sampler. This should be relatively straightforward now:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="p">...</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">texture1</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">texture2</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="n">FragColor</span> <span class="o">=</span> <span class="n">mix</span><span class="p">(</span><span class="n">texture</span><span class="p">(</span><span class="n">texture1</span><span class="p">,</span> <span class="n">TexCoord</span><span class="p">),</span> <span class="n">texture</span><span class="p">(</span><span class="n">texture2</span><span class="p">,</span> <span class="n">TexCoord</span><span class="p">),</span> <span class="mf">0.2</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>The final output color is now the combination of two texture lookups. GLSL&rsquo;s built-in mix function takes two values as input and linearly interpolates between them based on its third argument. If the third value is <code>0.0</code> it returns the first input; if it&rsquo;s <code>1.0</code> it returns the second input value. A value of <code>0.2</code> will return <code>80%</code> of the first input color and <code>20%</code> of the second input color, resulting in a mixture of both our textures.</p>
<p>We now want to load and create another texture; you should be familiar with the steps now. Make sure to create another texture object, load the image and generate the final texture using glTexImage2D. For the second texture we&rsquo;ll use an image of your <a href="https://learnopengl.com/img/textures/awesomeface.png" target="_blank">facial expression while learning OpenGL</a>:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">stbi_load</span><span class="p">(</span><span class="s">&#34;awesomeface.png&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">width</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">height</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nrChannels</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="n">glTexImage2D</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGB</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGBA</span><span class="p">,</span> <span class="n">GL_UNSIGNED_BYTE</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">    <span class="n">glGenerateMipmap</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>Note that we now load a <code>.png</code> image that includes an alpha (transparency) channel. This means we now need to specify that the image data contains an alpha channel as well by using GL_RGBA; otherwise OpenGL will incorrectly interpret the image data.</p>
<p>To use the second texture (and the first texture) we&rsquo;d have to change the rendering procedure a bit by binding both textures to the corresponding texture unit:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glActiveTexture</span><span class="p">(</span><span class="n">GL_TEXTURE0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">texture1</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">glActiveTexture</span><span class="p">(</span><span class="n">GL_TEXTURE1</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">texture2</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">VAO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="n">glDrawElements</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">GL_UNSIGNED_INT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> 
</span></span></code></pre></div><p>We also have to tell OpenGL to which texture unit each shader sampler belongs to by setting each sampler using glUniform1i. We only have to set this once, so we can do this before we enter the render loop:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">ourShader</span><span class="p">.</span><span class="n">use</span><span class="p">();</span> <span class="c1">// don&#39;t forget to activate the shader before setting uniforms!  
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="c1"></span><span class="n">glUniform1i</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">ourShader</span><span class="p">.</span><span class="n">ID</span><span class="p">,</span> <span class="s">&#34;texture1&#34;</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// set it manually
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="c1"></span><span class="n">ourShader</span><span class="p">.</span><span class="n">setInt</span><span class="p">(</span><span class="s">&#34;texture2&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// or with shader class
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="c1"></span>  
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="k">while</span><span class="p">(...)</span> 
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl">    <span class="p">[...]</span>
</span></span><span class="line"><span class="ln">8</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>By setting the samplers via glUniform1i we make sure each uniform sampler corresponds to the proper texture unit. You should get the following result:</p>
<p><a href="#R-image-f4efed712e66dafc635384b5a4ee56db" class="lightbox-link"><img src="./assets/textures_combined.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f4efed712e66dafc635384b5a4ee56db"><img src="./assets/textures_combined.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>You probably noticed that the texture is flipped upside-down! This happens because OpenGL expects the <code>0.0</code> coordinate on the y-axis to be on the bottom side of the image, but images usually have <code>0.0</code> at the top of the y-axis. Luckily for us, <code>stb_image.h</code> can flip the y-axis during image loading by adding the following statement before loading any image:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">stbi_set_flip_vertically_on_load</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>  
</span></span></code></pre></div><p>After telling <code>stb_image.h</code> to flip the y-axis when loading images you should get the following result:</p>
<p><a href="#R-image-31588633f8659e3268f0fb762f978b79" class="lightbox-link"><img src="./assets/textures_combined2.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-31588633f8659e3268f0fb762f978b79"><img src="./assets/textures_combined2.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>If you see one happy container, you did things right. You can compare it with the <a href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/4.2.textures_combined/textures_combined.cpp" target="_blank">source code</a>.</p>
<h4 id="exercises-2">Exercises</h4>
<p>To get more comfortable with textures it is advised to work through these exercises before continuing.</p>
<ul>
<li>Make sure <strong>only</strong> the happy face looks in the other/reverse direction by changing the fragment shader: <a href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/4.3.textures_exercise1/textures_exercise1.cpp" target="_blank">solution</a>.</li>
<li>Experiment with the different texture wrapping methods by specifying texture coordinates in the range <code>0.0f</code> to <code>2.0f</code> instead of <code>0.0f</code> to <code>1.0f</code>. See if you can display 4 smiley faces on a single container image clamped at its edge: <a href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/4.4.textures_exercise2/textures_exercise2.cpp" target="_blank">solution</a>, <a href="https://learnopengl.com/img/getting-started/textures_exercise2.png" target="_blank">result</a>. See if you can experiment with other wrapping methods as well.</li>
<li>Try to display only the center pixels of the texture image on the rectangle in such a way that the individual pixels are getting visible by changing the texture coordinates. Try to set the texture filtering method to GL_NEAREST to see the pixels more clearly: <a href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/4.5.textures_exercise3/textures_exercise3.cpp" target="_blank">solution</a>.</li>
<li>Use a uniform variable as the mix function&rsquo;s third parameter to vary the amount the two textures are visible. Use the up and down arrow keys to change how much the container or the smiley face is visible: <a href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/4.6.textures_exercise4/textures_exercise4.cpp" target="_blank">solution</a>.</li>
</ul>
<h3 id="transformations">Transformations</h3>
<p>We now know how to create objects, color them and/or give them a detailed appearance using textures, but they&rsquo;re still not that interesting since they&rsquo;re all static objects. We could try and make them move by changing their vertices and re-configuring their buffers each frame, but that&rsquo;s cumbersome and costs quite some processing power. There are much better ways to transform an object and that&rsquo;s by using (multiple) matrix objects. This doesn&rsquo;t mean we&rsquo;re going to talk about Kung Fu and a large digital artificial world.</p>
<p>Matrices are very powerful mathematical constructs that seem scary at first, but once you&rsquo;ll grow accustomed to them they&rsquo;ll prove extremely useful. When discussing matrices, we&rsquo;ll have to make a small dive into some mathematics and for the more mathematically inclined readers I&rsquo;ll post additional resources for further reading.</p>
<p>However, to fully understand transformations we first have to delve a bit deeper into vectors before discussing matrices. The focus of this chapter is to give you a basic mathematical background in topics we will require later on. If the subjects are difficult, try to understand them as much as you can and come back to this chapter later to review the concepts whenever you need them.</p>
<h4 id="vectors-1">Vectors</h4>
<p>In its most basic definition, vectors are directions and nothing more. A vector has a direction and a magnitude (also known as its strength or length). You can think of vectors like directions on a treasure map: &lsquo;go left 10 steps, now go north 3 steps and go right 5 steps&rsquo;; here &rsquo;left&rsquo; is the direction and &lsquo;10 steps&rsquo; is the magnitude of the vector. The directions for the treasure map thus contains 3 vectors. Vectors can have any dimension, but we usually work with dimensions of 2 to 4. If a vector has 2 dimensions it represents a direction on a plane (think of 2D graphs) and when it has 3 dimensions it can represent any direction in a 3D world.</p>
<p>Below you&rsquo;ll see 3 vectors where each vector is represented with <code>(x,y)</code> as arrows in a 2D graph. Because it is more intuitive to display vectors in 2D (rather than 3D) you can think of the 2D vectors as 3D vectors with a <code>z</code> coordinate of <code>0</code>. Since vectors represent directions, the origin of the vector does not change its value. In the graph below we can see that the vectors 
<span class="math align-center">$\color{red}{\bar{v}}$</span> and 
<span class="math align-center">$\color{blue}{\bar{w}}$</span> are equal even though their origin is different:</p>
<p><a href="#R-image-f107f5eab758306fa4430d30f452cc74" class="lightbox-link"><img src="./assets/vectors.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f107f5eab758306fa4430d30f452cc74"><img src="./assets/vectors.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>When describing vectors mathematicians generally prefer to describe vectors as character symbols with a little bar over their head like $\bar{v}$. Also, when displaying vectors in formulas they are generally displayed as follows:</p>

<span class="math align-center">$$
\bar{v} = \begin{pmatrix} \color{red}x \\ \color{green}y \\ \color{blue}z \end{pmatrix}
$$</span><p>Because vectors are specified as directions it is sometimes hard to visualize them as positions. If we want to visualize vectors as positions we can imagine the origin of the direction vector to be <code>(0,0,0)</code> and then point towards a certain direction that specifies the point, making it a position vector (we could also specify a different origin and then say: &rsquo;this vector points to that point in space from this origin&rsquo;). The position vector <code>(3,5)</code> would then point to <code>(3,5)</code> on the graph with an origin of <code>(0,0)</code>. Using vectors we can thus describe directions <strong>and</strong> positions in 2D and 3D space.</p>
<p>Just like with normal numbers we can also define several operations on vectors (some of which you&rsquo;ve already seen).</p>
<h4 id="scalar-vector-operations">Scalar vector operations</h4>
<p>A scalar is a single digit. When adding/subtracting/multiplying or dividing a vector with a scalar we simply add/subtract/multiply or divide each element of the vector by the scalar. For addition it would look like this:</p>

<span class="math align-center">$$
\begin{pmatrix} \color{red}1 \\ \color{green}2 \\ \color{blue}3 \end{pmatrix} + x \rightarrow \begin{pmatrix} \color{red}1 \\ \color{green}2 \\ \color{blue}3 \end{pmatrix} + \begin{pmatrix} x \\ x \\ x \end{pmatrix}  = \begin{pmatrix} \color{red}1 + x \\ \color{green}2 + x \\ \color{blue}3 + x \end{pmatrix}
$$</span><p>Where ++ can be ++,−−,⋅⋅ or ÷÷ where ⋅⋅ is the multiplication operator.</p>
<h4 id="vector-negation">Vector negation</h4>
<p>Negating a vector results in a vector in the reversed direction. A vector pointing north-east would point south-west after negation. To negate a vector we add a minus-sign to each component (you can also represent it as a scalar-vector multiplication with a scalar value of <code>-1</code>):</p>

<span class="math align-center">$$
-\bar{v} = -\begin{pmatrix} \color{red}{v_x} \\ \color{blue}{v_y} \\ \color{green}{v_z} \end{pmatrix} = \begin{pmatrix} -\color{red}{v_x} \\ -\color{blue}{v_y} \\ -\color{green}{v_z} \end{pmatrix}
$$</span><h4 id="addition-and-subtraction">Addition and subtraction</h4>
<p>Addition of two vectors is defined as component-wise addition, that is each component of one vector is added to the same component of the other vector like so:</p>

<span class="math align-center">$$
\bar{v} = \begin{pmatrix} \color{red}1 \\ \color{green}2 \\ \color{blue}3 \end{pmatrix}, \bar{k} = \begin{pmatrix} \color{red}4 \\ \color{green}5 \\ \color{blue}6 \end{pmatrix} \rightarrow \bar{v} + \bar{k} = \begin{pmatrix} \color{red}1 + \color{red}4 \\ \color{green}2 + \color{green}5 \\ \color{blue}3 + \color{blue}6 \end{pmatrix} = \begin{pmatrix} \color{red}5 \\ \color{green}7 \\ \color{blue}9 \end{pmatrix}
$$</span><p>Visually, it looks like this on vectors <code>v=(4,2)</code> and <code>k=(1,2)</code>, where the second vector is added on top of the first vector&rsquo;s end to find the end point of the resulting vector (head-to-tail method):</p>
<p><a href="#R-image-08c7a6aab6445b5df59bd111f35eda50" class="lightbox-link"><img src="./assets/vectors_addition.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-08c7a6aab6445b5df59bd111f35eda50"><img src="./assets/vectors_addition.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Just like normal addition and subtraction, vector subtraction is the same as addition with a negated second vector:</p>

<span class="math align-center">$$
\bar{v} = \begin{pmatrix} \color{red}{1} \\ \color{green}{2} \\ \color{blue}{3} \end{pmatrix}, \bar{k} = \begin{pmatrix} \color{red}{4} \\ \color{green}{5} \\ \color{blue}{6} \end{pmatrix} \rightarrow \bar{v} + -\bar{k} = \begin{pmatrix} \color{red}{1} + (-\color{red}{4}) \\ \color{green}{2} + (-\color{green}{5}) \\ \color{blue}{3} + (-\color{blue}{6}) \end{pmatrix} = \begin{pmatrix} -\color{red}{3} \\ -\color{green}{3} \\ -\color{blue}{3} \end{pmatrix}
$$</span><p>Subtracting two vectors from each other results in a vector that&rsquo;s the difference of the positions both vectors are pointing at. This proves useful in certain cases where we need to retrieve a vector that&rsquo;s the difference between two points.</p>
<p><a href="#R-image-54b9c4e2c3c9db8658e9948aea3ae4e3" class="lightbox-link"><img src="./assets/vectors_subtraction.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-54b9c4e2c3c9db8658e9948aea3ae4e3"><img src="./assets/vectors_subtraction.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<h4 id="length">Length</h4>
<p>To retrieve the length/magnitude of a vector we use the Pythagoras theorem that you may remember from your math classes. A vector forms a triangle when you visualize its individual <code>x</code> and <code>y</code> component as two sides of a triangle:</p>
<p><a href="#R-image-f538ecfba88667402b3cde865e95a27f" class="lightbox-link"><img src="./assets/vectors_triangle.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f538ecfba88667402b3cde865e95a27f"><img src="./assets/vectors_triangle.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Since the length of the two sides <code>(x, y)</code> are known and we want to know the length of the tilted side  
<span class="math align-center">$\color{red}{\bar{v}}$ </span> we can calculate it using the Pythagoras theorem as:</p>

<span class="math align-center">$$
||{\color{red}{\bar{v}}}|| = \sqrt{{\color{green}x}^2 + {\color{blue}y}^2}
$$</span><p>Where  
<span class="math align-center">$||{\color{red}{\bar{v}}}||$ </span> is denoted as <em>the length of vector  
<span class="math align-center">$\color{red}{\bar{v}}$ </span></em>. This is easily extended to 3D by adding  
<span class="math align-center">$z^2$ </span> to the equation.</p>
<p>In this case the length of vector <code>(4, 2)</code> equals:</p>

<span class="math align-center">$$
||{\color{red}{\bar{v}}}|| = \sqrt{{\color{green}4}^2 + {\color{blue}2}^2} = \sqrt{{\color{green}16} + {\color{blue}4}} = \sqrt{20} = 4.47
$$</span><p>Which is <code>4.47</code>.</p>
<p>There is also a special type of vector that we call a unit vector. A unit vector has one extra property and that is that its length is exactly 1. We can calculate a unit vector $\hat{n}$ from any vector by dividing each of the vector&rsquo;s components by its length:</p>

<span class="math align-center">$$
\hat{n} = \frac{\bar{v}}{||\bar{v}||}
$$</span><p>We call this normalizing a vector. Unit vectors are displayed with a little roof over their head and are generally easier to work with, especially when we only care about their directions (the direction does not change if we change a vector&rsquo;s length).</p>
<h4 id="vector-vector-multiplication">Vector-vector multiplication</h4>
<p>Multiplying two vectors is a bit of a weird case. Normal multiplication isn&rsquo;t really defined on vectors since it has no visual meaning, but we have two specific cases that we could choose from when multiplying: one is the dot product denoted as 
<span class="math align-center">$\bar{v} \cdot \bar{k}$</span> and the other is the cross product denoted as 
<span class="math align-center">$\bar{v} \times \bar{k}$​</span>.</p>
<h5 id="dot-product">Dot product</h5>
<p>The dot product of two vectors is equal to the scalar product of their lengths times the cosine of the angle between them. If this sounds confusing take a look at its formula:</p>

<span class="math align-center">$$
\bar{v} \cdot \bar{k} = ||\bar{v}|| \cdot ||\bar{k}|| \cdot \cos \theta
$$</span><p>Where the angle between them is represented as theta (
<span class="math align-center">$\theta$</span>). Why is this interesting? Well, imagine if 
<span class="math align-center">$\bar{v}$</span> and 
<span class="math align-center">$\bar{k}$</span> are unit vectors then their length would be equal to 1. This would effectively reduce the formula to:</p>

<span class="math align-center">$$
\hat{v} \cdot \hat{k} = 1 \cdot 1 \cdot \cos \theta = \cos \theta
$$</span><p>Now the dot product <strong>only</strong> defines the angle between both vectors. You may remember that the cosine or cos function becomes <code>0</code> when the angle is 90 degrees or <code>1</code> when the angle is 0. This allows us to easily test if the two vectors are orthogonal or parallel to each other using the dot product (orthogonal means the vectors are at a right-angle to each other). In case you want to know more about the <code>sin</code> or the <code>cos</code> functions I&rsquo;d suggest the following <a href="https://www.khanacademy.org/math/trigonometry/basic-trigonometry/basic_trig_ratios/v/basic-trigonometry" target="_blank">Khan Academy videos</a> about basic trigonometry.</p>
<p><note>You can also calculate the angle between two non-unit vectors, but then you&rsquo;d have to divide the lengths of both vectors from the result to be left with cosθ.</note></p>
<p>So how do we calculate the dot product? The dot product is a component-wise multiplication where we add the results together. It looks like this with two unit vectors (you can verify that both their lengths are exactly <code>1</code>):</p>

<span class="math align-center">$$
\begin{pmatrix} \color{red}{0.6} \\ -\color{green}{0.8} \\ \color{blue}0 \end{pmatrix} \cdot \begin{pmatrix} \color{red}0 \\ \color{green}1 \\ \color{blue}0 \end{pmatrix} = ({\color{red}{0.6}} * {\color{red}0}) + (-{\color{green}{0.8}} * {\color{green}1}) + ({\color{blue}0} * {\color{blue}0}) = -0.8
$$</span><p>To calculate the degree between both these unit vectors we use the inverse of the cosine function cos−1���−1 and this results in <code>143.1</code> degrees. We now effectively calculated the angle between these two vectors. The dot product proves very useful when doing lighting calculations later on.</p>
<h5 id="cross-product">Cross product</h5>
<p>The cross product is only defined in 3D space and takes two non-parallel vectors as input and produces a third vector that is orthogonal to both the input vectors. If both the input vectors are orthogonal to each other as well, a cross product would result in 3 orthogonal vectors; this will prove useful in the upcoming chapters. The following image shows what this looks like in 3D space:</p>
<p><a href="#R-image-9cf9abc644c067806632765ce3541199" class="lightbox-link"><img src="./assets/vectors_crossproduct.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-9cf9abc644c067806632765ce3541199"><img src="./assets/vectors_crossproduct.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Unlike the other operations, the cross product isn&rsquo;t really intuitive without delving into linear algebra so it&rsquo;s best to just memorize the formula and you&rsquo;ll be fine (or don&rsquo;t, you&rsquo;ll probably be fine as well). Below you&rsquo;ll see the cross product between two orthogonal vectors A and B:</p>

<span class="math align-center">$$
\begin{pmatrix} \color{red}{A_{x}} \\ \color{green}{A_{y}} \\ \color{blue}{A_{z}} \end{pmatrix} \times \begin{pmatrix} \color{red}{B_{x}} \\ \color{green}{B_{y}} \\ \color{blue}{B_{z}}  \end{pmatrix} = \begin{pmatrix} \color{green}{A_{y}} \cdot \color{blue}{B_{z}} - \color{blue}{A_{z}} \cdot \color{green}{B_{y}} \\ \color{blue}{A_{z}} \cdot \color{red}{B_{x}} - \color{red}{A_{x}} \cdot \color{blue}{B_{z}} \\ \color{red}{A_{x}} \cdot \color{green}{B_{y}} - \color{green}{A_{y}} \cdot \color{red}{B_{x}} \end{pmatrix}
$$</span><p>As you can see, it doesn&rsquo;t really seem to make sense. However, if you just follow these steps you&rsquo;ll get another vector that is orthogonal to your input vectors.</p>
<h4 id="matrices">Matrices</h4>
<p>Now that we&rsquo;ve discussed almost all there is to vectors it is time to enter the matrix! A matrix is a rectangular array of numbers, symbols and/or mathematical expressions. Each individual item in a matrix is called an element of the matrix. An example of a 2x3 matrix is shown below:</p>

<span class="math align-center">$$
\begin{bmatrix} 1 & 2 & 3 \\ 4 & 5 & 6 \end{bmatrix}
$$</span><p>Matrices are indexed by <code>(i,j)</code> where <code>i</code> is the row and <code>j</code> is the column, that is why the above matrix is called a 2x3 matrix (3 columns and 2 rows, also known as the dimensions of the matrix). This is the opposite of what you&rsquo;re used to when indexing 2D graphs as <code>(x,y)</code>. To retrieve the value 4 we would index it as <code>(2,1)</code> (second row, first column).</p>
<p>Matrices are basically nothing more than that, just rectangular arrays of mathematical expressions. They do have a very nice set of mathematical properties and just like vectors we can define several operations on matrices, namely: addition, subtraction and multiplication.</p>
<h5 id="addition-and-subtraction-1">Addition and subtraction</h5>
<p>Matrix addition and subtraction between two matrices is done on a per-element basis. So the same general rules apply that we&rsquo;re familiar with for normal numbers, but done on the elements of both matrices with the same index. This does mean that addition and subtraction is only defined for matrices of the same dimensions. A 3x2 matrix and a 2x3 matrix (or a 3x3 matrix and a 4x4 matrix) cannot be added or subtracted together. Let&rsquo;s see how matrix addition works on two 2x2 matrices:</p>

<span class="math align-center">$$
\begin{bmatrix} \color{red}1 & \color{red}2 \\ \color{green}3 & \color{green}4 \end{bmatrix} + \begin{bmatrix} \color{red}5 & \color{red}6 \\ \color{green}7 & \color{green}8 \end{bmatrix} = \begin{bmatrix} \color{red}1 + \color{red}5 & \color{red}2 + \color{red}6 \\ \color{green}3 + \color{green}7 & \color{green}4 + \color{green}8 \end{bmatrix} = \begin{bmatrix} \color{red}6 & \color{red}8 \\ \color{green}{10} & \color{green}{12} \end{bmatrix}
$$</span><p>The same rules apply for matrix subtraction:</p>

<span class="math align-center">$$
\begin{bmatrix} \color{red}4 & \color{red}2 \\ \color{green}1 & \color{green}6 \end{bmatrix} - \begin{bmatrix} \color{red}2 & \color{red}4 \\ \color{green}0 & \color{green}1 \end{bmatrix} = \begin{bmatrix} \color{red}4 - \color{red}2 & \color{red}2  - \color{red}4 \\ \color{green}1 - \color{green}0 & \color{green}6 - \color{green}1 \end{bmatrix} = \begin{bmatrix} \color{red}2 & -\color{red}2 \\ \color{green}1 & \color{green}5 \end{bmatrix}
$$</span><h5 id="matrix-scalar-products">Matrix-scalar products</h5>
<p>A matrix-scalar product multiples each element of the matrix by a scalar. The following example illustrates the multiplication:</p>

<span class="math align-center">$$
{\color{green}2} \cdot \begin{bmatrix} 1 & 2 \\ 3 & 4 \end{bmatrix} = \begin{bmatrix} {\color{green}2} \cdot 1 & {\color{green}2} \cdot 2 \\ {\color{green}2} \cdot 3 & {\color{green}2} \cdot 4 \end{bmatrix} = \begin{bmatrix} 2 & 4 \\ 6 & 8 \end{bmatrix}
$$</span><p>Now it also makes sense as to why those single numbers are called scalars. A scalar basically <em>scales</em> all the elements of the matrix by its value. In the previous example, all elements were scaled by <code>2</code>.</p>
<p>So far so good, all of our cases weren&rsquo;t really too complicated. That is, until we start on matrix-matrix multiplication.</p>
<h4 id="matrix-matrix-multiplication">Matrix-matrix multiplication</h4>
<p>Multiplying matrices is not necessarily complex, but rather difficult to get comfortable with. Matrix multiplication basically means to follow a set of pre-defined rules when multiplying. There are a few restrictions though:</p>
<ol>
<li>You can only multiply two matrices if the number of columns on the left-hand side matrix is equal to the number of rows on the right-hand side matrix.</li>
<li>Matrix multiplication is not commutative that is 
<span class="math align-center">$A \cdot B \neq B \cdot A$</span>.</li>
</ol>
<p>Let&rsquo;s get started with an example of a matrix multiplication of 2 <code>2x2</code> matrices:</p>

<span class="math align-center">$$
\begin{bmatrix} \color{red}1 & \color{red}2 \\ \color{green}3 & \color{green}4 \end{bmatrix} \cdot \begin{bmatrix} \color{blue}5 & \color{purple}6 \\ \color{blue}7 & \color{purple}8 \end{bmatrix} = \begin{bmatrix} \color{red}1 \cdot \color{blue}5 + \color{red}2 \cdot \color{blue}7 & \color{red}1 \cdot \color{purple}6 + \color{red}2 \cdot \color{purple}8 \\ \color{green}3 \cdot \color{blue}5 + \color{green}4 \cdot \color{blue}7 & \color{green}3 \cdot \color{purple}6 + \color{green}4 \cdot \color{purple}8 \end{bmatrix} = \begin{bmatrix} 19 & 22 \\ 43 & 50 \end{bmatrix}
$$</span><p>Right now you&rsquo;re probably trying to figure out what the hell just happened? Matrix multiplication is a combination of normal multiplication and addition using the left-matrix&rsquo;s rows with the right-matrix&rsquo;s columns. Let&rsquo;s try discussing this with the following image:</p>
<p><a href="#R-image-d9ebd4076c8b607bc037c1f1c7cc7567" class="lightbox-link"><img src="./assets/matrix_multiplication.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d9ebd4076c8b607bc037c1f1c7cc7567"><img src="./assets/matrix_multiplication.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>We first take the upper row of the left matrix and then take a column from the right matrix. The row and column that we picked decides which output value of the resulting <code>2x2</code> matrix we&rsquo;re going to calculate. If we take the first row of the left matrix the resulting value will end up in the first row of the result matrix, then we pick a column and if it&rsquo;s the first column the result value will end up in the first column of the result matrix. This is exactly the case of the red pathway. To calculate the bottom-right result we take the bottom row of the first matrix and the rightmost column of the second matrix.</p>
<p>To calculate the resulting value we multiply the first element of the row and column together using normal multiplication, we do the same for the second elements, third, fourth etc. The results of the individual multiplications are then summed up and we have our result. Now it also makes sense that one of the requirements is that the size of the left-matrix&rsquo;s columns and the right-matrix&rsquo;s rows are equal, otherwise we can&rsquo;t finish the operations!</p>
<p>The result is then a matrix that has dimensions of (<code>n,m</code>) where <code>n</code> is equal to the number of rows of the left-hand side matrix and <code>m</code> is equal to the columns of the right-hand side matrix.</p>
<p>Don&rsquo;t worry if you have difficulties imagining the multiplications inside your head. Just keep trying to do the calculations by hand and return to this page whenever you have difficulties. Over time, matrix multiplication becomes second nature to you.</p>
<p>Let&rsquo;s finish the discussion of matrix-matrix multiplication with a larger example. Try to visualize the pattern using the colors. As a useful exercise, see if you can come up with your own answer of the multiplication and then compare them with the resulting matrix (once you try to do a matrix multiplication by hand you&rsquo;ll quickly get the grasp of them).</p>

<span class="math align-center">$$
\begin{bmatrix} \color{red}4 & \color{red}2 & \color{red}0 \\ \color{green}0 & \color{green}8 & \color{green}1 \\ \color{blue}0 & \color{blue}1 & \color{blue}0 \end{bmatrix} \cdot \begin{bmatrix} \color{red}4 & \color{green}2 & \color{blue}1 \\ \color{red}2 & \color{green}0 & \color{blue}4 \\ \color{red}9 & \color{green}4 & \color{blue}2 \end{bmatrix} = \begin{bmatrix} {\color{red}4} \cdot {\color{red}4} + {\color{red}2} \cdot {\color{red}2} + {\color{red}0} \cdot {\color{red}9} & {\color{red}4} \cdot {\color{green}2} + {\color{red}2} \cdot {\color{green}0} + {\color{red}0} \cdot {\color{green}4} & {\color{red}4} \cdot {\color{blue}1} + {\color{red}2} \cdot {\color{blue}4} + {\color{red}0} \cdot {\color{blue}2} \\ {\color{green}0} \cdot {\color{red}4} + {\color{green}8} \cdot {\color{red}2} + {\color{green}1} \cdot {\color{red}9} & {\color{green}0} \cdot {\color{green}2} + {\color{green}8} \cdot {\color{green}0} + {\color{green}1} \cdot {\color{green}4} & {\color{green}0} \cdot {\color{blue}1} + {\color{green}8} \cdot {\color{blue}4} + {\color{green}1} \cdot {\color{blue}2} \\ {\color{blue}0} \cdot {\color{red}4} + {\color{blue}1} \cdot {\color{red}2} + {\color{blue}0} \cdot {\color{red}9} & {\color{blue}0} \cdot {\color{green}2} + {\color{blue}1} \cdot {\color{green}0} + {\color{blue}0} \cdot {\color{green}4} & {\color{blue}0} \cdot {\color{blue}1} + {\color{blue}1} \cdot {\color{blue}4} + {\color{blue}0} \cdot {\color{blue}2} \end{bmatrix} 
 \\ = \begin{bmatrix} 20 & 8 & 12 \\ 25 & 4 & 34 \\ 2 & 0 & 4 \end{bmatrix}
 $$</span><p>As you can see, matrix-matrix multiplication is quite a cumbersome process and very prone to errors (which is why we usually let computers do this) and this gets problematic real quick when the matrices become larger. If you&rsquo;re still thirsty for more and you&rsquo;re curious about some more of the mathematical properties of matrices I strongly suggest you take a look at these <a href="https://www.khanacademy.org/math/algebra-home/alg-matrices" target="_blank">Khan Academy videos</a> about matrices.</p>
<p>Anyways, now that we know how to multiply matrices together, we can start getting to the good stuff.</p>
<h4 id="matrix-vector-multiplication">Matrix-Vector multiplication</h4>
<p>Up until now we&rsquo;ve had our fair share of vectors. We used them to represent positions, colors and even texture coordinates. Let&rsquo;s move a bit further down the rabbit hole and tell you that a vector is basically a <code>Nx1</code> matrix where <code>N</code> is the vector&rsquo;s number of components (also known as an N-dimensional vector). If you think about it, it makes a lot of sense. Vectors are just like matrices an array of numbers, but with only 1 column. So, how does this new piece of information help us? Well, if we have a <code>MxN</code> matrix we can multiply this matrix with our <code>Nx1</code> vector, since the columns of the matrix are equal to the number of rows of the vector, thus matrix multiplication is defined.</p>
<p>But why do we care if we can multiply matrices with a vector? Well, it just so happens that there are lots of interesting 2D/3D transformations we can place inside a matrix, and multiplying that matrix with a vector then <em>transforms</em> that vector. In case you&rsquo;re still a bit confused, let&rsquo;s start with a few examples and you&rsquo;ll soon see what we mean.</p>
<h5 id="identity-matrix">Identity matrix</h5>
<p>In OpenGL we usually work with <code>4x4</code> transformation matrices for several reasons and one of them is that most of the vectors are of size 4. The most simple transformation matrix that we can think of is the identity matrix. The identity matrix is an <code>NxN</code> matrix with only 0s except on its diagonal. As you&rsquo;ll see, this transformation matrix leaves a vector completely unharmed:</p>

<span class="math align-center">$$
\begin{bmatrix} \color{red}1 & \color{red}0 & \color{red}0 & \color{red}0 \\ \color{green}0 & \color{green}1 & \color{green}0 & \color{green}0 \\ \color{blue}0 & \color{blue}0 & \color{blue}1 & \color{blue}0 \\ \color{purple}0 & \color{purple}0 & \color{purple}0 & \color{purple}1 \end{bmatrix} \cdot \begin{bmatrix} 1 \\ 2 \\ 3 \\ 4 \end{bmatrix} = \begin{bmatrix} {\color{red}1} \cdot 1 \\ {\color{green}1} \cdot 2 \\ {\color{blue}1} \cdot 3 \\ {\color{purple}1} \cdot 4 \end{bmatrix} = \begin{bmatrix} 1 \\ 2 \\ 3 \\ 4 \end{bmatrix}
$$</span><p>The vector is completely untouched. This becomes obvious from the rules of multiplication: the first result element is each individual element of the first row of the matrix multiplied with each element of the vector. Since each of the row&rsquo;s elements are 0 except the first one, we get: 
<span class="math align-center">${\color{red}1}\cdot1 + {\color{red}0}\cdot2 + {\color{red}0}\cdot3 + {\color{red}0}\cdot4 = 1$</span> and the same applies for the other 3 elements of the vector.</p>
<p><note>You may be wondering what the use is of a transformation matrix that does not transform? The identity matrix is usually a starting point for generating other transformation matrices and if we dig even deeper into linear algebra, a very useful matrix for proving theorems and solving linear equations.</note></p>
<h5 id="scaling">Scaling</h5>
<p>When we&rsquo;re scaling a vector we are increasing the length of the arrow by the amount we&rsquo;d like to scale, keeping its direction the same. Since we&rsquo;re working in either 2 or 3 dimensions we can define scaling by a vector of 2 or 3 scaling variables, each scaling one axis (<code>x</code>, <code>y</code> or <code>z</code>).</p>
<p>Let&rsquo;s try scaling the vector 
<span class="math align-center">${\color{red}{\bar{v}}} = (3,2)$</span>. We will scale the vector along the x-axis by <code>0.5</code>, thus making it twice as narrow; and we&rsquo;ll scale the vector by <code>2</code> along the y-axis, making it twice as high. Let&rsquo;s see what it looks like if we scale the vector by <code>(0.5,2)</code> as 
<span class="math align-center">$\color{blue}{\bar{s}}$</span>:</p>
<p><a href="#R-image-da9184a22667facab0d63c2d895f9b42" class="lightbox-link"><img src="./assets/vectors_scale.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-da9184a22667facab0d63c2d895f9b42"><img src="./assets/vectors_scale.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Keep in mind that OpenGL usually operates in 3D space so for this 2D case we could set the z-axis scale to <code>1</code>, leaving it unharmed. The scaling operation we just performed is a non-uniform scale, because the scaling factor is not the same for each axis. If the scalar would be equal on all axes it would be called a uniform scale.</p>
<p>Let&rsquo;s start building a transformation matrix that does the scaling for us. We saw from the identity matrix that each of the diagonal elements were multiplied with its corresponding vector element. What if we were to change the <code>1</code>s in the identity matrix to <code>3</code>s? In that case, we would be multiplying each of the vector elements by a value of <code>3</code> and thus effectively uniformly scale the vector by 3. If we represent the scaling variables as 
<span class="math align-center">$({\color{red}{S_1}}, {\color{green}{S_2}}, {\color{blue}{S_3}})$</span> we can define a scaling matrix on any vector 
<span class="math align-center">$(x,y,z)$</span> as:</p>

<span class="math align-center">$$
\begin{bmatrix} \color{red}{S_1} & \color{red}0 & \color{red}0 & \color{red}0 \\ \color{green}0 & \color{green}{S_2} & \color{green}0 & \color{green}0 \\ \color{blue}0 & \color{blue}0 & \color{blue}{S_3} & \color{blue}0 \\ \color{purple}0 & \color{purple}0 & \color{purple}0 & \color{purple}1 \end{bmatrix} \cdot \begin{pmatrix} x \\ y \\ z \\ 1 \end{pmatrix} = \begin{pmatrix} {\color{red}{S_1}} \cdot x \\ {\color{green}{S_2}} \cdot y \\ {\color{blue}{S_3}} \cdot z \\ 1 \end{pmatrix}
$$</span><p>Note that we keep the 4th scaling value <code>1</code>. The <code>w</code> component is used for other purposes as we&rsquo;ll see later on.</p>
<h5 id="translation">Translation</h5>
<p>Translation is the process of adding another vector on top of the original vector to return a new vector with a different position, thus <em>moving</em> the vector based on a translation vector. We&rsquo;ve already discussed vector addition so this shouldn&rsquo;t be too new.</p>
<p>Just like the scaling matrix there are several locations on a 4-by-4 matrix that we can use to perform certain operations and for translation those are the top-3 values of the 4th column. If we represent the translation vector as 
<span class="math align-center">$({\color{red}{T_x}},{\color{green}{T_y}},{\color{blue}{T_z}})$</span> we can define the translation matrix by:</p>

<span class="math align-center">$$
\begin{bmatrix}  \color{red}1 & \color{red}0 & \color{red}0 & \color{red}{T_x} \\ \color{green}0 & \color{green}1 & \color{green}0 & \color{green}{T_y} \\ \color{blue}0 & \color{blue}0 & \color{blue}1 & \color{blue}{T_z} \\ \color{purple}0 & \color{purple}0 & \color{purple}0 & \color{purple}1 \end{bmatrix} \cdot \begin{pmatrix} x \\ y \\ z \\ 1 \end{pmatrix} = \begin{pmatrix} x + \color{red}{T_x} \\ y + \color{green}{T_y} \\ z + \color{blue}{T_z} \\ 1 \end{pmatrix}
$$</span><p>This works because all of the translation values are multiplied by the vector&rsquo;s <code>w</code> column and added to the vector&rsquo;s original values (remember the matrix-multiplication rules). This wouldn&rsquo;t have been possible with a 3-by-3 matrix.</p>
<p><note><strong>Homogeneous coordinates</strong><br>The <code>w</code> component of a vector is also known as a homogeneous coordinate. To get the 3D vector from a homogeneous vector we divide the <code>x</code>, <code>y</code> and <code>z</code> coordinate by its <code>w</code> coordinate. We usually do not notice this since the <code>w</code> component is <code>1.0</code> most of the time. Using homogeneous coordinates has several advantages: it allows us to do matrix translations on 3D vectors (without a <code>w</code> component we can&rsquo;t translate vectors) and in the next chapter we&rsquo;ll use the <code>w</code> value to create 3D perspective.<br><br>Also, whenever the homogeneous coordinate is equal to <code>0</code>, the vector is specifically known as a direction vector since a vector with a <code>w</code> coordinate of <code>0</code> cannot be translated.</note></p>
<p>With a translation matrix we can move objects in any of the 3 axis directions (<code>x</code>, <code>y</code>, <code>z</code>), making it a very useful transformation matrix for our transformation toolkit.</p>
<h5 id="rotation">Rotation</h5>
<p>The last few transformations were relatively easy to understand and visualize in 2D or 3D space, but rotations are a bit trickier. If you want to know exactly how these matrices are constructed I&rsquo;d recommend that you watch the rotation items of Khan Academy&rsquo;s <a href="https://www.khanacademy.org/math/linear-algebra/matrix_transformations" target="_blank">linear algebra</a> videos.</p>
<p>First let&rsquo;s define what a rotation of a vector actually is. A rotation in 2D or 3D is represented with an angle. An angle could be in degrees or radians where a whole circle has 360 degrees or 2 <a href="http://en.wikipedia.org/wiki/Pi" target="_blank">PI</a> radians. I prefer explaining rotations using degrees as we&rsquo;re generally more accustomed to them.</p>
<p><note>Most rotation functions require an angle in radians, but luckily degrees are easily converted to radians:<br><code>angle in degrees = angle in radians * (180 / PI)</code><br><code>angle in radians = angle in degrees * (PI / 180)</code><br>Where <code>PI</code> equals (rounded) <code>3.14159265359</code>.</note></p>
<p>Rotating half a circle rotates us 360/2 = 180 degrees and rotating 1/5th to the right means we rotate 360/5 = 72 degrees to the right. This is demonstrated for a basic 2D vector where 
<span class="math align-center">$\color{red}{\bar{v}}$</span> is rotated 72 degrees to the right, or clockwise, from 
<span class="math align-center">$\color{green}{\bar{k}}$</span>:</p>
<p><a href="#R-image-62c7d65fe92e92a760d310f901ae20e6" class="lightbox-link"><img src="./assets/vectors_angle.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-62c7d65fe92e92a760d310f901ae20e6"><img src="./assets/vectors_angle.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Rotations in 3D are specified with an angle <strong>and</strong> a rotation axis. The angle specified will rotate the object along the rotation axis given. Try to visualize this by spinning your head a certain degree while continually looking down a single rotation axis. When rotating 2D vectors in a 3D world for example, we set the rotation axis to the z-axis (try to visualize this).</p>
<p>Using trigonometry it is possible to transform vectors to newly rotated vectors given an angle. This is usually done via a smart combination of the <code>sine</code> and <code>cosine</code> functions (commonly abbreviated to <code>sin</code> and <code>cos</code>). A discussion of how the rotation matrices are generated is out of the scope of this chapter.</p>
<p>A rotation matrix is defined for each unit axis in 3D space where the angle is represented as the theta symbol 
<span class="math align-center">$\theta$</span>.</p>
<p>Rotation around the X-axis:</p>

<span class="math align-center">$$
\begin{bmatrix} \color{red}1 & \color{red}0 & \color{red}0 & \color{red}0 \\ \color{green}0 & \color{green}{\cos \theta} & - \color{green}{\sin \theta} & \color{green}0 \\ \color{blue}0 & \color{blue}{\sin \theta} & \color{blue}{\cos \theta} & \color{blue}0 \\ \color{purple}0 & \color{purple}0 & \color{purple}0 & \color{purple}1 \end{bmatrix} \cdot \begin{pmatrix} x \\ y \\ z \\ 1 \end{pmatrix} = \begin{pmatrix} x \\ {\color{green}{\cos \theta}} \cdot y - {\color{green}{\sin \theta}} \cdot z \\ {\color{blue}{\sin \theta}} \cdot y + {\color{blue}{\cos \theta}} \cdot z \\ 1 \end{pmatrix}
$$</span><p>Rotation around the Y-axis:</p>

<span class="math align-center">$$
\begin{bmatrix} \color{red}{\cos \theta} & \color{red}0 & \color{red}{\sin \theta} & \color{red}0 \\ \color{green}0 & \color{green}1 & \color{green}0 & \color{green}0 \\ - \color{blue}{\sin \theta} & \color{blue}0 & \color{blue}{\cos \theta} & \color{blue}0 \\ \color{purple}0 & \color{purple}0 & \color{purple}0 & \color{purple}1 \end{bmatrix} \cdot \begin{pmatrix} x \\ y \\ z \\ 1 \end{pmatrix} = \begin{pmatrix} {\color{red}{\cos \theta}} \cdot x + {\color{red}{\sin \theta}} \cdot z \\ y \\ - {\color{blue}{\sin \theta}} \cdot x + {\color{blue}{\cos \theta}} \cdot z \\ 1 \end{pmatrix}
$$</span><p>Rotation around the Z-axis:</p>

<span class="math align-center">$$
\begin{bmatrix} \color{red}{\cos \theta} & - \color{red}{\sin \theta} & \color{red}0 & \color{red}0 \\ \color{green}{\sin \theta} & \color{green}{\cos \theta} & \color{green}0 & \color{green}0 \\ \color{blue}0 & \color{blue}0 & \color{blue}1 & \color{blue}0 \\ \color{purple}0 & \color{purple}0 & \color{purple}0 & \color{purple}1 \end{bmatrix} \cdot \begin{pmatrix} x \\ y \\ z \\ 1 \end{pmatrix} = \begin{pmatrix} {\color{red}{\cos \theta}} \cdot x - {\color{red}{\sin \theta}} \cdot y  \\ {\color{green}{\sin \theta}} \cdot x + {\color{green}{\cos \theta}} \cdot y \\ z \\ 1 \end{pmatrix}
$$</span><p>Using the rotation matrices we can transform our position vectors around one of the three unit axes. To rotate around an arbitrary 3D axis we can combine all 3 them by first rotating around the X-axis, then Y and then Z for example. However, this quickly introduces a problem called Gimbal lock. We won&rsquo;t discuss the details, but a better solution is to rotate around an arbitrary unit axis e.g. <code>(0.662,0.2,0.722)</code> (note that this is a unit vector) right away instead of combining the rotation matrices. Such a (verbose) matrix exists and is given below with 
<span class="math align-center">$({\color{red}{R_x}}, {\color{green}{R_y}}, {\color{blue}{R_z}})$</span> as the arbitrary rotation axis:</p>

<span class="math align-center">$$
\begin{bmatrix} \cos \theta + {\color{red}{R_x}}^2(1 - \cos \theta) & {\color{red}{R_x}}{\color{green}{R_y}}(1 - \cos \theta) - {\color{blue}{R_z}} \sin \theta & {\color{red}{R_x}}{\color{blue}{R_z}}(1 - \cos \theta) + {\color{green}{R_y}} \sin \theta & 0 \\ {\color{green}{R_y}}{\color{red}{R_x}} (1 - \cos \theta) + {\color{blue}{R_z}} \sin \theta & \cos \theta + {\color{green}{R_y}}^2(1 - \cos \theta) & {\color{green}{R_y}}{\color{blue}{R_z}}(1 - \cos \theta) - {\color{red}{R_x}} \sin \theta & 0 \\ {\color{blue}{R_z}}{\color{red}{R_x}}(1 - \cos \theta) - {\color{green}{R_y}} \sin \theta & {\color{blue}{R_z}}{\color{green}{R_y}}(1 - \cos \theta) + {\color{red}{R_x}} \sin \theta & \cos \theta + {\color{blue}{R_z}}^2(1 - \cos \theta) & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix}
$$</span><p>A mathematical discussion of generating such a matrix is out of the scope of this chapter. Keep in mind that even this matrix does not completely prevent gimbal lock (although it gets a lot harder). To truly prevent Gimbal locks we have to represent rotations using quaternions, that are not only safer, but also more computationally friendly. However, a discussion of quaternions is out of this chapter&rsquo;s scope.</p>
<h4 id="combining-matrices">Combining matrices</h4>
<p>The true power from using matrices for transformations is that we can combine multiple transformations in a single matrix thanks to matrix-matrix multiplication. Let&rsquo;s see if we can generate a transformation matrix that combines several transformations. Say we have a vector <code>(x,y,z)</code> and we want to scale it by 2 and then translate it by <code>(1,2,3)</code>. We need a translation and a scaling matrix for our required steps. The resulting transformation matrix would then look like:</p>

<span class="math align-center">$$
Trans . Scale = \begin{bmatrix} \color{red}1 & \color{red}0 & \color{red}0 & \color{red}1 \\ \color{green}0 & \color{green}1 & \color{green}0 & \color{green}2 \\ \color{blue}0 & \color{blue}0 & \color{blue}1 & \color{blue}3 \\ \color{purple}0 & \color{purple}0 & \color{purple}0 & \color{purple}1 \end{bmatrix} . \begin{bmatrix} \color{red}2 & \color{red}0 & \color{red}0 & \color{red}0 \\ \color{green}0 & \color{green}2 & \color{green}0 & \color{green}0 \\ \color{blue}0 & \color{blue}0 & \color{blue}2 & \color{blue}0 \\ \color{purple}0 & \color{purple}0 & \color{purple}0 & \color{purple}1 \end{bmatrix} = \begin{bmatrix} \color{red}2 & \color{red}0 & \color{red}0 & \color{red}1 \\ \color{green}0 & \color{green}2 & \color{green}0 & \color{green}2 \\ \color{blue}0 & \color{blue}0 & \color{blue}2 & \color{blue}3 \\ \color{purple}0 & \color{purple}0 & \color{purple}0 & \color{purple}1 \end{bmatrix}
$$</span><p>Note that we first do a translation and then a scale transformation when multiplying matrices. Matrix multiplication is not commutative, which means their order is important. When multiplying matrices the right-most matrix is first multiplied with the vector so you should read the multiplications from right to left. It is advised to first do scaling operations, then rotations and lastly translations when combining matrices otherwise they may (negatively) affect each other. For example, if you would first do a translation and then scale, the translation vector would also scale!</p>
<p>Running the final transformation matrix on our vector results in the following vector:</p>

<span class="math align-center">$$
\begin{bmatrix} \color{red}2 & \color{red}0 & \color{red}0 & \color{red}1 \\ \color{green}0 & \color{green}2 & \color{green}0 & \color{green}2 \\ \color{blue}0 & \color{blue}0 & \color{blue}2 & \color{blue}3 \\ \color{purple}0 & \color{purple}0 & \color{purple}0 & \color{purple}1 \end{bmatrix} . \begin{bmatrix} x \\ y \\ z \\ 1 \end{bmatrix} = \begin{bmatrix} {\color{red}2}x + \color{red}1 \\ {\color{green}2}y + \color{green}2  \\ {\color{blue}2}z + \color{blue}3 \\ 1 \end{bmatrix}
$$</span><p>Great! The vector is first scaled by two and then translated by <code>(1,2,3)</code>.</p>
<h4 id="in-practice">In practice</h4>
<p>Now that we&rsquo;ve explained all the theory behind transformations, it&rsquo;s time to see how we can actually use this knowledge to our advantage. OpenGL does not have any form of matrix or vector knowledge built in, so we have to define our own mathematics classes and functions. In this book we&rsquo;d rather abstract from all the tiny mathematical details and simply use pre-made mathematics libraries. Luckily, there is an easy-to-use and tailored-for-OpenGL mathematics library called GLM.</p>
<h5 id="glm">GLM</h5>
<p><img src="./assets/glm.png" class="right" /></p>
<p>GLM stands for Open<strong>GL</strong> <strong>M</strong>athematics and is a <em>header-only</em> library, which means that we only have to include the proper header files and we&rsquo;re done; no linking and compiling necessary. GLM can be downloaded from their <a href="https://glm.g-truc.net/0.9.8/index.html" target="_blank">website</a>. Copy the root directory of the header files into your <em>includes</em> folder and let&rsquo;s get rolling.</p>
<p>Most of GLM&rsquo;s functionality that we need can be found in 3 headers files that we&rsquo;ll include as follows:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;glm/glm.hpp&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;glm/gtc/matrix_transform.hpp&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;glm/gtc/type_ptr.hpp&gt;</span></span></span></code></pre></div><p>Let&rsquo;s see if we can put our transformation knowledge to good use by translating a vector of <code>(1,0,0)</code> by <code>(1,1,0)</code> (note that we define it as a <code>glm::vec4</code> with its homogeneous coordinate set to <code>1.0</code>:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">vec4</span> <span class="n">vec</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span> <span class="n">trans</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">trans</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">translate</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="n">vec</span> <span class="o">=</span> <span class="n">trans</span> <span class="o">*</span> <span class="n">vec</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">vec</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">vec</span><span class="p">.</span><span class="n">y</span> <span class="o">&lt;&lt;</span> <span class="n">vec</span><span class="p">.</span><span class="n">z</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span></span></span></code></pre></div><p>We first define a vector named <code>vec</code> using GLM&rsquo;s built-in vector class. Next we define a <code>mat4</code> and explicitly initialize it to the identity matrix by initializing the matrix&rsquo;s diagonals to <code>1.0</code>; if we do not initialize it to the identity matrix the matrix would be a null matrix (all elements <code>0</code>) and all subsequent matrix operations would end up a null matrix as well.</p>
<p>The next step is to create a transformation matrix by passing our identity matrix to the <code>glm::translate</code> function, together with a translation vector (the given matrix is then multiplied with a translation matrix and the resulting matrix is returned).
Then we multiply our vector by the transformation matrix and output the result. If we still remember how matrix translation works then the resulting vector should be <code>(1+1,0+1,0+0)</code> which is <code>(2,1,0)</code>. This snippet of code outputs <code>210</code> so the translation matrix did its job.</p>
<p>Let&rsquo;s do something more interesting and scale and rotate the container object from the previous chapter:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span> <span class="n">trans</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">trans</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">rotate</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">radians</span><span class="p">(</span><span class="mf">90.0f</span><span class="p">),</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">trans</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">scale</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">));</span>  
</span></span></code></pre></div><p>First we scale the container by <code>0.5</code> on each axis and then rotate the container <code>90</code> degrees around the Z-axis. GLM expects its angles in radians so we convert the degrees to radians using <code>glm::radians</code>. Note that the textured rectangle is on the XY plane so we want to rotate around the Z-axis. Keep in mind that the axis that we rotate around should be a unit vector, so be sure to normalize the vector first if you&rsquo;re not rotating around the X, Y, or Z axis. Because we pass the matrix to each of GLM&rsquo;s functions, GLM automatically multiples the matrices together, resulting in a transformation matrix that combines all the transformations.</p>
<p>The next big question is: how do we get the transformation matrix to the shaders? We shortly mentioned before that GLSL also has a <code>mat4</code> type. So we&rsquo;ll adapt the vertex shader to accept a <code>mat4</code> uniform variable and multiply the position vector by the matrix uniform:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">aPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec2</span> <span class="n">aTexCoord</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">out</span> <span class="n">vec2</span> <span class="n">TexCoord</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="n">uniform</span> <span class="n">mat4</span> <span class="n">transform</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">transform</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">aPos</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="n">TexCoord</span> <span class="o">=</span> <span class="n">vec2</span><span class="p">(</span><span class="n">aTexCoord</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">aTexCoord</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="p">}</span> 
</span></span></code></pre></div><p><note>GLSL also has <code>mat2</code> and <code>mat3</code> types that allow for swizzling-like operations just like vectors. All the aforementioned math operations (like scalar-matrix multiplication, matrix-vector multiplication and matrix-matrix multiplication) are allowed on the matrix types. Wherever special matrix operations are used we&rsquo;ll be sure to explain what&rsquo;s happening.</note></p>
<p>We added the uniform and multiplied the position vector with the transformation matrix before passing it to gl_Position. Our container should now be twice as small and rotated <code>90</code> degrees (tilted to the left). We still need to pass the transformation matrix to the shader though:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">transformLoc</span> <span class="o">=</span> <span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">ourShader</span><span class="p">.</span><span class="n">ID</span><span class="p">,</span> <span class="s">&#34;transform&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glUniformMatrix4fv</span><span class="p">(</span><span class="n">transformLoc</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">value_ptr</span><span class="p">(</span><span class="n">trans</span><span class="p">));</span></span></span></code></pre></div><p>We first query the location of the uniform variable and then send the matrix data to the shaders using glUniform with <code>Matrix4fv</code> as its postfix. The first argument should be familiar by now which is the uniform&rsquo;s location. The second argument tells OpenGL how many matrices we&rsquo;d like to send, which is <code>1</code>. The third argument asks us if we want to transpose our matrix, that is to swap the columns and rows. OpenGL developers often use an internal matrix layout called column-major ordering which is the default matrix layout in GLM so there is no need to transpose the matrices; we can keep it at GL_FALSE. The last parameter is the actual matrix data, but GLM stores their matrices&rsquo; data in a way that doesn&rsquo;t always match OpenGL&rsquo;s expectations so we first convert the data with GLM&rsquo;s built-in function value_ptr.</p>
<p>We created a transformation matrix, declared a uniform in the vertex shader and sent the matrix to the shaders where we transform our vertex coordinates. The result should look something like this:</p>
<p><a href="#R-image-fd13f6fb2b6b356c1e20b51ff1b74c51" class="lightbox-link"><img src="./assets/transformations.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-fd13f6fb2b6b356c1e20b51ff1b74c51"><img src="./assets/transformations.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Perfect! Our container is indeed tilted to the left and twice as small so the transformation was successful. Let&rsquo;s get a little more funky and see if we can rotate the container over time, and for fun we&rsquo;ll also reposition the container at the bottom-right side of the window. To rotate the container over time we have to update the transformation matrix in the render loop because it needs to update each frame. We use GLFW&rsquo;s time function to get an angle over time:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span> <span class="n">trans</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">trans</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">translate</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.5f</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">trans</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">rotate</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">glfwGetTime</span><span class="p">(),</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">));</span></span></span></code></pre></div><p>Keep in mind that in the previous case we could declare the transformation matrix anywhere, but now we have to create it every iteration to continuously update the rotation. This means we have to re-create the transformation matrix in each iteration of the render loop. Usually when rendering scenes we have several transformation matrices that are re-created with new values each frame.</p>
<p>Here we first rotate the container around the origin <code>(0,0,0)</code> and once it&rsquo;s rotated, we translate its rotated version to the bottom-right corner of the screen. Remember that the actual transformation order should be read in reverse: even though in code we first translate and then later rotate, the actual transformations first apply a rotation and then a translation. Understanding all these combinations of transformations and how they apply to objects is difficult to understand. Try and experiment with transformations like these and you&rsquo;ll quickly get a grasp of it.</p>
<p>If you did things right you should get the following result:</p>
<p><video src="assets/transformations.mp4" width="600" height="450" controls="" preload="auto"></video></p>
<p>And there you have it. A translated container that&rsquo;s rotated over time, all done by a single transformation matrix! Now you can see why matrices are such a powerful construct in graphics land. We can define an infinite amount of transformations and combine them all in a single matrix that we can re-use as often as we&rsquo;d like. Using transformations like this in the vertex shader saves us the effort of re-defining the vertex data and saves us some processing time as well, since we don&rsquo;t have to re-send our data all the time (which is quite slow); all we need to do is update the transformation uniform.</p>
<p>If you didn&rsquo;t get the right result or you&rsquo;re stuck somewhere else, take a look at the <a href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/5.1.transformations/transformations.cpp" target="_blank">source code</a> and the updated <a href="https://learnopengl.com/code_viewer_gh.php?code=includes/learnopengl/shader_m.h" target="_blank">shader</a> class.</p>
<p>In the next chapter we&rsquo;ll discuss how we can use matrices to define different coordinate spaces for our vertices. This will be our first step into 3D graphics!</p>
<h4 id="further-reading">Further reading</h4>
<ul>
<li><a href="https://www.youtube.com/playlist?list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE_ab" target="_blank">Essence of Linear Algebra</a>: great video tutorial series by Grant Sanderson about the underlying mathematics of transformations and linear algebra.</li>
</ul>
<h4 id="exercises-3">Exercises</h4>
<ul>
<li>Using the last transformation on the container, try switching the order around by first rotating and then translating. See what happens and try to reason why this happens: <a href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/5.2.transformations_exercise1/transformations_exercise1.cpp" target="_blank">solution</a>.</li>
<li>Try drawing a second container with another call to glDrawElements but place it at a different position using transformations <strong>only</strong>. Make sure this second container is placed at the top-left of the window and instead of rotating, scale it over time (using the <code>sin</code> function is useful here; note that using <code>sin</code> will cause the object to invert as soon as a negative scale is applied): <a href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/5.2.transformations_exercise2/transformations_exercise2.cpp" target="_blank">solution</a>.</li>
</ul>
<h3 id="coordinate-systems">Coordinate Systems</h3>
<p>In the last chapter we learned how we can use matrices to our advantage by transforming all vertices with transformation matrices. OpenGL expects all the vertices, that we want to become visible, to be in normalized device coordinates after each vertex shader run. That is, the <code>x</code>, <code>y</code> and <code>z</code> coordinates of each vertex should be between <code>-1.0</code> and <code>1.0</code>; coordinates outside this range will not be visible. What we usually do, is specify the coordinates in a range (or space) we determine ourselves and in the vertex shader transform these coordinates to normalized device coordinates (NDC). These NDC are then given to the rasterizer to transform them to 2D coordinates/pixels on your screen.</p>
<p>Transforming coordinates to NDC is usually accomplished in a step-by-step fashion where we transform an object&rsquo;s vertices to several coordinate systems before finally transforming them to NDC. The advantage of transforming them to several <em>intermediate</em> coordinate systems is that some operations/calculations are easier in certain coordinate systems as will soon become apparent. There are a total of 5 different coordinate systems that are of importance to us:</p>
<ul>
<li>Local space (or Object space)</li>
<li>World space</li>
<li>View space (or Eye space)</li>
<li>Clip space</li>
<li>Screen space</li>
</ul>
<p>Those are all a different state at which our vertices will be transformed in before finally ending up as fragments.</p>
<p>You&rsquo;re probably quite confused by now by what a space or coordinate system actually is so we&rsquo;ll explain them in a more high-level fashion first by showing the total picture and what each specific space represents.</p>
<h4 id="the-global-picture">The global picture</h4>
<p>To transform the coordinates from one space to the next coordinate space we&rsquo;ll use several transformation matrices of which the most important are the model, view and projection matrix. Our vertex coordinates first start in local space as local coordinates and are then further processed to world coordinates, view coordinates, clip coordinates and eventually end up as screen coordinates. The following image displays the process and shows what each transformation does:</p>
<p><a href="#R-image-c1853a30c1c8c14c3e797df9a6c31019" class="lightbox-link"><img src="./assets/coordinate_systems.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c1853a30c1c8c14c3e797df9a6c31019"><img src="./assets/coordinate_systems.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<ol>
<li>Local coordinates are the coordinates of your object relative to its local origin; they&rsquo;re the coordinates your object begins in.</li>
<li>The next step is to transform the local coordinates to world-space coordinates which are coordinates in respect of a larger world. These coordinates are relative to some global origin of the world, together with many other objects also placed relative to this world&rsquo;s origin.</li>
<li>Next we transform the world coordinates to view-space coordinates in such a way that each coordinate is as seen from the camera or viewer&rsquo;s point of view.</li>
<li>After the coordinates are in view space we want to project them to clip coordinates. Clip coordinates are processed to the <code>-1.0</code> and <code>1.0</code> range and determine which vertices will end up on the screen. Projection to clip-space coordinates can add perspective if using perspective projection.</li>
<li>And lastly we transform the clip coordinates to screen coordinates in a process we call viewport transform that transforms the coordinates from <code>-1.0</code> and <code>1.0</code> to the coordinate range defined by glViewport. The resulting coordinates are then sent to the rasterizer to turn them into fragments.</li>
</ol>
<p>You probably got a slight idea what each individual space is used for. The reason we&rsquo;re transforming our vertices into all these different spaces is that some operations make more sense or are easier to use in certain coordinate systems. For example, when modifying your object it makes most sense to do this in local space, while calculating certain operations on the object with respect to the position of other objects makes most sense in world coordinates and so on. If we want, we could define one transformation matrix that goes from local space to clip space all in one go, but that leaves us with less flexibility.</p>
<p>We&rsquo;ll discuss each coordinate system in more detail below.</p>
<h4 id="local-space">Local space</h4>
<p>Local space is the coordinate space that is local to your object, i.e. where your object begins in. Imagine that you&rsquo;ve created your cube in a modeling software package (like Blender). The origin of your cube is probably at <code>(0,0,0)</code> even though your cube may end up at a different location in your final application. Probably all the models you&rsquo;ve created all have <code>(0,0,0)</code> as their initial position. All the vertices of your model are therefore in <em>local</em> space: they are all local to your object.</p>
<p>The vertices of the container we&rsquo;ve been using were specified as coordinates between <code>-0.5</code> and <code>0.5</code> with <code>0.0</code> as its origin. These are local coordinates.</p>
<h4 id="world-space">World space</h4>
<p>If we would import all our objects directly in the application they would probably all be somewhere positioned inside each other at the world&rsquo;s origin of <code>(0,0,0)</code> which is not what we want. We want to define a position for each object to position them inside a larger world. The coordinates in world space are exactly what they sound like: the coordinates of all your vertices relative to a (game) world. This is the coordinate space where you want your objects transformed to in such a way that they&rsquo;re all scattered around the place (preferably in a realistic fashion). The coordinates of your object are transformed from local to world space; this is accomplished with the model matrix.</p>
<p>The model matrix is a transformation matrix that translates, scales and/or rotates your object to place it in the world at a location/orientation they belong to. Think of it as transforming a house by scaling it down (it was a bit too large in local space), translating it to a suburbia town and rotating it a bit to the left on the y-axis so that it neatly fits with the neighboring houses. You could think of the matrix in the previous chapter to position the container all over the scene as a sort of model matrix as well; we transformed the local coordinates of the container to some different place in the scene/world.</p>
<h4 id="view-space">View space</h4>
<p>The view space is what people usually refer to as the camera of OpenGL (it is sometimes also known as camera space or eye space). The view space is the result of transforming your world-space coordinates to coordinates that are in front of the user&rsquo;s view. The view space is thus the space as seen from the camera&rsquo;s point of view. This is usually accomplished with a combination of translations and rotations to translate/rotate the scene so that certain items are transformed to the front of the camera. These combined transformations are generally stored inside a view matrix that transforms world coordinates to view space. In the next chapter we&rsquo;ll extensively discuss how to create such a view matrix to simulate a camera.</p>
<h4 id="clip-space">Clip space</h4>
<p>At the end of each vertex shader run, OpenGL expects the coordinates to be within a specific range and any coordinate that falls outside this range is clipped. Coordinates that are clipped are discarded, so the remaining coordinates will end up as fragments visible on your screen. This is also where clip space gets its name from.</p>
<p>Because specifying all the visible coordinates to be within the range <code>-1.0</code> and <code>1.0</code> isn&rsquo;t really intuitive, we specify our own coordinate set to work in and convert those back to NDC as OpenGL expects them.</p>
<p>To transform vertex coordinates from view to clip-space we define a so called projection matrix that specifies a range of coordinates e.g. <code>-1000</code> and <code>1000</code> in each dimension. The projection matrix then converts coordinates within this specified range to normalized device coordinates (<code>-1.0</code>, <code>1.0</code>) (not directly, a step called Perspective Division sits in between). All coordinates outside this range will not be mapped between <code>-1.0</code> and <code>1.0</code> and therefore be clipped. With this range we specified in the projection matrix, a coordinate of (<code>1250</code>, <code>500</code>, <code>750</code>) would not be visible, since the <code>x</code> coordinate is out of range and thus gets converted to a coordinate higher than <code>1.0</code> in NDC and is therefore clipped.</p>
<p><note>Note that if only a part of a primitive e.g. a triangle is outside the clipping volume OpenGL will reconstruct the triangle as one or more triangles to fit inside the clipping range.</note></p>
<p>This <em>viewing box</em> a projection matrix creates is called a frustum and each coordinate that ends up inside this frustum will end up on the user&rsquo;s screen. The total process to convert coordinates within a specified range to NDC that can easily be mapped to 2D view-space coordinates is called projection since the projection matrix projects 3D coordinates to the easy-to-map-to-2D normalized device coordinates.</p>
<p>Once all the vertices are transformed to clip space a final operation called perspective division is performed where we divide the <code>x</code>, <code>y</code> and <code>z</code> components of the position vectors by the vector&rsquo;s homogeneous <code>w</code> component; perspective division is what transforms the 4D clip space coordinates to 3D normalized device coordinates. This step is performed automatically at the end of the vertex shader step.</p>
<p>It is after this stage where the resulting coordinates are mapped to screen coordinates (using the settings of glViewport) and turned into fragments.</p>
<p>The projection matrix to transform view coordinates to clip coordinates usually takes two different forms, where each form defines its own unique frustum. We can either create an orthographic projection matrix or a perspective projection matrix.</p>
<h5 id="orthographic-projection">Orthographic projection</h5>
<p>An orthographic projection matrix defines a cube-like frustum box that defines the clipping space where each vertex outside this box is clipped. When creating an orthographic projection matrix we specify the width, height and length of the visible frustum. All the coordinates inside this frustum will end up within the NDC range after transformed by its matrix and thus won&rsquo;t be clipped. The frustum looks a bit like a container:</p>
<p><a href="#R-image-26d2cdb6c9fc90452d174367424e3134" class="lightbox-link"><img src="./assets/orthographic_frustum.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-26d2cdb6c9fc90452d174367424e3134"><img src="./assets/orthographic_frustum.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>The frustum defines the visible coordinates and is specified by a width, a height and a near and far plane. Any coordinate in front of the near plane is clipped and the same applies to coordinates behind the far plane. The orthographic frustum <strong>directly</strong> maps all coordinates inside the frustum to normalized device coordinates without any special side effects since it won&rsquo;t touch the <code>w</code> component of the transformed vector; if the <code>w</code> component remains equal to <code>1.0</code> perspective division won&rsquo;t change the coordinates.</p>
<p>To create an orthographic projection matrix we make use of GLM&rsquo;s built-in function <code>glm::ortho</code>:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">ortho</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">800.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">600.0f</span><span class="p">,</span> <span class="mf">0.1f</span><span class="p">,</span> <span class="mf">100.0f</span><span class="p">);</span></span></span></code></pre></div><p>The first two parameters specify the left and right coordinate of the frustum and the third and fourth parameter specify the bottom and top part of the frustum. With those 4 points we&rsquo;ve defined the size of the near and far planes and the 5th and 6th parameter then define the distances between the near and far plane. This specific projection matrix transforms all coordinates between these <code>x</code>, <code>y</code> and <code>z</code> range values to normalized device coordinates.</p>
<p>An orthographic projection matrix directly maps coordinates to the 2D plane that is your screen, but in reality a direct projection produces unrealistic results since the projection doesn&rsquo;t take perspective into account. That is something the perspective projection matrix fixes for us.</p>
<h5 id="perspective-projection">Perspective projection</h5>
<p>If you ever were to enjoy the graphics the <em>real life</em> has to offer you&rsquo;ll notice that objects that are farther away appear much smaller. This weird effect is something we call perspective. Perspective is especially noticeable when looking down the end of an infinite motorway or railway as seen in the following image:</p>
<p><a href="#R-image-450103a60ea0bd43e5bc2e0dc71e3e12" class="lightbox-link"><img src="./assets/perspective.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-450103a60ea0bd43e5bc2e0dc71e3e12"><img src="./assets/perspective.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>As you can see, due to perspective the lines seem to coincide at a far enough distance. This is exactly the effect perspective projection tries to mimic and it does so using a perspective projection matrix. The projection matrix maps a given frustum range to clip space, but also manipulates the <code>w</code> value of each vertex coordinate in such a way that the further away a vertex coordinate is from the viewer, the higher this <code>w</code> component becomes. Once the coordinates are transformed to clip space they are in the range <code>-w</code> to <code>w</code> (anything outside this range is clipped). OpenGL requires that the visible coordinates fall between the range <code>-1.0</code> and <code>1.0</code> as the final vertex shader output, thus once the coordinates are in clip space, perspective division is applied to the clip space coordinates:</p>

<span class="math align-center">$$
out = \begin{pmatrix} x /w \\ y / w \\ z / w \end{pmatrix}
$$</span><p>Each component of the vertex coordinate is divided by its <code>w</code> component giving smaller vertex coordinates the further away a vertex is from the viewer. This is another reason why the <code>w</code> component is important, since it helps us with perspective projection. The resulting coordinates are then in normalized device space. If you&rsquo;re interested to figure out how the orthographic and perspective projection matrices are actually calculated (and aren&rsquo;t too scared of the mathematics) I can recommend <a href="http://www.songho.ca/opengl/gl_projectionmatrix.html" target="_blank">this excellent article</a> by Songho.</p>
<p>A perspective projection matrix can be created in GLM as follows:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span> <span class="n">proj</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">perspective</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">radians</span><span class="p">(</span><span class="mf">45.0f</span><span class="p">),</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">width</span><span class="o">/</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">height</span><span class="p">,</span> <span class="mf">0.1f</span><span class="p">,</span> <span class="mf">100.0f</span><span class="p">);</span></span></span></code></pre></div><p>What <code>glm::perspective</code> does is again create a large <em>frustum</em> that defines the visible space, anything outside the frustum will not end up in the clip space volume and will thus become clipped. A perspective frustum can be visualized as a non-uniformly shaped box from where each coordinate inside this box will be mapped to a point in clip space. An image of a perspective frustum is seen below:</p>
<p><a href="#R-image-547e000af3a89a1b605ba80589f653eb" class="lightbox-link"><img src="./assets/perspective_frustum.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-547e000af3a89a1b605ba80589f653eb"><img src="./assets/perspective_frustum.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Its first parameter defines the fov value, that stands for field of view and sets how large the viewspace is. For a realistic view it is usually set to 45 degrees, but for more doom-style results you could set it to a higher value. The second parameter sets the aspect ratio which is calculated by dividing the viewport&rsquo;s width by its height. The third and fourth parameter set the <em>near</em> and <em>far</em> plane of the frustum. We usually set the near distance to <code>0.1</code> and the far distance to <code>100.0</code>. All the vertices between the near and far plane and inside the frustum will be rendered.</p>
<p><note>Whenever the <em>near</em> value of your perspective matrix is set too high (like <code>10.0</code>), OpenGL will clip all coordinates close to the camera (between <code>0.0</code> and <code>10.0</code>), which can give a visual result you maybe have seen before in videogames where you could see through certain objects when moving uncomfortably close to them.</note></p>
<p>When using orthographic projection, each of the vertex coordinates are directly mapped to clip space without any fancy perspective division (it still does perspective division, but the <code>w</code> component is not manipulated (it stays <code>1</code>) and thus has no effect). Because the orthographic projection doesn&rsquo;t use perspective projection, objects farther away do not seem smaller, which produces a weird visual output. For this reason the orthographic projection is mainly used for 2D renderings and for some architectural or engineering applications where we&rsquo;d rather not have vertices distorted by perspective. Applications like <em>Blender</em> that are used for 3D modeling sometimes use orthographic projection for modeling, because it more accurately depicts each object&rsquo;s dimensions. Below you&rsquo;ll see a comparison of both projection methods in Blender:</p>
<p><a href="#R-image-9211b8ae210a62348c626111280cedd6" class="lightbox-link"><img src="./assets/perspective_orthographic.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-9211b8ae210a62348c626111280cedd6"><img src="./assets/perspective_orthographic.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>You can see that with perspective projection, the vertices farther away appear much smaller, while in orthographic projection each vertex has the same distance to the user.</p>
<h4 id="putting-it-all-together">Putting it all together</h4>
<p>We create a transformation matrix for each of the aforementioned steps: model, view and projection matrix. A vertex coordinate is then transformed to clip coordinates as follows:</p>

<span class="math align-center">$$
V_{clip} = M_{projection} \cdot M_{view} \cdot M_{model} \cdot V_{local}
$$</span><p>Note that the order of matrix multiplication is reversed (remember that we need to read matrix multiplication from right to left). The resulting vertex should then be assigned to gl_Position in the vertex shader and OpenGL will then automatically perform perspective division and clipping.</p>
<p><note><strong>And then?</strong><br>The output of the vertex shader requires the coordinates to be in clip-space which is what we just did with the transformation matrices. OpenGL then performs <em>perspective division</em> on the <em>clip-space coordinates</em> to transform them to <em>normalized-device coordinates</em>. OpenGL then uses the parameters from glViewPort to map the normalized-device coordinates to <em>screen coordinates</em> where each coordinate corresponds to a point on your screen (in our case a 800x600 screen). This process is called the <em>viewport transform</em>.</note></p>
<p>This is a difficult topic to understand so if you&rsquo;re still not exactly sure about what each space is used for you don&rsquo;t have to worry. Below you&rsquo;ll see how we can actually put these coordinate spaces to good use and enough examples will follow in the upcoming chapters.</p>
<h4 id="going-3d">Going 3D</h4>
<p>Now that we know how to transform 3D coordinates to 2D coordinates we can start rendering real 3D objects instead of the lame 2D plane we&rsquo;ve been showing so far.</p>
<p>To start drawing in 3D we&rsquo;ll first create a model matrix. The model matrix consists of translations, scaling and/or rotations we&rsquo;d like to apply to <em>transform</em> all object&rsquo;s vertices to the global world space. Let&rsquo;s transform our plane a bit by rotating it on the x-axis so it looks like it&rsquo;s laying on the floor. The model matrix then looks like this:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span> <span class="n">model</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">model</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">rotate</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">radians</span><span class="p">(</span><span class="o">-</span><span class="mf">55.0f</span><span class="p">),</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">));</span> 
</span></span></code></pre></div><p>By multiplying the vertex coordinates with this model matrix we&rsquo;re transforming the vertex coordinates to world coordinates. Our plane that is slightly on the floor thus represents the plane in the global world.</p>
<p>Next we need to create a view matrix. We want to move slightly backwards in the scene so the object becomes visible (when in world space we&rsquo;re located at the origin <code>(0,0,0)</code>). To move around the scene, think about the following:</p>
<ul>
<li>To move a camera backwards, is the same as moving the entire scene forward.</li>
</ul>
<p>That is exactly what a view matrix does, we move the entire scene around inversed to where we want the camera to move.
Because we want to move backwards and since OpenGL is a right-handed system we have to move in the positive z-axis. We do this by translating the scene towards the negative z-axis. This gives the impression that we are moving backwards.</p>
<p><note><strong>Right-handed system</strong><br>By convention, OpenGL is a right-handed system. What this basically says is that the positive x-axis is to your right, the positive y-axis is up and the positive z-axis is backwards. Think of your screen being the center of the 3 axes and the positive z-axis going through your screen towards you. The axes are drawn as follows:<br><a href="#R-image-49b4be6337d15348a1ef7fe711819120" class="lightbox-link"><img src="./assets/coordinate_systems_right_handed.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-49b4be6337d15348a1ef7fe711819120"><img src="./assets/coordinate_systems_right_handed.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a><br>To understand why it&rsquo;s called right-handed do the following:<br>◆ Stretch your right-arm along the positive y-axis with your hand up top.<br>◆ Let your thumb point to the right.<br>◆ Let your pointing finger point up.<br>◆ Now bend your middle finger downwards 90 degrees.<br><br>If you did things right, your thumb should point towards the positive x-axis, the pointing finger towards the positive y-axis and your middle finger towards the positive z-axis. If you were to do this with your left-arm you would see the z-axis is reversed. This is known as a left-handed system and is commonly used by DirectX. Note that in normalized device coordinates OpenGL actually uses a left-handed system (the projection matrix switches the handedness).</note></p>
<p>We&rsquo;ll discuss how to move around the scene in more detail in the next chapter. For now the view matrix looks like this:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span> <span class="n">view</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="c1">// note that we&#39;re translating the scene in the reverse direction of where we want to move
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="c1"></span><span class="n">view</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">translate</span><span class="p">(</span><span class="n">view</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.0f</span><span class="p">));</span> 
</span></span></code></pre></div><p>The last thing we need to define is the projection matrix. We want to use perspective projection for our scene so we&rsquo;ll declare the projection matrix like this:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span> <span class="n">projection</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">projection</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">perspective</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">radians</span><span class="p">(</span><span class="mf">45.0f</span><span class="p">),</span> <span class="mf">800.0f</span> <span class="o">/</span> <span class="mf">600.0f</span><span class="p">,</span> <span class="mf">0.1f</span><span class="p">,</span> <span class="mf">100.0f</span><span class="p">);</span></span></span></code></pre></div><p>Now that we created the transformation matrices we should pass them to our shaders. First let&rsquo;s declare the transformation matrices as uniforms in the vertex shader and multiply them with the vertex coordinates:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">aPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">uniform</span> <span class="n">mat4</span> <span class="n">model</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">uniform</span> <span class="n">mat4</span> <span class="n">view</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">uniform</span> <span class="n">mat4</span> <span class="n">projection</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="c1">// note that we read the multiplication from right to left
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="c1"></span>    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">projection</span> <span class="o">*</span> <span class="n">view</span> <span class="o">*</span> <span class="n">model</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">aPos</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>We should also send the matrices to the shader (this is usually done each frame since transformation matrices tend to change a lot):</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">int</span> <span class="n">modelLoc</span> <span class="o">=</span> <span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">ourShader</span><span class="p">.</span><span class="n">ID</span><span class="p">,</span> <span class="s">&#34;model&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glUniformMatrix4fv</span><span class="p">(</span><span class="n">modelLoc</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">value_ptr</span><span class="p">(</span><span class="n">model</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="p">...</span> <span class="c1">// same for View Matrix and Projection Matrix
</span></span></span></code></pre></div><p>Now that our vertex coordinates are transformed via the model, view and projection matrix the final object should be:</p>
<ul>
<li>Tilted backwards to the floor.</li>
<li>A bit farther away from us.</li>
<li>Be displayed with perspective (it should get smaller, the further its vertices are).</li>
</ul>
<p>Let&rsquo;s check if the result actually does fulfill these requirements:</p>
<p><a href="#R-image-cf78f4ca709e9e5e044f491892a64321" class="lightbox-link"><img src="./assets/coordinate_systems_result.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-cf78f4ca709e9e5e044f491892a64321"><img src="./assets/coordinate_systems_result.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>It does indeed look like the plane is a 3D plane that&rsquo;s resting at some imaginary floor. If you&rsquo;re not getting the same result, compare your code with the complete <a href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/6.1.coordinate_systems/coordinate_systems.cpp" target="_blank">source code</a>.</p>
<h4 id="more-3d">More 3D</h4>
<p>So far we&rsquo;ve been working with a 2D plane, even in 3D space, so let&rsquo;s take the adventurous route and extend our 2D plane to a 3D cube. To render a cube we need a total of 36 vertices (6 faces * 2 triangles * 3 vertices each). 36 vertices are a lot to sum up so you can retrieve them from <a href="https://learnopengl.com/code_viewer.php?code=getting-started/cube_vertices" target="_blank">here</a>.</p>
<p>For fun, we&rsquo;ll let the cube rotate over time:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">model</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">rotate</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">glfwGetTime</span><span class="p">()</span> <span class="o">*</span> <span class="n">glm</span><span class="o">::</span><span class="n">radians</span><span class="p">(</span><span class="mf">50.0f</span><span class="p">),</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.5f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">));</span>  
</span></span></code></pre></div><p>And then we&rsquo;ll draw the cube using glDrawArrays (as we didn&rsquo;t specify indices), but this time with a count of 36 vertices.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glDrawArrays</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">36</span><span class="p">);</span></span></span></code></pre></div><p>You should get something similar to the following:</p>
<p><video src="assets/coordinate_system_no_depth.mp4" width="600" height="450" controls="" preload="auto"></video></p>
<p>It does resemble a cube slightly but something&rsquo;s off. Some sides of the cubes are being drawn over other sides of the cube. This happens because when OpenGL draws your cube triangle-by-triangle, fragment by fragment, it will overwrite any pixel color that may have already been drawn there before. Since OpenGL gives no guarantee on the order of triangles rendered (within the same draw call), some triangles are drawn on top of each other even though one should clearly be in front of the other.</p>
<p>Luckily, OpenGL stores depth information in a buffer called the z-buffer that allows OpenGL to decide when to draw over a pixel and when not to. Using the z-buffer we can configure OpenGL to do depth-testing.</p>
<h5 id="z-buffer">Z-buffer</h5>
<p>OpenGL stores all its depth information in a z-buffer, also known as a depth buffer. GLFW automatically creates such a buffer for you (just like it has a color-buffer that stores the colors of the output image). The depth is stored within each fragment (as the fragment&rsquo;s <code>z</code> value) and whenever the fragment wants to output its color, OpenGL compares its depth values with the z-buffer. If the current fragment is behind the other fragment it is discarded, otherwise overwritten. This process is called depth testing and is done automatically by OpenGL.</p>
<p>However, if we want to make sure OpenGL actually performs the depth testing we first need to tell OpenGL we want to enable depth testing; it is disabled by default. We can enable depth testing using glEnable. The glEnable and glDisable functions allow us to enable/disable certain functionality in OpenGL. That functionality is then enabled/disabled until another call is made to disable/enable it. Right now we want to enable depth testing by enabling GL_DEPTH_TEST:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glEnable</span><span class="p">(</span><span class="n">GL_DEPTH_TEST</span><span class="p">);</span>  
</span></span></code></pre></div><p>Since we&rsquo;re using a depth buffer we also want to clear the depth buffer before each render iteration (otherwise the depth information of the previous frame stays in the buffer). Just like clearing the color buffer, we can clear the depth buffer by specifying the DEPTH_BUFFER_BIT bit in the glClear function:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glClear</span><span class="p">(</span><span class="n">GL_COLOR_BUFFER_BIT</span> <span class="o">|</span> <span class="n">GL_DEPTH_BUFFER_BIT</span><span class="p">);</span></span></span></code></pre></div><p>Let&rsquo;s re-run our program and see if OpenGL now performs depth testing:</p>
<p><video src="assets/coordinate_system_depth.mp4" width="600" height="450" controls="" preload="auto"></video></p>
<p>There we go! A fully textured cube with proper depth testing that rotates over time. Check the source code <a href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/6.2.coordinate_systems_depth/coordinate_systems_depth.cpp" target="_blank">here</a>.</p>
<h5 id="more-cubes">More cubes!</h5>
<p>Say we wanted to display 10 of our cubes on screen. Each cube will look the same but will only differ in where it&rsquo;s located in the world with each a different rotation. The graphical layout of the cube is already defined so we don&rsquo;t have to change our buffers or attribute arrays when rendering more objects. The only thing we have to change for each object is its model matrix where we transform the cubes into the world.</p>
<p>First, let&rsquo;s define a translation vector for each cube that specifies its position in world space. We&rsquo;ll define 10 cube positions in a <code>glm::vec3</code> array:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">cubePositions</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span> <span class="mf">0.0f</span><span class="p">,</span>  <span class="mf">0.0f</span><span class="p">,</span>  <span class="mf">0.0f</span><span class="p">),</span> 
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span> <span class="mf">2.0f</span><span class="p">,</span>  <span class="mf">5.0f</span><span class="p">,</span> <span class="o">-</span><span class="mf">15.0f</span><span class="p">),</span> 
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="o">-</span><span class="mf">1.5f</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.2f</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.5f</span><span class="p">),</span>  
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="o">-</span><span class="mf">3.8f</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.0f</span><span class="p">,</span> <span class="o">-</span><span class="mf">12.3f</span><span class="p">),</span>  
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span> <span class="mf">2.4f</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.4f</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.5f</span><span class="p">),</span>  
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="o">-</span><span class="mf">1.7f</span><span class="p">,</span>  <span class="mf">3.0f</span><span class="p">,</span> <span class="o">-</span><span class="mf">7.5f</span><span class="p">),</span>  
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span> <span class="mf">1.3f</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.0f</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.5f</span><span class="p">),</span>  
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span> <span class="mf">1.5f</span><span class="p">,</span>  <span class="mf">2.0f</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.5f</span><span class="p">),</span> 
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span> <span class="mf">1.5f</span><span class="p">,</span>  <span class="mf">0.2f</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.5f</span><span class="p">),</span> 
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="o">-</span><span class="mf">1.3f</span><span class="p">,</span>  <span class="mf">1.0f</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.5f</span><span class="p">)</span>  
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="p">};</span></span></span></code></pre></div><p>Now, within the render loop we want to call glDrawArrays 10 times, but this time send a different model matrix to the vertex shader each time before we send out the draw call. We will create a small loop within the render loop that renders our object 10 times with a different model matrix each time. Note that we also add a small unique rotation to each container.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">VAO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="n">glm</span><span class="o">::</span><span class="n">mat4</span> <span class="n">model</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="n">model</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">translate</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">cubePositions</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="kt">float</span> <span class="n">angle</span> <span class="o">=</span> <span class="mf">20.0f</span> <span class="o">*</span> <span class="n">i</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="n">model</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">rotate</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">radians</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.3f</span><span class="p">,</span> <span class="mf">0.5f</span><span class="p">));</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="n">ourShader</span><span class="p">.</span><span class="n">setMat4</span><span class="p">(</span><span class="s">&#34;model&#34;</span><span class="p">,</span> <span class="n">model</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="n">glDrawArrays</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">36</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>This snippet of code will update the model matrix each time a new cube is drawn and do this 10 times in total. Right now we should be looking into a world filled with 10 oddly rotated cubes:</p>
<p><a href="#R-image-cc3425a4554b3b14a039af98bf01b6f8" class="lightbox-link"><img src="./assets/coordinate_systems_multiple_objects.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-cc3425a4554b3b14a039af98bf01b6f8"><img src="./assets/coordinate_systems_multiple_objects.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Perfect! It looks like our container found some like-minded friends. If you&rsquo;re stuck see if you can compare your code with the <a href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/6.3.coordinate_systems_multiple/coordinate_systems_multiple.cpp" target="_blank">source code</a>.</p>
<h4 id="exercises-4">Exercises</h4>
<ul>
<li>Try experimenting with the <code>FoV</code> and <code>aspect-ratio</code> parameters of GLM&rsquo;s <code>projection</code> function. See if you can figure out how those affect the perspective frustum.</li>
<li>Play with the view matrix by translating in several directions and see how the scene changes. Think of the view matrix as a camera object.</li>
<li>Try to make every 3rd container (including the 1st) rotate over time, while leaving the other containers static using just the model matrix: <a href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/6.4.coordinate_systems_exercise3/coordinate_systems_exercise3.cpp" target="_blank">solution</a>.</li>
</ul>
<h3 id="camera">Camera</h3>
<p>In the previous chapter we discussed the view matrix and how we can use the view matrix to move around the scene (we moved backwards a little). OpenGL by itself is not familiar with the concept of a <em>camera</em>, but we can try to simulate one by moving all objects in the scene in the reverse direction, giving the illusion that <strong>we</strong> are moving.</p>
<p>In this chapter we&rsquo;ll discuss how we can set up a camera in OpenGL. We will discuss a fly style camera that allows you to freely move around in a 3D scene. We&rsquo;ll also discuss keyboard and mouse input and finish with a custom camera class.</p>
<h4 id="cameraview-space">Camera/View space</h4>
<p>When we&rsquo;re talking about camera/view space we&rsquo;re talking about all the vertex coordinates as seen from the camera&rsquo;s perspective as the origin of the scene: the view matrix transforms all the world coordinates into view coordinates that are relative to the camera&rsquo;s position and direction. To define a camera we need its position in world space, the direction it&rsquo;s looking at, a vector pointing to the right and a vector pointing upwards from the camera. A careful reader may notice that we&rsquo;re actually going to create a coordinate system with 3 perpendicular unit axes with the camera&rsquo;s position as the origin.</p>
<p><a href="#R-image-554f57f211b2f732c0794a8e7e418858" class="lightbox-link"><img src="./assets/camera_axes.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-554f57f211b2f732c0794a8e7e418858"><img src="./assets/camera_axes.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<h5 id="1-camera-position">1. Camera position</h5>
<p>Getting the camera position is easy. The camera position is a vector in world space that points to the camera&rsquo;s position. We set the camera at the same position we&rsquo;ve set the camera in the previous chapter:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">cameraPos</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">3.0f</span><span class="p">);</span></span></span></code></pre></div><p><note>Don&rsquo;t forget that the positive z-axis is going through your screen towards you so if we want the camera to move backwards, we move along the positive z-axis.</note></p>
<h5 id="2-camera-direction">2. Camera direction</h5>
<p>The next vector required is the camera&rsquo;s direction e.g. at what direction it is pointing at. For now we let the camera point to the origin of our scene: <code>(0,0,0)</code>. Remember that if we subtract two vectors from each other we get a vector that&rsquo;s the difference of these two vectors? Subtracting the camera position vector from the scene&rsquo;s origin vector thus results in the direction vector we want. For the view matrix&rsquo;s coordinate system we want its z-axis to be positive and because by convention (in OpenGL) the camera points towards the negative z-axis we want to negate the direction vector. If we switch the subtraction order around we now get a vector pointing towards the camera&rsquo;s positive z-axis:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">cameraTarget</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">cameraDirection</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">normalize</span><span class="p">(</span><span class="n">cameraPos</span> <span class="o">-</span> <span class="n">cameraTarget</span><span class="p">);</span></span></span></code></pre></div><p><warning>The name <em>direction</em> vector is not the best chosen name, since it is actually pointing in the reverse direction of what it is targeting.</warning></p>
<h5 id="3-right-axis">3. Right axis</h5>
<p>The next vector that we need is a <em>right</em> vector that represents the positive x-axis of the camera space. To get the <em>right</em> vector we use a little trick by first specifying an <em>up</em> vector that points upwards (in world space). Then we do a cross product on the up vector and the direction vector from step 2. Since the result of a cross product is a vector perpendicular to both vectors, we will get a vector that points in the positive x-axis&rsquo;s direction (if we would switch the cross product order we&rsquo;d get a vector that points in the negative x-axis):</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">up</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">cameraRight</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">normalize</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">cross</span><span class="p">(</span><span class="n">up</span><span class="p">,</span> <span class="n">cameraDirection</span><span class="p">));</span></span></span></code></pre></div><h5 id="4-up-axis">4. Up axis</h5>
<p>Now that we have both the x-axis vector and the z-axis vector, retrieving the vector that points to the camera&rsquo;s positive y-axis is relatively easy: we take the cross product of the right and direction vector:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">cameraUp</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">cross</span><span class="p">(</span><span class="n">cameraDirection</span><span class="p">,</span> <span class="n">cameraRight</span><span class="p">);</span></span></span></code></pre></div><p>With the help of the cross product and a few tricks we were able to create all the vectors that form the view/camera space. For the more mathematically inclined readers, this process is known as the <a href="http://en.wikipedia.org/wiki/Gram%e2%80%93Schmidt_process" target="_blank">Gram-Schmidt</a> process in linear algebra. Using these camera vectors we can now create a LookAt matrix that proves very useful for creating a camera.</p>
<h4 id="look-at">Look At</h4>
<p>A great thing about matrices is that if you define a coordinate space using 3 perpendicular (or non-linear) axes you can create a matrix with those 3 axes plus a translation vector and you can transform any vector to that coordinate space by multiplying it with this matrix. This is exactly what the <em>LookAt</em> matrix does and now that we have 3 perpendicular axes and a position vector to define the camera space we can create our own LookAt matrix:</p>

<span class="math align-center">$$
LookAt = \begin{bmatrix} \color{red}{R_x} & \color{red}{R_y} & \color{red}{R_z} & 0 \\ \color{green}{U_x} & \color{green}{U_y} & \color{green}{U_z} & 0 \\ \color{blue}{D_x} & \color{blue}{D_y} & \color{blue}{D_z} & 0 \\ 0 & 0 & 0  & 1 \end{bmatrix} * \begin{bmatrix} 1 & 0 & 0 & -\color{purple}{P_x} \\ 0 & 1 & 0 & -\color{purple}{P_y} \\ 0 & 0 & 1 & -\color{purple}{P_z} \\ 0 & 0 & 0  & 1 \end{bmatrix}
$$</span><p>Where 
<span class="math align-center">$\color{red}R$</span> is the right vector, 
<span class="math align-center">$\color{green}U$</span> is the up vector, 
<span class="math align-center">$\color{blue}D$</span> is the direction vector and 
<span class="math align-center">$\color{purple}P$</span> is the camera&rsquo;s position vector. Note that the rotation (left matrix) and translation (right matrix) parts are inverted (transposed and negated respectively) since we want to rotate and translate the world in the opposite direction of where we want the camera to move. Using this LookAt matrix as our view matrix effectively transforms all the world coordinates to the view space we just defined. The LookAt matrix then does exactly what it says: it creates a view matrix that <em>looks</em> at a given target.</p>
<p>Luckily for us, GLM already does all this work for us. We only have to specify a camera position, a target position and a vector that represents the up vector in world space (the up vector we used for calculating the right vector). GLM then creates the LookAt matrix that we can use as our view matrix:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span> <span class="n">view</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">view</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">lookAt</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">3.0f</span><span class="p">),</span> 
</span></span><span class="line"><span class="ln">3</span><span class="cl">  		   <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">),</span> 
</span></span><span class="line"><span class="ln">4</span><span class="cl">  		   <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">));</span></span></span></code></pre></div><p>The glm::LookAt function requires a position, target and up vector respectively. This example creates a view matrix that is the same as the one we created in the previous chapter.</p>
<p>Before delving into user input, let&rsquo;s get a little funky first by rotating the camera around our scene. We keep the target of the scene at <code>(0,0,0)</code>. We use a little bit of trigonometry to create an <code>x</code> and <code>z</code> coordinate each frame that represents a point on a circle and we&rsquo;ll use these for our camera position. By re-calculating the <code>x</code> and <code>y</code> coordinate over time we&rsquo;re traversing all the points in a circle and thus the camera rotates around the scene. We enlarge this circle by a pre-defined radius and create a new view matrix each frame using GLFW&rsquo;s glfwGetTime function:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">const</span> <span class="kt">float</span> <span class="n">radius</span> <span class="o">=</span> <span class="mf">10.0f</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="kt">float</span> <span class="n">camX</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">glfwGetTime</span><span class="p">())</span> <span class="o">*</span> <span class="n">radius</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="kt">float</span> <span class="n">camZ</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="n">glfwGetTime</span><span class="p">())</span> <span class="o">*</span> <span class="n">radius</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span> <span class="n">view</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="n">view</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">lookAt</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="n">camX</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">camZ</span><span class="p">),</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">));</span> 
</span></span></code></pre></div><p>If you run this code you should get something like this:</p>
<p><video src="assets/camera_circle.mp4" width="600" height="450" controls="" preload="auto"></video></p>
<p>With this little snippet of code the camera now circles around the scene over time. Feel free to experiment with the radius and position/direction parameters to get the feel of how this <em>LookAt</em> matrix works. Also, check the <a href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/7.1.camera_circle/camera_circle.cpp" target="_blank">source code</a> if you&rsquo;re stuck.</p>
<h4 id="walk-around">Walk around</h4>
<p>Swinging the camera around a scene is fun, but it&rsquo;s more fun to do all the movement ourselves! First we need to set up a camera system, so it is useful to define some camera variables at the top of our program:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">cameraPos</span>   <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span>  <span class="mf">3.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">cameraFront</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">cameraUp</span>    <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span>  <span class="mf">0.0f</span><span class="p">);</span></span></span></code></pre></div><p>The <code>LookAt</code> function now becomes:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">view</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">lookAt</span><span class="p">(</span><span class="n">cameraPos</span><span class="p">,</span> <span class="n">cameraPos</span> <span class="o">+</span> <span class="n">cameraFront</span><span class="p">,</span> <span class="n">cameraUp</span><span class="p">);</span></span></span></code></pre></div><p>First we set the camera position to the previously defined cameraPos. The direction is the current position + the direction vector we just defined. This ensures that however we move, the camera keeps looking at the target direction. Let&rsquo;s play a bit with these variables by updating the cameraPos vector when we press some keys.</p>
<p>We already defined a processInput function to manage GLFW&rsquo;s keyboard input so let&rsquo;s add a few extra key commands:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="nf">processInput</span><span class="p">(</span><span class="n">GLFWwindow</span> <span class="o">*</span><span class="n">window</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="k">const</span> <span class="kt">float</span> <span class="n">cameraSpeed</span> <span class="o">=</span> <span class="mf">0.05f</span><span class="p">;</span> <span class="c1">// adjust accordingly
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">glfwGetKey</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">GLFW_KEY_W</span><span class="p">)</span> <span class="o">==</span> <span class="n">GLFW_PRESS</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">        <span class="n">cameraPos</span> <span class="o">+=</span> <span class="n">cameraSpeed</span> <span class="o">*</span> <span class="n">cameraFront</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">glfwGetKey</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">GLFW_KEY_S</span><span class="p">)</span> <span class="o">==</span> <span class="n">GLFW_PRESS</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        <span class="n">cameraPos</span> <span class="o">-=</span> <span class="n">cameraSpeed</span> <span class="o">*</span> <span class="n">cameraFront</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">glfwGetKey</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">GLFW_KEY_A</span><span class="p">)</span> <span class="o">==</span> <span class="n">GLFW_PRESS</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">        <span class="n">cameraPos</span> <span class="o">-=</span> <span class="n">glm</span><span class="o">::</span><span class="n">normalize</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">cross</span><span class="p">(</span><span class="n">cameraFront</span><span class="p">,</span> <span class="n">cameraUp</span><span class="p">))</span> <span class="o">*</span> <span class="n">cameraSpeed</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">glfwGetKey</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">GLFW_KEY_D</span><span class="p">)</span> <span class="o">==</span> <span class="n">GLFW_PRESS</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">        <span class="n">cameraPos</span> <span class="o">+=</span> <span class="n">glm</span><span class="o">::</span><span class="n">normalize</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">cross</span><span class="p">(</span><span class="n">cameraFront</span><span class="p">,</span> <span class="n">cameraUp</span><span class="p">))</span> <span class="o">*</span> <span class="n">cameraSpeed</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>Whenever we press one of the <code>WASD</code> keys, the camera&rsquo;s position is updated accordingly. If we want to move forward or backwards we add or subtract the direction vector from the position vector scaled by some speed value. If we want to move sideways we do a cross product to create a <em>right</em> vector and we move along the right vector accordingly. This creates the familiar strafe effect when using the camera.</p>
<p><note>Note that we normalize the resulting <em>right</em> vector. If we wouldn&rsquo;t normalize this vector, the resulting cross product may return differently sized vectors based on the cameraFront variable. If we would not normalize the vector we would move slow or fast based on the camera&rsquo;s orientation instead of at a consistent movement speed.</note></p>
<p>By now, you should already be able to move the camera somewhat, albeit at a speed that&rsquo;s system-specific so you may need to adjust cameraSpeed.</p>
<h4 id="movement-speed">Movement speed</h4>
<p>Currently we used a constant value for movement speed when walking around. In theory this seems fine, but in practice people&rsquo;s machines have different processing powers and the result of that is that some people are able to render much more frames than others each second. Whenever a user renders more frames than another user he also calls processInput more often. The result is that some people move really fast and some really slow depending on their setup. When shipping your application you want to make sure it runs the same on all kinds of hardware.</p>
<p>Graphics applications and games usually keep track of a deltatime variable that stores the time it took to render the last frame. We then multiply all velocities with this deltaTime value. The result is that when we have a large deltaTime in a frame, meaning that the last frame took longer than average, the velocity for that frame will also be a bit higher to balance it all out. When using this approach it does not matter if you have a very fast or slow pc, the velocity of the camera will be balanced out accordingly so each user will have the same experience.</p>
<p>To calculate the deltaTime value we keep track of 2 global variables:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">float</span> <span class="n">deltaTime</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>	<span class="c1">// Time between current frame and last frame
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="c1"></span><span class="kt">float</span> <span class="n">lastFrame</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span> <span class="c1">// Time of last frame
</span></span></span></code></pre></div><p>Within each frame we then calculate the new deltaTime value for later use:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">float</span> <span class="n">currentFrame</span> <span class="o">=</span> <span class="n">glfwGetTime</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">deltaTime</span> <span class="o">=</span> <span class="n">currentFrame</span> <span class="o">-</span> <span class="n">lastFrame</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">lastFrame</span> <span class="o">=</span> <span class="n">currentFrame</span><span class="p">;</span>  
</span></span></code></pre></div><p>Now that we have deltaTime we can take it into account when calculating the velocities:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">void</span> <span class="nf">processInput</span><span class="p">(</span><span class="n">GLFWwindow</span> <span class="o">*</span><span class="n">window</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="kt">float</span> <span class="n">cameraSpeed</span> <span class="o">=</span> <span class="mf">2.5f</span> <span class="o">*</span> <span class="n">deltaTime</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="p">[...]</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>Since we&rsquo;re using deltaTime the camera will now move at a constant speed of <code>2.5</code> units per second. Together with the previous section we should now have a much smoother and more consistent camera system for moving around the scene:</p>
<p><video src="assets/camera_smooth.mp4" width="600" height="450" controls="" preload="auto"></video></p>
<p>And now we have a camera that walks and looks equally fast on any system. Again, check the <a href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/7.2.camera_keyboard_dt/camera_keyboard_dt.cpp" target="_blank">source code</a> if you&rsquo;re stuck. We&rsquo;ll see the deltaTime value frequently return with anything movement related.</p>
<h4 id="look-around">Look around</h4>
<p>Only using the keyboard keys to move around isn&rsquo;t that interesting. Especially since we can&rsquo;t turn around making the movement rather restricted. That&rsquo;s where the mouse comes in!</p>
<p>To look around the scene we have to change the cameraFront vector based on the input of the mouse. However, changing the direction vector based on mouse rotations is a little complicated and requires some trigonometry. If you do not understand the trigonometry, don&rsquo;t worry, you can just skip to the code sections and paste them in your code; you can always come back later if you want to know more.</p>
<h5 id="euler-angles">Euler angles</h5>
<p>Euler angles are 3 values that can represent any rotation in 3D, defined by Leonhard Euler somewhere in the 1700s. There are 3 Euler angles: <em>pitch</em>, <em>yaw</em> and <em>roll</em>. The following image gives them a visual meaning:</p>
<p><a href="#R-image-bb010852fb94095766dbd6f4123b0ca0" class="lightbox-link"><img src="./assets/camera_pitch_yaw_roll.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-bb010852fb94095766dbd6f4123b0ca0"><img src="./assets/camera_pitch_yaw_roll.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>The pitch is the angle that depicts how much we&rsquo;re looking up or down as seen in the first image. The second image shows the yaw value which represents the magnitude we&rsquo;re looking to the left or to the right. The roll represents how much we <em>roll</em> as mostly used in space-flight cameras. Each of the Euler angles are represented by a single value and with the combination of all 3 of them we can calculate any rotation vector in 3D.</p>
<p>For our camera system we only care about the yaw and pitch values so we won&rsquo;t discuss the roll value here. Given a pitch and a yaw value we can convert them into a 3D vector that represents a new direction vector. The process of converting yaw and pitch values to a direction vector requires a bit of trigonometry. and we start with a basic case:</p>
<p>Let&rsquo;s start with a bit of a refresher and check the general right triangle case (with one side at a 90 degree angle):</p>
<p><a href="#R-image-160cdd1d01117b59426b2cadf613090c" class="lightbox-link"><img src="./assets/camera_triangle.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-160cdd1d01117b59426b2cadf613090c"><img src="./assets/camera_triangle.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>If we define the hypotenuse to be of length <code>1</code> we know from trigonometry (soh cah toa) that the adjacant side&rsquo;s length is 
<span class="math align-center">$\cos \ {\color{red}x}/{\color{purple}h} = \cos \ {\color{red}x}/{\color{purple}1} = \cos\ \color{red}x$</span> and that the opposing side&rsquo;s length is 
<span class="math align-center">$\sin \ {\color{green}y}/{\color{purple}h} = \sin \ {\color{green}y}/{\color{purple}1} = \sin\ \color{green}y$</span>. This gives us some general formulas for retrieving the length in both the <code>x</code> and <code>y</code> sides on right triangles, depending on the given angle. Let&rsquo;s use this to calculate the components of the direction vector.</p>
<p>Let&rsquo;s imagine this same triangle, but now looking at it from a top perspective with the adjacent and opposite sides being parallel to the scene&rsquo;s x and z axis (as if looking down the y-axis).</p>
<p><a href="#R-image-618990f5e2528723e0cc62deace5409e" class="lightbox-link"><img src="./assets/camera_yaw.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-618990f5e2528723e0cc62deace5409e"><img src="./assets/camera_yaw.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>If we visualize the yaw angle to be the counter-clockwise angle starting from the <code>x</code> side we can see that the length of the <code>x</code> side relates to <code>cos(yaw)</code>. And similarly how the length of the <code>z</code> side relates to <code>sin(yaw)</code>.</p>
<p>If we take this knowledge and a given <code>yaw</code> value we can use it to create a camera direction vector:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">direction</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">direction</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">radians</span><span class="p">(</span><span class="n">yaw</span><span class="p">));</span> <span class="c1">// Note that we convert the angle to radians first
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="c1"></span><span class="n">direction</span><span class="p">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">radians</span><span class="p">(</span><span class="n">yaw</span><span class="p">));</span></span></span></code></pre></div><p>This solves how we can get a 3D direction vector from a yaw value, but pitch needs to be included as well. Let&rsquo;s now look at the <code>y</code> axis side as if we&rsquo;re sitting on the <code>xz</code> plane:</p>
<p><a href="#R-image-fb0e4bac09e8b58ca3c3406d26262ebd" class="lightbox-link"><img src="./assets/camera_pitch.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-fb0e4bac09e8b58ca3c3406d26262ebd"><img src="./assets/camera_pitch.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Similarly, from this triangle we can see that the direction&rsquo;s y component equals <code>sin(pitch)</code> so let&rsquo;s fill that in:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">direction</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">radians</span><span class="p">(</span><span class="n">pitch</span><span class="p">));</span> 
</span></span></code></pre></div><p>However, from the pitch triangle we can also see the <code>xz</code> sides are influenced by <code>cos(pitch)</code> so we need to make sure this is also part of the direction vector. With this included we get the final direction vector as translated from yaw and pitch Euler angles:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">direction</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">radians</span><span class="p">(</span><span class="n">yaw</span><span class="p">))</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">radians</span><span class="p">(</span><span class="n">pitch</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">direction</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">radians</span><span class="p">(</span><span class="n">pitch</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">direction</span><span class="p">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">radians</span><span class="p">(</span><span class="n">yaw</span><span class="p">))</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">radians</span><span class="p">(</span><span class="n">pitch</span><span class="p">));</span></span></span></code></pre></div><p>This gives us a formula to convert yaw and pitch values to a 3-dimensional direction vector that we can use for looking around.</p>
<p>We&rsquo;ve set up the scene world so everything&rsquo;s positioned in the direction of the negative z-axis. However, if we look at the <code>x</code> and <code>z</code> yaw triangle we see that a θ� of <code>0</code> results in the camera&rsquo;s <code>direction</code> vector to point towards the positive x-axis. To make sure the camera points towards the negative z-axis by default we can give the <code>yaw</code> a default value of a 90 degree clockwise rotation. Positive degrees rotate counter-clockwise so we set the default <code>yaw</code> value to:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">yaw</span> <span class="o">=</span> <span class="o">-</span><span class="mf">90.0f</span><span class="p">;</span></span></span></code></pre></div><p>You&rsquo;ve probably wondered by now: how do we set and modify these yaw and pitch values?</p>
<h4 id="mouse-input">Mouse input</h4>
<p>The yaw and pitch values are obtained from mouse (or controller/joystick) movement where horizontal mouse-movement affects the yaw and vertical mouse-movement affects the pitch. The idea is to store the last frame&rsquo;s mouse positions and calculate in the current frame how much the mouse values changed. The higher the horizontal or vertical difference, the more we update the pitch or yaw value and thus the more the camera should move.</p>
<p>First we will tell GLFW that it should hide the cursor and capture it. Capturing a cursor means that, once the application has focus, the mouse cursor stays within the center of the window (unless the application loses focus or quits). We can do this with one simple configuration call:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glfwSetInputMode</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">GLFW_CURSOR</span><span class="p">,</span> <span class="n">GLFW_CURSOR_DISABLED</span><span class="p">);</span> 
</span></span></code></pre></div><p>After this call, wherever we move the mouse it won&rsquo;t be visible and it should not leave the window. This is perfect for an FPS camera system.</p>
<p>To calculate the pitch and yaw values we need to tell GLFW to listen to mouse-movement events. We do this by creating a callback function with the following prototype:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">void</span> <span class="nf">mouse_callback</span><span class="p">(</span><span class="n">GLFWwindow</span><span class="o">*</span> <span class="n">window</span><span class="p">,</span> <span class="kt">double</span> <span class="n">xpos</span><span class="p">,</span> <span class="kt">double</span> <span class="n">ypos</span><span class="p">);</span></span></span></code></pre></div><p>Here xpos and ypos represent the current mouse positions. As soon as we register the callback function with GLFW each time the mouse moves, the mouse_callback function is called:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glfwSetCursorPosCallback</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">mouse_callback</span><span class="p">);</span>  
</span></span></code></pre></div><p>When handling mouse input for a fly style camera there are several steps we have to take before we&rsquo;re able to fully calculate the camera&rsquo;s direction vector:</p>
<ol>
<li>Calculate the mouse&rsquo;s offset since the last frame.</li>
<li>Add the offset values to the camera&rsquo;s yaw and pitch values.</li>
<li>Add some constraints to the minimum/maximum pitch values.</li>
<li>Calculate the direction vector.</li>
</ol>
<p>The first step is to calculate the offset of the mouse since last frame. We first have to store the last mouse positions in the application, which we initialize to be in the center of the screen (screen size is <code>800</code> by <code>600</code>) initially:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">float</span> <span class="n">lastX</span> <span class="o">=</span> <span class="mi">400</span><span class="p">,</span> <span class="n">lastY</span> <span class="o">=</span> <span class="mi">300</span><span class="p">;</span></span></span></code></pre></div><p>Then in the mouse&rsquo;s callback function we calculate the offset movement between the last and current frame:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">float</span> <span class="n">xoffset</span> <span class="o">=</span> <span class="n">xpos</span> <span class="o">-</span> <span class="n">lastX</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="kt">float</span> <span class="n">yoffset</span> <span class="o">=</span> <span class="n">lastY</span> <span class="o">-</span> <span class="n">ypos</span><span class="p">;</span> <span class="c1">// reversed since y-coordinates range from bottom to top
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="c1"></span><span class="n">lastX</span> <span class="o">=</span> <span class="n">xpos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="n">lastY</span> <span class="o">=</span> <span class="n">ypos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="k">const</span> <span class="kt">float</span> <span class="n">sensitivity</span> <span class="o">=</span> <span class="mf">0.1f</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="n">xoffset</span> <span class="o">*=</span> <span class="n">sensitivity</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">8</span><span class="cl"><span class="n">yoffset</span> <span class="o">*=</span> <span class="n">sensitivity</span><span class="p">;</span></span></span></code></pre></div><p>Note that we multiply the offset values by a sensitivity value. If we omit this multiplication the mouse movement would be way too strong; fiddle around with the sensitivity value to your liking.</p>
<p>Next we add the offset values to the globally declared pitch and yaw values:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">yaw</span>   <span class="o">+=</span> <span class="n">xoffset</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">pitch</span> <span class="o">+=</span> <span class="n">yoffset</span><span class="p">;</span> 
</span></span></code></pre></div><p>In the third step we&rsquo;d like to add some constraints to the camera so users won&rsquo;t be able to make weird camera movements (also causes a LookAt flip once direction vector is parallel to the world up direction). The pitch needs to be constrained in such a way that users won&rsquo;t be able to look higher than <code>89</code> degrees (at <code>90</code> degrees we get the LookAt flip) and also not below <code>-89</code> degrees. This ensures the user will be able to look up to the sky or below to his feet but not further. The constraints work by replacing the Euler value with its constraint value whenever it breaches the constraint:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">if</span><span class="p">(</span><span class="n">pitch</span> <span class="o">&gt;</span> <span class="mf">89.0f</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">  <span class="n">pitch</span> <span class="o">=</span>  <span class="mf">89.0f</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="k">if</span><span class="p">(</span><span class="n">pitch</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">89.0f</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">  <span class="n">pitch</span> <span class="o">=</span> <span class="o">-</span><span class="mf">89.0f</span><span class="p">;</span></span></span></code></pre></div><p>Note that we set no constraint on the yaw value since we don&rsquo;t want to constrain the user in horizontal rotation. However, it&rsquo;s just as easy to add a constraint to the yaw as well if you feel like it.</p>
<p>The fourth and last step is to calculate the actual direction vector using the formula from the previous section:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">direction</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">direction</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">radians</span><span class="p">(</span><span class="n">yaw</span><span class="p">))</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">radians</span><span class="p">(</span><span class="n">pitch</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">direction</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">radians</span><span class="p">(</span><span class="n">pitch</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="n">direction</span><span class="p">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">radians</span><span class="p">(</span><span class="n">yaw</span><span class="p">))</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">radians</span><span class="p">(</span><span class="n">pitch</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="n">cameraFront</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">normalize</span><span class="p">(</span><span class="n">direction</span><span class="p">);</span></span></span></code></pre></div><p>This computed direction vector then contains all the rotations calculated from the mouse&rsquo;s movement. Since the cameraFront vector is already included in glm&rsquo;s lookAt function we&rsquo;re set to go.</p>
<p>If you&rsquo;d now run the code you&rsquo;ll notice the camera makes a large sudden jump whenever the window first receives focus of your mouse cursor. The cause for this sudden jump is that as soon as your cursor enters the window the mouse callback function is called with an xpos and ypos position equal to the location your mouse entered the screen from. This is often a position that is significantly far away from the center of the screen, resulting in large offsets and thus a large movement jump. We can circumvent this issue by defining a global <code>bool</code> variable to check if this is the first time we receive mouse input. If it is the first time, we update the initial mouse positions to the new xpos and <code>ypos</code> values. The resulting mouse movements will then use the newly entered mouse&rsquo;s position coordinates to calculate the offsets:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">firstMouse</span><span class="p">)</span> <span class="c1">// initially set to true
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="n">lastX</span> <span class="o">=</span> <span class="n">xpos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="n">lastY</span> <span class="o">=</span> <span class="n">ypos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">    <span class="n">firstMouse</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>The final code then becomes:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="nf">mouse_callback</span><span class="p">(</span><span class="n">GLFWwindow</span><span class="o">*</span> <span class="n">window</span><span class="p">,</span> <span class="kt">double</span> <span class="n">xpos</span><span class="p">,</span> <span class="kt">double</span> <span class="n">ypos</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">firstMouse</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">        <span class="n">lastX</span> <span class="o">=</span> <span class="n">xpos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">        <span class="n">lastY</span> <span class="o">=</span> <span class="n">ypos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">        <span class="n">firstMouse</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="kt">float</span> <span class="n">xoffset</span> <span class="o">=</span> <span class="n">xpos</span> <span class="o">-</span> <span class="n">lastX</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="kt">float</span> <span class="n">yoffset</span> <span class="o">=</span> <span class="n">lastY</span> <span class="o">-</span> <span class="n">ypos</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="n">lastX</span> <span class="o">=</span> <span class="n">xpos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="n">lastY</span> <span class="o">=</span> <span class="n">ypos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="kt">float</span> <span class="n">sensitivity</span> <span class="o">=</span> <span class="mf">0.1f</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="n">xoffset</span> <span class="o">*=</span> <span class="n">sensitivity</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">    <span class="n">yoffset</span> <span class="o">*=</span> <span class="n">sensitivity</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">
</span></span><span class="line"><span class="ln">19</span><span class="cl">    <span class="n">yaw</span>   <span class="o">+=</span> <span class="n">xoffset</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">    <span class="n">pitch</span> <span class="o">+=</span> <span class="n">yoffset</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">
</span></span><span class="line"><span class="ln">22</span><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">pitch</span> <span class="o">&gt;</span> <span class="mf">89.0f</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">        <span class="n">pitch</span> <span class="o">=</span> <span class="mf">89.0f</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">pitch</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">89.0f</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl">        <span class="n">pitch</span> <span class="o">=</span> <span class="o">-</span><span class="mf">89.0f</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl">
</span></span><span class="line"><span class="ln">27</span><span class="cl">    <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">direction</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">28</span><span class="cl">    <span class="n">direction</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">radians</span><span class="p">(</span><span class="n">yaw</span><span class="p">))</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">radians</span><span class="p">(</span><span class="n">pitch</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">29</span><span class="cl">    <span class="n">direction</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">radians</span><span class="p">(</span><span class="n">pitch</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">30</span><span class="cl">    <span class="n">direction</span><span class="p">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">radians</span><span class="p">(</span><span class="n">yaw</span><span class="p">))</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">radians</span><span class="p">(</span><span class="n">pitch</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">31</span><span class="cl">    <span class="n">cameraFront</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">normalize</span><span class="p">(</span><span class="n">direction</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">32</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>There we go! Give it a spin and you&rsquo;ll see that we can now freely move through our 3D scene!</p>
<h4 id="zoom">Zoom</h4>
<p>As a little extra to the camera system we&rsquo;ll also implement a zooming interface. In the previous chapter we said the <em>Field of view</em> or <em>fov</em> largely defines how much we can see of the scene. When the field of view becomes smaller, the scene&rsquo;s projected space gets smaller. This smaller space is projected over the same NDC, giving the illusion of zooming in. To zoom in, we&rsquo;re going to use the mouse&rsquo;s scroll wheel. Similar to mouse movement and keyboard input we have a callback function for mouse scrolling:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">void</span> <span class="nf">scroll_callback</span><span class="p">(</span><span class="n">GLFWwindow</span><span class="o">*</span> <span class="n">window</span><span class="p">,</span> <span class="kt">double</span> <span class="n">xoffset</span><span class="p">,</span> <span class="kt">double</span> <span class="n">yoffset</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="n">fov</span> <span class="o">-=</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">yoffset</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">fov</span> <span class="o">&lt;</span> <span class="mf">1.0f</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">        <span class="n">fov</span> <span class="o">=</span> <span class="mf">1.0f</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">fov</span> <span class="o">&gt;</span> <span class="mf">45.0f</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl">        <span class="n">fov</span> <span class="o">=</span> <span class="mf">45.0f</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">8</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>When scrolling, the yoffset value tells us the amount we scrolled vertically. When the scroll_callback function is called we change the content of the globally declared fov variable. Since <code>45.0</code> is the default fov value we want to constrain the zoom level between <code>1.0</code> and <code>45.0</code>.</p>
<p>We now have to upload the perspective projection matrix to the GPU each frame, but this time with the fov variable as its field of view:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">projection</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">perspective</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">radians</span><span class="p">(</span><span class="n">fov</span><span class="p">),</span> <span class="mf">800.0f</span> <span class="o">/</span> <span class="mf">600.0f</span><span class="p">,</span> <span class="mf">0.1f</span><span class="p">,</span> <span class="mf">100.0f</span><span class="p">);</span>  
</span></span></code></pre></div><p>And lastly don&rsquo;t forget to register the scroll callback function:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glfwSetScrollCallback</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">scroll_callback</span><span class="p">);</span> 
</span></span></code></pre></div><p>And there you have it. We implemented a simple camera system that allows for free movement in a 3D environment.</p>
<p><video src="assets/camera_mouse.mp4" width="600" height="450" controls="" preload="auto"></video></p>
<p>Feel free to experiment a little and if you&rsquo;re stuck compare your code with the <a href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/7.3.camera_mouse_zoom/camera_mouse_zoom.cpp" target="_blank">source code</a>.</p>
<h4 id="camera-class">Camera class</h4>
<p>In the upcoming chapters we&rsquo;ll always use a camera to easily look around the scenes and see the results from all angles. However, since the camera code can take up a significant amount of space on each chapter we&rsquo;ll abstract its details a little and create our own camera object that does most of the work for us with some neat little extras. Unlike the Shader chapter we won&rsquo;t walk you through creating the camera class, but provide you with the (fully commented) source code if you want to know the inner workings.</p>
<p>Like the <code>Shader</code> object, we define the camera class entirely in a single header file. You can find the camera class <a href="https://learnopengl.com/code_viewer_gh.php?code=includes/learnopengl/camera.h" target="_blank">here</a>; you should be able to understand the code after this chapter. It is advised to at least check the class out once as an example on how you could create your own camera system.</p>
<p><warning>The camera system we introduced is a fly like camera that suits most purposes and works well with Euler angles, but be careful when creating different camera systems like an FPS camera, or a flight simulation camera. Each camera system has its own tricks and quirks so be sure to read up on them. For example, this fly camera doesn&rsquo;t allow for pitch values higher than or equal to <code>90</code> degrees and a static up vector of <code>(0,1,0)</code> doesn&rsquo;t work when we take roll values into account.</warning></p>
<p>The updated version of the source code using the new camera object can be found <a href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/7.4.camera_class/camera_class.cpp" target="_blank">here</a>.</p>
<h4 id="exercises-5">Exercises</h4>
<ul>
<li>See if you can transform the camera class in such a way that it becomes a <strong>true</strong> fps camera where you cannot fly; you can only look around while staying on the <code>xz</code> plane: <a href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/7.5.camera_exercise1/camera_exercise1.cpp" target="_blank">solution</a>.</li>
<li>Try to create your own LookAt function where you manually create a view matrix as discussed at the start of this chapter. Replace glm&rsquo;s LookAt function with your own implementation and see if it still acts the same: <a href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/7.6.camera_exercise2/camera_exercise2.cpp" target="_blank">solution</a>.</li>
</ul>
<h3 id="review">Review</h3>
<p>Congratulations on reaching the end of the <em>Getting started</em> chapters. By now you should be able to create a window, create and compile shaders, send vertex data to your shaders via buffer objects or uniforms, draw objects, use textures, understand vectors and matrices and combine all that knowledge to create a full 3D scene with a camera to play around with.</p>
<p>Phew, there is a lot that we learned these last few chapters. Try to play around with what you learned, experiment a bit or come up with your own ideas and solutions to some of the problems. As soon as you feel you got the hang of all the materials we&rsquo;ve discussed it&rsquo;s time to move on to the <a href="https://learnopengl.com/Lighting/Colors" target="_blank">next</a> Lighting chapters.</p>
<h4 id="glossary">Glossary</h4>
<ul>
<li><code>OpenGL</code>: a formal specification of a graphics API that defines the layout and output of each function.</li>
<li><code>GLAD</code>: an extension loading library that loads and sets all OpenGL&rsquo;s function pointers for us so we can use all (modern) OpenGL&rsquo;s functions.</li>
<li><code>Viewport</code>: the 2D window region where we render to.</li>
<li><code>Graphics Pipeline</code>: the entire process vertices have to walk through before ending up as one or more pixels on the screen.</li>
<li><code>Shader</code>: a small program that runs on the graphics card. Several stages of the graphics pipeline can use user-made shaders to replace existing functionality.</li>
<li><code>Vertex</code>: a collection of data that represent a single point.</li>
<li><code>Normalized Device Coordinates</code>: the coordinate system your vertices end up in after perspective division is performed on clip coordinates. All vertex positions in NDC between <code>-1.0</code> and <code>1.0</code> will not be discarded or clipped and end up visible.</li>
<li><code>Vertex Buffer Object</code>: a buffer object that allocates memory on the GPU and stores all the vertex data there for the graphics card to use.</li>
<li><code>Vertex Array Object</code>: stores buffer and vertex attribute state information.</li>
<li><code>Element Buffer Object</code>: a buffer object that stores indices on the GPU for indexed drawing.</li>
<li><code>Uniform</code>: a special type of GLSL variable that is global (each shader in a shader program can access this uniform variable) and only has to be set once.</li>
<li><code>Texture</code>: a special type of image used in shaders and usually wrapped around objects, giving the illusion an object is extremely detailed.</li>
<li><code>Texture Wrapping</code>: defines the mode that specifies how OpenGL should sample textures when texture coordinates are outside the range: (<code>0</code>, <code>1</code>).</li>
<li><code>Texture Filtering</code>: defines the mode that specifies how OpenGL should sample the texture when there are several texels (texture pixels) to choose from. This usually occurs when a texture is magnified.</li>
<li><code>Mipmaps</code>: stored smaller versions of a texture where the appropriate sized version is chosen based on the distance to the viewer.</li>
<li><code>stb_image</code>: image loading library.</li>
<li><code>Texture Units</code>: allows for multiple textures on a single shader program by binding multiple textures, each to a different texture unit.</li>
<li><code>Vector</code>: a mathematical entity that defines directions and/or positions in any dimension.</li>
<li><code>Matrix</code>: a rectangular array of mathematical expressions with useful transformation properties.</li>
<li><code>GLM</code>: a mathematics library tailored for OpenGL.</li>
<li><code>Local Space</code>: the space an object begins in. All coordinates relative to an object&rsquo;s origin.</li>
<li><code>World Space</code>: all coordinates relative to a global origin.</li>
<li><code>View Space</code>: all coordinates as viewed from a camera&rsquo;s perspective.</li>
<li><code>Clip Space</code>: all coordinates as viewed from the camera&rsquo;s perspective but with projection applied. This is the space the vertex coordinates should end up in, as output of the vertex shader. OpenGL does the rest (clipping/perspective division).</li>
<li><code>Screen Space</code>: all coordinates as viewed from the screen. Coordinates range from <code>0</code> to screen width/height.</li>
<li><code>LookAt</code>: a special type of view matrix that creates a coordinate system where all coordinates are rotated and translated in such a way that the user is looking at a given target from a given position.</li>
<li><code>Euler Angles</code>: defined as <code>yaw</code>, <code>pitch</code> and <code>roll</code> that allow us to form any 3D direction vector from these 3 values.</li>
</ul>
<h2 id="lighting">Lighting</h2>
<h3 id="colors">Colors</h3>
<p>We briefly used and manipulated colors in the previous chapters, but never defined them properly. Here we&rsquo;ll discuss what colors are and start building the scene for the upcoming Lighting chapters.</p>
<p>In the real world, colors can take any known color value with each object having its own color(s). In the digital world we need to map the (infinite) real colors to (limited) digital values and therefore not all real-world colors can be represented digitally. Colors are digitally represented using a <code>red</code>, <code>green</code> and <code>blue</code> component commonly abbreviated as <code>RGB</code>. Using different combinations of just those 3 values, within a range of <code>[0,1]</code>, we can represent almost any color there is. For example, to get a <em>coral</em> color, we define a color vector as:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">coral</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.31f</span><span class="p">);</span>  
</span></span></code></pre></div><p>The color of an object we see in real life is not the color it actually has, but is the color reflected from the object. The colors that aren&rsquo;t absorbed (rejected) by the object is the color we perceive of it. As an example, the light of the sun is perceived as a white light that is the combined sum of many different colors (as you can see in the image). If we would shine this white light on a blue toy, it would absorb all the white color&rsquo;s sub-colors except the blue color. Since the toy does not absorb the blue color part, it is reflected. This reflected light enters our eye, making it look like the toy has a blue color. The following image shows this for a coral colored toy where it reflects several colors with varying intensity:</p>
<p><a href="#R-image-22e901a07ae43fd32f40123f281c451b" class="lightbox-link"><img src="./assets/light_reflection.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-22e901a07ae43fd32f40123f281c451b"><img src="./assets/light_reflection.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>You can see that the white sunlight is a collection of all the visible colors and the object absorbs a large portion of those colors. It only reflects those colors that represent the object&rsquo;s color and the combination of those is what we perceive (in this case a coral color).</p>
<p><note>Technically it&rsquo;s a bit more complicated, but we&rsquo;ll get to that in the PBR chapters.</note></p>
<p>These rules of color reflection apply directly in graphics-land. When we define a light source in OpenGL we want to give this light source a color. In the previous paragraph we had a white color so we&rsquo;ll give the light source a white color as well. If we would then multiply the light source&rsquo;s color with an object&rsquo;s color value, the resulting color would be the reflected color of the object (and thus its perceived color). Let&rsquo;s revisit our toy (this time with a coral value) and see how we would calculate its perceived color in graphics-land. We get the resulting color vector by doing a component-wise multiplication between the light and object color vectors:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">lightColor</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">toyColor</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.31f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">result</span> <span class="o">=</span> <span class="n">lightColor</span> <span class="o">*</span> <span class="n">toyColor</span><span class="p">;</span> <span class="c1">// = (1.0f, 0.5f, 0.31f);
</span></span></span></code></pre></div><p>We can see that the toy&rsquo;s color <em>absorbs</em> a large portion of the white light, but reflects several red, green and blue values based on its own color value. This is a representation of how colors would work in real life. We can thus define an object&rsquo;s color as <em>the amount of each color component it reflects from a light source</em>. Now what would happen if we used a green light?</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">lightColor</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">toyColor</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.31f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">result</span> <span class="o">=</span> <span class="n">lightColor</span> <span class="o">*</span> <span class="n">toyColor</span><span class="p">;</span> <span class="c1">// = (0.0f, 0.5f, 0.0f);
</span></span></span></code></pre></div><p>As we can see, the toy has no red and blue light to absorb and/or reflect. The toy also absorbs half of the light&rsquo;s green value, but also reflects half of the light&rsquo;s green value. The toy&rsquo;s color we perceive would then be a dark-greenish color. We can see that if we use a green light, only the green color components can be reflected and thus perceived; no red and blue colors are perceived. As a result the coral object suddenly becomes a dark-greenish object. Let&rsquo;s try one more example with a dark olive-green light:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">lightColor</span><span class="p">(</span><span class="mf">0.33f</span><span class="p">,</span> <span class="mf">0.42f</span><span class="p">,</span> <span class="mf">0.18f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">toyColor</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.31f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">result</span> <span class="o">=</span> <span class="n">lightColor</span> <span class="o">*</span> <span class="n">toyColor</span><span class="p">;</span> <span class="c1">// = (0.33f, 0.21f, 0.06f);
</span></span></span></code></pre></div><p>As you can see, we can get interesting colors from objects using different light colors. It&rsquo;s not hard to get creative with colors.</p>
<p>But enough about colors, let&rsquo;s start building a scene where we can experiment in.</p>
<h4 id="a-lighting-scene">A lighting scene</h4>
<p>In the upcoming chapters we&rsquo;ll be creating interesting visuals by simulating real-world lighting making extensive use of colors. Since now we&rsquo;ll be using light sources we want to display them as visual objects in the scene and add at least one object to simulate the lighting from.</p>
<p>The first thing we need is an object to cast the light on and we&rsquo;ll use the infamous container cube from the previous chapters. We&rsquo;ll also be needing a light object to show where the light source is located in the 3D scene. For simplicity&rsquo;s sake we&rsquo;ll represent the light source with a cube as well (we already have the <a href="https://learnopengl.com/code_viewer.php?code=getting-started/cube_vertices_pos" target="_blank">vertex data</a> right?).</p>
<p>So, filling a vertex buffer object, setting vertex attribute pointers and all that jazz should be familiar for you by now so we won&rsquo;t walk you through those steps. If you still have no idea what&rsquo;s going on with those I suggest you review the <a href="https://learnopengl.com/Getting-started/Hello-Triangle" target="_blank">previous chapters</a>, and work through the exercises if possible, before continuing.</p>
<p>So, the first thing we&rsquo;ll need is a vertex shader to draw the container. The vertex positions of the container remain the same (although we won&rsquo;t be needing texture coordinates this time) so the code should be nothing new. We&rsquo;ll be using a stripped down version of the vertex shader from the last chapters:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">aPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">uniform</span> <span class="n">mat4</span> <span class="n">model</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">uniform</span> <span class="n">mat4</span> <span class="n">view</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">uniform</span> <span class="n">mat4</span> <span class="n">projection</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">projection</span> <span class="o">*</span> <span class="n">view</span> <span class="o">*</span> <span class="n">model</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">aPos</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="p">}</span> 
</span></span></code></pre></div><p>Make sure to update the vertex data and attribute pointers to match the new vertex shader (if you want, you can actually keep the texture data and attribute pointers active; we&rsquo;re just not using them right now).</p>
<p>Because we&rsquo;re also going to render a light source cube, we want to generate a new VAO specifically for the light source. We could render the light source with the same VAO and then do a few light position transformations on the model matrix, but in the upcoming chapters we&rsquo;ll be changing the vertex data and attribute pointers of the container object quite often and we don&rsquo;t want these changes to propagate to the light source object (we only care about the light cube&rsquo;s vertex positions), so we&rsquo;ll create a new VAO:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lightVAO</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glGenVertexArrays</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lightVAO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">lightVAO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="c1">// we only need to bind to the VBO, the container&#39;s VBO&#39;s data already contains the data.
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="c1"></span><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">VBO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="c1">// set the vertex attribute 
</span></span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="c1"></span><span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">8</span><span class="cl"><span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span></span></span></code></pre></div><p>The code should be relatively straightforward. Now that we created both the container and the light source cube there is one thing left to define and that is the fragment shader for both the container and the light source:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">out</span> <span class="n">vec4</span> <span class="n">FragColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">uniform</span> <span class="n">vec3</span> <span class="n">objectColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">uniform</span> <span class="n">vec3</span> <span class="n">lightColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="n">FragColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">lightColor</span> <span class="o">*</span> <span class="n">objectColor</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>The fragment shader accepts both an object color and a light color from a uniform variable. Here we multiply the light&rsquo;s color with the object&rsquo;s (reflected) color like we discussed at the beginning of this chapter. Again, this shader should be easy to understand. Let&rsquo;s set the object&rsquo;s color to the last section&rsquo;s coral color with a white light:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="c1">// don&#39;t forget to use the corresponding shader program first (to set the uniform)
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="c1"></span><span class="n">lightingShader</span><span class="p">.</span><span class="n">use</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">lightingShader</span><span class="p">.</span><span class="n">setVec3</span><span class="p">(</span><span class="s">&#34;objectColor&#34;</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.31f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="n">lightingShader</span><span class="p">.</span><span class="n">setVec3</span><span class="p">(</span><span class="s">&#34;lightColor&#34;</span><span class="p">,</span>  <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">);</span></span></span></code></pre></div><p>One thing left to note is that when we start to update these <em>lighting shaders</em> in the next chapters, the light source cube would also be affected and this is not what we want. We don&rsquo;t want the light source object&rsquo;s color to be affected the lighting calculations, but rather keep the light source isolated from the rest. We want the light source to have a constant bright color, unaffected by other color changes (this makes it look like the light source cube really is the source of the light).</p>
<p>To accomplish this we need to create a second set of shaders that we&rsquo;ll use to draw the light source cube, thus being safe from any changes to the lighting shaders. The vertex shader is the same as the lighting vertex shader so you can simply copy the source code over. The fragment shader of the light source cube ensures the cube&rsquo;s color remains bright by defining a constant white color on the lamp:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="cp"></span><span class="n">out</span> <span class="n">vec4</span> <span class="n">FragColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">    <span class="n">FragColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span> <span class="c1">// set all 4 vector values to 1.0
</span></span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></div><p>When we want to render, we want to render the container object (or possibly many other objects) using the lighting shader we just defined, and when we want to draw the light source we use the light source&rsquo;s shaders. During the Lighting chapters we&rsquo;ll gradually be updating the lighting shaders to slowly achieve more realistic results.</p>
<p>The main purpose of the light source cube is to show where the light comes from. We usually define a light source&rsquo;s position somewhere in the scene, but this is simply a position that has no visual meaning. To show where the light source actually is we render a cube at the same location of the light source. We render this cube with the light source cube shader to make sure the cube always stays white, regardless of the light conditions of the scene.</p>
<p>So let&rsquo;s declare a global <code>vec3</code> variable that represents the light source&rsquo;s location in world-space coordinates:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">lightPos</span><span class="p">(</span><span class="mf">1.2f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">2.0f</span><span class="p">);</span></span></span></code></pre></div><p>We then translate the light source cube to the light source&rsquo;s position and scale it down before rendering it:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">model</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">model</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">translate</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">lightPos</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">model</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">scale</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.2f</span><span class="p">));</span> 
</span></span></code></pre></div><p>The resulting render code for the light source cube should then look something like this:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">lightCubeShader</span><span class="p">.</span><span class="n">use</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="c1">// set the model, view and projection matrix uniforms
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="c1"></span><span class="p">[...]</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="c1">// draw the light cube object
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="c1"></span><span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">lightCubeVAO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="n">glDrawArrays</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">36</span><span class="p">);</span>			
</span></span></code></pre></div><p>Injecting all the code fragments at their appropriate locations would then result in a clean OpenGL application properly configured for experimenting with lighting. If everything compiles it should look like this:</p>
<p><a href="#R-image-e99638f22cc7eb9957f9b0b4124f06be" class="lightbox-link"><img src="./assets/colors_scene.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-e99638f22cc7eb9957f9b0b4124f06be"><img src="./assets/colors_scene.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Not really much to look at right now, but I&rsquo;ll promise it&rsquo;ll get more interesting in the upcoming chapters.</p>
<p>If you have difficulties finding out where all the code snippets fit together in the application as a whole, check the source code <a href="https://learnopengl.com/code_viewer_gh.php?code=src/2.lighting/1.colors/colors.cpp" target="_blank">here</a> and carefully work your way through the code/comments.</p>
<p>Now that we have a fair bit of knowledge about colors and created a basic scene for experimenting with lighting we can jump to the <a href="https://learnopengl.com/Lighting/Basic-Lighting" target="_blank">next</a> chapter where the real magic begins.</p>
<h3 id="basic-lighting">Basic Lighting</h3>
<p>Lighting in the real world is extremely complicated and depends on way too many factors, something we can&rsquo;t afford to calculate on the limited processing power we have. Lighting in OpenGL is therefore based on approximations of reality using simplified models that are much easier to process and look relatively similar. These lighting models are based on the physics of light as we understand it. One of those models is called the Phong lighting model. The major building blocks of the Phong lighting model consist of 3 components: ambient, diffuse and specular lighting. Below you can see what these lighting components look like on their own and combined:</p>
<p><a href="#R-image-b2a874574c567c2939bf1121944bb789" class="lightbox-link"><img src="./assets/basic_lighting_phong.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b2a874574c567c2939bf1121944bb789"><img src="./assets/basic_lighting_phong.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<ul>
<li>Ambient lighting: even when it is dark there is usually still some light somewhere in the world (the moon, a distant light) so objects are almost never completely dark. To simulate this we use an ambient lighting constant that always gives the object some color.</li>
<li>Diffuse lighting: simulates the directional impact a light object has on an object. This is the most visually significant component of the lighting model. The more a part of an object faces the light source, the brighter it becomes.</li>
<li>Specular lighting: simulates the bright spot of a light that appears on shiny objects. Specular highlights are more inclined to the color of the light than the color of the object.</li>
</ul>
<p>To create visually interesting scenes we want to at least simulate these 3 lighting components. We&rsquo;ll start with the simplest one: <em>ambient lighting</em>.</p>
<h4 id="ambient-lighting">Ambient lighting</h4>
<p>Light usually does not come from a single light source, but from many light sources scattered all around us, even when they&rsquo;re not immediately visible. One of the properties of light is that it can scatter and bounce in many directions, reaching spots that aren&rsquo;t directly visible; light can thus <em>reflect</em> on other surfaces and have an indirect impact on the lighting of an object. Algorithms that take this into consideration are called global illumination algorithms, but these are complicated and expensive to calculate.</p>
<p>Since we&rsquo;re not big fans of complicated and expensive algorithms we&rsquo;ll start by using a very simplistic model of global illumination, namely ambient lighting. As you&rsquo;ve seen in the previous section we use a small constant (light) color that we add to the final resulting color of the object&rsquo;s fragments, thus making it look like there is always some scattered light even when there&rsquo;s not a direct light source.</p>
<p>Adding ambient lighting to the scene is really easy. We take the light&rsquo;s color, multiply it with a small constant ambient factor, multiply this with the object&rsquo;s color, and use that as the fragment&rsquo;s color in the cube object&rsquo;s shader:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="kt">float</span> <span class="n">ambientStrength</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="n">vec3</span> <span class="n">ambient</span> <span class="o">=</span> <span class="n">ambientStrength</span> <span class="o">*</span> <span class="n">lightColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">
</span></span><span class="line"><span class="ln">6</span><span class="cl">    <span class="n">vec3</span> <span class="n">result</span> <span class="o">=</span> <span class="n">ambient</span> <span class="o">*</span> <span class="n">objectColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl">    <span class="n">FragColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">8</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>If you&rsquo;d now run the program, you&rsquo;ll notice that the first stage of lighting is now successfully applied to the object. The object is quite dark, but not completely since ambient lighting is applied (note that the light cube is unaffected because we use a different shader). It should look something like this:</p>
<p><a href="#R-image-3f7ed2b324f36cbf36e731a7a56acddf" class="lightbox-link"><img src="./assets/ambient_lighting.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-3f7ed2b324f36cbf36e731a7a56acddf"><img src="./assets/ambient_lighting.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<h4 id="diffuse-lighting">Diffuse lighting</h4>
<p>Ambient lighting by itself doesn&rsquo;t produce the most interesting results, but diffuse lighting however will start to give a significant visual impact on the object. Diffuse lighting gives the object more brightness the closer its fragments are aligned to the light rays from a light source. To give you a better understanding of diffuse lighting take a look at the following image:</p>
<p><a href="#R-image-d9e6dd2626afb6dbac4898e6e5bd81bd" class="lightbox-link"><img src="./assets/diffuse_light.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d9e6dd2626afb6dbac4898e6e5bd81bd"><img src="./assets/diffuse_light.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>To the left we find a light source with a light ray targeted at a single fragment of our object. We need to measure at what angle the light ray touches the fragment. If the light ray is perpendicular to the object&rsquo;s surface the light has the greatest impact. To measure the angle between the light ray and the fragment we use something called a normal vector, that is a vector perpendicular to the fragment&rsquo;s surface (here depicted as a yellow arrow); we&rsquo;ll get to that later. The angle between the two vectors can then easily be calculated with the dot product.</p>
<p>You may remember from the <a href="https://learnopengl.com/Getting-started/Transformations" target="_blank">transformations</a> chapter that, the lower the angle between two unit vectors, the more the dot product is inclined towards a value of 1. When the angle between both vectors is 90 degrees, the dot product becomes 0. The same applies to 
<span class="math align-center">$\theta$</span>: the larger 
<span class="math align-center">$\theta$</span> becomes, the less of an impact the light should have on the fragment&rsquo;s color.</p>
<p><note>Note that to get (only) the cosine of the angle between both vectors we will work with <em>unit vectors</em> (vectors of length <code>1</code>) so we need to make sure all the vectors are normalized, otherwise the dot product returns more than just the cosine (see <a href="https://learnopengl.com/Getting-started/Transformations" target="_blank">Transformations</a>).</note></p>
<p>The resulting dot product thus returns a scalar that we can use to calculate the light&rsquo;s impact on the fragment&rsquo;s color, resulting in differently lit fragments based on their orientation towards the light.</p>
<p>So, what do we need to calculate diffuse lighting:</p>
<ul>
<li>Normal vector: a vector that is perpendicular to the vertex&rsquo; surface.</li>
<li>The directed light ray: a direction vector that is the difference vector between the light&rsquo;s position and the fragment&rsquo;s position. To calculate this light ray we need the light&rsquo;s position vector and the fragment&rsquo;s position vector.</li>
</ul>
<h5 id="normal-vectors">Normal vectors</h5>
<p>A normal vector is a (unit) vector that is perpendicular to the surface of a vertex. Since a vertex by itself has no surface (it&rsquo;s just a single point in space) we retrieve a normal vector by using its surrounding vertices to figure out the surface of the vertex. We can use a little trick to calculate the normal vectors for all the cube&rsquo;s vertices by using the cross product, but since a 3D cube is not a complicated shape we can simply manually add them to the vertex data. The updated vertex data array can be found <a href="https://learnopengl.com/code_viewer.php?code=lighting/basic_lighting_vertex_data" target="_blank">here</a>. Try to visualize that the normals are indeed vectors perpendicular to each plane&rsquo;s surface (a cube consists of 6 planes).</p>
<p>Since we added extra data to the vertex array we should update the cube&rsquo;s vertex shader:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="cp"></span><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">aPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">aNormal</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="p">...</span></span></span></code></pre></div><p>Now that we added a normal vector to each of the vertices and updated the vertex shader we should update the vertex attribute pointers as well. Note that the light source&rsquo;s cube uses the same vertex array for its vertex data, but the lamp shader has no use of the newly added normal vectors. We don&rsquo;t have to update the lamp&rsquo;s shaders or attribute configurations, but we have to at least modify the vertex attribute pointers to reflect the new vertex array&rsquo;s size:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="mi">6</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span></span></span></code></pre></div><p>We only want to use the first <code>3</code> floats of each vertex and ignore the last <code>3</code> floats so we only need to update the <em>stride</em> parameter to <code>6</code> times the size of a <code>float</code> and we&rsquo;re done.</p>
<p><note>It may look inefficient using vertex data that is not completely used by the lamp shader, but the vertex data is already stored in the GPU&rsquo;s memory from the container object so we don&rsquo;t have to store new data into the GPU&rsquo;s memory. This actually makes it more efficient compared to allocating a new VBO specifically for the lamp.</note></p>
<p>All the lighting calculations are done in the fragment shader so we need to forward the normal vectors from the vertex shader to the fragment shader. Let&rsquo;s do that:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">out</span> <span class="n">vec3</span> <span class="n">Normal</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">projection</span> <span class="o">*</span> <span class="n">view</span> <span class="o">*</span> <span class="n">model</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">aPos</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">    <span class="n">Normal</span> <span class="o">=</span> <span class="n">aNormal</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="p">}</span> 
</span></span></code></pre></div><p>What&rsquo;s left to do is declare the corresponding input variable in the fragment shader:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">in</span> <span class="n">vec3</span> <span class="n">Normal</span><span class="p">;</span>  
</span></span></code></pre></div><h5 id="calculating-the-diffuse-color">Calculating the diffuse color</h5>
<p>We now have the normal vector for each vertex, but we still need the light&rsquo;s position vector and the fragment&rsquo;s position vector. Since the light&rsquo;s position is a single static variable we can declare it as a uniform in the fragment shader:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">uniform</span> <span class="n">vec3</span> <span class="n">lightPos</span><span class="p">;</span>  
</span></span></code></pre></div><p>And then update the uniform in the render loop (or outside since it doesn&rsquo;t change per frame). We use the lightPos vector declared in the previous chapter as the location of the diffuse light source:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">lightingShader</span><span class="p">.</span><span class="n">setVec3</span><span class="p">(</span><span class="s">&#34;lightPos&#34;</span><span class="p">,</span> <span class="n">lightPos</span><span class="p">);</span>  
</span></span></code></pre></div><p>Then the last thing we need is the actual fragment&rsquo;s position. We&rsquo;re going to do all the lighting calculations in world space so we want a vertex position that is in world space first. We can accomplish this by multiplying the vertex position attribute with the model matrix only (not the view and projection matrix) to transform it to world space coordinates. This can easily be accomplished in the vertex shader so let&rsquo;s declare an output variable and calculate its world space coordinates:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">out</span> <span class="n">vec3</span> <span class="n">FragPos</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">out</span> <span class="n">vec3</span> <span class="n">Normal</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">  
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">projection</span> <span class="o">*</span> <span class="n">view</span> <span class="o">*</span> <span class="n">model</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">aPos</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl">    <span class="n">FragPos</span> <span class="o">=</span> <span class="n">vec3</span><span class="p">(</span><span class="n">model</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">aPos</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">8</span><span class="cl">    <span class="n">Normal</span> <span class="o">=</span> <span class="n">aNormal</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">9</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>And lastly add the corresponding input variable to the fragment shader:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">in</span> <span class="n">vec3</span> <span class="n">FragPos</span><span class="p">;</span>  
</span></span></code></pre></div><p>This <code>in</code> variable will be interpolated from the 3 world position vectors of the triangle to form the FragPos vector that is the per-fragment world position. Now that all the required variables are set we can start the lighting calculations.</p>
<p>The first thing we need to calculate is the direction vector between the light source and the fragment&rsquo;s position. From the previous section we know that the light&rsquo;s direction vector is the difference vector between the light&rsquo;s position vector and the fragment&rsquo;s position vector. As you may remember from the <a href="https://learnopengl.com/Getting-started/Transformations" target="_blank">transformations</a> chapter we can easily calculate this difference by subtracting both vectors from each other. We also want to make sure all the relevant vectors end up as unit vectors so we normalize both the normal and the resulting direction vector:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">vec3</span> <span class="n">norm</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">Normal</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">vec3</span> <span class="n">lightDir</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">lightPos</span> <span class="o">-</span> <span class="n">FragPos</span><span class="p">);</span>  
</span></span></code></pre></div><p><note>When calculating lighting we usually do not care about the magnitude of a vector or their position; we only care about their direction. Because we only care about their direction almost all the calculations are done with unit vectors since it simplifies most calculations (like the dot product). So when doing lighting calculations, make sure you always normalize the relevant vectors to ensure they&rsquo;re actual unit vectors. Forgetting to normalize a vector is a popular mistake.</note></p>
<p>Next we need to calculate the diffuse impact of the light on the current fragment by taking the dot product between the norm and lightDir vectors. The resulting value is then multiplied with the light&rsquo;s color to get the diffuse component, resulting in a darker diffuse component the greater the angle between both vectors:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">float</span> <span class="n">diff</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">norm</span><span class="p">,</span> <span class="n">lightDir</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">vec3</span> <span class="n">diffuse</span> <span class="o">=</span> <span class="n">diff</span> <span class="o">*</span> <span class="n">lightColor</span><span class="p">;</span></span></span></code></pre></div><p>If the angle between both vectors is greater than <code>90</code> degrees then the result of the dot product will actually become negative and we end up with a negative diffuse component. For that reason we use the max function that returns the highest of both its parameters to make sure the diffuse component (and thus the colors) never become negative. Lighting for negative colors is not really defined so it&rsquo;s best to stay away from that, unless you&rsquo;re one of those eccentric artists.</p>
<p>Now that we have both an ambient and a diffuse component we add both colors to each other and then multiply the result with the color of the object to get the resulting fragment&rsquo;s output color:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">vec3</span> <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">ambient</span> <span class="o">+</span> <span class="n">diffuse</span><span class="p">)</span> <span class="o">*</span> <span class="n">objectColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">FragColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span></span></span></code></pre></div><p>If your application (and shaders) compiled successfully you should see something like this:</p>
<p><a href="#R-image-5ec8045c240dbe2275365dbb1841a621" class="lightbox-link"><img src="./assets/basic_lighting_diffuse.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-5ec8045c240dbe2275365dbb1841a621"><img src="./assets/basic_lighting_diffuse.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>ou can see that with diffuse lighting the cube starts to look like an actual cube again. Try visualizing the normal vectors in your head and move the camera around the cube to see that the larger the angle between the normal vector and the light&rsquo;s direction vector, the darker the fragment becomes.</p>
<p>Feel free to compare your source code with the complete source code <a href="https://learnopengl.com/code_viewer_gh.php?code=src/2.lighting/2.1.basic_lighting_diffuse/basic_lighting_diffuse.cpp" target="_blank">here</a> if you&rsquo;re stuck.</p>
<h5 id="one-last-thing-1">One last thing</h5>
<p>in the previous section we passed the normal vector directly from the vertex shader to the fragment shader. However, the calculations in the fragment shader are all done in world space, so shouldn&rsquo;t we transform the normal vectors to world space coordinates as well? Basically yes, but it&rsquo;s not as simple as simply multiplying it with a model matrix.</p>
<p>First of all, normal vectors are only direction vectors and do not represent a specific position in space. Second, normal vectors do not have a homogeneous coordinate (the <code>w</code> component of a vertex position). This means that translations should not have any effect on the normal vectors. So if we want to multiply the normal vectors with a model matrix we want to remove the translation part of the matrix by taking the upper-left <code>3x3</code> matrix of the model matrix (note that we could also set the <code>w</code> component of a normal vector to <code>0</code> and multiply with the 4x4 matrix).</p>
<p>Second, if the model matrix would perform a non-uniform scale, the vertices would be changed in such a way that the normal vector is not perpendicular to the surface anymore. The following image shows the effect such a model matrix (with non-uniform scaling) has on a normal vector:</p>
<p><a href="#R-image-bfc3cf51ebb5ef2233e3fdc511a83a24" class="lightbox-link"><img src="./assets/basic_lighting_normal_transformation.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-bfc3cf51ebb5ef2233e3fdc511a83a24"><img src="./assets/basic_lighting_normal_transformation.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Whenever we apply a non-uniform scale (note: a uniform scale only changes the normal&rsquo;s magnitude, not its direction, which is easily fixed by normalizing it) the normal vectors are not perpendicular to the corresponding surface anymore which distorts the lighting.</p>
<p>The trick of fixing this behavior is to use a different model matrix specifically tailored for normal vectors. This matrix is called the normal matrix and uses a few linear algebraic operations to remove the effect of wrongly scaling the normal vectors. If you want to know how this matrix is calculated I suggest the following <a href="http://www.lighthouse3d.com/tutorials/glsl-tutorial/the-normal-matrix/" target="_blank">article</a>.</p>
<p>The normal matrix is defined as &rsquo;the transpose of the inverse of the upper-left 3x3 part of the model matrix&rsquo;. Phew, that&rsquo;s a mouthful and if you don&rsquo;t really understand what that means, don&rsquo;t worry; we haven&rsquo;t discussed inverse and transpose matrices yet. Note that most resources define the normal matrix as derived from the model-view matrix, but since we&rsquo;re working in world space (and not in view space) we will derive it from the model matrix.</p>
<p>In the vertex shader we can generate the normal matrix by using the inverse and transpose functions in the vertex shader that work on any matrix type. Note that we cast the matrix to a 3x3 matrix to ensure it loses its translation properties and that it can multiply with the <code>vec3</code> normal vector:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">Normal</span> <span class="o">=</span> <span class="n">mat3</span><span class="p">(</span><span class="n">transpose</span><span class="p">(</span><span class="n">inverse</span><span class="p">(</span><span class="n">model</span><span class="p">)))</span> <span class="o">*</span> <span class="n">aNormal</span><span class="p">;</span>  
</span></span></code></pre></div><p><warning>Inversing matrices is a costly operation for shaders, so wherever possible try to avoid doing inverse operations since they have to be done on each vertex of your scene. For learning purposes this is fine, but for an efficient application you&rsquo;ll likely want to calculate the normal matrix on the CPU and send it to the shaders via a uniform before drawing (just like the model matrix).</warning></p>
<p>In the diffuse lighting section the lighting was fine because we didn&rsquo;t do any scaling on the object, so there was not really a need to use a normal matrix and we could&rsquo;ve just multiplied the normals with the model matrix. If you are doing a non-uniform scale however, it is essential that you multiply your normal vectors with the normal matrix.</p>
<h4 id="specular-lighting">Specular Lighting</h4>
<p>If you&rsquo;re not exhausted already by all the lighting talk we can start finishing the Phong lighting model by adding specular highlights.</p>
<p>Similar to diffuse lighting, specular lighting is based on the light&rsquo;s direction vector and the object&rsquo;s normal vectors, but this time it is also based on the view direction e.g. from what direction the player is looking at the fragment. Specular lighting is based on the reflective properties of surfaces. If we think of the object&rsquo;s surface as a mirror, the specular lighting is the strongest wherever we would see the light reflected on the surface. You can see this effect in the following image:</p>
<p><a href="#R-image-5bf3faeb277200883822bc43a4e4b789" class="lightbox-link"><img src="./assets/basic_lighting_specular_theory.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-5bf3faeb277200883822bc43a4e4b789"><img src="./assets/basic_lighting_specular_theory.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>We calculate a reflection vector by reflecting the light direction around the normal vector. Then we calculate the angular distance between this reflection vector and the view direction. The closer the angle between them, the greater the impact of the specular light. The resulting effect is that we see a bit of a highlight when we&rsquo;re looking at the light&rsquo;s direction reflected via the surface.</p>
<p>The view vector is the one extra variable we need for specular lighting which we can calculate using the viewer&rsquo;s world space position and the fragment&rsquo;s position. Then we calculate the specular&rsquo;s intensity, multiply this with the light color and add this to the ambient and diffuse components.</p>
<p><note>We chose to do the lighting calculations in world space, but most people tend to prefer doing lighting in view space. An advantage of view space is that the viewer&rsquo;s position is always at <code>(0,0,0)</code> so you already got the position of the viewer for free. However, I find calculating lighting in world space more intuitive for learning purposes. If you still want to calculate lighting in view space you want to transform all the relevant vectors with the view matrix as well (don&rsquo;t forget to change the normal matrix too).</note></p>
<p>To get the world space coordinates of the viewer we simply take the position vector of the camera object (which is the viewer of course). So let&rsquo;s add another uniform to the fragment shader and pass the camera position vector to the shader:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">uniform</span> <span class="n">vec3</span> <span class="n">viewPos</span><span class="p">;</span></span></span></code></pre></div><div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">lightingShader</span><span class="p">.</span><span class="n">setVec3</span><span class="p">(</span><span class="s">&#34;viewPos&#34;</span><span class="p">,</span> <span class="n">camera</span><span class="p">.</span><span class="n">Position</span><span class="p">);</span> 
</span></span></code></pre></div><p>Now that we have all the required variables we can calculate the specular intensity. First we define a specular intensity value to give the specular highlight a medium-bright color so that it doesn&rsquo;t have too much of an impact:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">float</span> <span class="n">specularStrength</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">;</span></span></span></code></pre></div><p>If we would set this to <code>1.0f</code> we&rsquo;d get a really bright specular component which is a bit too much for a coral cube. In the <a href="https://learnopengl.com/Lighting/Materials" target="_blank">next</a> chapter we&rsquo;ll talk about properly setting all these lighting intensities and how they affect the objects. Next we calculate the view direction vector and the corresponding reflect vector along the normal axis:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">vec3</span> <span class="n">viewDir</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">viewPos</span> <span class="o">-</span> <span class="n">FragPos</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">vec3</span> <span class="n">reflectDir</span> <span class="o">=</span> <span class="n">reflect</span><span class="p">(</span><span class="o">-</span><span class="n">lightDir</span><span class="p">,</span> <span class="n">norm</span><span class="p">);</span>  
</span></span></code></pre></div><p>Note that we negate the <code>lightDir</code> vector. The <code>reflect</code> function expects the first vector to point <strong>from</strong> the light source towards the fragment&rsquo;s position, but the <code>lightDir</code> vector is currently pointing the other way around: from the fragment <strong>towards</strong> the light source (this depends on the order of subtraction earlier on when we calculated the <code>lightDir</code> vector). To make sure we get the correct <code>reflect</code> vector we reverse its direction by negating the <code>lightDir</code> vector first. The second argument expects a normal vector so we supply the normalized <code>norm</code> vector.</p>
<p>Then what&rsquo;s left to do is to actually calculate the specular component. This is accomplished with the following formula:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">float</span> <span class="n">spec</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">viewDir</span><span class="p">,</span> <span class="n">reflectDir</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">),</span> <span class="mi">32</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">vec3</span> <span class="n">specular</span> <span class="o">=</span> <span class="n">specularStrength</span> <span class="o">*</span> <span class="n">spec</span> <span class="o">*</span> <span class="n">lightColor</span><span class="p">;</span>  
</span></span></code></pre></div><p>We first calculate the dot product between the view direction and the reflect direction (and make sure it&rsquo;s not negative) and then raise it to the power of <code>32</code>. This <code>32</code> value is the shininess value of the highlight. The higher the shininess value of an object, the more it properly reflects the light instead of scattering it all around and thus the smaller the highlight becomes. Below you can see an image that shows the visual impact of different shininess values:</p>
<p><a href="#R-image-7ceac4394ba3d93f9640c0566d3eb1e3" class="lightbox-link"><img src="./assets/basic_lighting_specular_shininess.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7ceac4394ba3d93f9640c0566d3eb1e3"><img src="./assets/basic_lighting_specular_shininess.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>We don&rsquo;t want the specular component to be too distracting so we keep the exponent at <code>32</code>. The only thing left to do is to add it to the ambient and diffuse components and multiply the combined result with the object&rsquo;s color:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">vec3</span> <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">ambient</span> <span class="o">+</span> <span class="n">diffuse</span> <span class="o">+</span> <span class="n">specular</span><span class="p">)</span> <span class="o">*</span> <span class="n">objectColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">FragColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span></span></span></code></pre></div><p>We now calculated all the lighting components of the Phong lighting model. Based on your point of view you should see something like this:</p>
<p><a href="#R-image-43516ea1a311f0bcd1e82429af04e066" class="lightbox-link"><img src="./assets/basic_lighting_specular.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-43516ea1a311f0bcd1e82429af04e066"><img src="./assets/basic_lighting_specular.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>You can find the complete source code of the application <a href="https://learnopengl.com/code_viewer_gh.php?code=src/2.lighting/2.2.basic_lighting_specular/basic_lighting_specular.cpp" target="_blank">here</a>.</p>
<p><note>In the earlier days of lighting shaders, developers used to implement the Phong lighting model in the vertex shader. The advantage of doing lighting in the vertex shader is that it is a lot more efficient since there are generally a lot less vertices compared to fragments, so the (expensive) lighting calculations are done less frequently. However, the resulting color value in the vertex shader is the resulting lighting color of that vertex only and the color values of the surrounding fragments are then the result of interpolated lighting colors. The result was that the lighting was not very realistic unless large amounts of vertices were used:<br><a href="#R-image-856fc30894b128004806b37ba2e0694c" class="lightbox-link"><img src="./assets/basic_lighting_gouruad.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-856fc30894b128004806b37ba2e0694c"><img src="./assets/basic_lighting_gouruad.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a><br>When the Phong lighting model is implemented in the vertex shader it is called Gouraud shading instead of Phong shading. Note that due to the interpolation the lighting looks somewhat off. The Phong shading gives much smoother lighting results.</note></p>
<p>By now you should be starting to see just how powerful shaders are. With little information shaders are able to calculate how lighting affects the fragment&rsquo;s colors for all our objects. In the <a href="https://learnopengl.com/Lighting/Materials" target="_blank">next</a> chapters we&rsquo;ll be delving much deeper into what we can do with the lighting model.</p>
<h5 id="exercises-6">Exercises</h5>
<ul>
<li>Right now the light source is a boring static light source that doesn&rsquo;t move. Try to move the light source around the scene over time using either sin or cos. Watching the lighting change over time gives you a good understanding of Phong&rsquo;s lighting model: <a href="https://learnopengl.com/code_viewer_gh.php?code=src/2.lighting/2.3.basic_lighting_exercise1/basic_lighting_exercise1.cpp" target="_blank">solution</a>.</li>
<li>Play around with different ambient, diffuse and specular strengths and see how they impact the result. Also experiment with the shininess factor. Try to comprehend why certain values have a certain visual output.</li>
<li>Do Phong shading in view space instead of world space: <a href="https://learnopengl.com/code_viewer_gh.php?code=src/2.lighting/2.4.basic_lighting_exercise2/basic_lighting_exercise2.cpp" target="_blank">solution</a>.</li>
<li>Implement Gouraud shading instead of Phong shading. If you did things right the lighting should <a href="https://learnopengl.com/img/lighting/basic_lighting_exercise3.png" target="_blank">look a bit off</a> (especially the specular highlights) with the cube object. Try to reason why it looks so weird: <a href="https://learnopengl.com/code_viewer_gh.php?code=src/2.lighting/2.5.basic_lighting_exercise3/basic_lighting_exercise3.cpp" target="_blank">solution</a>.</li>
</ul>
<h3 id="materials">Materials</h3>
<p>In the real world, each object has a different reaction to light. Steel objects are often shinier than a clay vase for example and a wooden container doesn&rsquo;t react the same to light as a steel container. Some objects reflect the light without much scattering resulting in small specular highlights and others scatter a lot giving the highlight a larger radius. If we want to simulate several types of objects in OpenGL we have to define material properties specific to each surface.</p>
<p>In the previous chapter we defined an object and light color to define the visual output of the object, combined with an ambient and specular intensity component. When describing a surface we can define a material color for each of the 3 lighting components: ambient, diffuse and specular lighting. By specifying a color for each of the components we have fine-grained control over the color output of the surface. Now add a shininess component to those 3 colors and we have all the material properties we need:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="cp"></span><span class="k">struct</span> <span class="nc">Material</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="n">vec3</span> <span class="n">ambient</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="n">vec3</span> <span class="n">diffuse</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">    <span class="n">vec3</span> <span class="n">specular</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">    <span class="kt">float</span> <span class="n">shininess</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="p">};</span> 
</span></span><span class="line"><span class="ln">8</span><span class="cl">  
</span></span><span class="line"><span class="ln">9</span><span class="cl"><span class="n">uniform</span> <span class="n">Material</span> <span class="n">material</span><span class="p">;</span></span></span></code></pre></div><p>In the fragment shader we create a <code>struct</code> to store the material properties of the surface. We can also store them as individual uniform values, but storing them as a struct keeps it more organized. We first define the layout of the struct and then simply declare a uniform variable with the newly created struct as its type.</p>
<p>As you can see, we define a color vector for each of the Phong lighting&rsquo;s components. The ambient material vector defines what color the surface reflects under ambient lighting; this is usually the same as the surface&rsquo;s color. The diffuse material vector defines the color of the surface under diffuse lighting. The diffuse color is (just like ambient lighting) set to the desired surface&rsquo;s color. The specular material vector sets the color of the specular highlight on the surface (or possibly even reflect a surface-specific color). Lastly, the shininess impacts the scattering/radius of the specular highlight.</p>
<p>With these 4 components that define an object&rsquo;s material we can simulate many real-world materials. A table as found at <a href="http://devernay.free.fr/cours/opengl/materials.html" target="_blank">devernay.free.fr</a> shows a list of material properties that simulate real materials found in the outside world. The following image shows the effect several of these real world material values have on our cube:</p>
<p><a href="#R-image-e76387964adc7fcdf900469609cd5fc3" class="lightbox-link"><img src="./assets/materials_real_world.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-e76387964adc7fcdf900469609cd5fc3"><img src="./assets/materials_real_world.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>As you can see, by correctly specifying the material properties of a surface it seems to change the perception we have of the object. The effects are clearly noticeable, but for the more realistic results we&rsquo;ll need to replace the cube with something more complicated. In the <a href="https://learnopengl.com/Model-Loading/Assimp" target="_blank">Model Loading</a> chapters we&rsquo;ll discuss more complicated shapes.</p>
<p>Figuring out the right material settings for an object is a difficult feat that mostly requires experimentation and a lot of experience. It&rsquo;s not that uncommon to completely destroy the visual quality of an object by a misplaced material.</p>
<p>Let&rsquo;s try implementing such a material system in the shaders.</p>
<h4 id="setting-materials">Setting materials</h4>
<p>We created a uniform material struct in the fragment shader so next we want to change the lighting calculations to comply with the new material properties. Since all the material variables are stored in a struct we can access them from the material uniform:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>    
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="c1">// ambient
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1"></span>    <span class="n">vec3</span> <span class="n">ambient</span> <span class="o">=</span> <span class="n">lightColor</span> <span class="o">*</span> <span class="n">material</span><span class="p">.</span><span class="n">ambient</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  	
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="c1">// diffuse 
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1"></span>    <span class="n">vec3</span> <span class="n">norm</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">Normal</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="n">vec3</span> <span class="n">lightDir</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">lightPos</span> <span class="o">-</span> <span class="n">FragPos</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="kt">float</span> <span class="n">diff</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">norm</span><span class="p">,</span> <span class="n">lightDir</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="n">vec3</span> <span class="n">diffuse</span> <span class="o">=</span> <span class="n">lightColor</span> <span class="o">*</span> <span class="p">(</span><span class="n">diff</span> <span class="o">*</span> <span class="n">material</span><span class="p">.</span><span class="n">diffuse</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="c1">// specular
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="c1"></span>    <span class="n">vec3</span> <span class="n">viewDir</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">viewPos</span> <span class="o">-</span> <span class="n">FragPos</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="n">vec3</span> <span class="n">reflectDir</span> <span class="o">=</span> <span class="n">reflect</span><span class="p">(</span><span class="o">-</span><span class="n">lightDir</span><span class="p">,</span> <span class="n">norm</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="kt">float</span> <span class="n">spec</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">viewDir</span><span class="p">,</span> <span class="n">reflectDir</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">),</span> <span class="n">material</span><span class="p">.</span><span class="n">shininess</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="n">vec3</span> <span class="n">specular</span> <span class="o">=</span> <span class="n">lightColor</span> <span class="o">*</span> <span class="p">(</span><span class="n">spec</span> <span class="o">*</span> <span class="n">material</span><span class="p">.</span><span class="n">specular</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">17</span><span class="cl">        
</span></span><span class="line"><span class="ln">18</span><span class="cl">    <span class="n">vec3</span> <span class="n">result</span> <span class="o">=</span> <span class="n">ambient</span> <span class="o">+</span> <span class="n">diffuse</span> <span class="o">+</span> <span class="n">specular</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">    <span class="n">FragColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>As you can see we now access all of the material struct&rsquo;s properties wherever we need them and this time calculate the resulting output color with the help of the material&rsquo;s colors. Each of the object&rsquo;s material attributes are multiplied with their respective lighting components.</p>
<p>We can set the material of the object in the application by setting the appropriate uniforms. A struct in GLSL however is not special in any regard when setting uniforms; a struct only really acts as a namespace of uniform variables. If we want to fill the struct we will have to set the individual uniforms, but prefixed with the struct&rsquo;s name:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">lightingShader</span><span class="p">.</span><span class="n">setVec3</span><span class="p">(</span><span class="s">&#34;material.ambient&#34;</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.31f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">lightingShader</span><span class="p">.</span><span class="n">setVec3</span><span class="p">(</span><span class="s">&#34;material.diffuse&#34;</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.31f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">lightingShader</span><span class="p">.</span><span class="n">setVec3</span><span class="p">(</span><span class="s">&#34;material.specular&#34;</span><span class="p">,</span> <span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.5f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="n">lightingShader</span><span class="p">.</span><span class="n">setFloat</span><span class="p">(</span><span class="s">&#34;material.shininess&#34;</span><span class="p">,</span> <span class="mf">32.0f</span><span class="p">);</span></span></span></code></pre></div><p>We set the ambient and diffuse component to the color we&rsquo;d like the object to have and set the specular component of the object to a medium-bright color; we don&rsquo;t want the specular component to be too strong. We also keep the shininess at <code>32</code>.</p>
<p>We can now easily influence the object&rsquo;s material from the application. Running the program gives you something like this:</p>
<p><a href="#R-image-06e563d27fe918832ab640448a987ada" class="lightbox-link"><img src="./assets/materials_with_material.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-06e563d27fe918832ab640448a987ada"><img src="./assets/materials_with_material.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>It doesn&rsquo;t really look right though?</p>
<h5 id="light-properties">Light properties</h5>
<p>The object is way too bright. The reason for the object being too bright is that the ambient, diffuse and specular colors are reflected with full force from any light source. Light sources also have different intensities for their ambient, diffuse and specular components respectively. In the previous chapter we solved this by varying the ambient and specular intensities with a strength value. We want to do something similar, but this time by specifying intensity vectors for each of the lighting components. If we&rsquo;d visualize lightColor as <code>vec3(1.0)</code> the code would look like this:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">vec3</span> <span class="n">ambient</span>  <span class="o">=</span> <span class="n">vec3</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">material</span><span class="p">.</span><span class="n">ambient</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">vec3</span> <span class="n">diffuse</span>  <span class="o">=</span> <span class="n">vec3</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">diff</span> <span class="o">*</span> <span class="n">material</span><span class="p">.</span><span class="n">diffuse</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">vec3</span> <span class="n">specular</span> <span class="o">=</span> <span class="n">vec3</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">spec</span> <span class="o">*</span> <span class="n">material</span><span class="p">.</span><span class="n">specular</span><span class="p">);</span> 
</span></span></code></pre></div><p>So each material property of the object is returned with full intensity for each of the light&rsquo;s components. These <code>vec3(1.0)</code> values can be influenced individually as well for each light source and this is usually what we want. Right now the ambient component of the object is fully influencing the color of the cube. The ambient component shouldn&rsquo;t really have such a big impact on the final color so we can restrict the ambient color by setting the light&rsquo;s ambient intensity to a lower value:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">vec3</span> <span class="n">ambient</span> <span class="o">=</span> <span class="n">vec3</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span> <span class="o">*</span> <span class="n">material</span><span class="p">.</span><span class="n">ambient</span><span class="p">;</span>  
</span></span></code></pre></div><p>We can influence the diffuse and specular intensity of the light source in the same way. This is closely similar to what we did in the <a href="https://learnopengl.com/Lighting/Basic-Lighting" target="_blank">previous</a> chapter; you could say we already created some light properties to influence each lighting component individually. We&rsquo;ll want to create something similar to the material struct for the light properties:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">struct</span> <span class="nc">Light</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">    <span class="n">vec3</span> <span class="n">position</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">  
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="n">vec3</span> <span class="n">ambient</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">    <span class="n">vec3</span> <span class="n">diffuse</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">    <span class="n">vec3</span> <span class="n">specular</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="ln">8</span><span class="cl">
</span></span><span class="line"><span class="ln">9</span><span class="cl"><span class="n">uniform</span> <span class="n">Light</span> <span class="n">light</span><span class="p">;</span>  
</span></span></code></pre></div><p>A light source has a different intensity for its ambient, diffuse and specular components. The ambient light is usually set to a low intensity because we don&rsquo;t want the ambient color to be too dominant. The diffuse component of a light source is usually set to the exact color we&rsquo;d like a light to have; often a bright white color. The specular component is usually kept at <code>vec3(1.0)</code> shining at full intensity. Note that we also added the light&rsquo;s position vector to the struct.</p>
<p>Just like with the material uniform we need to update the fragment shader:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">vec3</span> <span class="n">ambient</span>  <span class="o">=</span> <span class="n">light</span><span class="p">.</span><span class="n">ambient</span> <span class="o">*</span> <span class="n">material</span><span class="p">.</span><span class="n">ambient</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">vec3</span> <span class="n">diffuse</span>  <span class="o">=</span> <span class="n">light</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">*</span> <span class="p">(</span><span class="n">diff</span> <span class="o">*</span> <span class="n">material</span><span class="p">.</span><span class="n">diffuse</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">vec3</span> <span class="n">specular</span> <span class="o">=</span> <span class="n">light</span><span class="p">.</span><span class="n">specular</span> <span class="o">*</span> <span class="p">(</span><span class="n">spec</span> <span class="o">*</span> <span class="n">material</span><span class="p">.</span><span class="n">specular</span><span class="p">);</span>  
</span></span></code></pre></div><p>We then want to set the light intensities in the application:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">lightingShader</span><span class="p">.</span><span class="n">setVec3</span><span class="p">(</span><span class="s">&#34;light.ambient&#34;</span><span class="p">,</span>  <span class="mf">0.2f</span><span class="p">,</span> <span class="mf">0.2f</span><span class="p">,</span> <span class="mf">0.2f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">lightingShader</span><span class="p">.</span><span class="n">setVec3</span><span class="p">(</span><span class="s">&#34;light.diffuse&#34;</span><span class="p">,</span>  <span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.5f</span><span class="p">);</span> <span class="c1">// darken diffuse light a bit
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="c1"></span><span class="n">lightingShader</span><span class="p">.</span><span class="n">setVec3</span><span class="p">(</span><span class="s">&#34;light.specular&#34;</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">);</span> 
</span></span></code></pre></div><p>Now that we modulated how the light influences the object&rsquo;s material we get a visual output that looks much like the output from the previous chapter. This time however we got full control over the lighting and the material of the object:</p>
<p><a href="#R-image-079bea2733fd3fff73c2f07090b337bf" class="lightbox-link"><img src="./assets/materials_light.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-079bea2733fd3fff73c2f07090b337bf"><img src="./assets/materials_light.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Changing the visual aspects of objects is relatively easy right now. Let&rsquo;s spice things up a bit!</p>
<h5 id="different-light-colors">Different light colors</h5>
<p>So far we used light colors to only vary the intensity of their individual components by choosing colors that range from white to gray to black, not affecting the actual colors of the object (only its intensity). Since we now have easy access to the light&rsquo;s properties we can change their colors over time to get some really interesting effects. Since everything is already set up in the fragment shader, changing the light&rsquo;s colors is easy and immediately creates some funky effects:</p>
<p><video src="assets/materials.mp4" width="600" height="450" controls="" preload="auto"></video></p>
<p>As you can see, a different light color greatly influences the object&rsquo;s color output. Since the light color directly influences what colors the object can reflect (as you may remember from the <a href="https://learnopengl.com/Lighting/Colors" target="_blank">Colors</a> chapter) it has a significant impact on the visual output.</p>
<p>We can easily change the light&rsquo;s colors over time by changing the light&rsquo;s ambient and diffuse colors via sin and glfwGetTime:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">lightColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="n">lightColor</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">glfwGetTime</span><span class="p">()</span> <span class="o">*</span> <span class="mf">2.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">lightColor</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">glfwGetTime</span><span class="p">()</span> <span class="o">*</span> <span class="mf">0.7f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">lightColor</span><span class="p">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">glfwGetTime</span><span class="p">()</span> <span class="o">*</span> <span class="mf">1.3f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">diffuseColor</span> <span class="o">=</span> <span class="n">lightColor</span>   <span class="o">*</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.5f</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">ambientColor</span> <span class="o">=</span> <span class="n">diffuseColor</span> <span class="o">*</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.2f</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="n">lightingShader</span><span class="p">.</span><span class="n">setVec3</span><span class="p">(</span><span class="s">&#34;light.ambient&#34;</span><span class="p">,</span> <span class="n">ambientColor</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="n">lightingShader</span><span class="p">.</span><span class="n">setVec3</span><span class="p">(</span><span class="s">&#34;light.diffuse&#34;</span><span class="p">,</span> <span class="n">diffuseColor</span><span class="p">);</span></span></span></code></pre></div><p>Try and experiment with several lighting and material values and see how they affect the visual output. You can find the source code of the application <a href="https://learnopengl.com/code_viewer_gh.php?code=src/2.lighting/3.1.materials/materials.cpp" target="_blank">here</a>.</p>
<h4 id="exercises-7">Exercises</h4>
<ul>
<li>Can you make it so that changing the light color changes the color of the light&rsquo;s cube object?</li>
<li>Can you simulate some of the real-world objects by defining their respective materials like we&rsquo;ve seen at the start of this chapter? Note that the <a href="http://devernay.free.fr/cours/opengl/materials.html" target="_blank">table</a>&rsquo;s ambient values are not the same as the diffuse values; they didn&rsquo;t take light intensities into account. To correctly set their values you&rsquo;d have to set all the light intensities to <code>vec3(1.0)</code> to get the same output: <a href="https://learnopengl.com/code_viewer_gh.php?code=src/2.lighting/3.2.materials_exercise1/materials_exercise1.cpp" target="_blank">solution</a> of cyan plastic container.</li>
</ul>
<h3 id="lighting-maps">Lighting maps</h3>
<p>In the <a href="https://learnopengl.com/Lighting/Materials" target="_blank">previous</a> chapter we discussed the possibility of each object having a unique material of its own that reacts differently to light. This is great for giving each object a unique look in comparison to other objects, but still doesn&rsquo;t offer much flexibility on the visual output of an object.</p>
<p>In the previous chapter we defined a material for an entire object as a whole. Objects in the real world however usually do not consist of a single material, but of several materials. Think of a car: its exterior consists of a shiny fabric, it has windows that partly reflect the surrounding environment, its tires are all but shiny so they don&rsquo;t have specular highlights and it has rims that are super shiny (if you actually washed your car alright). The car also has diffuse and ambient colors that are not the same for the entire object; a car displays many different ambient/diffuse colors. All by all, such an object has different material properties for each of its different parts.</p>
<p>So the material system in the previous chapter isn&rsquo;t sufficient for all but the simplest models so we need to extend the system by introducing <em>diffuse</em> and <em>specular</em> maps. These allow us to influence the diffuse (and indirectly the ambient component since they should be the same anyways) and the specular component of an object with much more precision.</p>
<h4 id="diffuse-maps">Diffuse maps</h4>
<p>What we want is some way to set the diffuse colors of an object for each individual fragment. Some sort of system where we can retrieve a color value based on the fragment&rsquo;s position on the object?</p>
<p>This should probably all sound familiar and we&rsquo;ve been using such a system for a while now. This sounds just like <em>textures</em> we&rsquo;ve extensively discussed in one of the <a href="https://learnopengl.com/Getting-started/Textures" target="_blank">earlier</a> chapters and it basically is just that: a texture. We&rsquo;re just using a different name for the same underlying principle: using an image wrapped around an object that we can index for unique color values per fragment. In lit scenes this is usually called a diffuse map (this is generally how 3D artists call them before PBR) since a texture image represents all of the object&rsquo;s diffuse colors.</p>
<p>To demonstrate diffuse maps we&rsquo;re going to use the <a href="https://learnopengl.com/img/textures/container2.png" target="_blank">following image</a> of a wooden container with a steel border:</p>
<p><a href="#R-image-d093896dcb47cc8bd83b132cd18fde42" class="lightbox-link"><img src="./assets/container2.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d093896dcb47cc8bd83b132cd18fde42"><img src="./assets/container2.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Using a diffuse map in shaders is exactly like we showed in the texture chapter. This time however we store the texture as a <code>sampler2D</code> inside the Material struct. We replace the earlier defined <code>vec3</code> diffuse color vector with the diffuse map.</p>
<p><warning>Keep in mind that <code>sampler2D</code> is a so called opaque type which means we can&rsquo;t instantiate these types, but only define them as uniforms. If the struct would be instantiated other than as a uniform (like a function parameter) GLSL could throw strange errors; the same thus applies to any struct holding such opaque types.</warning></p>
<p>We also remove the ambient material color vector since the ambient color is equal to the diffuse color anyways now that we control ambient with the light. So there&rsquo;s no need to store it separately:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">struct</span> <span class="nc">Material</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">    <span class="n">sampler2D</span> <span class="n">diffuse</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="n">vec3</span>      <span class="n">specular</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="kt">float</span>     <span class="n">shininess</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="p">};</span> 
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="n">in</span> <span class="n">vec2</span> <span class="n">TexCoords</span><span class="p">;</span></span></span></code></pre></div><p><note>If you&rsquo;re a bit stubborn and still want to set the ambient colors to a different value (other than the diffuse value) you can keep the ambient <code>vec3</code>, but then the ambient colors would still remain the same for the entire object. To get different ambient values for each fragment you&rsquo;d have to use another texture for ambient values alone.</note></p>
<p>Note that we are going to need texture coordinates again in the fragment shader, so we declared an extra input variable. Then we simply sample from the texture to retrieve the fragment&rsquo;s diffuse color value:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">vec3</span> <span class="n">diffuse</span> <span class="o">=</span> <span class="n">light</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">*</span> <span class="n">diff</span> <span class="o">*</span> <span class="n">vec3</span><span class="p">(</span><span class="n">texture</span><span class="p">(</span><span class="n">material</span><span class="p">.</span><span class="n">diffuse</span><span class="p">,</span> <span class="n">TexCoords</span><span class="p">));</span>  
</span></span></code></pre></div><p>Also, don&rsquo;t forget to set the ambient material&rsquo;s color equal to the diffuse material&rsquo;s color as well:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">vec3</span> <span class="n">ambient</span> <span class="o">=</span> <span class="n">light</span><span class="p">.</span><span class="n">ambient</span> <span class="o">*</span> <span class="n">vec3</span><span class="p">(</span><span class="n">texture</span><span class="p">(</span><span class="n">material</span><span class="p">.</span><span class="n">diffuse</span><span class="p">,</span> <span class="n">TexCoords</span><span class="p">));</span></span></span></code></pre></div><p>And that&rsquo;s all it takes to use a diffuse map. As you can see it is nothing new, but it does provide a dramatic increase in visual quality. To get it working we do need to update the vertex data with texture coordinates, transfer them as vertex attributes to the fragment shader, load the texture, and bind the texture to the appropriate texture unit.</p>
<p>The updated vertex data can be found <a href="https://learnopengl.com/code_viewer.php?code=lighting/vertex_data_textures" target="_blank">here</a>. The vertex data now includes vertex positions, normal vectors, and texture coordinates for each of the cube&rsquo;s vertices. Let&rsquo;s update the vertex shader to accept texture coordinates as a vertex attribute and forward them to the fragment shader:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">aPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">aNormal</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec2</span> <span class="n">aTexCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">out</span> <span class="n">vec2</span> <span class="n">TexCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="n">TexCoords</span> <span class="o">=</span> <span class="n">aTexCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>Be sure to update the vertex attribute pointers of both VAOs to match the new vertex data and load the container image as a texture. Before rendering the cube we want to assign the right texture unit to the material.diffuse uniform sampler and bind the container texture to this texture unit:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">lightingShader</span><span class="p">.</span><span class="n">setInt</span><span class="p">(</span><span class="s">&#34;material.diffuse&#34;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">glActiveTexture</span><span class="p">(</span><span class="n">GL_TEXTURE0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">diffuseMap</span><span class="p">);</span></span></span></code></pre></div><p>Now using a diffuse map we get an enormous boost in detail again and this time the container really starts to shine (quite literally). Your container now probably looks something like this:</p>
<p><a href="#R-image-3e204053a1348862d58a3c3fa6b3711e" class="lightbox-link"><img src="./assets/materials_diffuse_map.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-3e204053a1348862d58a3c3fa6b3711e"><img src="./assets/materials_diffuse_map.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>You can find the full source code of the application <a href="https://learnopengl.com/code_viewer_gh.php?code=src/2.lighting/4.1.lighting_maps_diffuse_map/lighting_maps_diffuse.cpp" target="_blank">here</a>.</p>
<h4 id="specular-maps">Specular maps</h4>
<p>You probably noticed that the specular highlight looks a bit odd since the object is a container that mostly consists of wood and wood doesn&rsquo;t have specular highlights like that. We can fix this by setting the specular material of the object to <code>vec3(0.0)</code> but that would mean that the steel borders of the container would stop showing specular highlights as well and steel <strong>should</strong> show specular highlights. We would like to control what parts of the object should show a specular highlight with varying intensity. This is a problem that sounds familiar. Coincidence? I think not.</p>
<p>We can also use a texture map just for specular highlights. This means we need to generate a black and white (or colors if you feel like it) texture that defines the specular intensities of each part of the object. An example of a <a href="https://learnopengl.com/img/textures/container2_specular.png" target="_blank">specular map</a> is the following image:</p>
<p><a href="#R-image-ee8abaf0230190ca0e8887f0bc706bc9" class="lightbox-link"><img src="./assets/container2_specular.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-ee8abaf0230190ca0e8887f0bc706bc9"><img src="./assets/container2_specular.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>The intensity of the specular highlight comes from the brightness of each pixel in the image. Each pixel of the specular map can be displayed as a color vector where black represents the color vector <code>vec3(0.0)</code> and gray the color vector <code>vec3(0.5)</code> for example. In the fragment shader we then sample the corresponding color value and multiply this value with the light&rsquo;s specular intensity. The more &lsquo;white&rsquo; a pixel is, the higher the result of the multiplication and thus the brighter the specular component of an object becomes.</p>
<p>Because the container mostly consists of wood, and wood as a material should have no specular highlights, the entire wooden section of the diffuse texture was converted to black: black sections do not have any specular highlight. The steel border of the container has varying specular intensities with the steel itself being relatively susceptible to specular highlights while the cracks are not.</p>
<p><note>Technically wood also has specular highlights although with a much lower shininess value (more light scattering) and less impact, but for learning purposes we can just pretend wood doesn&rsquo;t have any reaction to specular light.</note></p>
<p>Using tools like <em>Photoshop</em> or <em>Gimp</em> it is relatively easy to transform a diffuse texture to a specular image like this by cutting out some parts, transforming it to black and white and increasing the brightness/contrast.</p>
<h5 id="sampling-specular-maps">Sampling specular maps</h5>
<p>A specular map is just like any other texture so the code is similar to the diffuse map code. Make sure to properly load the image and generate a texture object. Since we&rsquo;re using another texture sampler in the same fragment shader we have to use a different texture unit (see <a href="https://learnopengl.com/Getting-started/Textures" target="_blank">Textures</a>) for the specular map so let&rsquo;s bind it to the appropriate texture unit before rendering:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">lightingShader</span><span class="p">.</span><span class="n">setInt</span><span class="p">(</span><span class="s">&#34;material.specular&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">glActiveTexture</span><span class="p">(</span><span class="n">GL_TEXTURE1</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">specularMap</span><span class="p">);</span>  
</span></span></code></pre></div><p>Then update the material properties of the fragment shader to accept a <code>sampler2D</code> as its specular component instead of a <code>vec3</code>:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">struct</span> <span class="nc">Material</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">    <span class="n">sampler2D</span> <span class="n">diffuse</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="n">sampler2D</span> <span class="n">specular</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="kt">float</span>     <span class="n">shininess</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="p">};</span>  
</span></span></code></pre></div><p>And lastly we want to sample the specular map to retrieve the fragment&rsquo;s corresponding specular intensity:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">vec3</span> <span class="n">ambient</span>  <span class="o">=</span> <span class="n">light</span><span class="p">.</span><span class="n">ambient</span>  <span class="o">*</span> <span class="n">vec3</span><span class="p">(</span><span class="n">texture</span><span class="p">(</span><span class="n">material</span><span class="p">.</span><span class="n">diffuse</span><span class="p">,</span> <span class="n">TexCoords</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">vec3</span> <span class="n">diffuse</span>  <span class="o">=</span> <span class="n">light</span><span class="p">.</span><span class="n">diffuse</span>  <span class="o">*</span> <span class="n">diff</span> <span class="o">*</span> <span class="n">vec3</span><span class="p">(</span><span class="n">texture</span><span class="p">(</span><span class="n">material</span><span class="p">.</span><span class="n">diffuse</span><span class="p">,</span> <span class="n">TexCoords</span><span class="p">));</span>  
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">vec3</span> <span class="n">specular</span> <span class="o">=</span> <span class="n">light</span><span class="p">.</span><span class="n">specular</span> <span class="o">*</span> <span class="n">spec</span> <span class="o">*</span> <span class="n">vec3</span><span class="p">(</span><span class="n">texture</span><span class="p">(</span><span class="n">material</span><span class="p">.</span><span class="n">specular</span><span class="p">,</span> <span class="n">TexCoords</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="n">FragColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">ambient</span> <span class="o">+</span> <span class="n">diffuse</span> <span class="o">+</span> <span class="n">specular</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>   
</span></span></code></pre></div><p>By using a specular map we can specify with enormous detail what parts of an object have <em>shiny</em> properties and we can even control the corresponding intensity. Specular maps give us an added layer of control over lighting on top of the diffuse map.</p>
<p><note>If you don&rsquo;t want to be too mainstream you could also use actual colors in the specular map to not only set the specular intensity of each fragment, but also the color of the specular highlight. Realistically however, the color of the specular highlight is mostly determined by the light source itself so it wouldn&rsquo;t generate realistic visuals (that&rsquo;s why the images are usually black and white: we only care about the intensity).</note></p>
<p>If you would now run the application you can clearly see that the container&rsquo;s material now closely resembles that of an actual wooden container with steel frames:</p>
<p><a href="#R-image-799565f5eeff1ffea92d233d3e189107" class="lightbox-link"><img src="./assets/materials_specular_map.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-799565f5eeff1ffea92d233d3e189107"><img src="./assets/materials_specular_map.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>You can find the full source code of the application <a href="https://learnopengl.com/code_viewer_gh.php?code=src/2.lighting/4.2.lighting_maps_specular_map/lighting_maps_specular.cpp" target="_blank">here</a>.</p>
<p>Using diffuse and specular maps we can really add an enormous amount of detail into relatively simple objects. We can even add more detail into the objects using other texture maps like normal/bump maps and/or reflection maps, but that is something we&rsquo;ll reserve for later chapters. Show your container to all your friends and family and be content with the fact that our container can one day become even prettier than it already is!</p>
<h4 id="exercises-8">Exercises</h4>
<ul>
<li>Fool around with the light source&rsquo;s ambient, diffuse and specular vectors and see how they affect the visual output of the container.</li>
<li>Try inverting the color values of the specular map in the fragment shader so that the wood shows specular highlights and the steel borders do not (note that due to the cracks in the steel border the borders still show some specular highlight, although with less intensity): <a href="https://learnopengl.com/code_viewer_gh.php?code=src/2.lighting/4.3.lighting_maps_exercise2/lighting_maps_exercise2.cpp" target="_blank">solution</a>.</li>
<li>Try creating a specular map from the diffuse texture that uses actual colors instead of black and white and see that the result doesn&rsquo;t look too realistic. You can use this <a href="https://learnopengl.com/img/lighting/lighting_maps_specular_color.png" target="_blank">colored specular map</a> if you can&rsquo;t generate one yourself: <a href="https://learnopengl.com/img/lighting/lighting_maps_exercise3.png" target="_blank">result</a>.</li>
<li>Also add something they call an emission map which is a texture that stores emission values per fragment. Emission values are colors an object may <em>emit</em> as if it contains a light source itself; this way an object can glow regardless of the light conditions. Emission maps are often what you see when objects in a game glow (like <a href="https://learnopengl.com/img/lighting/lighting_maps_eyes_robot.jpg" target="_blank">eyes of a robot</a>, or <a href="https://learnopengl.com/img/lighting/lighting_maps_strips_container.png" target="_blank">light strips on a container</a>). Add the <a href="https://learnopengl.com/img/textures/matrix.jpg" target="_blank">following</a> texture (by creativesam) as an emission map onto the container as if the letters emit light: <a href="https://learnopengl.com/code_viewer_gh.php?code=src/2.lighting/4.4.lighting_maps_exercise4/lighting_maps_exercise4.cpp" target="_blank">solution</a>; <a href="https://learnopengl.com/img/lighting/lighting_maps_exercise4.png" target="_blank">result</a>.</li>
</ul>
<h3 id="light-casters">Light casters</h3>
<p>All the lighting we&rsquo;ve used so far came from a single source that is a single point in space. It gives good results, but in the real world we have several types of light that each act different. A light source that <em>casts</em> light upon objects is called a light caster. In this chapter we&rsquo;ll discuss several different types of light casters. Learning to simulate different light sources is yet another tool in your toolbox to further enrich your environments.</p>
<p>We&rsquo;ll first discuss a directional light, then a point light which is an extension of what we had before, and lastly we&rsquo;ll discuss spotlights. In the <a href="https://learnopengl.com/Lighting/Multiple-lights" target="_blank">next</a> chapter we&rsquo;ll combine several of these different light types into one scene.</p>
<h4 id="directional-light">Directional Light</h4>
<p>When a light source is far away the light rays coming from the light source are close to parallel to each other. It looks like all the light rays are coming from the same direction, regardless of where the object and/or the viewer is. When a light source is modeled to be <em>infinitely</em> far away it is called a directional light since all its light rays have the same direction; it is independent of the location of the light source.</p>
<p>A fine example of a directional light source is the sun as we know it. The sun is not infinitely far away from us, but it is so far away that we can perceive it as being infinitely far away in the lighting calculations. All the light rays from the sun are then modeled as parallel light rays as we can see in the following image:</p>
<p><a href="#R-image-a2f7a13cb9126f865f23b328d6d2bb95" class="lightbox-link"><img src="./assets/light_casters_directional.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a2f7a13cb9126f865f23b328d6d2bb95"><img src="./assets/light_casters_directional.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Because all the light rays are parallel it does not matter how each object relates to the light source&rsquo;s position since the light direction remains the same for each object in the scene. Because the light&rsquo;s direction vector stays the same, the lighting calculations will be similar for each object in the scene.</p>
<p>We can model such a directional light by defining a light direction vector instead of a position vector. The shader calculations remain mostly the same except this time we directly use the light&rsquo;s direction vector instead of calculating the lightDir vector using the light&rsquo;s position vector:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">struct</span> <span class="nc">Light</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    <span class="c1">// vec3 position; // no longer necessary when using directional lights.
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="c1"></span>    <span class="n">vec3</span> <span class="n">direction</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="n">vec3</span> <span class="n">ambient</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="n">vec3</span> <span class="n">diffuse</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="n">vec3</span> <span class="n">specular</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="p">[...]</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="kt">void</span> <span class="n">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">  <span class="n">vec3</span> <span class="n">lightDir</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="o">-</span><span class="n">light</span><span class="p">.</span><span class="n">direction</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">  <span class="p">[...]</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>Note that we first negate the light.direction vector. The lighting calculations we used so far expect the light direction to be a direction from the fragment <strong>towards</strong> the light source, but people generally prefer to specify a directional light as a global direction pointing <strong>from</strong> the light source. Therefore we have to negate the global light direction vector to switch its direction; it&rsquo;s now a direction vector pointing towards the light source. Also, be sure to normalize the vector since it is unwise to assume the input vector to be a unit vector.</p>
<p>The resulting lightDir vector is then used as before in the diffuse and specular computations.</p>
<p>To clearly demonstrate that a directional light has the same effect on multiple objects we revisit the container party scene from the end of the <a href="https://learnopengl.com/Getting-started/Coordinate-Systems" target="_blank">Coordinate systems</a> chapter. In case you missed the party we defined 10 different <a href="https://learnopengl.com/code_viewer.php?code=lighting/light_casters_container_positions" target="_blank">container positions</a> and generated a different model matrix per container where each model matrix contained the appropriate local-to-world transformations:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="n">glm</span><span class="o">::</span><span class="n">mat4</span> <span class="n">model</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="n">model</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">translate</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">cubePositions</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="kt">float</span> <span class="n">angle</span> <span class="o">=</span> <span class="mf">20.0f</span> <span class="o">*</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="n">model</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">rotate</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">radians</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.3f</span><span class="p">,</span> <span class="mf">0.5f</span><span class="p">));</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="n">lightingShader</span><span class="p">.</span><span class="n">setMat4</span><span class="p">(</span><span class="s">&#34;model&#34;</span><span class="p">,</span> <span class="n">model</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="n">glDrawArrays</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">36</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>Also, don&rsquo;t forget to actually specify the direction of the light source (note that we define the direction as a direction <strong>from</strong> the light source; you can quickly see the light&rsquo;s direction is pointing downwards):</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">lightingShader</span><span class="p">.</span><span class="n">setVec3</span><span class="p">(</span><span class="s">&#34;light.direction&#34;</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.2f</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0f</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.3f</span><span class="p">);</span> 	
</span></span></code></pre></div><p><note>We&rsquo;ve been passing the light&rsquo;s position and direction vectors as <code>vec3</code>s for a while now, but some people tend to prefer to keep all the vectors defined as <code>vec4</code>. When defining position vectors as a <code>vec4</code> it is important to set the <code>w</code> component to <code>1.0</code> so translation and projections are properly applied. However, when defining a direction vector as a <code>vec4</code> we don&rsquo;t want translations to have an effect (since they just represent directions, nothing more) so then we define the <code>w</code> component to be <code>0.0</code>.<br><br>Direction vectors can then be represented as: <code>vec4(-0.2f, -1.0f, -0.3f, 0.0f)</code>. This can also function as an easy check for light types: you could check if the <code>w</code> component is equal to <code>1.0</code> to see that we now have a light&rsquo;s position vector and if <code>w</code> is equal to <code>0.0</code> we have a light&rsquo;s direction vector; so adjust the calculations based on that:<br><a href="#R-image-94293b3a845abfb19b81b6fb86cc3251" class="lightbox-link"><img src="./assets/20240213194548.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-94293b3a845abfb19b81b6fb86cc3251"><img src="./assets/20240213194548.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a><br>Fun fact: this is actually how the old OpenGL (fixed-functionality) determined if a light source was a directional light or a positional light source and adjusted its lighting based on that.</note></p>
<p>If you&rsquo;d now compile the application and fly through the scene it looks like there is a sun-like light source casting light on all the objects. Can you see that the diffuse and specular components all react as if there was a light source somewhere in the sky? It&rsquo;ll look something like this:</p>
<p><a href="#R-image-18eae4a867828370d2e80fcce4035f46" class="lightbox-link"><img src="./assets/light_casters_directional_light.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-18eae4a867828370d2e80fcce4035f46"><img src="./assets/light_casters_directional_light.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>You can find the full source code of the application <a href="https://learnopengl.com/code_viewer_gh.php?code=src/2.lighting/5.1.light_casters_directional/light_casters_directional.cpp" target="_blank">here</a>.</p>
<h4 id="point-lights">Point lights</h4>
<p>Directional lights are great for global lights that illuminate the entire scene, but we usually also want several point lights scattered throughout the scene. A point light is a light source with a given position somewhere in a world that illuminates in all directions, where the light rays fade out over distance. Think of light bulbs and torches as light casters that act as a point light.</p>
<p><a href="#R-image-a97ba6d142902f34814363ba24fec755" class="lightbox-link"><img src="./assets/light_casters_point.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a97ba6d142902f34814363ba24fec755"><img src="./assets/light_casters_point.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>In the earlier chapters we&rsquo;ve been working with a simplistic point light. We had a light source at a given position that scatters light in all directions from that given light position. However, the light source we defined simulated light rays that never fade out thus making it look like the light source is extremely strong. In most 3D applications we&rsquo;d like to simulate a light source that only illuminates an area close to the light source and not the entire scene.</p>
<p>If you&rsquo;d add the 10 containers to the lighting scene from the previous chapters, you&rsquo;d notice that the container all the way in the back is lit with the same intensity as the container in front of the light; there is no logic yet that diminishes light over distance. We want the container in the back to only be slightly lit in comparison to the containers close to the light source.</p>
<h5 id="attenuation">Attenuation</h5>
<p>To reduce the intensity of light over the distance a light ray travels is generally called attenuation. One way to reduce the light intensity over distance is to simply use a linear equation. Such an equation would linearly reduce the light intensity over the distance thus making sure that objects at a distance are less bright. However, such a linear function tends to look a bit fake. In the real world, lights are generally quite bright standing close by, but the brightness of a light source diminishes quickly at a distance; the remaining light intensity then slowly diminishes over distance. We are thus in need of a different equation for reducing the light&rsquo;s intensity.</p>
<p>Luckily some smart people already figured this out for us. The following formula calculates an attenuation value based on a fragment&rsquo;s distance to the light source which we later multiply with the light&rsquo;s intensity vector:</p>

<span class="math align-center">$$
\begin{equation} F_{att} = \frac{1.0}{K_c + K_l * d + K_q * d^2} \end{equation} \quad\quad(1)
$$</span><p>Here 
<span class="math align-center">$d$</span> represents the distance from the fragment to the light source. Then to calculate the attenuation value we define 3 (configurable) terms: a constant term 
<span class="math align-center">$K_c$</span>, a linear term 
<span class="math align-center">$K_l$</span> and a quadratic term 
<span class="math align-center">$K_q$</span>.</p>
<ul>
<li>The constant term is usually kept at <code>1.0</code> which is mainly there to make sure the denominator never gets smaller than <code>1</code> since it would otherwise boost the intensity with certain distances, which is not the effect we&rsquo;re looking for.</li>
<li>The linear term is multiplied with the distance value that reduces the intensity in a linear fashion.</li>
<li>The quadratic term is multiplied with the quadrant of the distance and sets a quadratic decrease of intensity for the light source. The quadratic term will be less significant compared to the linear term when the distance is small, but gets much larger as the distance grows.</li>
</ul>
<p>Due to the quadratic term the light will diminish mostly at a linear fashion until the distance becomes large enough for the quadratic term to surpass the linear term and then the light intensity will decrease a lot faster. The resulting effect is that the light is quite intense when at a close range, but quickly loses its brightness over distance until it eventually loses its brightness at a more slower pace. The following graph shows the effect such an attenuation has over a distance of <code>100</code>:</p>
<p><a href="#R-image-010e6e2504d44d9a704148e529c66f92" class="lightbox-link"><img src="./assets/attenuation.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-010e6e2504d44d9a704148e529c66f92"><img src="./assets/attenuation.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>You can see that the light has the highest intensity when the distance is small, but as soon as the distance grows its intensity is significantly reduced and slowly reaches <code>0</code> intensity at around a distance of <code>100</code>. This is exactly what we want.</p>
<h5 id="choosing-the-right-values">Choosing the right values</h5>
<p>But at what values do we set those 3 terms? Setting the right values depend on many factors: the environment, the distance you want a light to cover, the type of light etc. In most cases, it simply is a question of experience and a moderate amount of tweaking. The following table shows some of the values these terms could take to simulate a realistic (sort of) light source that covers a specific radius (distance). The first column specifies the distance a light will cover with the given terms. These values are good starting points for most lights, with courtesy of <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=-Point&#43;Light&#43;Attenuation" target="_blank">Ogre3D&rsquo;s wiki</a>:</p>
<table>
  <tbody><tr>
  	<th>Distance</th>
  	<th>Constant</th>
  	<th>Linear</th>
  	<th>Quadratic</th>
  </tr>  
  <tr>
    <td><code>7</code></td>
 	<td><code>1.0</code></td>
  	<td><code>0.7</code></td>
 	<td><code>1.8</code></td> 
  </tr>
  <tr>
    <td><code>13</code></td>
 	<td><code>1.0</code></td>
  	<td><code>0.35</code></td>
 	<td><code>0.44</code></td> 
  </tr>
  <tr>
    <td><code>20</code></td>
 	<td><code>1.0</code></td>
  	<td><code>0.22</code></td>
 	<td><code>0.20</code></td> 
  </tr>
  <tr>
    <td><code>32</code></td>
 	<td><code>1.0</code></td>
  	<td><code>0.14</code></td>
 	<td><code>0.07</code></td> 
  </tr><tr>
    <td><code>50</code></td>
 	<td><code>1.0</code></td>
  	<td><code>0.09</code></td>
 	<td><code>0.032</code></td> 
  </tr>
  <tr>
    <td><code>65</code></td>
 	<td><code>1.0</code></td>
  	<td><code>0.07</code></td>
 	<td><code>0.017</code></td> 
  </tr><tr>
    <td><code>100</code></td>
 	<td><code>1.0</code></td>
  	<td><code>0.045</code></td>
 	<td><code>0.0075</code></td> 
  </tr><tr>
    <td><code>160</code></td>
 	<td><code>1.0</code></td>
  	<td><code>0.027</code></td>
 	<td><code>0.0028</code></td> 
  </tr>
  <tr>
    <td><code>200</code></td>
 	<td><code>1.0</code></td>
  	<td><code>0.022</code></td>
 	<td><code>0.0019</code></td> 
  </tr><tr>
    <td><code>325</code></td>
 	<td><code>1.0</code></td>
  	<td><code>0.014</code></td>
 	<td><code>0.0007</code></td> 
  </tr>
  <tr>
    <td><code>600</code></td>
 	<td><code>1.0</code></td>
  	<td><code>0.007</code></td>
 	<td><code>0.0002</code></td> 
  </tr>
  <tr>
    <td><code>3250</code></td>
 	<td><code>1.0</code></td>
  	<td><code>0.0014</code></td>
 	<td><code>0.000007</code></td> 
  </tr>
</tbody></table>
<p>As you can see, the constant term 
<span class="math align-center">$K_c$</span> is kept at <code>1.0</code> in all cases. The linear term 
<span class="math align-center">$K_l$</span> is usually quite small to cover larger distances and the quadratic term 
<span class="math align-center">$K_q$</span> is even smaller. Try to experiment a bit with these values to see their effect in your implementation. In our environment a distance of <code>32</code> to <code>100</code> is generally enough for most lights.</p>
<h5 id="implementing-attenuation">Implementing attenuation</h5>
<p>To implement attenuation we&rsquo;ll be needing 3 extra values in the fragment shader: namely the constant, linear and quadratic terms of the equation. These are best stored in the Light struct we defined earlier. Note that we need to calculate lightDir again using position as this is a point light (as we did in the previous chapter) and not a directional light.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">struct</span> <span class="nc">Light</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    <span class="n">vec3</span> <span class="n">position</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="n">vec3</span> <span class="n">ambient</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="n">vec3</span> <span class="n">diffuse</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="n">vec3</span> <span class="n">specular</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">	
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="kt">float</span> <span class="n">constant</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="kt">float</span> <span class="n">linear</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="kt">float</span> <span class="n">quadratic</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="p">};</span> 
</span></span></code></pre></div><p>Then we set the terms in our application: we want the light to cover a distance of <code>50</code> so we&rsquo;ll use the appropriate constant, linear and quadratic terms from the table:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">lightingShader</span><span class="p">.</span><span class="n">setFloat</span><span class="p">(</span><span class="s">&#34;light.constant&#34;</span><span class="p">,</span>  <span class="mf">1.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">lightingShader</span><span class="p">.</span><span class="n">setFloat</span><span class="p">(</span><span class="s">&#34;light.linear&#34;</span><span class="p">,</span>    <span class="mf">0.09f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">lightingShader</span><span class="p">.</span><span class="n">setFloat</span><span class="p">(</span><span class="s">&#34;light.quadratic&#34;</span><span class="p">,</span> <span class="mf">0.032f</span><span class="p">);</span>	    
</span></span></code></pre></div><p>Implementing attenuation in the fragment shader is relatively straightforward: we simply calculate an attenuation value based on the equation and multiply this with the ambient, diffuse and specular components.</p>
<p>We do need the distance to the light source for the equation to work though. Remember how we can calculate the length of a vector? We can retrieve the distance term by calculating the difference vector between the fragment and the light source and take that resulting vector&rsquo;s length. We can use GLSL&rsquo;s built-in length function for that purpose:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">float</span> <span class="n">distance</span>    <span class="o">=</span> <span class="n">length</span><span class="p">(</span><span class="n">light</span><span class="p">.</span><span class="n">position</span> <span class="o">-</span> <span class="n">FragPos</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="kt">float</span> <span class="n">attenuation</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">light</span><span class="p">.</span><span class="n">constant</span> <span class="o">+</span> <span class="n">light</span><span class="p">.</span><span class="n">linear</span> <span class="o">*</span> <span class="n">distance</span> <span class="o">+</span> 
</span></span><span class="line"><span class="ln">3</span><span class="cl">    		    <span class="n">light</span><span class="p">.</span><span class="n">quadratic</span> <span class="o">*</span> <span class="p">(</span><span class="n">distance</span> <span class="o">*</span> <span class="n">distance</span><span class="p">));</span>    
</span></span></code></pre></div><p>Then we include this attenuation value in the lighting calculations by multiplying the attenuation value with the ambient, diffuse and specular colors.</p>
<p><note>We could leave the ambient component alone so ambient lighting is not decreased over distance, but if we were to use more than 1 light source all the ambient components will start to stack up. In that case we want to attenuate ambient lighting as well. Simply play around with what&rsquo;s best for your environment.</note></p>
<div class="wrap-code highlight"><pre tabindex="0"><code>ambient  *= attenuation; 
diffuse  *= attenuation;
specular *= attenuation;  </code></pre></div><p>If you&rsquo;d run the application you&rsquo;d get something like this:</p>
<p><a href="#R-image-cc720dba7c575b6554083dd849b1520e" class="lightbox-link"><img src="./assets/light_casters_point_light.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-cc720dba7c575b6554083dd849b1520e"><img src="./assets/light_casters_point_light.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>You can see that right now only the front containers are lit with the closest container being the brightest. The containers in the back are not lit at all since they&rsquo;re too far from the light source. You can find the source code of the application <a href="https://learnopengl.com/code_viewer_gh.php?code=src/2.lighting/5.2.light_casters_point/light_casters_point.cpp" target="_blank">here</a>.</p>
<p>A point light is thus a light source with a configurable location and attenuation applied to its lighting calculations. Yet another type of light for our lighting arsenal.</p>
<h4 id="spotlight">Spotlight</h4>
<p>The last type of light we&rsquo;re going to discuss is a spotlight. A spotlight is a light source that is located somewhere in the environment that, instead of shooting light rays in all directions, only shoots them in a specific direction. The result is that only the objects within a certain radius of the spotlight&rsquo;s direction are lit and everything else stays dark. A good example of a spotlight would be a street lamp or a flashlight.</p>
<p>A spotlight in OpenGL is represented by a world-space position, a direction and a cutoff angle that specifies the radius of the spotlight. For each fragment we calculate if the fragment is between the spotlight&rsquo;s cutoff directions (thus in its cone) and if so, we lit the fragment accordingly. The following image gives you an idea of how a spotlight works:</p>
<p><a href="#R-image-aea67279d6e9467fcd4124b98a187ae5" class="lightbox-link"><img src="./assets/light_casters_spotlight_angles.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-aea67279d6e9467fcd4124b98a187ae5"><img src="./assets/light_casters_spotlight_angles.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<ul>
<li><code>LightDir</code>: the vector pointing from the fragment to the light source.</li>
<li><code>SpotDir</code>: the direction the spotlight is aiming at.</li>
<li><code>Phi</code> 
<span class="math align-center">$\phi$</span>: the cutoff angle that specifies the spotlight&rsquo;s radius. Everything outside this angle is not lit by the spotlight.</li>
<li><code>Theta</code> 
<span class="math align-center">$\theta$</span>: the angle between the LightDir vector and the SpotDir vector. The 
<span class="math align-center">$\theta$</span> value should be smaller than 
<span class="math align-center">$\Phi$</span> to be inside the spotlight.</li>
</ul>
<p>So what we basically need to do, is calculate the dot product (returns the cosine of the angle between two unit vectors) between the LightDir vector and the SpotDir vector and compare this with the cutoff angle 
<span class="math align-center">$\phi$</span>. Now that you (sort of) understand what a spotlight is all about we&rsquo;re going to create one in the form of a flashlight.</p>
<h4 id="flashlight">Flashlight</h4>
<p>A flashlight is a spotlight located at the viewer&rsquo;s position and usually aimed straight ahead from the player&rsquo;s perspective. A flashlight is basically a normal spotlight, but with its position and direction continually updated based on the player&rsquo;s position and orientation.</p>
<p>So, the values we&rsquo;re going to need for the fragment shader are the spotlight&rsquo;s position vector (to calculate the fragment-to-light&rsquo;s direction vector), the spotlight&rsquo;s direction vector and the cutoff angle. We can store these values in the Light struct:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">struct</span> <span class="nc">Light</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">    <span class="n">vec3</span>  <span class="n">position</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="n">vec3</span>  <span class="n">direction</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="kt">float</span> <span class="n">cutOff</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="p">};</span>    
</span></span></code></pre></div><p>Next we pass the appropriate values to the shader:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">lightingShader</span><span class="p">.</span><span class="n">setVec3</span><span class="p">(</span><span class="s">&#34;light.position&#34;</span><span class="p">,</span>  <span class="n">camera</span><span class="p">.</span><span class="n">Position</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">lightingShader</span><span class="p">.</span><span class="n">setVec3</span><span class="p">(</span><span class="s">&#34;light.direction&#34;</span><span class="p">,</span> <span class="n">camera</span><span class="p">.</span><span class="n">Front</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">lightingShader</span><span class="p">.</span><span class="n">setFloat</span><span class="p">(</span><span class="s">&#34;light.cutOff&#34;</span><span class="p">,</span>   <span class="n">glm</span><span class="o">::</span><span class="n">cos</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">radians</span><span class="p">(</span><span class="mf">12.5f</span><span class="p">)));</span></span></span></code></pre></div><p>As you can see we&rsquo;re not setting an angle for the cutoff value but calculate the cosine value based on an angle and pass the cosine result to the fragment shader. The reason for this is that in the fragment shader we&rsquo;re calculating the dot product between the <code>LightDir</code> and the <code>SpotDir</code> vector and the dot product returns a cosine value and not an angle; and we can&rsquo;t directly compare an angle with a cosine value. To get the angle in the shader we then have to calculate the inverse cosine of the dot product&rsquo;s result which is an expensive operation. So to save some performance we calculate the cosine value of a given cutoff angle beforehand and pass this result to the fragment shader. Since both angles are now represented as cosines, we can directly compare between them without expensive operations.</p>
<p>Now what&rsquo;s left to do is calculate the theta 
<span class="math align-center">$\theta$</span> value and compare this with the cutoff 
<span class="math align-center">$\phi$</span> value to determine if we&rsquo;re in or outside the spotlight:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">float</span> <span class="n">theta</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">lightDir</span><span class="p">,</span> <span class="n">normalize</span><span class="p">(</span><span class="o">-</span><span class="n">light</span><span class="p">.</span><span class="n">direction</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">    
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="k">if</span><span class="p">(</span><span class="n">theta</span> <span class="o">&gt;</span> <span class="n">light</span><span class="p">.</span><span class="n">cutOff</span><span class="p">)</span> 
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="p">{</span>       
</span></span><span class="line"><span class="ln">5</span><span class="cl">  <span class="c1">// do lighting calculations
</span></span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="k">else</span>  <span class="c1">// else, use ambient light so scene isn&#39;t completely dark outside the spotlight.
</span></span></span><span class="line"><span class="ln">8</span><span class="cl"><span class="c1"></span>  <span class="n">color</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">light</span><span class="p">.</span><span class="n">ambient</span> <span class="o">*</span> <span class="n">vec3</span><span class="p">(</span><span class="n">texture</span><span class="p">(</span><span class="n">material</span><span class="p">.</span><span class="n">diffuse</span><span class="p">,</span> <span class="n">TexCoords</span><span class="p">)),</span> <span class="mf">1.0</span><span class="p">);</span></span></span></code></pre></div><p>We first calculate the dot product between the lightDir vector and the negated direction vector (negated, because we want the vectors to point towards the light source, instead of from). Be sure to normalize all the relevant vectors.</p>
<p><note>You may be wondering why there is a <code>&gt;</code> sign instead of a <code>&lt;</code> sign in the <code>if</code> guard. Shouldn&rsquo;t theta be smaller than the light&rsquo;s cutoff value to be inside the spotlight? That is right, but don&rsquo;t forget angle values are represented as cosine values and an angle of <code>0</code> degrees is represented as the cosine value of <code>1.0</code> while an angle of <code>90</code> degrees is represented as the cosine value of <code>0.0</code> as you can see here:<br><a href="#R-image-c66b16ebfe0be56d05fd2bf610e0d70a" class="lightbox-link"><img src="./assets/light_casters_cos.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c66b16ebfe0be56d05fd2bf610e0d70a"><img src="./assets/light_casters_cos.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a><br>You can now see that the closer the cosine value is to <code>1.0</code> the smaller its angle. Now it makes sense why theta needs to be larger than the cutoff value. The cutoff value is currently set at the cosine of <code>12.5</code> which is equal to <code>0.976</code> so a cosine theta value between <code>0.976</code> and <code>1.0</code> would result in the fragment being lit as if inside the spotlight.</note></p>
<p>Running the application results in a spotlight that only lights the fragments that are directly inside the cone of the spotlight. It&rsquo;ll look something like this:</p>
<p><a href="#R-image-d0826c41f6e59d871edd5c2f3ddd3873" class="lightbox-link"><img src="./assets/light_casters_spotlight_hard.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d0826c41f6e59d871edd5c2f3ddd3873"><img src="./assets/light_casters_spotlight_hard.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>You can find the full source code <a href="https://learnopengl.com/code_viewer_gh.php?code=src/2.lighting/5.3.light_casters_spot/light_casters_spot.cpp" target="_blank">here</a>.</p>
<p>It still looks a bit fake though, mostly because the spotlight has hard edges. Wherever a fragment reaches the edge of the spotlight&rsquo;s cone it is shut down completely instead of with a nice smooth fade. A realistic spotlight would reduce the light gradually around its edges.</p>
<h5 id="smoothsoft-edges">Smooth/Soft edges</h5>
<p>To create the effect of a smoothly-edged spotlight we want to simulate a spotlight having an inner and an outer cone. We can set the inner cone as the cone defined in the previous section, but we also want an outer cone that gradually dims the light from the inner to the edges of the outer cone.</p>
<p>To create an outer cone we simply define another cosine value that represents the angle between the spotlight&rsquo;s direction vector and the outer cone&rsquo;s vector (equal to its radius). Then, if a fragment is between the inner and the outer cone it should calculate an intensity value between <code>0.0</code> and <code>1.0</code>. If the fragment is inside the inner cone its intensity is equal to <code>1.0</code> and <code>0.0</code> if the fragment is outside the outer cone.</p>
<p>We can calculate such a value using the following equation:</p>

<span class="math align-center">$$
\begin{equation} I = \frac{\theta - \gamma}{\epsilon} \end{equation} \quad\quad (2)
$$</span><p>Here 
<span class="math align-center">$\epsilon$</span> (epsilon) is the cosine difference between the inner (
<span class="math align-center">$\phi$</span>) and the outer cone (
<span class="math align-center">$\epsilon =  \phi - \gamma$</span>). The resulting $I$ value is then the intensity of the spotlight at the current fragment.</p>
<p>It is a bit hard to visualize how this formula actually works so let&rsquo;s try it out with a few sample values:</p>
<table>
  <tbody><tr>
  	<th>θ</th>
    <th>θ in degrees</th>
  	<th>ϕ (inner cutoff)</th>
    <th>ϕ in degrees</th>
  	<th>γ (outer cutoff)</th>
    <th>γ in degrees</th>
  	<th>ϵ</th>
    <th>I</th>
  </tr>  
  <tr>
    <td><code>0.87</code></td>
    <td><code>30</code></td>
 	<td><code>0.91</code></td>
  	<td><code>25</code></td>
 	<td><code>0.82</code></td> 
    <td><code>35</code></td> 
    <td><code>0.91 - 0.82 = 0.09</code></td> 
    <td><code>0.87 - 0.82 / 0.09 = 0.56</code></td> 
  </tr>
  <tr>
    <td><code>0.9</code></td>
    <td><code>26</code></td>
 	<td><code>0.91</code></td>
  	<td><code>25</code></td>
 	<td><code>0.82</code></td> 
    <td><code>35</code></td> 
    <td><code>0.91 - 0.82 = 0.09</code></td> 
    <td><code>0.9 - 0.82 / 0.09 = 0.89</code></td> 
  </tr>
  <tr>
    <td><code>0.97</code></td>
    <td><code>14</code></td>
 	<td><code>0.91</code></td>
  	<td><code>25</code></td>
 	<td><code>0.82</code></td> 
    <td><code>35</code></td> 
    <td><code>0.91 - 0.82 = 0.09</code></td> 
    <td><code>0.97 - 0.82 / 0.09 = 1.67</code></td> 
  </tr>
  <tr>
    <td><code>0.83</code></td>
    <td><code>34</code></td>
 	<td><code>0.91</code></td>
  	<td><code>25</code></td>
 	<td><code>0.82</code></td> 
    <td><code>35</code></td> 
    <td><code>0.91 - 0.82 = 0.09</code></td> 
    <td><code>0.83 - 0.82 / 0.09 = 0.11</code></td> 
  </tr>
  <tr>
    <td><code>0.64</code></td>
    <td><code>50</code></td>
 	<td><code>0.91</code></td>
  	<td><code>25</code></td>
 	<td><code>0.82</code></td> 
    <td><code>35</code></td> 
    <td><code>0.91 - 0.82 = 0.09</code></td> 
    <td><code>0.64 - 0.82 / 0.09 = -2.0</code></td> 
  </tr>
  <tr>
    <td><code>0.966</code></td>
    <td><code>15</code></td>
 	<td><code>0.9978</code></td>
  	<td><code>12.5</code></td>
 	<td><code>0.953</code></td> 
    <td><code>17.5</code></td> 
    <td><code>0.9978 - 0.953 = 0.0448</code></td> 
    <td><code>0.966 - 0.953 / 0.0448 = 0.29</code></td> 
  </tr>
</tbody></table>
<p>As you can see we&rsquo;re basically interpolating between the outer cosine and the inner cosine based on the θ� value. If you still don&rsquo;t really see what&rsquo;s going on, don&rsquo;t worry, you can simply take the formula for granted and return here when you&rsquo;re much older and wiser.</p>
<p>We now have an intensity value that is either negative when outside the spotlight, higher than <code>1.0</code> when inside the inner cone, and somewhere in between around the edges. If we properly clamp the values we don&rsquo;t need an <code>if-else</code> in the fragment shader anymore and we can simply multiply the light components with the calculated intensity value:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">float</span> <span class="n">theta</span>     <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">lightDir</span><span class="p">,</span> <span class="n">normalize</span><span class="p">(</span><span class="o">-</span><span class="n">light</span><span class="p">.</span><span class="n">direction</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="kt">float</span> <span class="n">epsilon</span>   <span class="o">=</span> <span class="n">light</span><span class="p">.</span><span class="n">cutOff</span> <span class="o">-</span> <span class="n">light</span><span class="p">.</span><span class="n">outerCutOff</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="kt">float</span> <span class="n">intensity</span> <span class="o">=</span> <span class="n">clamp</span><span class="p">((</span><span class="n">theta</span> <span class="o">-</span> <span class="n">light</span><span class="p">.</span><span class="n">outerCutOff</span><span class="p">)</span> <span class="o">/</span> <span class="n">epsilon</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>    
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="c1">// we&#39;ll leave ambient unaffected so we always have a little light.
</span></span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="c1"></span><span class="n">diffuse</span>  <span class="o">*=</span> <span class="n">intensity</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="n">specular</span> <span class="o">*=</span> <span class="n">intensity</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">8</span><span class="cl"><span class="p">...</span></span></span></code></pre></div><p>Note that we use the clamp function that clamps its first argument between the values <code>0.0</code> and <code>1.0</code>. This makes sure the intensity values won&rsquo;t end up outside the [<code>0</code>, <code>1</code>] range.</p>
<p>Make sure you add the outerCutOff value to the Light struct and set its uniform value in the application. For the following image an inner cutoff angle of <code>12.5</code> and an outer cutoff angle of <code>17.5</code> was used:</p>
<p><a href="#R-image-b1b21673c828f4c35d8a5ef5a683d398" class="lightbox-link"><img src="./assets/light_casters_spotlight.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b1b21673c828f4c35d8a5ef5a683d398"><img src="./assets/light_casters_spotlight.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Ahhh, that&rsquo;s much better. Play around with the inner and outer cutoff angles and try to create a spotlight that better suits your needs. You can find the source code of the application <a href="https://learnopengl.com/code_viewer_gh.php?code=src/2.lighting/5.4.light_casters_spot_soft/light_casters_spot_soft.cpp" target="_blank">here</a>.</p>
<p>Such a flashlight/spotlight type of lamp is perfect for horror games and combined with directional and point lights the environment will really start to light up.</p>
<h4 id="exercises-9">Exercises</h4>
<ul>
<li>Try experimenting with all the different light types and their fragment shaders. Try inverting some vectors and/or use &lt; instead of &gt;. Try to explain the different visual outcomes.</li>
</ul>
<h3 id="multiple-lights">Multiple lights</h3>
<p>In the previous chapters we learned a lot about lighting in OpenGL. We learned about Phong shading, materials, lighting maps and different types of light casters. In this chapter we&rsquo;re going to combine all the previously obtained knowledge by creating a fully lit scene with 6 active light sources. We are going to simulate a sun-like light as a directional light source, 4 point lights scattered throughout the scene and we&rsquo;ll be adding a flashlight as well.</p>
<p>To use more than one light source in the scene we want to encapsulate the lighting calculations into GLSL functions. The reason for that is that the code quickly gets nasty when we do lighting computations with multiple light types, each requiring different computations. If we were to do all these calculations in the main function only, the code quickly becomes difficult to understand.</p>
<p>Functions in GLSL are just like C-functions. We have a function name, a return type and we need to declare a prototype at the top of the code file if the function hasn&rsquo;t been declared yet before the main function. We&rsquo;ll create a different function for each of the light types: directional lights, point lights and spotlights.</p>
<p>When using multiple lights in a scene the approach is usually as follows: we have a single color vector that represents the fragment&rsquo;s output color. For each light, the light&rsquo;s contribution to the fragment is added to this output color vector. So each light in the scene will calculate its individual impact and contribute that to the final output color. A general structure would look something like this:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">out</span> <span class="n">vec4</span> <span class="n">FragColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  <span class="c1">// define an output color value
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="c1"></span>  <span class="n">vec3</span> <span class="n">output</span> <span class="o">=</span> <span class="n">vec3</span><span class="p">(</span><span class="mf">0.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  <span class="c1">// add the directional light&#39;s contribution to the output
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="c1"></span>  <span class="n">output</span> <span class="o">+=</span> <span class="n">someFunctionToCalculateDirectionalLight</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  <span class="c1">// do the same for all point lights
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1"></span>  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_of_point_lights</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">  	<span class="n">output</span> <span class="o">+=</span> <span class="n">someFunctionToCalculatePointLight</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">  <span class="c1">// and add others lights as well (like spotlights)
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="c1"></span>  <span class="n">output</span> <span class="o">+=</span> <span class="n">someFunctionToCalculateSpotLight</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">  
</span></span><span class="line"><span class="ln">15</span><span class="cl">  <span class="n">FragColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>The actual code will likely differ per implementation, but the general structure remains the same. We define several functions that calculate the impact per light source and add its resulting color to an output color vector. If for example two light sources are close to the fragment, their combined contribution would result in a more brightly lit fragment compared to the fragment being lit by a single light source.</p>
<h4 id="directional-light-1">Directional light</h4>
<p>We want to define a function in the fragment shader that calculates the contribution a directional light has on the corresponding fragment: a function that takes a few parameters and returns the calculated directional lighting color.</p>
<p>First we need to set the required variables that we minimally need for a directional light source. We can store the variables in a struct called DirLight and define it as a uniform. The struct&rsquo;s variables should be familiar from the <a href="https://learnopengl.com/Lighting/Light-casters" target="_blank">previous</a> chapter:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">struct</span> <span class="nc">DirLight</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">    <span class="n">vec3</span> <span class="n">direction</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">  
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="n">vec3</span> <span class="n">ambient</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">    <span class="n">vec3</span> <span class="n">diffuse</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">    <span class="n">vec3</span> <span class="n">specular</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="p">};</span>  
</span></span><span class="line"><span class="ln">8</span><span class="cl"><span class="n">uniform</span> <span class="n">DirLight</span> <span class="n">dirLight</span><span class="p">;</span></span></span></code></pre></div><p>We can then pass the dirLight uniform to a function with the following prototype:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">vec3</span> <span class="nf">CalcDirLight</span><span class="p">(</span><span class="n">DirLight</span> <span class="n">light</span><span class="p">,</span> <span class="n">vec3</span> <span class="n">normal</span><span class="p">,</span> <span class="n">vec3</span> <span class="n">viewDir</span><span class="p">);</span>  
</span></span></code></pre></div><p><note>Just like C and C++, when we want to call a function (in this case inside the main function) the function should be defined somewhere before the caller&rsquo;s line number. In this case we&rsquo;d prefer to define the functions below the main function so this requirement doesn&rsquo;t hold. Therefore we declare the function&rsquo;s prototypes somewhere above the main function, just like we would in C.</note></p>
<p>You can see that the function requires a DirLight struct and two other vectors required for its computation. If you successfully completed the previous chapter then the content of this function should come as no surprise:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">vec3</span> <span class="nf">CalcDirLight</span><span class="p">(</span><span class="n">DirLight</span> <span class="n">light</span><span class="p">,</span> <span class="n">vec3</span> <span class="n">normal</span><span class="p">,</span> <span class="n">vec3</span> <span class="n">viewDir</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="n">vec3</span> <span class="n">lightDir</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="o">-</span><span class="n">light</span><span class="p">.</span><span class="n">direction</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="c1">// diffuse shading
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="c1"></span>    <span class="kt">float</span> <span class="n">diff</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="n">lightDir</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="c1">// specular shading
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1"></span>    <span class="n">vec3</span> <span class="n">reflectDir</span> <span class="o">=</span> <span class="n">reflect</span><span class="p">(</span><span class="o">-</span><span class="n">lightDir</span><span class="p">,</span> <span class="n">normal</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="kt">float</span> <span class="n">spec</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">viewDir</span><span class="p">,</span> <span class="n">reflectDir</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">),</span> <span class="n">material</span><span class="p">.</span><span class="n">shininess</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="c1">// combine results
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1"></span>    <span class="n">vec3</span> <span class="n">ambient</span>  <span class="o">=</span> <span class="n">light</span><span class="p">.</span><span class="n">ambient</span>  <span class="o">*</span> <span class="n">vec3</span><span class="p">(</span><span class="n">texture</span><span class="p">(</span><span class="n">material</span><span class="p">.</span><span class="n">diffuse</span><span class="p">,</span> <span class="n">TexCoords</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="n">vec3</span> <span class="n">diffuse</span>  <span class="o">=</span> <span class="n">light</span><span class="p">.</span><span class="n">diffuse</span>  <span class="o">*</span> <span class="n">diff</span> <span class="o">*</span> <span class="n">vec3</span><span class="p">(</span><span class="n">texture</span><span class="p">(</span><span class="n">material</span><span class="p">.</span><span class="n">diffuse</span><span class="p">,</span> <span class="n">TexCoords</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="n">vec3</span> <span class="n">specular</span> <span class="o">=</span> <span class="n">light</span><span class="p">.</span><span class="n">specular</span> <span class="o">*</span> <span class="n">spec</span> <span class="o">*</span> <span class="n">vec3</span><span class="p">(</span><span class="n">texture</span><span class="p">(</span><span class="n">material</span><span class="p">.</span><span class="n">specular</span><span class="p">,</span> <span class="n">TexCoords</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="n">ambient</span> <span class="o">+</span> <span class="n">diffuse</span> <span class="o">+</span> <span class="n">specular</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>We basically copied the code from the previous chapter and used the vectors given as function arguments to calculate the directional light&rsquo;s contribution vector. The resulting ambient, diffuse and specular contributions are then returned as a single color vector.</p>
<h4 id="point-light">Point light</h4>
<p>Similar to directional lights we also want to define a function that calculates the contribution a point light has on the given fragment, including its attenuation. Just like directional lights we want to define a struct that specifies all the variables required for a point light:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">struct</span> <span class="nc">PointLight</span> <span class="p">{</span>    
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    <span class="n">vec3</span> <span class="n">position</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="kt">float</span> <span class="n">constant</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="kt">float</span> <span class="n">linear</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="kt">float</span> <span class="n">quadratic</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="n">vec3</span> <span class="n">ambient</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="n">vec3</span> <span class="n">diffuse</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="n">vec3</span> <span class="n">specular</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="p">};</span>  
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="cp">#define NR_POINT_LIGHTS 4  
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="cp"></span><span class="n">uniform</span> <span class="n">PointLight</span> <span class="n">pointLights</span><span class="p">[</span><span class="n">NR_POINT_LIGHTS</span><span class="p">];</span></span></span></code></pre></div><p>As you can see we used a pre-processor directive in GLSL to define the number of point lights we want to have in our scene. We then use this NR_POINT_LIGHTS constant to create an array of PointLight structs. Arrays in GLSL are just like C arrays and can be created by the use of two square brackets. Right now we have 4 PointLight structs to fill with data.</p>
<p>The prototype of the point light&rsquo;s function is as follows:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">vec3</span> <span class="nf">CalcPointLight</span><span class="p">(</span><span class="n">PointLight</span> <span class="n">light</span><span class="p">,</span> <span class="n">vec3</span> <span class="n">normal</span><span class="p">,</span> <span class="n">vec3</span> <span class="n">fragPos</span><span class="p">,</span> <span class="n">vec3</span> <span class="n">viewDir</span><span class="p">);</span>  
</span></span></code></pre></div><p>The function takes all the data it needs as its arguments and returns a <code>vec3</code> that represents the color contribution that this specific point light has on the fragment. Again, some intelligent copy-and-pasting results in the following function:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">vec3</span> <span class="nf">CalcPointLight</span><span class="p">(</span><span class="n">PointLight</span> <span class="n">light</span><span class="p">,</span> <span class="n">vec3</span> <span class="n">normal</span><span class="p">,</span> <span class="n">vec3</span> <span class="n">fragPos</span><span class="p">,</span> <span class="n">vec3</span> <span class="n">viewDir</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="n">vec3</span> <span class="n">lightDir</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">light</span><span class="p">.</span><span class="n">position</span> <span class="o">-</span> <span class="n">fragPos</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="c1">// diffuse shading
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="c1"></span>    <span class="kt">float</span> <span class="n">diff</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="n">lightDir</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="c1">// specular shading
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1"></span>    <span class="n">vec3</span> <span class="n">reflectDir</span> <span class="o">=</span> <span class="n">reflect</span><span class="p">(</span><span class="o">-</span><span class="n">lightDir</span><span class="p">,</span> <span class="n">normal</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="kt">float</span> <span class="n">spec</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">viewDir</span><span class="p">,</span> <span class="n">reflectDir</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">),</span> <span class="n">material</span><span class="p">.</span><span class="n">shininess</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="c1">// attenuation
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1"></span>    <span class="kt">float</span> <span class="n">distance</span>    <span class="o">=</span> <span class="n">length</span><span class="p">(</span><span class="n">light</span><span class="p">.</span><span class="n">position</span> <span class="o">-</span> <span class="n">fragPos</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="kt">float</span> <span class="n">attenuation</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">light</span><span class="p">.</span><span class="n">constant</span> <span class="o">+</span> <span class="n">light</span><span class="p">.</span><span class="n">linear</span> <span class="o">*</span> <span class="n">distance</span> <span class="o">+</span> 
</span></span><span class="line"><span class="ln">12</span><span class="cl">  			     <span class="n">light</span><span class="p">.</span><span class="n">quadratic</span> <span class="o">*</span> <span class="p">(</span><span class="n">distance</span> <span class="o">*</span> <span class="n">distance</span><span class="p">));</span>    
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="c1">// combine results
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="c1"></span>    <span class="n">vec3</span> <span class="n">ambient</span>  <span class="o">=</span> <span class="n">light</span><span class="p">.</span><span class="n">ambient</span>  <span class="o">*</span> <span class="n">vec3</span><span class="p">(</span><span class="n">texture</span><span class="p">(</span><span class="n">material</span><span class="p">.</span><span class="n">diffuse</span><span class="p">,</span> <span class="n">TexCoords</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="n">vec3</span> <span class="n">diffuse</span>  <span class="o">=</span> <span class="n">light</span><span class="p">.</span><span class="n">diffuse</span>  <span class="o">*</span> <span class="n">diff</span> <span class="o">*</span> <span class="n">vec3</span><span class="p">(</span><span class="n">texture</span><span class="p">(</span><span class="n">material</span><span class="p">.</span><span class="n">diffuse</span><span class="p">,</span> <span class="n">TexCoords</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="n">vec3</span> <span class="n">specular</span> <span class="o">=</span> <span class="n">light</span><span class="p">.</span><span class="n">specular</span> <span class="o">*</span> <span class="n">spec</span> <span class="o">*</span> <span class="n">vec3</span><span class="p">(</span><span class="n">texture</span><span class="p">(</span><span class="n">material</span><span class="p">.</span><span class="n">specular</span><span class="p">,</span> <span class="n">TexCoords</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">    <span class="n">ambient</span>  <span class="o">*=</span> <span class="n">attenuation</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">    <span class="n">diffuse</span>  <span class="o">*=</span> <span class="n">attenuation</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">    <span class="n">specular</span> <span class="o">*=</span> <span class="n">attenuation</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="n">ambient</span> <span class="o">+</span> <span class="n">diffuse</span> <span class="o">+</span> <span class="n">specular</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="p">}</span> 
</span></span></code></pre></div><p>Abstracting this functionality away in a function like this has the advantage that we can easily calculate the lighting for multiple point lights without the need for duplicated code. In the main function we simply create a loop that iterates over the point light array that calls CalcPointLight for each point light.</p>
<h4 id="putting-it-all-together-1">Putting it all together</h4>
<p>Now that we defined both a function for directional lights and a function for point lights we can put it all together in the main function.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="c1">// properties
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1"></span>    <span class="n">vec3</span> <span class="n">norm</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">Normal</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="n">vec3</span> <span class="n">viewDir</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">viewPos</span> <span class="o">-</span> <span class="n">FragPos</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="c1">// phase 1: Directional lighting
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="c1"></span>    <span class="n">vec3</span> <span class="n">result</span> <span class="o">=</span> <span class="n">CalcDirLight</span><span class="p">(</span><span class="n">dirLight</span><span class="p">,</span> <span class="n">norm</span><span class="p">,</span> <span class="n">viewDir</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="c1">// phase 2: Point lights
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NR_POINT_LIGHTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">        <span class="n">result</span> <span class="o">+=</span> <span class="n">CalcPointLight</span><span class="p">(</span><span class="n">pointLights</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">norm</span><span class="p">,</span> <span class="n">FragPos</span><span class="p">,</span> <span class="n">viewDir</span><span class="p">);</span>    
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="c1">// phase 3: Spot light
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="c1"></span>    <span class="c1">//result += CalcSpotLight(spotLight, norm, FragPos, viewDir);    
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="n">FragColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>Each light type adds its contribution to the resulting output color until all light sources are processed. The resulting color contains the color impact of all the light sources in the scene combined. We leave the CalcSpotLight function as an exercise for the reader.</p>
<p><note>There are lot of duplicated calculations in this approach spread out over the light type functions (e.g. calculating the reflect vector, diffuse and specular terms, and sampling the material textures) so there&rsquo;s room for optimization here.</note></p>
<p>Setting the uniforms for the directional light struct shouldn&rsquo;t be too unfamiliar, but you may be wondering how to set the uniform values of the point lights since the point light uniform is actually an array of PointLight structs. This isn&rsquo;t something we&rsquo;ve discussed before.</p>
<p>Luckily for us, it isn&rsquo;t too complicated. Setting the uniform values of an array of structs works just like setting the uniforms of a single struct, although this time we also have to define the appropriate index when querying the uniform&rsquo;s location:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">lightingShader</span><span class="p">.</span><span class="n">setFloat</span><span class="p">(</span><span class="s">&#34;pointLights[0].constant&#34;</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">);</span></span></span></code></pre></div><p>Here we index the first PointLight struct in the pointLights array and internally retrieve the location of its constant variable, which we set to <code>1.0</code>.</p>
<p>Let&rsquo;s not forget that we also need to define a position vector for each of the 4 point lights so let&rsquo;s spread them up a bit around the scene. We&rsquo;ll define another <code>glm::vec3</code> array that contains the pointlights&rsquo; positions:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">pointLightPositions</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">	<span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span> <span class="mf">0.7f</span><span class="p">,</span>  <span class="mf">0.2f</span><span class="p">,</span>  <span class="mf">2.0f</span><span class="p">),</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">	<span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span> <span class="mf">2.3f</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.3f</span><span class="p">,</span> <span class="o">-</span><span class="mf">4.0f</span><span class="p">),</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">	<span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="o">-</span><span class="mf">4.0f</span><span class="p">,</span>  <span class="mf">2.0f</span><span class="p">,</span> <span class="o">-</span><span class="mf">12.0f</span><span class="p">),</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">	<span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span> <span class="mf">0.0f</span><span class="p">,</span>  <span class="mf">0.0f</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.0f</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="p">};</span>  
</span></span></code></pre></div><p>Then we index the corresponding PointLight struct from the pointLights array and set its position attribute as one of the positions we just defined. Also be sure to now draw 4 light cubes instead of just 1. Simply create a different model matrix for each of the light objects just like we did with the containers.</p>
<p>If you&rsquo;d also use a flashlight, the result of all the combined lights looks something like this:</p>
<p><a href="#R-image-d5b92391be8f5d6a17f807dd0f588714" class="lightbox-link"><img src="./assets/multiple_lights_combined.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d5b92391be8f5d6a17f807dd0f588714"><img src="./assets/multiple_lights_combined.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>As you can see there appears to be some form of a global light (like a sun) somewhere in the sky, we have 4 lights scattered throughout the scene and a flashlight is visible from the player&rsquo;s perspective. Looks pretty neat doesn&rsquo;t it?</p>
<p>You can find the full source code of the final application <a href="https://learnopengl.com/code_viewer_gh.php?code=src/2.lighting/6.multiple_lights/multiple_lights.cpp" target="_blank">here</a>.</p>
<p>The image shows all the light sources set with the default light properties we&rsquo;ve used in the previous chapters, but if you play around with these values you can get pretty interesting results. Artists and level designers generally tweak all these lighting variables in a large editor to make sure the lighting matches the environment. Using our simple environment you can already create some pretty interesting visuals simply by tweaking the lights&rsquo; attributes:</p>
<p><a href="#R-image-5d201c6cb2d32a121d87d08fb00b7afa" class="lightbox-link"><img src="./assets/multiple_lights_atmospheres.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-5d201c6cb2d32a121d87d08fb00b7afa"><img src="./assets/multiple_lights_atmospheres.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>We also changed the clear color to better reflect the lighting. You can see that by simply adjusting some of the lighting parameters you can create completely different atmospheres.</p>
<p>By now you should have a pretty good understanding of lighting in OpenGL. With the knowledge so far we can already create interesting and visually rich environments and atmospheres. Try playing around with all the different values to create your own atmospheres.</p>
<h4 id="exercises-10">Exercises</h4>
<ul>
<li>Can you (sort of) re-create the different atmospheres of the last image by tweaking the light&rsquo;s attribute values? <a href="https://learnopengl.com/code_viewer_gh.php?code=src/2.lighting/6.multiple_lights_exercise1/multiple_lights_exercise1.cpp" target="_blank">solution</a>.</li>
</ul>
<h3 id="review-1">Review</h3>
<p>Congratulations on making it this far! I&rsquo;m not sure if you noticed, but over all the lighting chapters we learned nothing new about OpenGL itself aside from a few minor items like accessing uniform arrays. All of the lighting chapters so far were all about manipulating shaders using techniques and equations to achieve realistic lighting results. This again shows you the power of shaders. Shaders are extremely flexible and you witnessed first-hand that with just a few 3D vectors and some configurable variables we were able to create amazing graphics!</p>
<p>The last few chapters you learned about colors, the Phong lighting model (that includes ambient, diffuse and specular lighting), object materials, configurable light properties, diffuse and specular maps, different types of lights, and how to combine all the knowledge into a single fully lit scene. Be sure to experiment with different lights, material colors, light properties, and try to create your own environments with the help of a little bit of creativity.</p>
<p>In the next chapters we&rsquo;ll be adding more advanced geometry shapes to our scene that look really well in the lighting models we&rsquo;ve discussed.</p>
<h4 id="glossary-1">Glossary</h4>
<ul>
<li><code>Color vector</code>: a vector portraying most of the real world colors via a combination of red, green and blue components (abbreviated to <code>RGB</code>). The color of an object is the reflected color components that an object did not absorb.</li>
<li><code>Phong lighting model</code>: a model for approximating real-world lighting by computing an ambient, diffuse and specular component.</li>
<li><code>Ambient lighting</code>: approximation of global illumination by giving each object a small brightness so that objects aren&rsquo;t completely dark if not directly lit.</li>
<li><code>Diffuse shading</code>: lighting that gets stronger the more a vertex/fragment is aligned to a light source. Makes use of normal vectors to calculate the angles.</li>
<li><code>Normal vector</code>: a unit vector that is perpendicular to a surface.</li>
<li><code>Normal matrix</code>: a 3x3 matrix that is the model (or model-view) matrix without translation. It is also modified in such a way (inverse-transpose) that it keeps normal vectors facing in the correct direction when applying non-uniform scaling. Otherwise normal vectors get distorted when using non-uniform scaling.</li>
<li><code>Specular lighting</code>: sets a specular highlight the closer the viewer is looking at the reflection of a light source on a surface. Based on the viewer&rsquo;s direction, the light&rsquo;s direction and a shininess value that sets the amount of scattering of the highlight.</li>
<li><code>Phong shading</code>: the Phong lighting model applied in the fragment shader.</li>
<li><code>Gouraud shading</code>: the Phong lighting model applied in the vertex shader. Produces noticeable artifacts when using a small number of vertices. Gains efficiency for loss of visual quality.</li>
<li><code>GLSL struct</code>: a C-like struct that acts as a container for shader variables. Mostly used for organizing input, output, and uniforms.</li>
<li><code>Material</code>: the ambient, diffuse and specular color an object reflects. These set the colors an object has.</li>
<li><code>Light (properties)</code>: the ambient, diffuse and specular intensity of a light. These can take any color value and define at what color/intensity a light source shines for each specific Phong component.</li>
<li><code>Diffuse map</code>: a texture image that sets the diffuse color per fragment.</li>
<li><code>Specular map</code>: a texture map that sets the specular intensity/color per fragment. Allows for specular highlights only on certain areas of an object.</li>
<li><code>Directional light</code>: a light source with only a direction. It is modeled to be at an infinite distance which has the effect that all its light rays seem parallel and its direction vector thus stays the same over the entire scene.</li>
<li><code>Point light</code>: a light source with a location in a scene with light that fades out over distance.</li>
<li><code>Attenuation</code>: the process of light reducing its intensity over distance, used in point lights and spotlights.</li>
<li><code>Spotlight</code>: a light source that is defined by a cone in one specific direction.</li>
<li><code>Flashlight</code>: a spotlight positioned from the viewer&rsquo;s perspective.</li>
<li><code>GLSL uniform array</code>: an array of uniform values. Work just like a C-array, except that they can&rsquo;t be dynamically allocated.</li>
</ul>
<h2 id="model-loading">Model Loading</h2>
<h3 id="assimp">Assimp</h3>
<p>In all the scenes so far we&rsquo;ve been extensively playing with our little container friend, but over time, even our best friends can get a little boring. In bigger graphics applications, there are usually lots of complicated and interesting models that are much prettier to look at than a static container. However, unlike the container object, we can&rsquo;t really manually define all the vertices, normals, and texture coordinates of complicated shapes like houses, vehicles, or human-like characters. What we want instead, is to <em>import</em> these models into the application; models that were carefully designed by 3D artists in tools like <a href="http://www.blender.org/" target="_blank">Blender</a>, <a href="http://www.autodesk.nl/products/3ds-max/overview" target="_blank">3DS Max</a> or <a href="http://www.autodesk.com/products/autodesk-maya/overview" target="_blank">Maya</a>.</p>
<p>These so called 3D modeling tools allow artists to create complicated shapes and apply textures to them via a process called uv-mapping. The tools then automatically generate all the vertex coordinates, vertex normals, and texture coordinates while exporting them to a model file format we can use. This way, artists have an extensive toolkit to create high quality models without having to care too much about the technical details. All the technical aspects are hidden in the exported model file. We, as graphics programmers, <strong>do</strong> have to care about these technical details though.</p>
<p>It is our job to parse these exported model files and extract all the relevant information so we can store them in a format that OpenGL understands. A common issue is that there are dozens of different file formats where each exports the model data in its own unique way. Model formats like the <a href="http://en.wikipedia.org/wiki/Wavefront_.obj_file" target="_blank">Wavefront .obj</a> only contains model data with minor material information like model colors and diffuse/specular maps, while model formats like the XML-based <a href="http://en.wikipedia.org/wiki/COLLADA" target="_blank">Collada file format</a> are extremely extensive and contain models, lights, many types of materials, animation data, cameras, complete scene information, and much more. The wavefront object format is generally considered to be an easy-to-parse model format. It is recommended to visit the Wavefront&rsquo;s wiki page at least once to see how such a file format&rsquo;s data is structured. This should give you a basic perception of how model file formats are generally structured.</p>
<p>All by all, there are many different file formats where a common general structure between them usually does not exist. So if we want to import a model from these file formats, we&rsquo;d have to write an importer ourselves for each of the file formats we want to import. Luckily for us, there just happens to be a library for this.</p>
<h4 id="a-model-loading-library">A model loading library</h4>
<p>A very popular model importing library out there is called <a href="http://assimp.org/" target="_blank">Assimp</a> that stands for <em>Open Asset Import Library</em>. Assimp is able to import dozens of different model file formats (and export to some as well) by loading all the model&rsquo;s data into Assimp&rsquo;s generalized data structures. As soon as Assimp has loaded the model, we can retrieve all the data we need from Assimp&rsquo;s data structures. Because the data structure of Assimp stays the same, regardless of the type of file format we imported, it abstracts us from all the different file formats out there.</p>
<p>When importing a model via Assimp it loads the entire model into a <em>scene</em> object that contains all the data of the imported model/scene. Assimp then has a collection of nodes where each node contains indices to data stored in the scene object where each node can have any number of children. A (simplistic) model of Assimp&rsquo;s structure is shown below:</p>
<p><a href="#R-image-61feb05354a845314d3878b02ea234e5" class="lightbox-link"><img src="./assets/assimp_structure.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-61feb05354a845314d3878b02ea234e5"><img src="./assets/assimp_structure.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<ul>
<li>All the data of the scene/model is contained in the Scene object like all the materials and the meshes. It also contains a reference to the root node of the scene.</li>
<li>The Root node of the scene may contain children nodes (like all other nodes) and could have a set of indices that point to mesh data in the scene object&rsquo;s mMeshes array. The scene&rsquo;s mMeshes array contains the actual Mesh objects, the values in the mMeshes array of a node are only indices for the scene&rsquo;s meshes array.</li>
<li>A Mesh object itself contains all the relevant data required for rendering, think of vertex positions, normal vectors, texture coordinates, faces, and the material of the object.</li>
<li>A mesh contains several faces. A Face represents a render primitive of the object (triangles, squares, points). A face contains the indices of the vertices that form a primitive. Because the vertices and the indices are separated, this makes it easy for us to render via an index buffer (see <a href="https://learnopengl.com/Getting-started/Hello-Triangle" target="_blank">Hello Triangle</a>).</li>
<li>Finally a mesh also links to a Material object that hosts several functions to retrieve the material properties of an object. Think of colors and/or texture maps (like diffuse and specular maps).</li>
</ul>
<p>What we want to do is: first load an object into a Scene object, recursively retrieve the corresponding Mesh objects from each of the nodes (we recursively search each node&rsquo;s children), and process each Mesh object to retrieve the vertex data, indices, and its material properties. The result is then a collection of mesh data that we want to contain in a single <code>Model</code> object.</p>
<p><note><strong>Mesh</strong><br>When modeling objects in modeling toolkits, artists generally do not create an entire model out of a single shape. Usually, each model has several sub-models/shapes that it consists of. Each of those single shapes is called a mesh. Think of a human-like character: artists usually model the head, limbs, clothes, and weapons all as separate components, and the combined result of all these meshes represents the final model. A single mesh is the minimal representation of what we need to draw an object in OpenGL (vertex data, indices, and material properties). A model (usually) consists of several meshes.</note></p>
<p>In the <a href="https://learnopengl.com/Model-Loading/Mesh" target="_blank">next</a> chapters we&rsquo;ll create our own Model and Mesh class that load and store imported models using the structure we&rsquo;ve just described. If we then want to draw a model, we do not render the model as a whole, but we render all of the individual meshes that the model is composed of. However, before we can start importing models, we first need to actually include Assimp in our project.</p>
<h4 id="building-assimp">Building Assimp</h4>
<p>You can download Assimp from their <a href="https://github.com/assimp/assimp/blob/master/Build.md" target="_blank">GitHub</a> page and choose the corresponding version. For this writing, the Assimp version used was version <code>3.1.1</code>. It is advised to compile the libraries by yourself, since their pre-compiled libraries don&rsquo;t always work on all systems. Review the <a href="https://learnopengl.com/Getting-started/Creating-a-window" target="_blank">Creating a window</a> chapter if you forgot how to compile a library by yourself via CMake.</p>
<p>A few issues can come up while building Assimp, so I&rsquo;ll note them down here with their solutions in case any of you get the same errors:</p>
<ul>
<li>
<p>CMake continually gives errors while retrieving the configuration list about DirectX libraries missing, messages like:</p>
<div class="wrap-code highlight"><pre tabindex="0"><code>Could not locate DirectX
CMake Error at cmake-modules/FindPkgMacros.cmake:110 (message):
Required library DirectX not found! Install the library (including dev packages) 
and try again. If the library is already installed, set the missing variables 
manually in cmake.</code></pre></div><p>The solution here is to install the DirectX SDK in case you haven&rsquo;t installed this before. You can download the SDK from <a href="http://www.microsoft.com/en-us/download/details.aspx?id=6812" target="_blank">here</a>.</p>
</li>
<li>
<p>While installing the DirectX SDK, a possible error code of <code>s1023</code> could pop up. In that case you first want to de-install the C++ Redistributable package(s) before installing the SDK.</p>
</li>
</ul>
<p>Once the configuration is completed, you can generate a solution file, open it, and compile the libraries (either as a release version or a debug version, whatever floats your boat). Be sure to compile it for 64-bit as all LearnOpenGL code is 64 bit.</p>
<p>The default configuration builds Assimp as a dynamic library so we need to include the resulting DLL named <code>assimp.dll</code> (or with some post-fix) alongside the application&rsquo;s binaries. You can simply copy the DLL to the same folder where your application&rsquo;s executable is located.</p>
<p>After compiling the generated solution, the resulting library and DLL file are located in the <code>code/Debug</code> or <code>code/Release</code> folder. Then simply move the lib and DLL to their appropriate locations, link them from your solution, and be sure to copy Assimp&rsquo;s headers to your <code>include</code> directory (the header files are found in the <code>include</code> folder in the files downloaded from Assimp).</p>
<p>By now you should have compiled Assimp and linked it to your application. If you still received any unreported error, feel free to ask for help in the comments.</p>
<h3 id="mesh">Mesh</h3>
<p>With Assimp we can load many different models into the application, but once loaded they&rsquo;re all stored in Assimp&rsquo;s data structures. What we eventually want is to transform that data to a format that OpenGL understands so that we can render the objects. We learned from the previous chapter that a mesh represents a single drawable entity, so let&rsquo;s start by defining a mesh class of our own.</p>
<p>Let&rsquo;s review a bit of what we&rsquo;ve learned so far to think about what a mesh should minimally have as its data. A mesh should at least need a set of vertices, where each vertex contains a position vector, a normal vector, and a texture coordinate vector. A mesh should also contain indices for indexed drawing, and material data in the form of textures (diffuse/specular maps).</p>
<p>Now that we set the minimal requirements for a mesh class we can define a vertex in OpenGL:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">struct</span> <span class="nc">Vertex</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">    <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">Position</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">Normal</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="n">glm</span><span class="o">::</span><span class="n">vec2</span> <span class="n">TexCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="p">};</span></span></span></code></pre></div><p>We store each of the required vertex attributes in a struct called Vertex. Next to a Vertex struct we also want to organize the texture data in a Texture struct:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">struct</span> <span class="nc">Texture</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">id</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="n">string</span> <span class="n">type</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="p">};</span>  
</span></span></code></pre></div><p>We store the id of the texture and its type e.g. a diffuse or specular texture.</p>
<p>Knowing the actual representation of a vertex and a texture we can start defining the structure of the mesh class:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">class</span> <span class="nc">Mesh</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">        <span class="c1">// mesh data
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1"></span>        <span class="n">vector</span><span class="o">&lt;</span><span class="n">Vertex</span><span class="o">&gt;</span>       <span class="n">vertices</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">indices</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">        <span class="n">vector</span><span class="o">&lt;</span><span class="n">Texture</span><span class="o">&gt;</span>      <span class="n">textures</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        <span class="n">Mesh</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Vertex</span><span class="o">&gt;</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">indices</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">Texture</span><span class="o">&gt;</span> <span class="n">textures</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">        <span class="kt">void</span> <span class="nf">Draw</span><span class="p">(</span><span class="n">Shader</span> <span class="o">&amp;</span><span class="n">shader</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">        <span class="c1">//  render data
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="c1"></span>        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">VAO</span><span class="p">,</span> <span class="n">VBO</span><span class="p">,</span> <span class="n">EBO</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">
</span></span><span class="line"><span class="ln">14</span><span class="cl">        <span class="kt">void</span> <span class="nf">setupMesh</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="p">};</span>  
</span></span></code></pre></div><p>As you can see, the class isn&rsquo;t too complicated. In the constructor we give the mesh all the necessary data, we initialize the buffers in the setupMesh function, and finally draw the mesh via the Draw function. Note that we give a shader to the Draw function; by passing the shader to the mesh we can set several uniforms before drawing (like linking samplers to texture units).</p>
<p>The function content of the constructor is pretty straightforward. We simply set the class&rsquo;s public variables with the constructor&rsquo;s corresponding argument variables. We also call the setupMesh function in the constructor:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">Mesh</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Vertex</span><span class="o">&gt;</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">indices</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">Texture</span><span class="o">&gt;</span> <span class="n">textures</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="k">this</span><span class="o">-&gt;</span><span class="n">vertices</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="k">this</span><span class="o">-&gt;</span><span class="n">indices</span> <span class="o">=</span> <span class="n">indices</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">    <span class="k">this</span><span class="o">-&gt;</span><span class="n">textures</span> <span class="o">=</span> <span class="n">textures</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">
</span></span><span class="line"><span class="ln">7</span><span class="cl">    <span class="n">setupMesh</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">8</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>Nothing special going on here. Let&rsquo;s delve right into the setupMesh function now.</p>
<h4 id="initialization">Initialization</h4>
<p>Thanks to the constructor we now have large lists of mesh data that we can use for rendering. We do need to setup the appropriate buffers and specify the vertex shader layout via vertex attribute pointers. By now you should have no trouble with these concepts, but we&rsquo;ve spiced it up a bit this time with the introduction of vertex data in structs:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="nf">setupMesh</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="n">glGenVertexArrays</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">VAO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="n">glGenBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">VBO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="n">glGenBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">EBO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">VAO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">VBO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">vertices</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Vertex</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">GL_STATIC_DRAW</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">11</span><span class="cl">
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ELEMENT_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">EBO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ELEMENT_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">indices</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">),</span> 
</span></span><span class="line"><span class="ln">14</span><span class="cl">                 <span class="o">&amp;</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">GL_STATIC_DRAW</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="c1">// vertex positions
</span></span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="c1"></span>    <span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>	
</span></span><span class="line"><span class="ln">18</span><span class="cl">    <span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Vertex</span><span class="p">),</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">    <span class="c1">// vertex normals
</span></span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="c1"></span>    <span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>	
</span></span><span class="line"><span class="ln">21</span><span class="cl">    <span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Vertex</span><span class="p">),</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">offsetof</span><span class="p">(</span><span class="n">Vertex</span><span class="p">,</span> <span class="n">Normal</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">    <span class="c1">// vertex texture coords
</span></span></span><span class="line"><span class="ln">23</span><span class="cl"><span class="c1"></span>    <span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>	
</span></span><span class="line"><span class="ln">24</span><span class="cl">    <span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Vertex</span><span class="p">),</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">offsetof</span><span class="p">(</span><span class="n">Vertex</span><span class="p">,</span> <span class="n">TexCoords</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl">
</span></span><span class="line"><span class="ln">26</span><span class="cl">    <span class="n">glBindVertexArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>The code is not much different from what you&rsquo;d expect, but a few little tricks were used with the help of the Vertex struct.</p>
<p>Structs have a great property in C++ that their memory layout is sequential. That is, if we were to represent a struct as an array of data, it would only contain the struct&rsquo;s variables in sequential order which directly translates to a float (actually byte) array that we want for an array buffer. For example, if we have a filled Vertex struct, its memory layout would be equal to:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">Vertex</span> <span class="n">vertex</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">vertex</span><span class="p">.</span><span class="n">Position</span>  <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.2f</span><span class="p">,</span> <span class="mf">0.4f</span><span class="p">,</span> <span class="mf">0.6f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">vertex</span><span class="p">.</span><span class="n">Normal</span>    <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="n">vertex</span><span class="p">.</span><span class="n">TexCoords</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec2</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="c1">// = [0.2f, 0.4f, 0.6f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f];
</span></span></span></code></pre></div><p>Thanks to this useful property we can directly pass a pointer to a large list of Vertex structs as the buffer&rsquo;s data and they translate perfectly to what glBufferData expects as its argument:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">vertices</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Vertex</span><span class="p">),</span> <span class="n">vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">GL_STATIC_DRAW</span><span class="p">);</span>    
</span></span></code></pre></div><p>Naturally the <code>sizeof</code> operator can also be used on the struct for the appropriate size in bytes. This should be <code>32</code> bytes (<code>8</code> floats * <code>4</code> bytes each).</p>
<p>Another great use of structs is a preprocessor directive called <code>offsetof(s,m)</code> that takes as its first argument a struct and as its second argument a variable name of the struct. The macro returns the byte offset of that variable from the start of the struct. This is perfect for defining the offset parameter of the glVertexAttribPointer function:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Vertex</span><span class="p">),</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">offsetof</span><span class="p">(</span><span class="n">Vertex</span><span class="p">,</span> <span class="n">Normal</span><span class="p">));</span>  
</span></span></code></pre></div><p>The offset is now defined using the offsetof macro that, in this case, sets the byte offset of the normal vector equal to the byte offset of the normal attribute in the struct which is <code>3</code> floats and thus <code>12</code> bytes.</p>
<p>Using a struct like this doesn&rsquo;t only get us more readable code, but also allows us to easily extend the structure. If we want another vertex attribute we can simply add it to the struct and due to its flexible nature, the rendering code won&rsquo;t break.</p>
<h4 id="rendering-1">Rendering</h4>
<p>The last function we need to define for the Mesh class to be complete is its Draw function. Before rendering the mesh, we first want to bind the appropriate textures before calling glDrawElements. However, this is somewhat difficult since we don&rsquo;t know from the start how many (if any) textures the mesh has and what type they may have. So how do we set the texture units and samplers in the shaders?</p>
<p>To solve the issue we&rsquo;re going to assume a certain naming convention: each diffuse texture is named <code>texture_diffuseN</code>, and each specular texture should be named <code>texture_specularN</code> where <code>N</code> is any number ranging from <code>1</code> to the maximum number of texture samplers allowed. Let&rsquo;s say we have 3 diffuse textures and 2 specular textures for a particular mesh, their texture samplers should then be called:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">texture_diffuse1</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">texture_diffuse2</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">texture_diffuse3</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">texture_specular1</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">texture_specular2</span><span class="p">;</span></span></span></code></pre></div><p>By this convention we can define as many texture samplers as we want in the shaders (up to OpenGL&rsquo;s maximum) and if a mesh actually does contain (so many) textures, we know what their names are going to be. By this convention we can process any amount of textures on a single mesh and the shader developer is free to use as many of those as he wants by defining the proper samplers.</p>
<p><note>There are many solutions to problems like this and if you don&rsquo;t like this particular solution it is up to you to get creative and come up with your own approach.</note></p>
<p>The resulting drawing code then becomes:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="nf">Draw</span><span class="p">(</span><span class="n">Shader</span> <span class="o">&amp;</span><span class="n">shader</span><span class="p">)</span> 
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">diffuseNr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">specularNr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">textures</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">        <span class="n">glActiveTexture</span><span class="p">(</span><span class="n">GL_TEXTURE0</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span> <span class="c1">// activate proper texture unit before binding
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="c1"></span>        <span class="c1">// retrieve texture number (the N in diffuse_textureN)
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1"></span>        <span class="n">string</span> <span class="n">number</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">        <span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="n">textures</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">type</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="s">&#34;texture_diffuse&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">            <span class="n">number</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">diffuseNr</span><span class="o">++</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">        <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="s">&#34;texture_specular&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">            <span class="n">number</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">specularNr</span><span class="o">++</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">
</span></span><span class="line"><span class="ln">16</span><span class="cl">        <span class="n">shader</span><span class="p">.</span><span class="n">setInt</span><span class="p">((</span><span class="s">&#34;material.&#34;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="n">number</span><span class="p">).</span><span class="n">c_str</span><span class="p">(),</span> <span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">        <span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">textures</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">id</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">    <span class="n">glActiveTexture</span><span class="p">(</span><span class="n">GL_TEXTURE0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">
</span></span><span class="line"><span class="ln">21</span><span class="cl">    <span class="c1">// draw mesh
</span></span></span><span class="line"><span class="ln">22</span><span class="cl"><span class="c1"></span>    <span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">VAO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">    <span class="n">glDrawElements</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">,</span> <span class="n">indices</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">GL_UNSIGNED_INT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">    <span class="n">glBindVertexArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>We first calculate the N-component per texture type and concatenate it to the texture&rsquo;s type string to get the appropriate uniform name. We then locate the appropriate sampler, give it the location value to correspond with the currently active texture unit, and bind the texture. This is also the reason we need the shader in the Draw function.</p>
<p>We also added <code>&quot;material.&quot;</code> to the resulting uniform name because we usually store the textures in a material struct (this may differ per implementation).</p>
<p><note>Note that we increment the diffuse and specular counters the moment we convert them to <code>string</code>. In C++ the increment call: <code>variable++</code> returns the variable as is and <strong>then</strong> increments the variable while <code>++variable</code> <strong>first</strong> increments the variable and <strong>then</strong> returns it. In our case the value passed to <code>std::string</code> is the original counter value. After that the value is incremented for the next round.</note></p>
<p>You can find the full source code of the Mesh class <a href="https://learnopengl.com/code_viewer_gh.php?code=includes/learnopengl/mesh.h" target="_blank">here</a>.</p>
<p>The Mesh class we just defined is an abstraction for many of the topics we&rsquo;ve discussed in the early chapters. In the <a href="https://learnopengl.com/Model-Loading/Model" target="_blank">next</a> chapter we&rsquo;ll create a model that acts as a container for several mesh objects and implements Assimp&rsquo;s loading interface.</p>
<h3 id="model">Model</h3>
<p>Now it is time to get our hands dirty with Assimp and start creating the actual loading and translation code. The goal of this chapter is to create another class that represents a model in its entirety, that is, a model that contains multiple meshes, possibly with multiple textures. A house, that contains a wooden balcony, a tower, and perhaps a swimming pool, could still be loaded as a single model. We&rsquo;ll load the model via Assimp and translate it to multiple Mesh objects we&rsquo;ve created in the <a href="https://learnopengl.com/Model-Loading/Mesh" target="_blank">previous</a> chapter.</p>
<p>Without further ado, I present you the class structure of the Model class:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">class</span> <span class="nc">Model</span> 
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">        <span class="n">Model</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">            <span class="n">loadModel</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        <span class="kt">void</span> <span class="nf">Draw</span><span class="p">(</span><span class="n">Shader</span> <span class="o">&amp;</span><span class="n">shader</span><span class="p">);</span>	
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">        <span class="c1">// model data
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="c1"></span>        <span class="n">vector</span><span class="o">&lt;</span><span class="n">Mesh</span><span class="o">&gt;</span> <span class="n">meshes</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">        <span class="n">string</span> <span class="n">directory</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">
</span></span><span class="line"><span class="ln">14</span><span class="cl">        <span class="kt">void</span> <span class="nf">loadModel</span><span class="p">(</span><span class="n">string</span> <span class="n">path</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">        <span class="kt">void</span> <span class="nf">processNode</span><span class="p">(</span><span class="n">aiNode</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="k">const</span> <span class="n">aiScene</span> <span class="o">*</span><span class="n">scene</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">        <span class="n">Mesh</span> <span class="nf">processMesh</span><span class="p">(</span><span class="n">aiMesh</span> <span class="o">*</span><span class="n">mesh</span><span class="p">,</span> <span class="k">const</span> <span class="n">aiScene</span> <span class="o">*</span><span class="n">scene</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">        <span class="n">vector</span><span class="o">&lt;</span><span class="n">Texture</span><span class="o">&gt;</span> <span class="n">loadMaterialTextures</span><span class="p">(</span><span class="n">aiMaterial</span> <span class="o">*</span><span class="n">mat</span><span class="p">,</span> <span class="n">aiTextureType</span> <span class="n">type</span><span class="p">,</span> 
</span></span><span class="line"><span class="ln">18</span><span class="cl">                                             <span class="n">string</span> <span class="n">typeName</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="p">};</span></span></span></code></pre></div><p>The Model class contains a vector of Mesh objects and requires us to give it a file location in its constructor. It then loads the file right away via the loadModel function that is called in the constructor. The private functions are all designed to process a part of Assimp&rsquo;s import routine and we&rsquo;ll cover them shortly. We also store the directory of the file path that we&rsquo;ll later need when loading textures.</p>
<p>The Draw function is nothing special and basically loops over each of the meshes to call their respective Draw function:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">void</span> <span class="nf">Draw</span><span class="p">(</span><span class="n">Shader</span> <span class="o">&amp;</span><span class="n">shader</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">meshes</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">        <span class="n">meshes</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Draw</span><span class="p">(</span><span class="n">shader</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><h4 id="importing-a-3d-model-into-opengl">Importing a 3D model into OpenGL</h4>
<p>To import a model and translate it to our own structure, we first need to include the appropriate headers of Assimp:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;assimp/Importer.hpp&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;assimp/scene.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;assimp/postprocess.h&gt;</span></span></span></code></pre></div><p>The first function we&rsquo;re calling is loadModel, that&rsquo;s directly called from the constructor. Within loadModel, we use Assimp to load the model into a data structure of Assimp called a scene object. You may remember from the <a href="https://learnopengl.com/Model-Loading/Assimp" target="_blank">first</a> chapter of the model loading series that this is the root object of Assimp&rsquo;s data interface. Once we have the scene object, we can access all the data we need from the loaded model.</p>
<p>The great thing about Assimp is that it neatly abstracts from all the technical details of loading all the different file formats and does all this with a single one-liner:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">Assimp</span><span class="o">::</span><span class="n">Importer</span> <span class="n">importer</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="k">const</span> <span class="n">aiScene</span> <span class="o">*</span><span class="n">scene</span> <span class="o">=</span> <span class="n">importer</span><span class="p">.</span><span class="n">ReadFile</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">aiProcess_Triangulate</span> <span class="o">|</span> <span class="n">aiProcess_FlipUVs</span><span class="p">);</span> 
</span></span></code></pre></div><p>We first declare an Importer object from Assimp&rsquo;s namespace and then call its ReadFile function. The function expects a file path and several post-processing options as its second argument. Assimp allows us to specify several options that forces Assimp to do extra calculations/operations on the imported data. By setting aiProcess_Triangulate we tell Assimp that if the model does not (entirely) consist of triangles, it should transform all the model&rsquo;s primitive shapes to triangles first. The aiProcess_FlipUVs flips the texture coordinates on the y-axis where necessary during processing (you may remember from the <a href="https://learnopengl.com/Getting-started/Textures" target="_blank">Textures</a> chapter that most images in OpenGL were reversed around the y-axis; this little postprocessing option fixes that for us). A few other useful options are:</p>
<ul>
<li>aiProcess_GenNormals: creates normal vectors for each vertex if the model doesn&rsquo;t contain normal vectors.</li>
<li>aiProcess_SplitLargeMeshes: splits large meshes into smaller sub-meshes which is useful if your rendering has a maximum number of vertices allowed and can only process smaller meshes.</li>
<li>aiProcess_OptimizeMeshes: does the reverse by trying to join several meshes into one larger mesh, reducing drawing calls for optimization.</li>
</ul>
<p>Assimp provides a great set of postprocessing options and you can find all of them <a href="http://assimp.sourceforge.net/lib_html/postprocess_8h.html" target="_blank">here</a>. Loading a model via Assimp is (as you can see) surprisingly easy. The hard work is in using the returned scene object to translate the loaded data to an array of <code>Mesh</code> objects.</p>
<p>The complete loadModel function is listed here:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="nf">loadModel</span><span class="p">(</span><span class="n">string</span> <span class="n">path</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="n">Assimp</span><span class="o">::</span><span class="n">Importer</span> <span class="n">import</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="k">const</span> <span class="n">aiScene</span> <span class="o">*</span><span class="n">scene</span> <span class="o">=</span> <span class="n">import</span><span class="p">.</span><span class="n">ReadFile</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">aiProcess_Triangulate</span> <span class="o">|</span> <span class="n">aiProcess_FlipUVs</span><span class="p">);</span>	
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">	
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">scene</span> <span class="o">||</span> <span class="n">scene</span><span class="o">-&gt;</span><span class="n">mFlags</span> <span class="o">&amp;</span> <span class="n">AI_SCENE_FLAGS_INCOMPLETE</span> <span class="o">||</span> <span class="o">!</span><span class="n">scene</span><span class="o">-&gt;</span><span class="n">mRootNode</span><span class="p">)</span> 
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;ERROR::ASSIMP::&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">import</span><span class="p">.</span><span class="n">GetErrorString</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="n">directory</span> <span class="o">=</span> <span class="n">path</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">path</span><span class="p">.</span><span class="n">find_last_of</span><span class="p">(</span><span class="sc">&#39;/&#39;</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="n">processNode</span><span class="p">(</span><span class="n">scene</span><span class="o">-&gt;</span><span class="n">mRootNode</span><span class="p">,</span> <span class="n">scene</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>After we load the model, we check if the scene and the root node of the scene are not null and check one of its flags to see if the returned data is incomplete. If any of these error conditions are met, we report the error retrieved from the importer&rsquo;s GetErrorString function and return. We also retrieve the directory path of the given file path.</p>
<p>If nothing went wrong, we want to process all of the scene&rsquo;s nodes. We pass the first node (root node) to the recursive processNode function. Because each node (possibly) contains a set of children we want to first process the node in question, and then continue processing all the node&rsquo;s children and so on. This fits a recursive structure, so we&rsquo;ll be defining a recursive function. A recursive function is a function that does some processing and recursively calls the same function with different parameters until a certain condition is met. In our case the exit condition is met when all nodes have been processed.</p>
<p>As you may remember from Assimp&rsquo;s structure, each node contains a set of mesh indices where each index points to a specific mesh located in the scene object. We thus want to retrieve these mesh indices, retrieve each mesh, process each mesh, and then do this all again for each of the node&rsquo;s children nodes. The content of the processNode function is shown below:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="nf">processNode</span><span class="p">(</span><span class="n">aiNode</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="k">const</span> <span class="n">aiScene</span> <span class="o">*</span><span class="n">scene</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="c1">// process all the node&#39;s meshes (if any)
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">mNumMeshes</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">        <span class="n">aiMesh</span> <span class="o">*</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">scene</span><span class="o">-&gt;</span><span class="n">mMeshes</span><span class="p">[</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">mMeshes</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span> 
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">        <span class="n">meshes</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">processMesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">scene</span><span class="p">));</span>			
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="c1">// then do the same for each of its children
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">mNumChildren</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">        <span class="n">processNode</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">mChildren</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">scene</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>We first check each of the node&rsquo;s mesh indices and retrieve the corresponding mesh by indexing the scene&rsquo;s mMeshes array. The returned mesh is then passed to the processMesh function that returns a Mesh object that we can store in the meshes list/vector.</p>
<p>Once all the meshes have been processed, we iterate through all of the node&rsquo;s children and call the same processNode function for each its children. Once a node no longer has any children, the recursion stops.</p>
<p><note>A careful reader may have noticed that we could forget about processing any of the nodes and simply loop through all of the scene&rsquo;s meshes directly, without doing all this complicated stuff with indices. The reason we&rsquo;re doing this is that the initial idea for using nodes like this is that it defines a parent-child relation between meshes. By recursively iterating through these relations, we can define certain meshes to be parents of other meshes.
An example use case for such a system is when you want to translate a car mesh and make sure that all its children (like an engine mesh, a steering wheel mesh, and its tire meshes) translate as well; such a system is easily created using parent-child relations.<br>Right now however we&rsquo;re not using such a system, but it is generally recommended to stick with this approach for whenever you want extra control over your mesh data. These node-like relations are after all defined by the artists who created the models.</note></p>
<p>The next step is to process Assimp&rsquo;s data into the Mesh class from the previous chapter.</p>
<h5 id="assimp-to-mesh">Assimp to Mesh</h5>
<p>Translating an <code>aiMesh</code> object to a mesh object of our own is not too difficult. All we need to do, is access each of the mesh&rsquo;s relevant properties and store them in our own object. The general structure of the processMesh function then becomes:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">Mesh</span> <span class="nf">processMesh</span><span class="p">(</span><span class="n">aiMesh</span> <span class="o">*</span><span class="n">mesh</span><span class="p">,</span> <span class="k">const</span> <span class="n">aiScene</span> <span class="o">*</span><span class="n">scene</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Vertex</span><span class="o">&gt;</span> <span class="n">vertices</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">indices</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Texture</span><span class="o">&gt;</span> <span class="n">textures</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mesh</span><span class="o">-&gt;</span><span class="n">mNumVertices</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">        <span class="n">Vertex</span> <span class="n">vertex</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">        <span class="c1">// process vertex positions, normals and texture coordinates
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="c1"></span>        <span class="p">[...]</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">        <span class="n">vertices</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">vertex</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="c1">// process indices
</span></span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="c1"></span>    <span class="p">[...]</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="c1">// process material
</span></span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">mesh</span><span class="o">-&gt;</span><span class="n">mMaterialIndex</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">        <span class="p">[...]</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">
</span></span><span class="line"><span class="ln">22</span><span class="cl">    <span class="k">return</span> <span class="n">Mesh</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">textures</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>Processing a mesh is a 3-part process: retrieve all the vertex data, retrieve the mesh&rsquo;s indices, and finally retrieve the relevant material data. The processed data is stored in one of the <code>3</code> vectors and from those a Mesh is created and returned to the function&rsquo;s caller.</p>
<p>Retrieving the vertex data is pretty simple: we define a Vertex struct that we add to the vertices array after each loop iteration. We loop for as much vertices there exist within the mesh (retrieved via <code>mesh-&gt;mNumVertices</code>). Within the iteration we want to fill this struct with all the relevant data. For vertex positions this is done as follows:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">vector</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">vector</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">-&gt;</span><span class="n">mVertices</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">vector</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">-&gt;</span><span class="n">mVertices</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="n">vector</span><span class="p">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">-&gt;</span><span class="n">mVertices</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">z</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="n">vertex</span><span class="p">.</span><span class="n">Position</span> <span class="o">=</span> <span class="n">vector</span><span class="p">;</span></span></span></code></pre></div><p>Note that we define a temporary <code>vec3</code> for transferring Assimp&rsquo;s data to. This is necessary as Assimp maintains its own data types for vector, matrices, strings etc. and they don&rsquo;t convert that well to glm&rsquo;s data types.</p>
<p><note>Assimp calls their vertex position array mVertices which isn&rsquo;t the most intuitive name.</note></p>
<p>The procedure for normals should come as no surprise now:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">vector</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">-&gt;</span><span class="n">mNormals</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">vector</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">-&gt;</span><span class="n">mNormals</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">vector</span><span class="p">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">-&gt;</span><span class="n">mNormals</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">z</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="n">vertex</span><span class="p">.</span><span class="n">Normal</span> <span class="o">=</span> <span class="n">vector</span><span class="p">;</span>  
</span></span></code></pre></div><p>Texture coordinates are roughly the same, but Assimp allows a model to have up to 8 different texture coordinates per vertex. We&rsquo;re not going to use 8, we only care about the first set of texture coordinates. We&rsquo;ll also want to check if the mesh actually contains texture coordinates (which may not be always the case):</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">if</span><span class="p">(</span><span class="n">mesh</span><span class="o">-&gt;</span><span class="n">mTextureCoords</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="c1">// does the mesh contain texture coordinates?
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="n">glm</span><span class="o">::</span><span class="n">vec2</span> <span class="n">vec</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="n">vec</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">-&gt;</span><span class="n">mTextureCoords</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">x</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">5</span><span class="cl">    <span class="n">vec</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">-&gt;</span><span class="n">mTextureCoords</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">    <span class="n">vertex</span><span class="p">.</span><span class="n">TexCoords</span> <span class="o">=</span> <span class="n">vec</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">8</span><span class="cl"><span class="k">else</span>
</span></span><span class="line"><span class="ln">9</span><span class="cl">    <span class="n">vertex</span><span class="p">.</span><span class="n">TexCoords</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec2</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">);</span>  
</span></span></code></pre></div><p>The vertex struct is now completely filled with the required vertex attributes and we can push it to the back of the vertices vector at the end of the iteration. This process is repeated for each of the mesh&rsquo;s vertices.</p>
<h5 id="indices">Indices</h5>
<p>Assimp&rsquo;s interface defines each mesh as having an array of faces, where each face represents a single primitive, which in our case (due to the aiProcess_Triangulate option) are always triangles. A face contains the indices of the vertices we need to draw in what order for its primitive. So if we iterate over all the faces and store all the face&rsquo;s indices in the indices vector we&rsquo;re all set:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mesh</span><span class="o">-&gt;</span><span class="n">mNumFaces</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="n">aiFace</span> <span class="n">face</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">-&gt;</span><span class="n">mFaces</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">face</span><span class="p">.</span><span class="n">mNumIndices</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">        <span class="n">indices</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">face</span><span class="p">.</span><span class="n">mIndices</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>After the outer loop has finished, we now have a complete set of vertices and index data for drawing the mesh via glDrawElements. However, to finish the discussion and to add some detail to the mesh, we want to process the mesh&rsquo;s material as well.</p>
<h5 id="material">Material</h5>
<p>Similar to nodes, a mesh only contains an index to a material object. To retrieve the material of a mesh, we need to index the scene&rsquo;s mMaterials array. The mesh&rsquo;s material index is set in its mMaterialIndex property, which we can also query to check if the mesh contains a material or not:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">if</span><span class="p">(</span><span class="n">mesh</span><span class="o">-&gt;</span><span class="n">mMaterialIndex</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="n">aiMaterial</span> <span class="o">*</span><span class="n">material</span> <span class="o">=</span> <span class="n">scene</span><span class="o">-&gt;</span><span class="n">mMaterials</span><span class="p">[</span><span class="n">mesh</span><span class="o">-&gt;</span><span class="n">mMaterialIndex</span><span class="p">];</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Texture</span><span class="o">&gt;</span> <span class="n">diffuseMaps</span> <span class="o">=</span> <span class="n">loadMaterialTextures</span><span class="p">(</span><span class="n">material</span><span class="p">,</span> 
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">                                        <span class="n">aiTextureType_DIFFUSE</span><span class="p">,</span> <span class="s">&#34;texture_diffuse&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="n">textures</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">textures</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">diffuseMaps</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">diffuseMaps</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Texture</span><span class="o">&gt;</span> <span class="n">specularMaps</span> <span class="o">=</span> <span class="n">loadMaterialTextures</span><span class="p">(</span><span class="n">material</span><span class="p">,</span> 
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">                                        <span class="n">aiTextureType_SPECULAR</span><span class="p">,</span> <span class="s">&#34;texture_specular&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="n">textures</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">textures</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">specularMaps</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">specularMaps</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>We first retrieve the <code>aiMaterial</code> object from the scene&rsquo;s mMaterials array. Then we want to load the mesh&rsquo;s diffuse and/or specular textures. A material object internally stores an array of texture locations for each texture type. The different texture types are all prefixed with <code>aiTextureType_</code>. We use a helper function called loadMaterialTextures to retrieve, load, and initialize the textures from the material. The function returns a vector of Texture structs that we store at the end of the model&rsquo;s textures vector.</p>
<p>The loadMaterialTextures function iterates over all the texture locations of the given texture type, retrieves the texture&rsquo;s file location and then loads and generates the texture and stores the information in a Vertex struct. It looks like this:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="n">Texture</span><span class="o">&gt;</span> <span class="n">loadMaterialTextures</span><span class="p">(</span><span class="n">aiMaterial</span> <span class="o">*</span><span class="n">mat</span><span class="p">,</span> <span class="n">aiTextureType</span> <span class="n">type</span><span class="p">,</span> <span class="n">string</span> <span class="n">typeName</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Texture</span><span class="o">&gt;</span> <span class="n">textures</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mat</span><span class="o">-&gt;</span><span class="n">GetTextureCount</span><span class="p">(</span><span class="n">type</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">        <span class="n">aiString</span> <span class="n">str</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">        <span class="n">mat</span><span class="o">-&gt;</span><span class="n">GetTexture</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">str</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        <span class="n">Texture</span> <span class="n">texture</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">        <span class="n">texture</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">TextureFromFile</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">C_Str</span><span class="p">(),</span> <span class="n">directory</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">        <span class="n">texture</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">typeName</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">        <span class="n">texture</span><span class="p">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">str</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">        <span class="n">textures</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">texture</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="k">return</span> <span class="n">textures</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>We first check the amount of textures stored in the material via its GetTextureCount function that expects one of the texture types we&rsquo;ve given. We retrieve each of the texture&rsquo;s file locations via the GetTexture function that stores the result in an <code>aiString</code>. We then use another helper function called TextureFromFile that loads a texture (with <code>stb_image.h</code>) for us and returns the texture&rsquo;s ID. You can check the complete code listing at the end for its content if you&rsquo;re not sure how such a function is written.</p>
<p><note>Note that we make the assumption that texture file paths in model files are local to the actual model object e.g. in the same directory as the location of the model itself. We can then simply concatenate the texture location string and the directory string we retrieved earlier (in the loadModel function) to get the complete texture path (that&rsquo;s why the GetTexture function also needs the directory string).<br>Some models found over the internet use absolute paths for their texture locations, which won&rsquo;t work on each machine. In that case you probably want to manually edit the file to use local paths for the textures (if possible).</note></p>
<p>And that is all there is to importing a model with Assimp.</p>
<h4 id="an-optimization">An optimization</h4>
<p>We&rsquo;re not completely done yet, since there is still a large (but not completely necessary) optimization we want to make. Most scenes re-use several of their textures onto several meshes; think of a house again that has a granite texture for its walls. This texture could also be applied to the floor, its ceilings, the staircase, perhaps a table, and maybe even a small well close by. Loading textures is not a cheap operation and in our current implementation a new texture is loaded and generated for each mesh, even though the exact same texture could have been loaded several times before. This quickly becomes the bottleneck of your model loading implementation.</p>
<p>So we&rsquo;re going to add one small tweak to the model code by storing all of the loaded textures globally. Wherever we want to load a texture, we first check if it hasn&rsquo;t been loaded already. If so, we take that texture and skip the entire loading routine, saving us a lot of processing power. To be able to compare textures we need to store their path as well:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">struct</span> <span class="nc">Texture</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">id</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="n">string</span> <span class="n">type</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="n">string</span> <span class="n">path</span><span class="p">;</span>  <span class="c1">// we store the path of the texture to compare with other textures
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="c1"></span><span class="p">};</span></span></span></code></pre></div><p>Then we store all the loaded textures in another vector declared at the top of the model&rsquo;s class file as a private variable:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="n">Texture</span><span class="o">&gt;</span> <span class="n">textures_loaded</span><span class="p">;</span> 
</span></span></code></pre></div><p>In the loadMaterialTextures function, we want to compare the texture path with all the textures in the textures_loaded vector to see if the current texture path equals any of those. If so, we skip the texture loading/generation part and simply use the located texture struct as the mesh&rsquo;s texture. The (updated) function is shown below:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="n">Texture</span><span class="o">&gt;</span> <span class="n">loadMaterialTextures</span><span class="p">(</span><span class="n">aiMaterial</span> <span class="o">*</span><span class="n">mat</span><span class="p">,</span> <span class="n">aiTextureType</span> <span class="n">type</span><span class="p">,</span> <span class="n">string</span> <span class="n">typeName</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Texture</span><span class="o">&gt;</span> <span class="n">textures</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mat</span><span class="o">-&gt;</span><span class="n">GetTextureCount</span><span class="p">(</span><span class="n">type</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">        <span class="n">aiString</span> <span class="n">str</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">        <span class="n">mat</span><span class="o">-&gt;</span><span class="n">GetTexture</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">str</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        <span class="kt">bool</span> <span class="n">skip</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">textures_loaded</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">strcmp</span><span class="p">(</span><span class="n">textures_loaded</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">path</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">str</span><span class="p">.</span><span class="n">C_Str</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">                <span class="n">textures</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">textures_loaded</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">                <span class="n">skip</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">15</span><span class="cl">                <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">skip</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">        <span class="p">{</span>   <span class="c1">// if texture hasn&#39;t been loaded already, load it
</span></span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="c1"></span>            <span class="n">Texture</span> <span class="n">texture</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">            <span class="n">texture</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">TextureFromFile</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">C_Str</span><span class="p">(),</span> <span class="n">directory</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">            <span class="n">texture</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">typeName</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">            <span class="n">texture</span><span class="p">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">str</span><span class="p">.</span><span class="n">C_Str</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">            <span class="n">textures</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">texture</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl">            <span class="n">textures_loaded</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">texture</span><span class="p">);</span> <span class="c1">// add to loaded textures
</span></span></span><span class="line"><span class="ln">26</span><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">28</span><span class="cl">    <span class="k">return</span> <span class="n">textures</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">29</span><span class="cl"><span class="p">}</span> 
</span></span></code></pre></div><p><warning>Some versions of Assimp tend to load models quite slow when using the debug version and/or the debug mode of your IDE, so be sure to test it out with release versions as well if you run into slow loading times.</warning></p>
<p>You can find the complete source code of the Model class <a href="https://learnopengl.com/code_viewer_gh.php?code=includes/learnopengl/model.h" target="_blank">here</a>.</p>
<h4 id="no-more-containers">No more containers!</h4>
<p>So let&rsquo;s give our implementation a spin by actually importing a model created by genuine artists, not something done by the creative genius that I am. Because I don&rsquo;t want to give myself too much credit, I&rsquo;ll occasionally allow some other artists to join the ranks and this time we&rsquo;re going to load this amazing <a href="https://sketchfab.com/3d-models/survival-guitar-backpack-low-poly-799f8c4511f84fab8c3f12887f7e6b36" target="_blank">Survival Guitar Backpack</a> by Berk Gedik. I&rsquo;ve modified the material and paths a bit so it works directly with the way we&rsquo;ve set up the model loading. The model is exported as a <code>.obj</code> file together with a <code>.mtl</code> file that links to the model&rsquo;s diffuse, specular, and normal maps (we&rsquo;ll get to those later). You can download the adjusted model for this chapter <a href="https://learnopengl.com/data/models/backpack.zip" target="_blank">here</a>. Note that there&rsquo;s a few extra texture types we won&rsquo;t be using yet, and that all the textures and the model file(s) should be located in the same directory for the textures to load.</p>
<p><note>The modified version of the backpack uses local relative texture paths, and renamed the albedo and metallic textures to diffuse and specular respectively.</note></p>
<p>Now, declare a Model object and pass in the model&rsquo;s file location. The model should then automatically load and (if there were no errors) render the object in the render loop using its Draw function and that is it. No more buffer allocations, attribute pointers, and render commands, just a simple one-liner. If you create a simple set of shaders where the fragment shader only outputs the object&rsquo;s diffuse texture, the result looks a bit like this:</p>
<p><a href="#R-image-2892d8fc1f4ce51aa99b78dc8844a36c" class="lightbox-link"><img src="./assets/model_diffuse.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-2892d8fc1f4ce51aa99b78dc8844a36c"><img src="./assets/model_diffuse.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>You can find the complete source code <a href="https://learnopengl.com/code_viewer_gh.php?code=src/3.model_loading/1.model_loading/model_loading.cpp" target="_blank">here</a>. Note that we tell <code>stb_image.h</code> to flip textures vertically, if you haven&rsquo;t done so already, before we load the model. Otherwise the textures will look all messed up.</p>
<p>We can also get more creative and introduce point lights to the render equation as we learned from the <a href="https://learnopengl.com/Lighting/Light-casters" target="_blank">Lighting</a> chapters and together with specular maps get amazing results:</p>
<p><a href="#R-image-94a8d78c1474da091cf617048cc913f7" class="lightbox-link"><img src="./assets/model_lighting.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-94a8d78c1474da091cf617048cc913f7"><img src="./assets/model_lighting.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Even I have to admit that this is maybe a bit more fancy than the containers we&rsquo;ve used so far. Using Assimp you can load tons of models found over the internet. There are quite a few resource websites that offer free 3D models for you to download in several file formats. Do note that some models still won&rsquo;t load properly, have texture paths that won&rsquo;t work, or are simply exported in a format even Assimp can&rsquo;t read.</p>
<h4 id="further-reading-1">Further reading</h4>
<ul>
<li><a href="https://www.youtube.com/watch?v=4DQquG_o-Ac" target="_blank">How-To Texture Wavefront (.obj) Models for OpenGL</a>: great video guide by Matthew Early on how to set up 3D models in Blender so they directly work with the current model loader (as the texture setup we&rsquo;ve chosen doesn&rsquo;t always work out of the box).</li>
</ul>
<h2 id="advanced-opengl">Advanced OpenGL</h2>
<h3 id="depth-testing">Depth testing</h3>
<p>In the <a href="https://learnopengl.com/Getting-started/Coordinate-Systems" target="_blank">coordinate systems</a> chapter we&rsquo;ve rendered a 3D container and made use of a depth buffer to prevent triangles rendering in the front while they&rsquo;re supposed to be behind other triangles. In this chapter we&rsquo;re going to elaborate a bit more on those depth values the depth buffer (or z-buffer) stores and how it actually determines if a fragment is in front.</p>
<p>The depth-buffer is a buffer that, just like the color buffer (that stores all the fragment colors: the visual output), stores information per fragment and has the same width and height as the color buffer. The depth buffer is automatically created by the windowing system and stores its depth values as <code>16</code>, <code>24</code> or <code>32</code> bit floats. In most systems you&rsquo;ll see a depth buffer with a precision of <code>24</code> bits.</p>
<p>When depth testing is enabled, OpenGL tests the depth value of a fragment against the content of the depth buffer. OpenGL performs a depth test and if this test passes, the fragment is rendered and the depth buffer is updated with the new depth value. If the depth test fails, the fragment is discarded.</p>
<p>Depth testing is done in screen space after the fragment shader has run (and after the stencil test which we&rsquo;ll get to in the <a href="https://learnopengl.com/Advanced-OpenGL/Stencil-testing" target="_blank">next</a> chapter). The screen space coordinates relate directly to the viewport defined by OpenGL&rsquo;s glViewport function and can be accessed via GLSL&rsquo;s built-in gl_FragCoord variable in the fragment shader. The x and y components of gl_FragCoord represent the fragment&rsquo;s screen-space coordinates (with (0,0) being the bottom-left corner). The gl_FragCoord variable also contains a z-component which contains the depth value of the fragment. This z value is the value that is compared to the depth buffer&rsquo;s content.</p>
<p><note>Today most GPUs support a hardware feature called early depth testing. Early depth testing allows the depth test to run before the fragment shader runs. Whenever it is clear a fragment isn&rsquo;t going to be visible (it is behind other objects) we can prematurely discard the fragment.<br><br>Fragment shaders are usually quite expensive so wherever we can avoid running them we should. A restriction on the fragment shader for early depth testing is that you shouldn&rsquo;t write to the fragment&rsquo;s depth value. If a fragment shader would write to its depth value, early depth testing is impossible; OpenGL won&rsquo;t be able to figure out the depth value beforehand.</note></p>
<p>Depth testing is disabled by default so to enable depth testing we need to enable it with the GL_DEPTH_TEST option:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glEnable</span><span class="p">(</span><span class="n">GL_DEPTH_TEST</span><span class="p">);</span>  
</span></span></code></pre></div><p>Once enabled, OpenGL automatically stores fragments their z-values in the depth buffer if they passed the depth test and discards fragments if they failed the depth test accordingly. If you have depth testing enabled you should also clear the depth buffer before each frame using GL_DEPTH_BUFFER_BIT; otherwise you&rsquo;re stuck with the depth values from last frame:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glClear</span><span class="p">(</span><span class="n">GL_COLOR_BUFFER_BIT</span> <span class="o">|</span> <span class="n">GL_DEPTH_BUFFER_BIT</span><span class="p">);</span>  
</span></span></code></pre></div><p>There are certain scenarios imaginable where you want to perform the depth test on all fragments and discard them accordingly, but <strong>not</strong> update the depth buffer. Basically, you&rsquo;re (temporarily) using a read-only depth buffer. OpenGL allows us to disable writing to the depth buffer by setting its depth mask to <code>GL_FALSE</code>:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glDepthMask</span><span class="p">(</span><span class="n">GL_FALSE</span><span class="p">);</span>  
</span></span></code></pre></div><p>Note that this only has effect if depth testing is enabled.</p>
<h4 id="depth-test-function">Depth test function</h4>
<p>OpenGL allows us to modify the comparison operators it uses for the depth test. This allows us to control when OpenGL should pass or discard fragments and when to update the depth buffer. We can set the comparison operator (or depth function) by calling glDepthFunc:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glDepthFunc</span><span class="p">(</span><span class="n">GL_LESS</span><span class="p">);</span>  
</span></span></code></pre></div><p>The function accepts several comparison operators that are listed in the table below:</p>
<table>
  <tbody><tr>
  	<th>Function</th>
  	<th>Description</th>
  </tr>  
  <tr>
    <td><code>GL_ALWAYS</code></td>
 	<td>The depth test always passes.</td>
  </tr>
  <tr>
    <td><code>GL_NEVER</code></td>
 	<td>The depth test never passes.</td>
  </tr>
  <tr>
    <td><code>GL_LESS</code></td>
 	<td>Passes if the fragment's depth value is less than the stored depth value.</td>
  </tr>
  <tr>
    <td><code>GL_EQUAL</code></td>
 	<td>Passes if the fragment's depth value is equal to the stored depth value.</td>
  </tr><tr>
    <td><code>GL_LEQUAL</code></td>
 	<td>Passes if the fragment's depth value is less than or equal to the stored depth value.</td>
  </tr> 
  <tr>
    <td><code>GL_GREATER</code></td>
 	<td>Passes if the fragment's depth value is greater than the stored depth value.</td>
  </tr>
  <tr>
    <td><code>GL_NOTEQUAL</code></td>
 	<td>Passes if the fragment's depth value is not equal to the stored depth value.</td>
  </tr>
  <tr>
    <td><code>GL_GEQUAL</code></td>
 	<td>Passes if the fragment's depth value is greater than or equal to the stored depth value.</td>
  </tr>
</tbody></table>
<p>By default the depth function GL_LESS is used that discards all the fragments that have a depth value higher than or equal to the current depth buffer&rsquo;s value.</p>
<p>Let&rsquo;s show the effect that changing the depth function has on the visual output. We&rsquo;ll use a fresh code setup that displays a basic scene with two textured cubes sitting on a textured floor with no lighting. You can find the source code <a href="https://learnopengl.com/code_viewer_gh.php?code=src/4.advanced_opengl/1.1.depth_testing/depth_testing.cpp" target="_blank">here</a>.</p>
<p>Within the source code we changed the depth function to GL_ALWAYS:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glEnable</span><span class="p">(</span><span class="n">GL_DEPTH_TEST</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glDepthFunc</span><span class="p">(</span><span class="n">GL_ALWAYS</span><span class="p">);</span> 
</span></span></code></pre></div><p>This simulates the same behavior we&rsquo;d get if we didn&rsquo;t enable depth testing. The depth test always passes so the fragments that are drawn last are rendered in front of the fragments that were drawn before, even though they should&rsquo;ve been at the front. Since we&rsquo;ve drawn the floor plane last, the plane&rsquo;s fragments overwrite each of the container&rsquo;s previously written fragments:</p>
<p><a href="#R-image-b2e1c02a7a02ad0f2ebdaa58a1cd2fa7" class="lightbox-link"><img src="./assets/depth_testing_func_always.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b2e1c02a7a02ad0f2ebdaa58a1cd2fa7"><img src="./assets/depth_testing_func_always.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Setting it all back to GL_LESS gives us the type of scene we&rsquo;re used to:</p>
<p><a href="#R-image-5e229e739ac4543a0521c0a6a3639047" class="lightbox-link"><img src="./assets/depth_testing_func_less.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-5e229e739ac4543a0521c0a6a3639047"><img src="./assets/depth_testing_func_less.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<h4 id="depth-value-precision">Depth value precision</h4>
<p>The depth buffer contains depth values between <code>0.0</code> and <code>1.0</code> and it compares its content with the z-values of all the objects in the scene as seen from the viewer. These z-values in view space can be any value between the projection-frustum&rsquo;s <code>near</code> and <code>far</code> plane. We thus need some way to transform these view-space z-values to the range of <code>[0,1]</code> and one way is to linearly transform them. The following (linear) equation transforms the z-value to a depth value between <code>0.0</code> and <code>1.0</code>:</p>

<span class="math align-center">$$
\begin{equation} F_{depth} = \frac{z - near}{far - near} \end{equation} \tag{1}
$$</span><p>Here <em><strong>near</strong></em> and <em><strong>far</strong></em> are the <em>near</em> and <em>far</em> values we used to provide to the projection matrix to set the visible frustum (see <a href="https://learnopengl.com/Getting-started/Coordinate-Systems" target="_blank">coordinate Systems</a>). The equation takes a depth value 
<span class="math align-center">$z$</span> within the frustum and transforms it to the range <code>[0,1]</code>. The relation between the z-value and its corresponding depth value is presented in the following graph:</p>
<p><a href="#R-image-3984d7ae0d59abbf9f49055f0907cdb6" class="lightbox-link"><img src="./assets/depth_linear_graph.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-3984d7ae0d59abbf9f49055f0907cdb6"><img src="./assets/depth_linear_graph.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><note>Note that all equations give a depth value close to <code>0.0</code> when the object is close by and a depth value close to <code>1.0</code> when the object is close to the far plane.</note></p>
<p>In practice however, a linear depth buffer like this is almost never used. Because of projection properties a non-linear depth equation is used that is proportional to 1/z. The result is that we get enormous precision when z is small and much less precision when z is far away.</p>
<p>Since the non-linear function is proportional to 1/z, z-values between <code>1.0</code> and <code>2.0</code> would result in depth values between <code>1.0</code> and <code>0.5</code> which is half of the [0,1] range, giving us enormous precision at small z-values. Z-values between <code>50.0</code> and <code>100.0</code> would account for only 2% of the [0,1] range. Such an equation, that also takes near and far distances into account, is given below:</p>

<span class="math align-center">$$
\begin{equation} F_{depth} = \frac{1/z - 1/near}{1/far - 1/near} \end{equation} \tag{2}
$$</span><p>Don&rsquo;t worry if you don&rsquo;t know exactly what is going on with this equation. The important thing to remember is that the values in the depth buffer are not linear in clip-space (they are linear in view-space before the projection matrix is applied). A value of <code>0.5</code> in the depth buffer does not mean the pixel&rsquo;s z-value is halfway in the frustum; the z-value of the vertex is actually quite close to the near plane! You can see the non-linear relation between the z-value and the resulting depth buffer&rsquo;s value in the following graph:</p>
<p><a href="#R-image-e1570b0ef771829a28bda5c617ab71d6" class="lightbox-link"><img src="./assets/depth_non_linear_graph.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-e1570b0ef771829a28bda5c617ab71d6"><img src="./assets/depth_non_linear_graph.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>As you can see, the depth values are greatly determined by the small z-values giving us large depth precision to the objects close by. The equation to transform z-values (from the viewer&rsquo;s perspective) is embedded within the projection matrix so when we transform vertex coordinates from view to clip, and then to screen-space the non-linear equation is applied.</p>
<p>The effect of this non-linear equation quickly becomes apparent when we try to visualize the depth buffer.</p>
<h4 id="visualizing-the-depth-buffer">Visualizing the depth buffer</h4>
<p>We know that the z-value of the built-in gl_FragCoord vector in the fragment shader contains the depth value of that particular fragment. If we were to output this depth value of the fragment as a color we could display the depth values of all the fragments in the scene:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>             
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="n">FragColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">vec3</span><span class="p">(</span><span class="n">gl_FragCoord</span><span class="p">.</span><span class="n">z</span><span class="p">),</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>If you&rsquo;d then run the program you&rsquo;ll probably notice that everything is white, making it look like all of our depth values are the maximum depth value of <code>1.0</code>. So why aren&rsquo;t any of the depth values closer to <code>0.0</code> and thus darker?</p>
<p>In the previous section we described that depth values in screen space are non-linear e.g. they have a very high precision for small z-values and a low precision for large z-values. The depth value of the fragment increases rapidly over distance so almost all the vertices have values close to <code>1.0</code>. If we were to carefully move really close to an object you may eventually see the colors getting darker, their z-values becoming smaller:</p>
<p><a href="#R-image-d2c11bb099b5d5ef7b6c2bb024c3f087" class="lightbox-link"><img src="./assets/depth_testing_visible_depth.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d2c11bb099b5d5ef7b6c2bb024c3f087"><img src="./assets/depth_testing_visible_depth.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>This clearly shows the non-linearity of the depth value. Objects close by have a much larger effect on the depth value than objects far away. Only moving a few inches can result in the colors going from dark to completely white.</p>
<p>We can however, transform the non-linear depth values of the fragment back to its linear sibling. To achieve this we basically need to reverse the process of projection for the depth values alone. This means we have to first re-transform the depth values from the range <code>[0,1]</code> to normalized device coordinates in the range <code>[-1,1]</code>. Then we want to reverse the non-linear equation (equation 2) as done in the projection matrix and apply this inversed equation to the resulting depth value. The result is then a linear depth value.</p>
<p>First we transform the depth value to NDC which is not too difficult:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">float</span> <span class="n">ndc</span> <span class="o">=</span> <span class="n">depth</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">;</span> 
</span></span></code></pre></div><p>We then take the resulting ndc value and apply the inverse transformation to retrieve its linear depth value:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">float</span> <span class="n">linearDepth</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">near</span> <span class="o">*</span> <span class="n">far</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">far</span> <span class="o">+</span> <span class="n">near</span> <span class="o">-</span> <span class="n">ndc</span> <span class="o">*</span> <span class="p">(</span><span class="n">far</span> <span class="o">-</span> <span class="n">near</span><span class="p">));</span>	
</span></span></code></pre></div><p>This equation is derived from the projection matrix for non-linearizing the depth values, returning depth values between near and far. This <a href="http://www.songho.ca/opengl/gl_projectionmatrix.html" target="_blank">math-heavy article</a> explains the projection matrix in enormous detail for the interested reader; it also shows where the equations come from.</p>
<p>The complete fragment shader that transforms the non-linear depth in screen-space to a linear depth value is then as follows:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">out</span> <span class="n">vec4</span> <span class="n">FragColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="kt">float</span> <span class="n">near</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="kt">float</span> <span class="n">far</span>  <span class="o">=</span> <span class="mf">100.0</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="kt">float</span> <span class="nf">LinearizeDepth</span><span class="p">(</span><span class="kt">float</span> <span class="n">depth</span><span class="p">)</span> 
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="kt">float</span> <span class="n">z</span> <span class="o">=</span> <span class="n">depth</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">;</span> <span class="c1">// back to NDC 
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">near</span> <span class="o">*</span> <span class="n">far</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">far</span> <span class="o">+</span> <span class="n">near</span> <span class="o">-</span> <span class="n">z</span> <span class="o">*</span> <span class="p">(</span><span class="n">far</span> <span class="o">-</span> <span class="n">near</span><span class="p">));</span>	
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="p">{</span>             
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="kt">float</span> <span class="n">depth</span> <span class="o">=</span> <span class="n">LinearizeDepth</span><span class="p">(</span><span class="n">gl_FragCoord</span><span class="p">.</span><span class="n">z</span><span class="p">)</span> <span class="o">/</span> <span class="n">far</span><span class="p">;</span> <span class="c1">// divide by far for demonstration
</span></span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="c1"></span>    <span class="n">FragColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">vec3</span><span class="p">(</span><span class="n">depth</span><span class="p">),</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>Because the linearized depth values range from near to far most of its values will be above <code>1.0</code> and displayed as completely white. By dividing the linear depth value by far in the main function we convert the linear depth value to the range [<code>0</code>, <code>1</code>]. This way we can gradually see the scene become brighter the closer the fragments are to the projection frustum&rsquo;s far plane, which works better for visualization purposes.</p>
<p>If we&rsquo;d now run the application we get depth values that are linear over distance. Try moving around the scene to see the depth values change in a linear fashion.</p>
<p><a href="#R-image-0c8ad710c2f7316063f8d7f9d3a093ce" class="lightbox-link"><img src="./assets/depth_testing_visible_linear.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-0c8ad710c2f7316063f8d7f9d3a093ce"><img src="./assets/depth_testing_visible_linear.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>The colors are mostly black because the depth values range linearly from the <code>near</code> plane (<code>0.1</code>) to the <code>far</code> plane (<code>100</code>) which is still quite far away from us. The result is that we&rsquo;re relatively close to the near plane and therefore get lower (darker) depth values.</p>
<h4 id="z-fighting">Z-fighting</h4>
<p>A common visual artifact may occur when two planes or triangles are so closely aligned to each other that the depth buffer does not have enough precision to figure out which one of the two shapes is in front of the other. The result is that the two shapes continually seem to switch order which causes weird glitchy patterns. This is called z-fighting, because it looks like the shapes are fighting over who gets on top.</p>
<p>In the scene we&rsquo;ve been using so far there are a few spots where z-fighting can be noticed. The containers were placed at the exact height of the floor which means the bottom plane of the container is coplanar with the floor plane. The depth values of both planes are then the same so the resulting depth test has no way of figuring out which is the right one.</p>
<p>If you move the camera inside one of the containers the effects are clearly visible, the bottom part of the container is constantly switching between the container&rsquo;s plane and the floor&rsquo;s plane in a zigzag pattern:</p>
<p><a href="#R-image-e68a1a629c3a2307cdd1c6a727118f07" class="lightbox-link"><img src="./assets/depth_testing_z_fighting.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-e68a1a629c3a2307cdd1c6a727118f07"><img src="./assets/depth_testing_z_fighting.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Z-fighting is a common problem with depth buffers and it&rsquo;s generally more noticeable when objects are further away (because the depth buffer has less precision at larger z-values). Z-fighting can&rsquo;t be completely prevented, but there are a few tricks that will help to mitigate or completely prevent z-fighting in your scene.</p>
<h5 id="prevent-z-fighting">Prevent z-fighting</h5>
<p>The first and most important trick is <em>never place objects too close to each other in a way that some of their triangles closely overlap</em>. By creating a small offset between two objects you can completely remove z-fighting between the two objects. In the case of the containers and the plane we could&rsquo;ve easily moved the containers slightly upwards in the positive y direction. The small change of the container&rsquo;s positions would probably not be noticeable at all and would completely reduce the z-fighting. However, this requires manual intervention of each of the objects and thorough testing to make sure no objects in a scene produce z-fighting.</p>
<p>A second trick is to <em>set the near plane as far as possible</em>. In one of the previous sections we&rsquo;ve discussed that precision is extremely large when close to the <code>near</code> plane so if we move the <code>near</code> plane away from the viewer, we&rsquo;ll have significantly greater precision over the entire frustum range. However, setting the <code>near</code> plane too far could cause clipping of near objects so it is usually a matter of tweaking and experimentation to figure out the best <code>near</code> distance for your scene.</p>
<p>Another great trick at the cost of some performance is to <em>use a higher precision depth buffer</em>. Most depth buffers have a precision of <code>24</code> bits, but most GPUs nowadays support <code>32</code> bit depth buffers, increasing the precision by a significant amount. So at the cost of some performance you&rsquo;ll get much more precision with depth testing, reducing z-fighting.</p>
<p>The 3 techniques we&rsquo;ve discussed are the most common and easy-to-implement anti z-fighting techniques. There are some other techniques out there that require a lot more work and still won&rsquo;t completely disable z-fighting. Z-fighting is a common issue, but if you use the proper combination of the listed techniques you probably won&rsquo;t need to deal with z-fighting that much.</p>
<h3 id="stencil-testing">Stencil testing</h3>
<p>Once the fragment shader has processed the fragment a so called stencil test is executed that, just like the depth test, has the option to discard fragments. After that the remaining fragments are passed to the depth test where OpenGL could possibly discard even more fragments. The stencil test is based on the content of yet another buffer called the stencil buffer that we&rsquo;re allowed to update during rendering to achieve interesting effects.</p>
<p>A stencil buffer (usually) contains <code>8</code> bits per stencil value that amounts to a total of <code>256</code> different stencil values per pixel. We can set these stencil values to values of our liking and we can discard or keep fragments whenever a particular fragment has a certain stencil value.</p>
<p><note>Each windowing library needs to set up a stencil buffer for you. GLFW does this automatically so we don&rsquo;t have to tell GLFW to create one, but other windowing libraries may not create a stencil buffer by default so be sure to check your library&rsquo;s documentation.</note></p>
<p>A simple example of a stencil buffer is shown below (pixels not-to-scale):</p>
<p><a href="#R-image-4de1ab26b5fe25d7ace0ed4458111968" class="lightbox-link"><img src="./assets/stencil_buffer.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-4de1ab26b5fe25d7ace0ed4458111968"><img src="./assets/stencil_buffer.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>The stencil buffer is first cleared with zeros and then an open rectangle of <code>1</code>s is stored in the stencil buffer. The fragments of the scene are then only rendered (the others are discarded) wherever the stencil value of that fragment contains a <code>1</code>.</p>
<p>Stencil buffer operations allow us to set the stencil buffer at specific values wherever we&rsquo;re rendering fragments. By changing the content of the stencil buffer while we&rsquo;re rendering, we&rsquo;re <em>writing</em> to the stencil buffer. In the same (or following) frame(s) we can <em>read</em> these values to discard or pass certain fragments. When using stencil buffers you can get as crazy as you like, but the general outline is usually as follows:</p>
<ul>
<li>Enable writing to the stencil buffer.</li>
<li>Render objects, updating the content of the stencil buffer.</li>
<li>Disable writing to the stencil buffer.</li>
<li>Render (other) objects, this time discarding certain fragments based on the content of the stencil buffer.</li>
</ul>
<p>By using the stencil buffer we can thus discard certain fragments based on the fragments of other drawn objects in the scene.</p>
<p>You can enable stencil testing by enabling GL_STENCIL_TEST. From that point on, all rendering calls will influence the stencil buffer in one way or another.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glEnable</span><span class="p">(</span><span class="n">GL_STENCIL_TEST</span><span class="p">);</span>    
</span></span></code></pre></div><p>Note that you also need to clear the stencil buffer each iteration just like the color and depth buffer:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glClear</span><span class="p">(</span><span class="n">GL_COLOR_BUFFER_BIT</span> <span class="o">|</span> <span class="n">GL_DEPTH_BUFFER_BIT</span> <span class="o">|</span> <span class="n">GL_STENCIL_BUFFER_BIT</span><span class="p">);</span> 
</span></span></code></pre></div><p>Also, just like the depth testing&rsquo;s glDepthMask function, there is an equivalent function for the stencil buffer. The function glStencilMask allows us to set a bitmask that is <code>AND</code>ed with the stencil value about to be written to the buffer. By default this is set to a bitmask of all <code>1</code>s not affecting the output, but if we were to set this to <code>0x00</code> all the stencil values written to the buffer end up as <code>0</code>s. This is equivalent to depth testing&rsquo;s glDepthMask(GL_FALSE):</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glStencilMask</span><span class="p">(</span><span class="mh">0xFF</span><span class="p">);</span> <span class="c1">// each bit is written to the stencil buffer as is
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="c1"></span><span class="n">glStencilMask</span><span class="p">(</span><span class="mh">0x00</span><span class="p">);</span> <span class="c1">// each bit ends up as 0 in the stencil buffer (disabling writes)
</span></span></span></code></pre></div><p>Most of the cases you&rsquo;ll only be using <code>0x00</code> or <code>0xFF</code> as the stencil mask, but it&rsquo;s good to know there are options to set custom bit-masks.</p>
<h4 id="stencil-functions">Stencil functions</h4>
<p>Similar to depth testing, we have a certain amount of control over when a stencil test should pass or fail and how it should affect the stencil buffer. There are a total of two functions we can use to configure stencil testing: glStencilFunc and glStencilOp.</p>
<p>The glStencilFunc(GLenum func, GLint ref, GLuint mask) has three parameters:</p>
<ul>
<li><code>func</code>: sets the stencil test function that determines whether a fragment passes or is discarded. This test function is applied to the stored stencil value and the glStencilFunc&rsquo;s <code>ref</code> value. Possible options are: GL_NEVER, GL_LESS, GL_LEQUAL, GL_GREATER, GL_GEQUAL, GL_EQUAL, GL_NOTEQUAL and GL_ALWAYS. The semantic meaning of these is similar to the depth buffer&rsquo;s functions.</li>
<li><code>ref</code>: specifies the reference value for the stencil test. The stencil buffer&rsquo;s content is compared to this value.</li>
<li><code>mask</code>: specifies a mask that is <code>AND</code>ed with both the reference value and the stored stencil value before the test compares them. Initially set to all <code>1</code>s.</li>
</ul>
<p>So in the case of the simple stencil example we&rsquo;ve shown at the start, the function would be set to:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glStencilFunc</span><span class="p">(</span><span class="n">GL_EQUAL</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">)</span></span></span></code></pre></div><p>This tells OpenGL that whenever the stencil value of a fragment is equal (GL_EQUAL) to the reference value <code>1</code>, the fragment passes the test and is drawn, otherwise discarded.</p>
<p>But glStencilFunc only describes whether OpenGL should pass or discard fragments based on the stencil buffer&rsquo;s content, not how we can actually update the buffer. That is where glStencilOp comes in.</p>
<p>The glStencilOp(GLenum sfail, GLenum dpfail, GLenum dppass) contains three options of which we can specify for each option what action to take:</p>
<ul>
<li><code>sfail</code>: action to take if the stencil test fails.</li>
<li><code>dpfail</code>: action to take if the stencil test passes, but the depth test fails.</li>
<li><code>dppass</code>: action to take if both the stencil and the depth test pass.</li>
</ul>
<p>Then for each of the options you can take any of the following actions:</p>
<table>
  <tbody><tr>
  	<th>Action</th>
  	<th>Description</th>
  </tr>  
  <tr>
    <td><code>GL_KEEP</code></td>
 	<td>The currently stored stencil value is kept.</td>
  </tr>
  <tr>
    <td><code>GL_ZERO</code></td>
 	<td>The stencil value is set to <code>0</code>.</td>
  </tr>
  <tr>
    <td><code>GL_REPLACE</code></td>
 	<td>The stencil value is replaced with the reference value set with <fun><function id="68">glStencilFunc</function></fun>.</td>
  </tr>
  <tr>
    <td><code>GL_INCR</code></td>
 	<td>The stencil value is increased by <code>1</code> if it is lower than the maximum value. </td>
  </tr><tr>
    <td><code>GL_INCR_WRAP</code></td>
 	<td>Same as <var>GL_INCR</var>, but wraps it back to <code>0</code> as soon as the maximum value is exceeded.</td>
  </tr> 
  <tr>
    <td><code>GL_DECR</code></td>
 	<td>The stencil value is decreased by <code>1</code> if it is higher than the minimum value.</td>
  </tr>
  <tr>
    <td><code>GL_DECR_WRAP</code></td>
 	<td>Same as <var>GL_DECR</var>, but wraps it to the maximum value if it ends up lower than <code>0</code>.</td>
  </tr>
  <tr>
    <td><code>GL_INVERT</code></td>
 	<td>Bitwise inverts the current stencil buffer value.</td>
  </tr>
</tbody></table>
<p>By default the glStencilOp function is set to <code>(GL_KEEP, GL_KEEP, GL_KEEP)</code> so whatever the outcome of any of the tests, the stencil buffer keeps its values. The default behavior does not update the stencil buffer, so if you want to write to the stencil buffer you need to specify at least one different action for any of the options.</p>
<p>So using glStencilFunc and glStencilOp we can precisely specify when and how we want to update the stencil buffer and when to pass or discard fragments based on its content.</p>
<h4 id="object-outlining">Object outlining</h4>
<p>It would be unlikely if you completely understood how stencil testing works from the previous sections alone so we&rsquo;re going to demonstrate a particular useful feature that can be implemented with stencil testing alone called object outlining.</p>
<p><a href="#R-image-42e1454f403ac7742a003c34bf5b94b2" class="lightbox-link"><img src="./assets/stencil_object_outlining.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-42e1454f403ac7742a003c34bf5b94b2"><img src="./assets/stencil_object_outlining.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Object outlining does exactly what it says it does. For each object (or only one) we&rsquo;re creating a small colored border around the (combined) objects. This is a particular useful effect when you want to select units in a strategy game for example and need to show the user which of the units were selected. The routine for outlining your objects is as follows:</p>
<ol>
<li>Enable stencil writing.</li>
<li>Set the stencil op to GL_ALWAYS before drawing the (to be outlined) objects, updating the stencil buffer with <code>1</code>s wherever the objects&rsquo; fragments are rendered.</li>
<li>Render the objects.</li>
<li>Disable stencil writing and depth testing.</li>
<li>Scale each of the objects by a small amount.</li>
<li>Use a different fragment shader that outputs a single (border) color.</li>
<li>Draw the objects again, but only if their fragments&rsquo; stencil values are not equal to <code>1</code>.</li>
<li>Enable depth testing again and restore stencil func to GL_KEEP.</li>
</ol>
<p>This process sets the content of the stencil buffer to <code>1</code>s for each of the object&rsquo;s fragments and when it&rsquo;s time to draw the borders, we draw scaled-up versions of the objects only where the stencil test passes. We&rsquo;re effectively discarding all the fragments of the scaled-up versions that are part of the original objects&rsquo; fragments using the stencil buffer.</p>
<p>So we&rsquo;re first going to create a very basic fragment shader that outputs a border color. We simply set a hardcoded color value and call the shader shaderSingleColor:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="n">FragColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="mf">0.04</span><span class="p">,</span> <span class="mf">0.28</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>Using the scene from the <a href="https://learnopengl.com/Advanced-OpenGL/Depth-testing" target="_blank">previous</a> chapter we&rsquo;re going to add object outlining to the two containers, so we&rsquo;ll leave the floor out of it. We want to first draw the floor, then the two containers (while writing to the stencil buffer), and then draw the scaled-up containers (while discarding the fragments that write over the previously drawn container fragments).</p>
<p>We first need to enable stencil testing:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glEnable</span><span class="p">(</span><span class="n">GL_STENCIL_TEST</span><span class="p">);</span></span></span></code></pre></div><p>And then in each frame we want to specify the action to take whenever any of the stencil tests succeed or fail:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glStencilOp</span><span class="p">(</span><span class="n">GL_KEEP</span><span class="p">,</span> <span class="n">GL_KEEP</span><span class="p">,</span> <span class="n">GL_REPLACE</span><span class="p">);</span>  
</span></span></code></pre></div><p>If any of the tests fail we do nothing; we simply keep the currently stored value that is in the stencil buffer. If both the stencil test and the depth test succeed however, we want to replace the stored stencil value with the reference value set via glStencilFunc which we later set to <code>1</code>.</p>
<p>We clear the stencil buffer to <code>0</code>s at the start of the frame and for the containers we update the stencil buffer to <code>1</code> for each fragment drawn:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glStencilOp</span><span class="p">(</span><span class="n">GL_KEEP</span><span class="p">,</span> <span class="n">GL_KEEP</span><span class="p">,</span> <span class="n">GL_REPLACE</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glStencilFunc</span><span class="p">(</span><span class="n">GL_ALWAYS</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">);</span> <span class="c1">// all fragments should pass the stencil test
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="c1"></span><span class="n">glStencilMask</span><span class="p">(</span><span class="mh">0xFF</span><span class="p">);</span> <span class="c1">// enable writing to the stencil buffer
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="c1"></span><span class="n">normalShader</span><span class="p">.</span><span class="n">use</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="n">DrawTwoContainers</span><span class="p">();</span></span></span></code></pre></div><p>By using GL_REPLACE as the stencil op function we make sure that each of the containers&rsquo; fragments update the stencil buffer with a stencil value of <code>1</code>. Because the fragments always pass the stencil test, the stencil buffer is updated with the reference value wherever we&rsquo;ve drawn them.</p>
<p>Now that the stencil buffer is updated with <code>1</code>s where the containers were drawn we&rsquo;re going to draw the upscaled containers, but this time with the appropriate test function and disabling writes to the stencil buffer:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glStencilFunc</span><span class="p">(</span><span class="n">GL_NOTEQUAL</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glStencilMask</span><span class="p">(</span><span class="mh">0x00</span><span class="p">);</span> <span class="c1">// disable writing to the stencil buffer
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="c1"></span><span class="n">glDisable</span><span class="p">(</span><span class="n">GL_DEPTH_TEST</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="n">shaderSingleColor</span><span class="p">.</span><span class="n">use</span><span class="p">();</span> 
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="n">DrawTwoScaledUpContainers</span><span class="p">();</span></span></span></code></pre></div><p>We set the stencil function to GL_NOTEQUAL to make sure that we&rsquo;re only drawing parts of the containers that are not equal to <code>1</code>. This way we only draw the part of the containers that are outside the previously drawn containers. Note that we also disable depth testing so the scaled up containers (e.g. the borders) do not get overwritten by the floor. Make sure to enable the depth buffer again once you&rsquo;re done.</p>
<p>The total object outlining routine for our scene looks something like this:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">glEnable</span><span class="p">(</span><span class="n">GL_DEPTH_TEST</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="n">glStencilOp</span><span class="p">(</span><span class="n">GL_KEEP</span><span class="p">,</span> <span class="n">GL_KEEP</span><span class="p">,</span> <span class="n">GL_REPLACE</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">glClear</span><span class="p">(</span><span class="n">GL_COLOR_BUFFER_BIT</span> <span class="o">|</span> <span class="n">GL_DEPTH_BUFFER_BIT</span> <span class="o">|</span> <span class="n">GL_STENCIL_BUFFER_BIT</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">glStencilMask</span><span class="p">(</span><span class="mh">0x00</span><span class="p">);</span> <span class="c1">// make sure we don&#39;t update the stencil buffer while drawing the floor
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1"></span><span class="n">normalShader</span><span class="p">.</span><span class="n">use</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="n">DrawFloor</span><span class="p">()</span>  
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="n">glStencilFunc</span><span class="p">(</span><span class="n">GL_ALWAYS</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="n">glStencilMask</span><span class="p">(</span><span class="mh">0xFF</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="n">DrawTwoContainers</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">  
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="n">glStencilFunc</span><span class="p">(</span><span class="n">GL_NOTEQUAL</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="n">glStencilMask</span><span class="p">(</span><span class="mh">0x00</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="n">glDisable</span><span class="p">(</span><span class="n">GL_DEPTH_TEST</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="n">shaderSingleColor</span><span class="p">.</span><span class="n">use</span><span class="p">();</span> 
</span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="n">DrawTwoScaledUpContainers</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="n">glStencilMask</span><span class="p">(</span><span class="mh">0xFF</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="n">glStencilFunc</span><span class="p">(</span><span class="n">GL_ALWAYS</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">);</span>   
</span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="n">glEnable</span><span class="p">(</span><span class="n">GL_DEPTH_TEST</span><span class="p">);</span>  
</span></span></code></pre></div><p>As long as you understand the general idea behind stencil testing this shouldn&rsquo;t be too hard to understand. Otherwise try to carefully read the previous sections again and try to completely understand what each of the functions does now that you&rsquo;ve seen an example of it can be used.</p>
<p>The result of the outlining algorithm then looks like this:</p>
<p><a href="#R-image-f317e33343b755d6bef2c4d021d05059" class="lightbox-link"><img src="./assets/stencil_scene_outlined.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f317e33343b755d6bef2c4d021d05059"><img src="./assets/stencil_scene_outlined.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Check the source code <a href="https://learnopengl.com/code_viewer_gh.php?code=src/4.advanced_opengl/2.stencil_testing/stencil_testing.cpp" target="_blank">here</a> to see the complete code of the object outlining algorithm.</p>
<p><note>You can see that the borders overlap between both containers which is usually the effect that we want (think of strategy games where we want to select 10 units; merging borders is generally preferred). If you want a complete border per object you&rsquo;d have to clear the stencil buffer per object and get a little creative with the depth buffer.</note></p>
<p>The object outlining algorithm you&rsquo;ve seen is commonly used in games to visualize selected objects (think of strategy games) and an algorithm like this can easily be implemented within a model class. You could set a boolean flag within the model class to draw either with borders or without. If you want to be creative you could even give the borders a more natural look with the help of post-processing filters like Gaussian Blur.</p>
<p>Stencil testing has many more purposes (beside outlining objects) like drawing textures inside a rear-view mirror so it neatly fits into the mirror shape, or rendering real-time shadows with a stencil buffer technique called shadow volumes. Stencil buffers give us with yet another nice tool in our already extensive OpenGL toolkit.</p>
<h3 id="bleanding">Bleanding</h3>
<p>Blending in OpenGL is commonly known as the technique to implement transparency within objects. Transparency is all about objects (or parts of them) not having a solid color, but having a combination of colors from the object itself and any other object behind it with varying intensity. A colored glass window is a transparent object; the glass has a color of its own, but the resulting color contains the colors of all the objects behind the glass as well. This is also where the name blending comes from, since we blend several pixel colors (from different objects) to a single color. Transparency thus allows us to see through objects.</p>
<p><a href="#R-image-15f4b49c8b386c1583ab3792788161cb" class="lightbox-link"><img src="./assets/blending_transparency.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-15f4b49c8b386c1583ab3792788161cb"><img src="./assets/blending_transparency.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Transparent objects can be completely transparent (letting all colors through) or partially transparent (letting colors through, but also some of its own colors). The amount of transparency of an object is defined by its color&rsquo;s alpha value. The alpha color value is the 4th component of a color vector that you&rsquo;ve probably seen quite often now. Up until this chapter, we&rsquo;ve always kept this 4th component at a value of <code>1.0</code> giving the object <code>0.0</code> transparency. An alpha value of <code>0.0</code> would result in the object having complete transparency. An alpha value of <code>0.5</code> tells us the object&rsquo;s color consist of 50% of its own color and 50% of the colors behind the object.</p>
<p>The textures we&rsquo;ve used so far all consisted of <code>3</code> color components: red, green and blue, but some textures also have an embedded alpha channel that contains an alpha value per texel. This alpha value tells us exactly which parts of the texture have transparency and by how much. For example, the following <a href="https://learnopengl.com/img/advanced/blending_transparent_window.png" target="_blank">window texture</a> has an alpha value of <code>0.25</code> at its glass part and an alpha value of <code>0.0</code> at its corners. The glass part would normally be completely red, but since it has 75% transparency it largely shows the page&rsquo;s background through it, making it seem a lot less red:</p>
<p><a href="#R-image-251ae969d307b62723a2513c29bd8a3a" class="lightbox-link"><img src="./assets/blending_transparent_window.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-251ae969d307b62723a2513c29bd8a3a"><img src="./assets/blending_transparent_window.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>We&rsquo;ll soon be adding this windowed texture to the scene from the depth testing chapter, but first we&rsquo;ll discuss an easier technique to implement transparency for pixels that are either fully transparent or fully opaque.</p>
<h4 id="discarding-fragments">Discarding fragments</h4>
<p>Some effects do not care about partial transparency, but either want to show something or nothing at all based on the color value of a texture. Think of grass; to create something like grass with little effort you generally paste a grass texture onto a 2D quad and place that quad into your scene. However, grass isn&rsquo;t exactly shaped like a 2D square so you only want to display some parts of the grass texture and ignore the others.</p>
<p>The following <a href="https://learnopengl.com/img/textures/grass.png" target="_blank">texture</a> is exactly such a texture where it either is full opaque (an alpha value of <code>1.0</code>) or it is fully transparent (an alpha value of <code>0.0</code>) and nothing in between. You can see that wherever there is no grass, the image shows the page&rsquo;s background color instead of its own.</p>
<p><a href="#R-image-9353aaab73059330bee9b315195d9159" class="lightbox-link"><img src="./assets/grass.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-9353aaab73059330bee9b315195d9159"><img src="./assets/grass.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>So when adding vegetation to a scene we don&rsquo;t want to see a square image of grass, but rather only show the actual grass and see through the rest of the image. We want to discard the fragments that show the transparent parts of the texture, not storing that fragment into the color buffer.</p>
<p>Before we get into that we first need to learn how to load a transparent texture. To load textures with alpha values there&rsquo;s not much we need to change. <code>stb_image</code> automatically loads an image&rsquo;s alpha channel if it&rsquo;s available, but we do need to tell OpenGL our texture now uses an alpha channel in the texture generation procedure:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glTexImage2D</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGBA</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGBA</span><span class="p">,</span> <span class="n">GL_UNSIGNED_BYTE</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>  
</span></span></code></pre></div><p>Also make sure that you retrieve all <code>4</code> color components of the texture in the fragment shader, not just the RGB components:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="c1">// FragColor = vec4(vec3(texture(texture1, TexCoords)), 1.0);
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="c1"></span>    <span class="n">FragColor</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">texture1</span><span class="p">,</span> <span class="n">TexCoords</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>Now that we know how to load transparent textures it&rsquo;s time to put it to the test by adding several of these leaves of grass throughout the basic scene introduced in the <a href="https://learnopengl.com/Advanced-OpenGL/Depth-testing" target="_blank">depth testing</a> chapter.</p>
<p>We create a small <code>vector</code> array where we add several <code>glm::vec3</code> vectors to represent the location of the grass leaves:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="o">&gt;</span> <span class="n">vegetation</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">vegetation</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="o">-</span><span class="mf">1.5f</span><span class="p">,</span>  <span class="mf">0.0f</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.48f</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">vegetation</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span> <span class="mf">1.5f</span><span class="p">,</span>  <span class="mf">0.0f</span><span class="p">,</span>  <span class="mf">0.51f</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="n">vegetation</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span> <span class="mf">0.0f</span><span class="p">,</span>  <span class="mf">0.0f</span><span class="p">,</span>  <span class="mf">0.7f</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="n">vegetation</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="o">-</span><span class="mf">0.3f</span><span class="p">,</span>  <span class="mf">0.0f</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.3f</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="n">vegetation</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span> <span class="mf">0.5f</span><span class="p">,</span>  <span class="mf">0.0f</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.6f</span><span class="p">));</span>  
</span></span></code></pre></div><p>Each of the grass objects is rendered as a single quad with the grass texture attached to it. It&rsquo;s not a perfect 3D representation of grass, but it&rsquo;s a lot more efficient than loading and rendering a large number of complex models. With a few tricks like adding randomized rotations and scales you can get pretty convincing results with quads.</p>
<p>Because the grass texture is going to be displayed on a quad object we&rsquo;ll need to create another VAO again, fill the VBO, and set the appropriate vertex attribute pointers. Then after we&rsquo;ve rendered the floor and the two cubes we&rsquo;re going to render the grass leaves:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">vegetationVAO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">grassTexture</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vegetation</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> 
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">    <span class="n">model</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">    <span class="n">model</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">translate</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">vegetation</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>				
</span></span><span class="line"><span class="ln">7</span><span class="cl">    <span class="n">shader</span><span class="p">.</span><span class="n">setMat4</span><span class="p">(</span><span class="s">&#34;model&#34;</span><span class="p">,</span> <span class="n">model</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">8</span><span class="cl">    <span class="n">glDrawArrays</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">9</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>Running the application will now look a bit like this:</p>
<p><a href="#R-image-6a193b2a8c3335e2c360c785b56dce66" class="lightbox-link"><img src="./assets/blending_no_discard.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-6a193b2a8c3335e2c360c785b56dce66"><img src="./assets/blending_no_discard.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>This happens because OpenGL by default does not know what to do with alpha values, nor when to discard them. We have to manually do this ourselves. Luckily this is quite easy thanks to the use of shaders. GLSL gives us the <code>discard</code> command that (once called) ensures the fragment will not be further processed and thus not end up into the color buffer. Thanks to this command we can check whether a fragment has an alpha value below a certain threshold and if so, discard the fragment as if it had never been processed:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">out</span> <span class="n">vec4</span> <span class="n">FragColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">in</span> <span class="n">vec2</span> <span class="n">TexCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">texture1</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="p">{</span>             
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="n">vec4</span> <span class="n">texColor</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">texture1</span><span class="p">,</span> <span class="n">TexCoords</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">texColor</span><span class="p">.</span><span class="n">a</span> <span class="o">&lt;</span> <span class="mf">0.1</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">        <span class="n">discard</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="n">FragColor</span> <span class="o">=</span> <span class="n">texColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>Here we check if the sampled texture color contains an alpha value lower than a threshold of <code>0.1</code> and if so, discard the fragment. This fragment shader ensures us that it only renders fragments that are not (almost) completely transparent. Now it&rsquo;ll look like it should:</p>
<p><a href="#R-image-f2fe68ea028fa6f75f3e08e48dfbe12d" class="lightbox-link"><img src="./assets/blending_discard.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f2fe68ea028fa6f75f3e08e48dfbe12d"><img src="./assets/blending_discard.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><note>Note that when sampling textures at their borders, OpenGL interpolates the border values with the next repeated value of the texture (because we set its wrapping parameters to GL_REPEAT by default). This is usually okay, but since we&rsquo;re using transparent values, the top of the texture image gets its transparent value interpolated with the bottom border&rsquo;s solid color value. The result is then a slightly semi-transparent colored border you may see wrapped around your textured quad. To prevent this, set the texture wrapping method to GL_CLAMP_TO_EDGE whenever you use alpha textures that you don&rsquo;t want to repeat:<br><a href="#R-image-7017a7e03f9cc57589bdc9dfec2ac0cd" class="lightbox-link"><img src="./assets/20240214082018.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7017a7e03f9cc57589bdc9dfec2ac0cd"><img src="./assets/20240214082018.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></note></p>
<p>You can find the source code <a href="https://learnopengl.com/code_viewer_gh.php?code=src/4.advanced_opengl/3.1.blending_discard/blending_discard.cpp" target="_blank">here</a>.</p>
<h4 id="blending">Blending</h4>
<p>While discarding fragments is great and all, it doesn&rsquo;t give us the flexibility to render semi-transparent images; we either render the fragment or completely discard it. To render images with different levels of transparency we have to enable blending. Like most of OpenGL&rsquo;s functionality we can enable blending by enabling GL_BLEND:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glEnable</span><span class="p">(</span><span class="n">GL_BLEND</span><span class="p">);</span>  
</span></span></code></pre></div><p>Now that we&rsquo;ve enabled blending we need to tell OpenGL <strong>how</strong> it should actually blend.</p>
<p>Blending in OpenGL happens with the following equation:</p>

<span class="math align-center">$$
\begin{equation}\bar{C}_{result} = \bar{\color{green}C}_{source} * {\color{green}F}_{source} + \bar{\color{red}C}_{destination} * {\color{red}F}_{destination}\end{equation} \tag{1}
$$</span><ul>
<li>
<span class="math align-center">$\bar{\color{green}C}_{source}$</span>: the source color vector. This is the color output of the fragment shader.</li>
<li>
<span class="math align-center">$\bar{\color{red}C}_{destination}$</span>: the destination color vector. This is the color vector that is currently stored in the color buffer.</li>
<li>
<span class="math align-center">${\color{green}F}_{source}$</span>: the source factor value. Sets the impact of the alpha value on the source color.</li>
<li>
<span class="math align-center">${\color{red}F}_{destination}$</span>: the destination factor value. Sets the impact of the alpha value on the destination color.</li>
</ul>
<p>After the fragment shader has run and all the tests have passed, this blend equation is let loose on the fragment&rsquo;s color output and with whatever is currently in the color buffer. The source and destination colors will automatically be set by OpenGL, but the source and destination factor can be set to a value of our choosing. Let&rsquo;s start with a simple example:</p>
<p><a href="#R-image-2f7a5e354c47e28368532166e915c1a8" class="lightbox-link"><img src="./assets/blending_equation.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-2f7a5e354c47e28368532166e915c1a8"><img src="./assets/blending_equation.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>We have two squares where we want to draw the semi-transparent green square on top of the red square. The red square will be the destination color (and thus should be first in the color buffer) and we are now going to draw the green square over the red square.</p>
<p>The question then arises: what do we set the factor values to? Well, we at least want to multiply the green square with its alpha value so we want to set the 
<span class="math align-center">$F_{src}$</span> equal to the alpha value of the source color vector which is <code>0.6</code>. Then it makes sense to let the destination square have a contribution equal to the remainder of the alpha value. If the green square contributes 60% to the final color we want the red square to contribute 40% of the final color e.g. <code>1.0 - 0.6</code>. So we set 
<span class="math align-center">$F_{destination}$</span> equal to one minus the alpha value of the source color vector. The equation thus becomes:</p>

<span class="math align-center">$$
\begin{equation}\bar{C}_{result} = \begin{pmatrix} \color{red}{0.0} \\ \color{green}{1.0} \\ \color{blue}{0.0} \\ \color{purple}{0.6} \end{pmatrix} * {\color{green}{0.6}} + \begin{pmatrix} \color{red}{1.0} \\ \color{green}{0.0} \\ \color{blue}{0.0} \\ \color{purple}{1.0} \end{pmatrix} * ({\color{red}{1 - 0.6}}) \end{equation} \tag{2}
$$</span><p>The result is that the combined square fragments contain a color that is 60% green and 40% red:</p>
<p><a href="#R-image-64dcaa74653fa327ac80780ca1522e1e" class="lightbox-link"><img src="./assets/blending_equation_mixed.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-64dcaa74653fa327ac80780ca1522e1e"><img src="./assets/blending_equation_mixed.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>The resulting color is then stored in the color buffer, replacing the previous color.</p>
<p>So this is great and all, but how do we actually tell OpenGL to use factors like that? Well it just so happens that there is a function for this called glBlendFunc.</p>
<p>The glBlendFunc(GLenum sfactor, GLenum dfactor) function expects two parameters that set the option for the source and destination factor. OpenGL defined quite a few options for us to set of which we&rsquo;ll list the most common options below. Note that the constant color vector 
<span class="math align-center">$\bar{\color{blue}C}_{constant}$</span> can be separately set via the glBlendColor function.</p>
<p><a href="#R-image-ec7a2b84f5382d129fb1cc7238198376" class="lightbox-link"><img src="./assets/20240214083131.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-ec7a2b84f5382d129fb1cc7238198376"><img src="./assets/20240214083131.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>To get the blending result of our little two square example, we want to take the 
<span class="math align-center">$alpha$</span> of the source color vector for the source factor and 
<span class="math align-center">$1−alpha$</span> of the same color vector for the destination factor. This translates to glBlendFunc as follows:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glBlendFunc</span><span class="p">(</span><span class="n">GL_SRC_ALPHA</span><span class="p">,</span> <span class="n">GL_ONE_MINUS_SRC_ALPHA</span><span class="p">);</span>  
</span></span></code></pre></div><p>It is also possible to set different options for the RGB and alpha channel individually using glBlendFuncSeparate:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glBlendFuncSeparate</span><span class="p">(</span><span class="n">GL_SRC_ALPHA</span><span class="p">,</span> <span class="n">GL_ONE_MINUS_SRC_ALPHA</span><span class="p">,</span> <span class="n">GL_ONE</span><span class="p">,</span> <span class="n">GL_ZERO</span><span class="p">);</span></span></span></code></pre></div><p>This function sets the RGB components as we&rsquo;ve set them previously, but only lets the resulting alpha component be influenced by the source&rsquo;s alpha value.</p>
<p>OpenGL gives us even more flexibility by allowing us to change the operator between the source and destination part of the equation. Right now, the source and destination components are added together, but we could also subtract them if we want. glBlendEquation(GLenum mode) allows us to set this operation and has 5 possible options:</p>
<ul>
<li><code>GL_FUNC_ADD</code>: the default, adds both colors to each other: 
<span class="math align-center">$\bar{C}_{result} = {\color{green}{Src}} + \color{red}{Dst}$</span>.</li>
<li><code>GL_FUNC_SUBTRACT</code>: subtracts both colors from each other: 
<span class="math align-center">$\bar{C}_{result} = {\color{green}{Src}} - \color{red}{Dst}$</span>.</li>
<li><code>GL_FUNC_REVERSE_SUBTRACT</code>: subtracts both colors, but reverses order: 
<span class="math align-center">$\bar{C}_{result} = {\color{red}{Dst}} - \color{green}{Src}$</span>.</li>
<li><code>GL_MIN</code>: takes the component-wise minimum of both colors: 
<span class="math align-center">$\bar{C}_{result} = max({\color{red}{Dst}}, {\color{green}{Src}})$</span>.</li>
<li><code>GL_MAX</code>: takes the component-wise maximum of both colors: 
<span class="math align-center">$\bar{C}_{result} = max({\color{red}{Dst}}, {\color{green}{Src}})$</span>.</li>
</ul>
<p>Usually we can simply omit a call to glBlendEquation because GL_FUNC_ADD is the preferred blending equation for most operations, but if you&rsquo;re really trying your best to break the mainstream circuit any of the other equations could suit your needs.</p>
<h4 id="rendering-semi-transparent-textures">Rendering semi-transparent textures</h4>
<p>Now that we know how OpenGL works with regards to blending it&rsquo;s time to put our knowledge to the test by adding several semi-transparent windows. We&rsquo;ll be using the same scene as in the start of this chapter, but instead of rendering a grass texture we&rsquo;re now going to use the <a href="https://learnopengl.com/img/advanced/blending_transparent_window.png" target="_blank">transparent window</a> texture from the start of this chapter.</p>
<p>First, during initialization we enable blending and set the appropriate blending function:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glEnable</span><span class="p">(</span><span class="n">GL_BLEND</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glBlendFunc</span><span class="p">(</span><span class="n">GL_SRC_ALPHA</span><span class="p">,</span> <span class="n">GL_ONE_MINUS_SRC_ALPHA</span><span class="p">);</span>  
</span></span></code></pre></div><p>Since we enabled blending there is no need to discard fragments so we&rsquo;ll reset the fragment shader to its original version:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">out</span> <span class="n">vec4</span> <span class="n">FragColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">in</span> <span class="n">vec2</span> <span class="n">TexCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">texture1</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="p">{</span>             
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="n">FragColor</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">texture1</span><span class="p">,</span> <span class="n">TexCoords</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>This time (whenever OpenGL renders a fragment) it combines the current fragment&rsquo;s color with the fragment color currently in the color buffer based on the alpha value of FragColor. Since the glass part of the window texture is semi-transparent we should be able to see the rest of the scene by looking through this window.</p>
<p><a href="#R-image-04ae1b6803163af08d9c564c27abe722" class="lightbox-link"><img src="./assets/blending_incorrect_order.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-04ae1b6803163af08d9c564c27abe722"><img src="./assets/blending_incorrect_order.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>If you take a closer look however, you may notice something is off. The transparent parts of the front window are occluding the windows in the background. Why is this happening?</p>
<p>The reason for this is that depth testing works a bit tricky combined with blending. When writing to the depth buffer, the depth test does not care if the fragment has transparency or not, so the transparent parts are written to the depth buffer as any other value. The result is that the background windows are tested on depth as any other opaque object would be, ignoring transparency. Even though the transparent part should show the windows behind it, the depth test discards them.</p>
<p>So we cannot simply render the windows however we want and expect the depth buffer to solve all our issues for us; this is also where blending gets a little nasty. To make sure the windows show the windows behind them, we have to draw the windows in the background first. This means we have to manually sort the windows from furthest to nearest and draw them accordingly ourselves.</p>
<p><note>Note that with fully transparent objects like the grass leaves we have the option to discard the transparent fragments instead of blending them, saving us a few of these headaches (no depth issues).</note></p>
<h5 id="dont-break-the-order">Don&rsquo;t break the order</h5>
<p>To make blending work for multiple objects we have to draw the most distant object first and the closest object last. The normal non-blended objects can still be drawn as normal using the depth buffer so they don&rsquo;t have to be sorted. We do have to make sure they are drawn first before drawing the (sorted) transparent objects. When drawing a scene with non-transparent and transparent objects the general outline is usually as follows:</p>
<ol>
<li>Draw all opaque objects first.</li>
<li>Sort all the transparent objects.</li>
<li>Draw all the transparent objects in sorted order.</li>
</ol>
<p>One way of sorting the transparent objects is to retrieve the distance of an object from the viewer&rsquo;s perspective. This can be achieved by taking the distance between the camera&rsquo;s position vector and the object&rsquo;s position vector. We then store this distance together with the corresponding position vector in a map data structure from the STL library. A map automatically sorts its values based on its keys, so once we&rsquo;ve added all positions with their distance as the key they&rsquo;re automatically sorted on their distance value:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="o">&gt;</span> <span class="n">sorted</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">windows</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="kt">float</span> <span class="n">distance</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">length</span><span class="p">(</span><span class="n">camera</span><span class="p">.</span><span class="n">Position</span> <span class="o">-</span> <span class="n">windows</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">    <span class="n">sorted</span><span class="p">[</span><span class="n">distance</span><span class="p">]</span> <span class="o">=</span> <span class="n">windows</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>The result is a sorted container object that stores each of the window positions based on their distance key value from lowest to highest distance.</p>
<p>Then, this time when rendering, we take each of the map&rsquo;s values in reverse order (from farthest to nearest) and then draw the corresponding windows in correct order:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="o">&gt;::</span><span class="n">reverse_iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">sorted</span><span class="p">.</span><span class="n">rbegin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">sorted</span><span class="p">.</span><span class="n">rend</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> 
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="n">model</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="n">model</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">translate</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">);</span>				
</span></span><span class="line"><span class="ln">5</span><span class="cl">    <span class="n">shader</span><span class="p">.</span><span class="n">setMat4</span><span class="p">(</span><span class="s">&#34;model&#34;</span><span class="p">,</span> <span class="n">model</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">    <span class="n">glDrawArrays</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>We take a reverse iterator from the map to iterate through each of the items in reverse order and then translate each window quad to the corresponding window position. This relatively simple approach to sorting transparent objects fixes the previous problem and now the scene looks like this:</p>
<p><a href="#R-image-ef5dac30af5ebaf1d5f51a62c70d3803" class="lightbox-link"><img src="./assets/blending_sorted.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-ef5dac30af5ebaf1d5f51a62c70d3803"><img src="./assets/blending_sorted.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>You can find the complete source code with sorting <a href="https://learnopengl.com/code_viewer_gh.php?code=src/4.advanced_opengl/3.2.blending_sort/blending_sorted.cpp" target="_blank">here</a>.</p>
<p>While this approach of sorting the objects by their distance works well for this specific scenario, it doesn&rsquo;t take rotations, scaling or any other transformation into account and weirdly shaped objects need a different metric than simply a position vector.</p>
<p>Sorting objects in your scene is a difficult feat that depends greatly on the type of scene you have, let alone the extra processing power it costs. Completely rendering a scene with solid and transparent objects isn&rsquo;t all that easy. There are more advanced techniques like order independent transparency but these are out of the scope of this chapter. For now you&rsquo;ll have to live with normally blending your objects, but if you&rsquo;re careful and know the limitations you can get pretty decent blending implementations.</p>
<h3 id="face-culling">Face culling</h3>
<p>Try mentally visualizing a 3D cube and count the maximum number of faces you&rsquo;ll be able to see from any direction. If your imagination is not too creative you probably ended up with a maximum number of 3. You can view a cube from any position and/or direction, but you would never be able to see more than 3 faces. So why would we waste the effort of drawing those other 3 faces that we can&rsquo;t even see. If we could discard those in some way we would save more than 50% of this cube&rsquo;s total fragment shader runs!</p>
<p><note>We say <em>more than 50%</em> instead of 50%, because from certain angles only 2 or even 1 face could be visible. In that case we&rsquo;d save <strong>more</strong> than 50%.</note></p>
<p>This is a really great idea, but there&rsquo;s one problem we need to solve: how do we know if a face of an object is not visible from the viewer&rsquo;s point of view? If we imagine any closed shape, each of its faces has two sides. Each side would either <em>face</em> the user or show its back to the user. What if we could only render the faces that are <em>facing</em> the viewer?</p>
<p>This is exactly what face culling does. OpenGL checks all the faces that are front facing towards the viewer and renders those while discarding all the faces that are back facing, saving us a lot of fragment shader calls. We do need to tell OpenGL which of the faces we use are actually the front faces and which faces are the back faces. OpenGL uses a clever trick for this by analyzing the winding order of the vertex data.</p>
<h4 id="winding-order">Winding order</h4>
<p>When we define a set of triangle vertices we&rsquo;re defining them in a certain winding order that is either clockwise or counter-clockwise. Each triangle consists of 3 vertices and we specify those 3 vertices in a winding order as seen from the center of the triangle.</p>
<p><a href="#R-image-a7d522f033a277f92b57ccc50bc872cb" class="lightbox-link"><img src="./assets/faceculling_windingorder.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a7d522f033a277f92b57ccc50bc872cb"><img src="./assets/faceculling_windingorder.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>As you can see in the image we first define vertex <code>1</code> and from there we can choose whether the next vertex is <code>2</code> or <code>3</code>. This choice defines the winding order of this triangle. The following code illustrates this:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">float</span> <span class="n">vertices</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    <span class="c1">// clockwise
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="c1"></span>    <span class="n">vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="c1">// vertex 1
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1"></span>    <span class="n">vertices</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="c1">// vertex 2
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="c1"></span>    <span class="n">vertices</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="c1">// vertex 3
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="c1"></span>    <span class="c1">// counter-clockwise
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1"></span>    <span class="n">vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="c1">// vertex 1
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="c1"></span>    <span class="n">vertices</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="c1">// vertex 3
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1"></span>    <span class="n">vertices</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1">// vertex 2  
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1"></span><span class="p">};</span></span></span></code></pre></div><p>Each set of 3 vertices that form a triangle primitive thus contain a winding order. OpenGL uses this information when rendering your primitives to determine if a triangle is a front-facing or a back-facing triangle. By default, triangles defined with counter-clockwise vertices are processed as front-facing triangles.</p>
<p>When defining your vertex order you visualize the corresponding triangle as if it was facing you, so each triangle that you&rsquo;re specifying should be counter-clockwise as if you&rsquo;re directly facing that triangle. The cool thing about specifying all your vertices like this is that the actual winding order is calculated at the rasterization stage, so when the vertex shader has already run. The vertices are then seen as from the <strong>viewer&rsquo;s point of view</strong>.</p>
<p>All the triangle vertices that the viewer is then facing are indeed in the correct winding order as we specified them, but the vertices of the triangles at the other side of the cube are now rendered in such a way that their winding order becomes reversed. The result is that the triangles we&rsquo;re facing are seen as front-facing triangles and the triangles at the back are seen as back-facing triangles. The following image shows this effect:</p>
<p><a href="#R-image-a0eeb959efdf5a68b20ac58b9edc3697" class="lightbox-link"><img src="./assets/faceculling_frontback.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a0eeb959efdf5a68b20ac58b9edc3697"><img src="./assets/faceculling_frontback.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>In the vertex data we defined both triangles in counter-clockwise order (the front and back triangle as 1, 2, 3). However, from the viewer&rsquo;s direction the back triangle is rendered clockwise if we draw it in the order of 1, 2 and 3 from the viewer&rsquo;s current point of view. Even though we specified the back triangle in counter-clockwise order, it is now rendered in a clockwise order. This is exactly what we want to cull (discard) non-visible faces!</p>
<h4 id="face-culling-1">Face culling</h4>
<p>At the start of the chapter we said that OpenGL is able to discard triangle primitives if they&rsquo;re rendered as back-facing triangles. Now that we know how to set the winding order of the vertices we can start using OpenGL&rsquo;s face culling option which is disabled by default.</p>
<p>The cube vertex data we used in the previous chapters wasn&rsquo;t defined with the counter-clockwise winding order in mind, so I updated the vertex data to reflect a counter-clockwise winding order which you can copy from <a href="https://learnopengl.com/code_viewer.php?code=advanced/faceculling_vertexdata" target="_blank">here</a>. It&rsquo;s a good practice to try and visualize that these vertices are indeed all defined in a counter-clockwise order for each triangle.</p>
<p>To enable face culling we only have to enable OpenGL&rsquo;s GL_CULL_FACE option:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glEnable</span><span class="p">(</span><span class="n">GL_CULL_FACE</span><span class="p">);</span>  
</span></span></code></pre></div><p>From this point on, all the faces that are not front-faces are discarded (try flying inside the cube to see that all inner faces are indeed discarded). Currently we save over 50% of performance on rendering fragments if OpenGL decides to render the back faces first (otherwise depth testing would&rsquo;ve discarded them already). Do note that this only really works with closed shapes like a cube. We do have to disable face culling again when we draw the grass leaves from the <a href="https://learnopengl.com/Advanced-OpenGL/Blending" target="_blank">previous</a> chapter, since their front <strong>and</strong> back face should be visible.</p>
<p>OpenGL allows us to change the type of face we want to cull as well. What if we want to cull front faces and not the back faces? We can define this behavior with glCullFace:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glCullFace</span><span class="p">(</span><span class="n">GL_FRONT</span><span class="p">);</span>  
</span></span></code></pre></div><p>The glCullFace function has three possible options:</p>
<ul>
<li>GL_BACK: Culls only the back faces.</li>
<li>GL_FRONT: Culls only the front faces.</li>
<li>GL_FRONT_AND_BACK: Culls both the front and back faces.</li>
</ul>
<p>The initial value of glCullFace is GL_BACK. We can also tell OpenGL we&rsquo;d rather prefer clockwise faces as the front-faces instead of counter-clockwise faces via glFrontFace:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glFrontFace</span><span class="p">(</span><span class="n">GL_CCW</span><span class="p">);</span>  
</span></span></code></pre></div><p>The default value is GL_CCW that stands for counter-clockwise ordering with the other option being GL_CW which (obviously) stands for clockwise ordering.</p>
<p>As a simple test we could reverse the winding order by telling OpenGL that the front-faces are now determined by a clockwise ordering instead of a counter-clockwise ordering:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glEnable</span><span class="p">(</span><span class="n">GL_CULL_FACE</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glCullFace</span><span class="p">(</span><span class="n">GL_BACK</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">glFrontFace</span><span class="p">(</span><span class="n">GL_CW</span><span class="p">);</span>  
</span></span></code></pre></div><p>The result is that only the back faces are rendered:</p>
<p><a href="#R-image-e64c8edd2970c2a63ae6de8629036352" class="lightbox-link"><img src="./assets/faceculling_reverse.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-e64c8edd2970c2a63ae6de8629036352"><img src="./assets/faceculling_reverse.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Note that you can create the same effect by culling front faces with the default counter-clockwise winding order:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glEnable</span><span class="p">(</span><span class="n">GL_CULL_FACE</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glCullFace</span><span class="p">(</span><span class="n">GL_FRONT</span><span class="p">);</span>  
</span></span></code></pre></div><p>As you can see, face culling is a great tool for increasing performance of your OpenGL applications with minimal effort; especially as all 3D applications export models with consistent winding orders (CCW by default). You do have to keep track of the objects that will actually benefit from face culling and which objects shouldn&rsquo;t be culled at all.</p>
<h4 id="exercises-11">Exercises</h4>
<ul>
<li>Can you re-define the vertex data by specifying each triangle in clockwise order and then render the scene with clockwise triangles set as the front faces: <a href="https://learnopengl.com/code_viewer.php?code=advanced/faceculling-exercise1" target="_blank">solution</a></li>
</ul>
<h3 id="framebuffers">Framebuffers</h3>
<p>So far we&rsquo;ve used several types of screen buffers: a color buffer for writing color values, a depth buffer to write and test depth information, and finally a stencil buffer that allows us to discard certain fragments based on some condition. The combination of these buffers is stored somewhere in GPU memory and is called a framebuffer. OpenGL gives us the flexibility to define our own framebuffers and thus define our own color (and optionally a depth and stencil) buffer.</p>
<p>The rendering operations we&rsquo;ve done so far were all done on top of the render buffers attached to the default framebuffer. The default framebuffer is created and configured when you create your window (GLFW does this for us). By creating our own framebuffer we can get an additional target to render to.</p>
<p>The application of framebuffers may not immediately make sense, but rendering your scene to a different framebuffer allows us to use that result to create mirrors in a scene, or do cool post-processing effects for example. First we&rsquo;ll discuss how they actually work and then we&rsquo;ll use them by implementing those cool post-processing effects.</p>
<h4 id="creating-a-framebuffer">Creating a framebuffer</h4>
<p>Just like any other object in OpenGL we can create a framebuffer object (abbreviated to FBO) by using a function called glGenFramebuffers:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fbo</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glGenFramebuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fbo</span><span class="p">);</span></span></span></code></pre></div><p>This pattern of object creation and usage is something we&rsquo;ve seen dozens of times now so their usage functions are similar to all the other object&rsquo;s we&rsquo;ve seen: first we create a framebuffer object, bind it as the active framebuffer, do some operations, and unbind the framebuffer. To bind the framebuffer we use glBindFramebuffer:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">fbo</span><span class="p">);</span>  
</span></span></code></pre></div><p>By binding to the GL_FRAMEBUFFER target all the next <em>read</em> and <em>write</em> framebuffer operations will affect the currently bound framebuffer. It is also possible to bind a framebuffer to a read or write target specifically by binding to GL_READ_FRAMEBUFFER or GL_DRAW_FRAMEBUFFER respectively. The framebuffer bound to GL_READ_FRAMEBUFFER is then used for all read operations like glReadPixels and the framebuffer bound to GL_DRAW_FRAMEBUFFER is used as the destination for rendering, clearing and other write operations. Most of the times you won&rsquo;t need to make this distinction though and you generally bind to both with GL_FRAMEBUFFER.</p>
<p>Unfortunately, we can&rsquo;t use our framebuffer yet because it is not complete. For a framebuffer to be complete the following requirements have to be satisfied:</p>
<ul>
<li>We have to attach at least one buffer (color, depth or stencil buffer).</li>
<li>There should be at least one color attachment.</li>
<li>All attachments should be complete as well (reserved memory).</li>
<li>Each buffer should have the same number of samples.</li>
</ul>
<p>Don&rsquo;t worry if you don&rsquo;t know what samples are, we&rsquo;ll get to those in a <a href="https://learnopengl.com/Advanced-OpenGL/Anti-Aliasing" target="_blank">later</a> chapter.</p>
<p>From the requirements it should be clear that we need to create some kind of attachment for the framebuffer and attach this attachment to the framebuffer. After we&rsquo;ve completed all requirements we can check if we actually successfully completed the framebuffer by calling glCheckFramebufferStatus with GL_FRAMEBUFFER. It then checks the currently bound framebuffer and returns any of <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCheckFramebufferStatus.xhtml" target="_blank">these</a> values found in the specification. If it returns GL_FRAMEBUFFER_COMPLETE we&rsquo;re good to go:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">if</span><span class="p">(</span><span class="n">glCheckFramebufferStatus</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">)</span> <span class="o">==</span> <span class="n">GL_FRAMEBUFFER_COMPLETE</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">  <span class="c1">// execute victory dance
</span></span></span></code></pre></div><p>All subsequent rendering operations will now render to the attachments of the currently bound framebuffer. Since our framebuffer is not the default framebuffer, the rendering commands will have no impact on the visual output of your window. For this reason it is called off-screen rendering when rendering to a different framebuffer. If you want all rendering operations to have a visual impact again on the main window we need to make the default framebuffer active by binding to <code>0</code>:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>   
</span></span></code></pre></div><p>When we&rsquo;re done with all framebuffer operations, do not forget to delete the framebuffer object:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glDeleteFramebuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fbo</span><span class="p">);</span>  
</span></span></code></pre></div><p>Now before the completeness check is executed we need to attach one or more attachments to the framebuffer. An attachment is a memory location that can act as a buffer for the framebuffer, think of it as an image. When creating an attachment we have two options to take: textures or renderbuffer objects.</p>
<h4 id="texture-attachments">Texture attachments</h4>
<p>When attaching a texture to a framebuffer, all rendering commands will write to the texture as if it was a normal color/depth or stencil buffer. The advantage of using textures is that the render output is stored inside the texture image that we can then easily use in our shaders.</p>
<p>Creating a texture for a framebuffer is roughly the same as creating a normal texture:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">texture</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glGenTextures</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">texture</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">texture</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">  
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="n">glTexImage2D</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGB</span><span class="p">,</span> <span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGB</span><span class="p">,</span> <span class="n">GL_UNSIGNED_BYTE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">
</span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MIN_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">8</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MAG_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR</span><span class="p">);</span>  
</span></span></code></pre></div><p>The main differences here is that we set the dimensions equal to the screen size (although this is not required) and we pass <code>NULL</code> as the texture&rsquo;s <code>data</code> parameter. For this texture, we&rsquo;re only allocating memory and not actually filling it. Filling the texture will happen as soon as we render to the framebuffer. Also note that we do not care about any of the wrapping methods or mipmapping since we won&rsquo;t be needing those in most cases.</p>
<p><note>If you want to render your whole screen to a texture of a smaller or larger size you need to call glViewport again (before rendering to your framebuffer) with the new dimensions of your texture, otherwise render commands will only fill part of the texture.</note></p>
<p>Now that we&rsquo;ve created a texture, the last thing we need to do is actually attach it to the framebuffer:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glFramebufferTexture2D</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">GL_COLOR_ATTACHMENT0</span><span class="p">,</span> <span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">texture</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  
</span></span></code></pre></div><p>The glFrameBufferTexture2D function has the following parameters:</p>
<ul>
<li><code>target</code>: the framebuffer type we&rsquo;re targeting (draw, read or both).</li>
<li><code>attachment</code>: the type of attachment we&rsquo;re going to attach. Right now we&rsquo;re attaching a color attachment. Note that the <code>0</code> at the end suggests we can attach more than 1 color attachment. We&rsquo;ll get to that in a later chapter.</li>
<li><code>textarget</code>: the type of the texture you want to attach.</li>
<li><code>texture</code>: the actual texture to attach.</li>
<li><code>level</code>: the mipmap level. We keep this at <code>0</code>.</li>
</ul>
<p>Next to the color attachments we can also attach a depth and a stencil texture to the framebuffer object. To attach a depth attachment we specify the attachment type as GL_DEPTH_ATTACHMENT. Note that the texture&rsquo;s format and internalformat type should then become GL_DEPTH_COMPONENT to reflect the depth buffer&rsquo;s storage format. To attach a stencil buffer you use GL_STENCIL_ATTACHMENT as the second argument and specify the texture&rsquo;s formats as GL_STENCIL_INDEX.</p>
<p>It is also possible to attach both a depth buffer and a stencil buffer as a single texture. Each 32 bit value of the texture then contains 24 bits of depth information and 8 bits of stencil information. To attach a depth and stencil buffer as one texture we use the GL_DEPTH_STENCIL_ATTACHMENT type and configure the texture&rsquo;s formats to contain combined depth and stencil values. An example of attaching a depth and stencil buffer as one texture to the framebuffer is given below:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glTexImage2D</span><span class="p">(</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">  <span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_DEPTH24_STENCIL8</span><span class="p">,</span> <span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> 
</span></span><span class="line"><span class="ln">3</span><span class="cl">  <span class="n">GL_DEPTH_STENCIL</span><span class="p">,</span> <span class="n">GL_UNSIGNED_INT_24_8</span><span class="p">,</span> <span class="nb">NULL</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="n">glFramebufferTexture2D</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">GL_DEPTH_STENCIL_ATTACHMENT</span><span class="p">,</span> <span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">texture</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  
</span></span></code></pre></div><h4 id="renderbuffer-object-attachments">Renderbuffer object attachments</h4>
<p>Renderbuffer objects were introduced to OpenGL after textures as a possible type of framebuffer attachment, Just like a texture image, a renderbuffer object is an actual buffer e.g. an array of bytes, integers, pixels or whatever. However, a renderbuffer object can not be directly read from. This gives it the added advantage that OpenGL can do a few memory optimizations that can give it a performance edge over textures for off-screen rendering to a framebuffer.</p>
<p>Renderbuffer objects store all the render data directly into their buffer without any conversions to texture-specific formats, making them faster as a writeable storage medium. You cannot read from them directly, but it is possible to read from them via the slow glReadPixels. This returns a specified area of pixels from the currently bound framebuffer, but not directly from the attachment itself.</p>
<p>Because their data is in a native format they are quite fast when writing data or copying data to other buffers. Operations like switching buffers are therefore quite fast when using renderbuffer objects. The glfwSwapBuffers function we&rsquo;ve been using at the end of each frame may as well be implemented with renderbuffer objects: we simply write to a renderbuffer image, and swap to the other one at the end. Renderbuffer objects are perfect for these kind of operations.</p>
<p>Creating a renderbuffer object looks similar to the framebuffer&rsquo;s code:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rbo</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glGenRenderbuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rbo</span><span class="p">);</span></span></span></code></pre></div><p>And similarly we want to bind the renderbuffer object so all subsequent renderbuffer operations affect the current rbo:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glBindRenderbuffer</span><span class="p">(</span><span class="n">GL_RENDERBUFFER</span><span class="p">,</span> <span class="n">rbo</span><span class="p">);</span>  
</span></span></code></pre></div><p>Since renderbuffer objects are write-only they are often used as depth and stencil attachments, since most of the time we don&rsquo;t really need to read values from them, but we do care about depth and stencil testing. We <strong>need</strong> the depth and stencil values for testing, but don&rsquo;t need to <em>sample</em> these values so a renderbuffer object suits this perfectly. When we&rsquo;re not sampling from these buffers, a renderbuffer object is generally preferred.</p>
<p>Creating a depth and stencil renderbuffer object is done by calling the glRenderbufferStorage function:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glRenderbufferStorage</span><span class="p">(</span><span class="n">GL_RENDERBUFFER</span><span class="p">,</span> <span class="n">GL_DEPTH24_STENCIL8</span><span class="p">,</span> <span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">);</span></span></span></code></pre></div><p>Creating a renderbuffer object is similar to texture objects, the difference being that this object is specifically designed to be used as a framebuffer attachment, instead of a general purpose data buffer like a texture. Here we&rsquo;ve chosen GL_DEPTH24_STENCIL8 as the internal format, which holds both the depth and stencil buffer with 24 and 8 bits respectively.</p>
<p>The last thing left to do is to actually attach the renderbuffer object:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glFramebufferRenderbuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">GL_DEPTH_STENCIL_ATTACHMENT</span><span class="p">,</span> <span class="n">GL_RENDERBUFFER</span><span class="p">,</span> <span class="n">rbo</span><span class="p">);</span>  
</span></span></code></pre></div><p>Renderbuffer objects can be more efficient for use in your off-screen render projects, but it is important to realize when to use renderbuffer objects and when to use textures. The general rule is that if you never need to sample data from a specific buffer, it is wise to use a renderbuffer object for that specific buffer. If you need to sample data from a specific buffer like colors or depth values, you should use a texture attachment instead.</p>
<h4 id="rendering-to-a-texture">Rendering to a texture</h4>
<p>Now that we know how framebuffers (sort of) work it&rsquo;s time to put them to good use. We&rsquo;re going to render the scene into a color texture attached to a framebuffer object we created and then draw this texture over a simple quad that spans the whole screen. The visual output is then exactly the same as without a framebuffer, but this time it&rsquo;s all printed on top of a single quad. Now why is this useful? In the next section we&rsquo;ll see why.</p>
<p>First thing to do is to create an actual framebuffer object and bind it, this is all relatively straightforward:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">framebuffer</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glGenFramebuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">framebuffer</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">framebuffer</span><span class="p">);</span>    
</span></span></code></pre></div><p>Next we create a texture image that we attach as a color attachment to the framebuffer. We set the texture&rsquo;s dimensions equal to the width and height of the window and keep its data uninitialized:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="c1">// generate texture
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1"></span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">textureColorbuffer</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">glGenTextures</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">textureColorbuffer</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">textureColorbuffer</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">glTexImage2D</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGB</span><span class="p">,</span> <span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGB</span><span class="p">,</span> <span class="n">GL_UNSIGNED_BYTE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MIN_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR</span> <span class="p">);</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MAG_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1">// attach it to currently bound framebuffer object
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="c1"></span><span class="n">glFramebufferTexture2D</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">GL_COLOR_ATTACHMENT0</span><span class="p">,</span> <span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">textureColorbuffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  
</span></span></code></pre></div><p>We also want to make sure OpenGL is able to do depth testing (and optionally stencil testing) so we have to make sure to add a depth (and stencil) attachment to the framebuffer. Since we&rsquo;ll only be sampling the color buffer and not the other buffers we can create a renderbuffer object for this purpose.</p>
<p>Creating a renderbuffer object isn&rsquo;t too hard. The only thing we have to remember is that we&rsquo;re creating it as a depth <strong>and</strong> stencil attachment renderbuffer object. We set its <em>internal format</em> to GL_DEPTH24_STENCIL8 which is enough precision for our purposes:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rbo</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glGenRenderbuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rbo</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">glBindRenderbuffer</span><span class="p">(</span><span class="n">GL_RENDERBUFFER</span><span class="p">,</span> <span class="n">rbo</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="n">glRenderbufferStorage</span><span class="p">(</span><span class="n">GL_RENDERBUFFER</span><span class="p">,</span> <span class="n">GL_DEPTH24_STENCIL8</span><span class="p">,</span> <span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="n">glBindRenderbuffer</span><span class="p">(</span><span class="n">GL_RENDERBUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span></span></span></code></pre></div><p>Once we&rsquo;ve allocated enough memory for the renderbuffer object we can unbind the renderbuffer.</p>
<p>hen, as a final step before we complete the framebuffer, we attach the renderbuffer object to the depth <strong>and</strong> stencil attachment of the framebuffer:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glFramebufferRenderbuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">GL_DEPTH_STENCIL_ATTACHMENT</span><span class="p">,</span> <span class="n">GL_RENDERBUFFER</span><span class="p">,</span> <span class="n">rbo</span><span class="p">);</span></span></span></code></pre></div><p>Then we want to check if the framebuffer is complete and if it&rsquo;s not, we print an error message.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">if</span><span class="p">(</span><span class="n">glCheckFramebufferStatus</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">)</span> <span class="o">!=</span> <span class="n">GL_FRAMEBUFFER_COMPLETE</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;ERROR::FRAMEBUFFER:: Framebuffer is not complete!&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  
</span></span></code></pre></div><p>Be sure to unbind the framebuffer to make sure we&rsquo;re not accidentally rendering to the wrong framebuffer.</p>
<p>Now that the framebuffer is complete, all we need to do to render to the framebuffer&rsquo;s buffers instead of the default framebuffers is to simply bind the framebuffer object. All subsequent render commands will then influence the currently bound framebuffer. All the depth and stencil operations will also read from the currently bound framebuffer&rsquo;s depth and stencil attachments if they&rsquo;re available. If you were to omit a depth buffer for example, all depth testing operations will no longer work.</p>
<p>So, to draw the scene to a single texture we&rsquo;ll have to take the following steps:</p>
<ol>
<li>Render the scene as usual with the new framebuffer bound as the active framebuffer.</li>
<li>Bind to the default framebuffer.</li>
<li>Draw a quad that spans the entire screen with the new framebuffer&rsquo;s color buffer as its texture.</li>
</ol>
<p>We&rsquo;ll render the same scene we&rsquo;ve used in the <a href="https://learnopengl.com/Advanced-OpenGL/Depth-testing" target="_blank">depth testing</a> chapter, but this time with the old-school <a href="https://learnopengl.com/img/textures/container.jpg" target="_blank">container</a> texture.</p>
<p>o render the quad we&rsquo;re going to create a fresh set of simple shaders. We&rsquo;re not going to include fancy matrix transformations since we&rsquo;ll be supplying the <a href="https://learnopengl.com/code_viewer.php?code=advanced/framebuffers_quad_vertices" target="_blank">vertex coordinates as normalized device coordinates</a> so we can directly forward them as output of the vertex shader. The vertex shader looks like this:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec2</span> <span class="n">aPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec2</span> <span class="n">aTexCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">out</span> <span class="n">vec2</span> <span class="n">TexCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">aPos</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">aPos</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="n">TexCoords</span> <span class="o">=</span> <span class="n">aTexCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>Nothing too fancy. The fragment shader is even more basic since the only thing we have to do is sample from a texture:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">out</span> <span class="n">vec4</span> <span class="n">FragColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">in</span> <span class="n">vec2</span> <span class="n">TexCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">screenTexture</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="n">FragColor</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">screenTexture</span><span class="p">,</span> <span class="n">TexCoords</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>It is then up to you to create and configure a VAO for the screen quad. A single render iteration of the framebuffer procedure has the following structure:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="c1">// first pass
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1"></span><span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">framebuffer</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">glClearColor</span><span class="p">(</span><span class="mf">0.1f</span><span class="p">,</span> <span class="mf">0.1f</span><span class="p">,</span> <span class="mf">0.1f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">glClear</span><span class="p">(</span><span class="n">GL_COLOR_BUFFER_BIT</span> <span class="o">|</span> <span class="n">GL_DEPTH_BUFFER_BIT</span><span class="p">);</span> <span class="c1">// we&#39;re not using the stencil buffer now
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="c1"></span><span class="n">glEnable</span><span class="p">(</span><span class="n">GL_DEPTH_TEST</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">DrawScene</span><span class="p">();</span>	
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="c1">// second pass
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1"></span><span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// back to default
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1"></span><span class="n">glClearColor</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="n">glClear</span><span class="p">(</span><span class="n">GL_COLOR_BUFFER_BIT</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">  
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="n">screenShader</span><span class="p">.</span><span class="n">use</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">quadVAO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="n">glDisable</span><span class="p">(</span><span class="n">GL_DEPTH_TEST</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">textureColorbuffer</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="n">glDrawArrays</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>  
</span></span></code></pre></div><p>There are a few things to note. First, since each framebuffer we&rsquo;re using has its own set of buffers, we want to clear each of those buffers with the appropriate bits set by calling glClear. Second, when drawing the quad, we&rsquo;re disabling depth testing since we want to make sure the quad always renders in front of everything else; we&rsquo;ll have to enable depth testing again when we draw the normal scene though.</p>
<p>There are quite some steps that could go wrong here, so if you have no output, try to debug where possible and re-read the relevant sections of the chapter. If everything did work out successfully you&rsquo;ll get a visual result that looks like this:</p>
<p><a href="#R-image-9c583f69f7f651f45144f4b7ac40fe09" class="lightbox-link"><img src="./assets/framebuffers_screen_texture.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-9c583f69f7f651f45144f4b7ac40fe09"><img src="./assets/framebuffers_screen_texture.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>The left shows the visual output, exactly the same as we&rsquo;ve seen in the <a href="https://learnopengl.com/Advanced-OpenGL/Depth-testing" target="_blank">depth testing</a> chapter, but this time rendered on a simple quad. If we render the scene in wireframe it&rsquo;s obvious we&rsquo;ve only drawn a single quad in the default framebuffer.</p>
<p>You can find the source code of the application <a href="https://learnopengl.com/code_viewer_gh.php?code=src/4.advanced_opengl/5.1.framebuffers/framebuffers.cpp" target="_blank">here</a>.</p>
<p>So what was the use of this again? Well, because we can now freely access each of the pixels of the completely rendered scene as a single texture image, we can create some interesting effects in the fragment shader.</p>
<h4 id="post-processing">Post-processing</h4>
<p>Now that the entire scene is rendered to a single texture we can create cool post-processing effects by manipulating the scene texture. In this section we&rsquo;ll show you some of the more popular post-processing effects and how you may create your own with some added creativity.</p>
<p>Let&rsquo;s start with one of the simplest post-processing effects.</p>
<h5 id="inversion">Inversion</h5>
<p>We have access to each of the colors of the render output so it&rsquo;s not so hard to return the inverse of these colors in the fragment shader. We can take the color of the screen texture and inverse it by subtracting it from <code>1.0</code>:</p>
<div class="wrap-code highlight"><pre tabindex="0"><code>void main()
{
    FragColor = vec4(vec3(1.0 - texture(screenTexture, TexCoords)), 1.0);
}  </code></pre></div><p>While inversion is a relatively simple post-processing effect it already creates funky results:</p>
<p><a href="#R-image-3a930e5656124f4d3c12a5c4ef6bd3ba" class="lightbox-link"><img src="./assets/framebuffers_inverse.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-3a930e5656124f4d3c12a5c4ef6bd3ba"><img src="./assets/framebuffers_inverse.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>The entire scene now has all its colors inversed with a single line of code in the fragment shader. Pretty cool huh?</p>
<h5 id="grayscale">Grayscale</h5>
<p>Another interesting effect is to remove all colors from the scene except the white, gray and black colors; effectively grayscaling the entire image. An easy way to do this is by taking all the color components and averaging their results:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="n">FragColor</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">screenTexture</span><span class="p">,</span> <span class="n">TexCoords</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="kt">float</span> <span class="n">average</span> <span class="o">=</span> <span class="p">(</span><span class="n">FragColor</span><span class="p">.</span><span class="n">r</span> <span class="o">+</span> <span class="n">FragColor</span><span class="p">.</span><span class="n">g</span> <span class="o">+</span> <span class="n">FragColor</span><span class="p">.</span><span class="n">b</span><span class="p">)</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">    <span class="n">FragColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">average</span><span class="p">,</span> <span class="n">average</span><span class="p">,</span> <span class="n">average</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="p">}</span>   
</span></span></code></pre></div><p>This already creates pretty good results, but the human eye tends to be more sensitive to green colors and the least to blue. So to get the most physically accurate results we&rsquo;ll need to use weighted channels:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="n">FragColor</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">screenTexture</span><span class="p">,</span> <span class="n">TexCoords</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="kt">float</span> <span class="n">average</span> <span class="o">=</span> <span class="mf">0.2126</span> <span class="o">*</span> <span class="n">FragColor</span><span class="p">.</span><span class="n">r</span> <span class="o">+</span> <span class="mf">0.7152</span> <span class="o">*</span> <span class="n">FragColor</span><span class="p">.</span><span class="n">g</span> <span class="o">+</span> <span class="mf">0.0722</span> <span class="o">*</span> <span class="n">FragColor</span><span class="p">.</span><span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">    <span class="n">FragColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">average</span><span class="p">,</span> <span class="n">average</span><span class="p">,</span> <span class="n">average</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="p">}</span> 
</span></span></code></pre></div><p><a href="#R-image-732386e5ef3aa581fe348d6f205aa57f" class="lightbox-link"><img src="./assets/framebuffers_grayscale.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-732386e5ef3aa581fe348d6f205aa57f"><img src="./assets/framebuffers_grayscale.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>You probably won&rsquo;t notice the difference right away, but with more complicated scenes, such a weighted grayscaling effect tends to be more realistic.</p>
<h4 id="kernel-effects">Kernel effects</h4>
<p>Another advantage about doing post-processing on a single texture image is that we can sample color values from other parts of the texture not specific to that fragment. We could for example take a small area around the current texture coordinate and sample multiple texture values around the current texture value. We can then create interesting effects by combining them in creative ways.</p>
<p>A kernel (or convolution matrix) is a small matrix-like array of values centered on the current pixel that multiplies surrounding pixel values by its kernel values and adds them all together to form a single value. We&rsquo;re adding a small offset to the texture coordinates in surrounding directions of the current pixel and combine the results based on the kernel. An example of a kernel is given below:</p>

<span class="math align-center">$$
\begin{bmatrix}2 & 2 & 2 \\ 2 & -15 & 2 \\ 2 & 2 & 2 \end{bmatrix}
$$</span><p>This kernel takes 8 surrounding pixel values and multiplies them by <code>2</code> and the current pixel by <code>-15</code>. This example kernel multiplies the surrounding pixels by several weights determined in the kernel and balances the result by multiplying the current pixel by a large negative weight.</p>
<p><note>Most kernels you&rsquo;ll find over the internet all sum up to <code>1</code> if you add all the weights together. If they don&rsquo;t add up to <code>1</code> it means that the resulting texture color ends up brighter or darker than the original texture value.</note></p>
<p>Kernels are an extremely useful tool for post-processing since they&rsquo;re quite easy to use and experiment with, and a lot of examples can be found online. We do have to slightly adapt the fragment shader a bit to actually support kernels. We make the assumption that each kernel we&rsquo;ll be using is a 3x3 kernel (which most kernels are):</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">const</span> <span class="kt">float</span> <span class="n">offset</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mf">300.0</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="n">vec2</span> <span class="n">offsets</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="n">vec2</span><span class="p">[](</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">        <span class="n">vec2</span><span class="p">(</span><span class="o">-</span><span class="n">offset</span><span class="p">,</span>  <span class="n">offset</span><span class="p">),</span> <span class="c1">// top-left
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1"></span>        <span class="n">vec2</span><span class="p">(</span> <span class="mf">0.0f</span><span class="p">,</span>    <span class="n">offset</span><span class="p">),</span> <span class="c1">// top-center
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="c1"></span>        <span class="n">vec2</span><span class="p">(</span> <span class="n">offset</span><span class="p">,</span>  <span class="n">offset</span><span class="p">),</span> <span class="c1">// top-right
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1"></span>        <span class="n">vec2</span><span class="p">(</span><span class="o">-</span><span class="n">offset</span><span class="p">,</span>  <span class="mf">0.0f</span><span class="p">),</span>   <span class="c1">// center-left
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1"></span>        <span class="n">vec2</span><span class="p">(</span> <span class="mf">0.0f</span><span class="p">,</span>    <span class="mf">0.0f</span><span class="p">),</span>   <span class="c1">// center-center
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="c1"></span>        <span class="n">vec2</span><span class="p">(</span> <span class="n">offset</span><span class="p">,</span>  <span class="mf">0.0f</span><span class="p">),</span>   <span class="c1">// center-right
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="c1"></span>        <span class="n">vec2</span><span class="p">(</span><span class="o">-</span><span class="n">offset</span><span class="p">,</span> <span class="o">-</span><span class="n">offset</span><span class="p">),</span> <span class="c1">// bottom-left
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="c1"></span>        <span class="n">vec2</span><span class="p">(</span> <span class="mf">0.0f</span><span class="p">,</span>   <span class="o">-</span><span class="n">offset</span><span class="p">),</span> <span class="c1">// bottom-center
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="c1"></span>        <span class="n">vec2</span><span class="p">(</span> <span class="n">offset</span><span class="p">,</span> <span class="o">-</span><span class="n">offset</span><span class="p">)</span>  <span class="c1">// bottom-right    
</span></span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="c1"></span>    <span class="p">);</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">
</span></span><span class="line"><span class="ln">17</span><span class="cl">    <span class="kt">float</span> <span class="n">kernel</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="kt">float</span><span class="p">[](</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">        <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">        <span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">        <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">    <span class="p">);</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">    
</span></span><span class="line"><span class="ln">23</span><span class="cl">    <span class="n">vec3</span> <span class="n">sampleTex</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">9</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl">        <span class="n">sampleTex</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">vec3</span><span class="p">(</span><span class="n">texture</span><span class="p">(</span><span class="n">screenTexture</span><span class="p">,</span> <span class="n">TexCoords</span><span class="p">.</span><span class="n">st</span> <span class="o">+</span> <span class="n">offsets</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">28</span><span class="cl">    <span class="n">vec3</span> <span class="n">col</span> <span class="o">=</span> <span class="n">vec3</span><span class="p">(</span><span class="mf">0.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">29</span><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">9</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">30</span><span class="cl">        <span class="n">col</span> <span class="o">+=</span> <span class="n">sampleTex</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">kernel</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="ln">31</span><span class="cl">    
</span></span><span class="line"><span class="ln">32</span><span class="cl">    <span class="n">FragColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">33</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>In the fragment shader we first create an array of 9 <code>vec2</code> offsets for each surrounding texture coordinate. The offset is a constant value that you could customize to your liking. Then we define the kernel, which in this case is a sharpen kernel that sharpens each color value by sampling all surrounding pixels in an interesting way. Lastly, we add each offset to the current texture coordinate when sampling and multiply these texture values with the weighted kernel values that we add together.</p>
<p>This particular sharpen kernel looks like this:</p>
<p><a href="#R-image-c86dfd6e70f432edfa2f4b87ecac9399" class="lightbox-link"><img src="./assets/framebuffers_sharpen.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c86dfd6e70f432edfa2f4b87ecac9399"><img src="./assets/framebuffers_sharpen.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>This could be the base of some interesting effects where your player may be on a narcotic adventure.</p>
<h5 id="blur">Blur</h5>
<p>A kernel that creates a blur effect is defined as follows:</p>

<span class="math align-center">$$
\begin{bmatrix} 1 & 2 & 1 \\ 2 & 4 & 2 \\ 1 & 2 & 1 \end{bmatrix} / 16
$$</span><p>Because all values add up to 16, directly returning the combined sampled colors would result in an extremely bright color so we have to divide each value of the kernel by <code>16</code>. The resulting kernel array then becomes:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">float</span> <span class="n">kernel</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="kt">float</span><span class="p">[](</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">    <span class="mf">1.0</span> <span class="o">/</span> <span class="mi">16</span><span class="p">,</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="mi">16</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mi">16</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="mf">2.0</span> <span class="o">/</span> <span class="mi">16</span><span class="p">,</span> <span class="mf">4.0</span> <span class="o">/</span> <span class="mi">16</span><span class="p">,</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="mi">16</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="mf">1.0</span> <span class="o">/</span> <span class="mi">16</span><span class="p">,</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="mi">16</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mi">16</span>  
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="p">);</span></span></span></code></pre></div><p>By only changing the kernel array in the fragment shader we can completely change the post-processing effect. It now looks something like this:</p>
<p><a href="#R-image-879b12d1fa62645eebed64dfd07a21e6" class="lightbox-link"><img src="./assets/framebuffers_blur.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-879b12d1fa62645eebed64dfd07a21e6"><img src="./assets/framebuffers_blur.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Such a blur effect creates interesting possibilities. We could vary the blur amount over time to create the effect of someone being drunk, or increase the blur whenever the main character is not wearing glasses. Blurring can also be a useful tool for smoothing color values which we&rsquo;ll see use of in later chapters.</p>
<p>You can see that once we have such a little kernel implementation in place it is quite easy to create cool post-processing effects. Let&rsquo;s show you a last popular effect to finish this discussion.</p>
<h5 id="edge-detection">Edge detection</h5>
<p>Below you can find an edge-detection kernel that is similar to the sharpen kernel:</p>

<span class="math align-center">$$
\begin{bmatrix} 1 & 1 & 1 \\ 1 & -8 & 1 \\ 1 & 1 & 1 \end{bmatrix}
$$</span><p>This kernel highlights all edges and darkens the rest, which is pretty useful when we only care about edges in an image.</p>
<p><a href="#R-image-50d87a7a19ec7e639ef6d2981073bbba" class="lightbox-link"><img src="./assets/framebuffers_edge_detection.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-50d87a7a19ec7e639ef6d2981073bbba"><img src="./assets/framebuffers_edge_detection.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>It probably does not come as a surprise that kernels like this are used as image-manipulating tools/filters in tools like Photoshop. Because of a graphic card&rsquo;s ability to process fragments with extreme parallel capabilities, we can manipulate images on a per-pixel basis in real-time with relative ease. Image-editing tools therefore tend to use graphics cards for image-processing.</p>
<h4 id="exercises-12">Exercises</h4>
<ul>
<li>Can you use framebuffers to create a rear-view mirror? For this you&rsquo;ll have to draw your scene twice: one with the camera rotated 180 degrees and the other as normal. Try to create a small quad at the top of your screen to apply the mirror texture on, something like <a href="https://learnopengl.com/img/advanced/framebuffers_mirror.png" target="_blank">this</a>; <a href="https://learnopengl.com/code_viewer_gh.php?code=src/4.advanced_opengl/5.2.framebuffers_exercise1/framebuffers_exercise1.cpp" target="_blank">solution</a>.</li>
<li>Play around with the kernel values and create your own interesting post-processing effects. Try searching the internet as well for other interesting kernels.</li>
</ul>
<h3 id="cubemaps">Cubemaps</h3>
<p>We&rsquo;ve been using 2D textures for a while now, but there are more texture types we haven&rsquo;t explored yet and in this chapter we&rsquo;ll discuss a texture type that is a combination of multiple textures mapped into one: a cube map.</p>
<p>A cubemap is a texture that contains 6 individual 2D textures that each form one side of a cube: a textured cube. You may be wondering what the point is of such a cube? Why bother combining 6 individual textures into a single entity instead of just using 6 individual textures? Well, cube maps have the useful property that they can be indexed/sampled using a direction vector. Imagine we have a 1x1x1 unit cube with the origin of a direction vector residing at its center. Sampling a texture value from the cube map with an orange direction vector looks a bit like this:</p>
<p><a href="#R-image-51085504891497a71c4741536aa8a894" class="lightbox-link"><img src="./assets/cubemaps_sampling.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-51085504891497a71c4741536aa8a894"><img src="./assets/cubemaps_sampling.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><note>The magnitude of the direction vector doesn&rsquo;t matter. As long as a direction is supplied, OpenGL retrieves the corresponding texels that the direction hits (eventually) and returns the properly sampled texture value.</note></p>
<p>If we imagine we have a cube shape that we attach such a cubemap to, this direction vector would be similar to the (interpolated) local vertex position of the cube. This way we can sample the cubemap using the cube&rsquo;s actual position vectors as long as the cube is centered on the origin. We thus consider all vertex positions of the cube to be its texture coordinates when sampling a cubemap. The result is a texture coordinate that accesses the proper individual face texture of the cubemap.</p>
<h4 id="creating-a-cubemap">Creating a cubemap</h4>
<p>A cubemap is a texture like any other texture, so to create one we generate a texture and bind it to the proper texture target before we do any further texture operations. This time binding it to GL_TEXTURE_CUBE_MAP:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">textureID</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glGenTextures</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">textureID</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_CUBE_MAP</span><span class="p">,</span> <span class="n">textureID</span><span class="p">);</span></span></span></code></pre></div><p>Because a cubemap contains 6 textures, one for each face, we have to call glTexImage2D six times with their parameters set similarly to the previous chapters. This time however, we have to set the texture <em>target</em> parameter to match a specific face of the cubemap, telling OpenGL which side of the cubemap we&rsquo;re creating a texture for. This means we have to call glTexImage2D once for each face of the cubemap.</p>
<p>Since we have 6 faces OpenGL gives us 6 special texture targets for targeting a face of the cubemap:</p>
<p><a href="#R-image-48ad6312c9be28ab3f2b6b03d011ac60" class="lightbox-link"><img src="./assets/20240214085909.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-48ad6312c9be28ab3f2b6b03d011ac60"><img src="./assets/20240214085909.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Like many of OpenGL&rsquo;s enums, their behind-the-scenes int value is linearly incremented, so if we were to have an array or vector of texture locations we could loop over them by starting with GL_TEXTURE_CUBE_MAP_POSITIVE_X and incrementing the enum by 1 each iteration, effectively looping through all the texture targets:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">nrChannels</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">textures_faces</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="n">data</span> <span class="o">=</span> <span class="n">stbi_load</span><span class="p">(</span><span class="n">textures_faces</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">c_str</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">width</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">height</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nrChannels</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="n">glTexImage2D</span><span class="p">(</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">        <span class="n">GL_TEXTURE_CUBE_MAP_POSITIVE_X</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> 
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGB</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGB</span><span class="p">,</span> <span class="n">GL_UNSIGNED_BYTE</span><span class="p">,</span> <span class="n">data</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="p">);</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>Here we have a vector called textures_faces that contain the locations of all the textures required for the cubemap in the order as given in the table. This generates a texture for each face of the currently bound cubemap.</p>
<p>Because a cubemap is a texture like any other texture, we will also specify its wrapping and filtering methods:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_CUBE_MAP</span><span class="p">,</span> <span class="n">GL_TEXTURE_MAG_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_CUBE_MAP</span><span class="p">,</span> <span class="n">GL_TEXTURE_MIN_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_CUBE_MAP</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_S</span><span class="p">,</span> <span class="n">GL_CLAMP_TO_EDGE</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_CUBE_MAP</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_T</span><span class="p">,</span> <span class="n">GL_CLAMP_TO_EDGE</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_CUBE_MAP</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_R</span><span class="p">,</span> <span class="n">GL_CLAMP_TO_EDGE</span><span class="p">);</span>  
</span></span></code></pre></div><p>Don&rsquo;t be scared by the GL_TEXTURE_WRAP_R, this simply sets the wrapping method for the texture&rsquo;s <code>R</code> coordinate which corresponds to the texture&rsquo;s 3rd dimension (like <code>z</code> for positions). We set the wrapping method to GL_CLAMP_TO_EDGE since texture coordinates that are exactly between two faces may not hit an exact face (due to some hardware limitations) so by using GL_CLAMP_TO_EDGE OpenGL always returns their edge values whenever we sample between faces.</p>
<p>Then before drawing the objects that will use the cubemap, we activate the corresponding texture unit and bind the cubemap before rendering; not much of a difference compared to normal 2D textures.</p>
<p>Within the fragment shader we also have to use a different sampler of the type <code>samplerCube</code> that we sample from using the texture function, but this time using a <code>vec3</code> direction vector instead of a <code>vec2</code>. An example of fragment shader using a cubemap looks like this:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">in</span> <span class="n">vec3</span> <span class="n">textureDir</span><span class="p">;</span> <span class="c1">// direction vector representing a 3D texture coordinate
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="c1"></span><span class="n">uniform</span> <span class="n">samplerCube</span> <span class="n">cubemap</span><span class="p">;</span> <span class="c1">// cubemap texture sampler
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="p">{</span>             
</span></span><span class="line"><span class="ln">6</span><span class="cl">    <span class="n">FragColor</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">cubemap</span><span class="p">,</span> <span class="n">textureDir</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>That is still great and all, but why bother? Well, it just so happens that there are quite a few interesting techniques that are a lot easier to implement with a cubemap. One of those techniques is creating a skybox.</p>
<h4 id="skybox">Skybox</h4>
<p>A skybox is a (large) cube that encompasses the entire scene and contains 6 images of a surrounding environment, giving the player the illusion that the environment he&rsquo;s in is actually much larger than it actually is. Some examples of skyboxes used in videogames are images of mountains, of clouds, or of a starry night sky. An example of a skybox, using starry night sky images, can be seen in the following screenshot of the third elder scrolls game:</p>
<p><a href="#R-image-5f176c1af06eda629307168d3682c96f" class="lightbox-link"><img src="./assets/cubemaps_morrowind.jpg" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-5f176c1af06eda629307168d3682c96f"><img src="./assets/cubemaps_morrowind.jpg" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>You probably guessed by now that skyboxes like this suit cubemaps perfectly: we have a cube that has 6 faces and needs to be textured per face. In the previous image they used several images of a night sky to give the illusion the player is in some large universe while he&rsquo;s actually inside a tiny little box.</p>
<p>There are usually enough resources online where you could find skyboxes like that. These skybox images usually have the following pattern:</p>
<p><a href="#R-image-4cdf08d3726693d312562c892cf17a84" class="lightbox-link"><img src="./assets/cubemaps_skybox.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-4cdf08d3726693d312562c892cf17a84"><img src="./assets/cubemaps_skybox.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>If you would fold those 6 sides into a cube you&rsquo;d get the completely textured cube that simulates a large landscape. Some resources provide the skybox in a format like that in which case you&rsquo;d have to manually extract the 6 face images, but in most cases they&rsquo;re provided as 6 single texture images.</p>
<p>This particular (high-quality) skybox is what we&rsquo;ll use for our scene and can be downloaded <a href="https://learnopengl.com/img/textures/skybox.zip" target="_blank">here</a>.</p>
<h4 id="loading-a-skybox">Loading a skybox</h4>
<p>Since a skybox is by itself just a cubemap, loading a skybox isn&rsquo;t too different from what we&rsquo;ve seen at the start of this chapter. To load the skybox we&rsquo;re going to use the following function that accepts a vector of 6 texture locations:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">loadCubemap</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">faces</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">textureID</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="n">glGenTextures</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">textureID</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_CUBE_MAP</span><span class="p">,</span> <span class="n">textureID</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">nrChannels</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">faces</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">        <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">stbi_load</span><span class="p">(</span><span class="n">faces</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">c_str</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">width</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">height</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nrChannels</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">            <span class="n">glTexImage2D</span><span class="p">(</span><span class="n">GL_TEXTURE_CUBE_MAP_POSITIVE_X</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> 
</span></span><span class="line"><span class="ln">14</span><span class="cl">                         <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGB</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGB</span><span class="p">,</span> <span class="n">GL_UNSIGNED_BYTE</span><span class="p">,</span> <span class="n">data</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">            <span class="p">);</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">            <span class="n">stbi_image_free</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">        <span class="k">else</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Cubemap tex failed to load at path: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">faces</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">            <span class="n">stbi_image_free</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">    <span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_CUBE_MAP</span><span class="p">,</span> <span class="n">GL_TEXTURE_MIN_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl">    <span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_CUBE_MAP</span><span class="p">,</span> <span class="n">GL_TEXTURE_MAG_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl">    <span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_CUBE_MAP</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_S</span><span class="p">,</span> <span class="n">GL_CLAMP_TO_EDGE</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl">    <span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_CUBE_MAP</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_T</span><span class="p">,</span> <span class="n">GL_CLAMP_TO_EDGE</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">28</span><span class="cl">    <span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_CUBE_MAP</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_R</span><span class="p">,</span> <span class="n">GL_CLAMP_TO_EDGE</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">29</span><span class="cl">
</span></span><span class="line"><span class="ln">30</span><span class="cl">    <span class="k">return</span> <span class="n">textureID</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">31</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>The function itself shouldn&rsquo;t be too surprising. It is basically all the cubemap code we&rsquo;ve seen in the previous section, but combined in a single manageable function.</p>
<p>Now, before we call this function we&rsquo;ll load the appropriate texture paths in a vector in the order as specified by the cubemap enums:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">faces</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="s">&#34;right.jpg&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="s">&#34;left.jpg&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="s">&#34;top.jpg&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="s">&#34;bottom.jpg&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="s">&#34;front.jpg&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="s">&#34;back.jpg&#34;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cubemapTexture</span> <span class="o">=</span> <span class="n">loadCubemap</span><span class="p">(</span><span class="n">faces</span><span class="p">);</span>  
</span></span></code></pre></div><p>We loaded the skybox as a cubemap with cubemapTexture as its id. We can now finally bind it to a cube to replace that lame clear color we&rsquo;ve been using all this time.</p>
<h4 id="displaying-a-skybox">Displaying a skybox</h4>
<p>Because a skybox is drawn on a cube we&rsquo;ll need another VAO, VBO and a fresh set of vertices like any other 3D object. You can get its vertex data <a href="https://learnopengl.com/code_viewer.php?code=advanced/cubemaps_skybox_data" target="_blank">here</a>.</p>
<p>A cubemap used to texture a 3D cube can be sampled using the local positions of the cube as its texture coordinates. When a cube is centered on the origin (0,0,0) each of its position vectors is also a direction vector from the origin. This direction vector is exactly what we need to get the corresponding texture value at that specific cube&rsquo;s position. For this reason we only need to supply position vectors and don&rsquo;t need texture coordinates.</p>
<p>To render the skybox we&rsquo;ll need a new set of shaders which aren&rsquo;t too complicated. Because we only have one vertex attribute the vertex shader is quite simple:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">aPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">out</span> <span class="n">vec3</span> <span class="n">TexCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">uniform</span> <span class="n">mat4</span> <span class="n">projection</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="n">uniform</span> <span class="n">mat4</span> <span class="n">view</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="n">TexCoords</span> <span class="o">=</span> <span class="n">aPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">projection</span> <span class="o">*</span> <span class="n">view</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">aPos</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>The interesting part of this vertex shader is that we set the incoming local position vector as the outcoming texture coordinate for (interpolated) use in the fragment shader. The fragment shader then takes these as input to sample a <code>samplerCube</code>:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">out</span> <span class="n">vec4</span> <span class="n">FragColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">in</span> <span class="n">vec3</span> <span class="n">TexCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">uniform</span> <span class="n">samplerCube</span> <span class="n">skybox</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="p">{</span>    
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="n">FragColor</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">skybox</span><span class="p">,</span> <span class="n">TexCoords</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>The fragment shader is relatively straightforward. We take the vertex attribute&rsquo;s interpolated position vector as the texture&rsquo;s direction vector and use it to sample the texture values from the cubemap.</p>
<p>Rendering the skybox is easy now that we have a cubemap texture, we simply bind the cubemap texture and the skybox sampler is automatically filled with the skybox cubemap. To draw the skybox we&rsquo;re going to draw it as the first object in the scene and disable depth writing. This way the skybox will always be drawn at the background of all the other objects since the unit cube is most likely smaller than the rest of the scene.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glDepthMask</span><span class="p">(</span><span class="n">GL_FALSE</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">skyboxShader</span><span class="p">.</span><span class="n">use</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="c1">// ... set view and projection matrix
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="c1"></span><span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">skyboxVAO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_CUBE_MAP</span><span class="p">,</span> <span class="n">cubemapTexture</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="n">glDrawArrays</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">36</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="n">glDepthMask</span><span class="p">(</span><span class="n">GL_TRUE</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">8</span><span class="cl"><span class="c1">// ... draw rest of the scene
</span></span></span></code></pre></div><p>If you run this you will get into difficulties though. We want the skybox to be centered around the player so that no matter how far the player moves, the skybox won&rsquo;t get any closer, giving the impression the surrounding environment is extremely large. The current view matrix however transforms all the skybox&rsquo;s positions by rotating, scaling and translating them, so if the player moves, the cubemap moves as well! We want to remove the translation part of the view matrix so only rotation will affect the skybox&rsquo;s position vectors.</p>
<p>You may remember from the <a href="https://learnopengl.com/Lighting/Basic-Lighting" target="_blank">basic lighting</a> chapter that we can remove the translation section of transformation matrices by taking the upper-left 3x3 matrix of the 4x4 matrix. We can achieve this by converting the view matrix to a 3x3 matrix (removing translation) and converting it back to a 4x4 matrix:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span> <span class="n">view</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">mat3</span><span class="p">(</span><span class="n">camera</span><span class="p">.</span><span class="n">GetViewMatrix</span><span class="p">()));</span>  
</span></span></code></pre></div><p>This removes any translation, but keeps all rotation transformations so the user can still look around the scene.</p>
<p>The result is a scene that instantly looks enormous due to our skybox. If you&rsquo;d fly around the basic container you immediately get a sense of scale which dramatically improves the realism of the scene. The result looks something like this:</p>
<p><a href="#R-image-31ac72337ca3a9f08c342a13bb8635f8" class="lightbox-link"><img src="./assets/cubemaps_skybox_result.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-31ac72337ca3a9f08c342a13bb8635f8"><img src="./assets/cubemaps_skybox_result.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Try experimenting with different skyboxes and see how they can have an enormous impact on the look and feel of your scene.</p>
<h4 id="an-optimization-1">An optimization</h4>
<p>Right now we&rsquo;ve rendered the skybox first before we rendered all the other objects in the scene. This works great, but isn&rsquo;t too efficient. If we render the skybox first we&rsquo;re running the fragment shader for each pixel on the screen even though only a small part of the skybox will eventually be visible; fragments that could have easily been discarded using early depth testing saving us valuable bandwidth.</p>
<p>So to give us a slight performance boost we&rsquo;re going to render the skybox last. This way, the depth buffer is completely filled with all the scene&rsquo;s depth values so we only have to render the skybox&rsquo;s fragments wherever the early depth test passes, greatly reducing the number of fragment shader calls. The problem is that the skybox will most likely render on top of all other objects since it&rsquo;s only a 1x1x1 cube, succeeding most depth tests. Simply rendering it without depth testing is not a solution since the skybox will then still overwrite all the other objects in the scene as it&rsquo;s rendered last. We need to trick the depth buffer into believing that the skybox has the maximum depth value of <code>1.0</code> so that it fails the depth test wherever there&rsquo;s a different object in front of it.</p>
<p>In the <a href="https://learnopengl.com/Getting-started/Coordinate-Systems" target="_blank">coordinate systems</a> chapter we said that <em>perspective division</em> is performed after the vertex shader has run, dividing the gl_Position&rsquo;s <code>xyz</code> coordinates by its <code>w</code> component. We also know from the <a href="https://learnopengl.com/Advanced-OpenGL/Depth-testing" target="_blank">depth testing</a> chapter that the <code>z</code> component of the resulting division is equal to that vertex&rsquo;s depth value. Using this information we can set the <code>z</code> component of the output position equal to its <code>w</code> component which will result in a <code>z</code> component that is always equal to <code>1.0</code>, because when the perspective division is applied its <code>z</code> component translates to <code>w</code> / <code>w</code> = <code>1.0</code>:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="n">TexCoords</span> <span class="o">=</span> <span class="n">aPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="n">vec4</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">projection</span> <span class="o">*</span> <span class="n">view</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">aPos</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">pos</span><span class="p">.</span><span class="n">xyww</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>The resulting <em>normalized device coordinates</em> will then always have a <code>z</code> value equal to <code>1.0</code>: the maximum depth value. The skybox will as a result only be rendered wherever there are no objects visible (only then it will pass the depth test, everything else is in front of the skybox).</p>
<p>We do have to change the depth function a little by setting it to GL_LEQUAL instead of the default GL_LESS. The depth buffer will be filled with values of <code>1.0</code> for the skybox, so we need to make sure the skybox passes the depth tests with values <em>less than or equal</em> to the depth buffer instead of <em>less than</em>.</p>
<p>You can find the more optimized version of the source code <a href="https://learnopengl.com/code_viewer_gh.php?code=src/4.advanced_opengl/6.1.cubemaps_skybox/cubemaps_skybox.cpp" target="_blank">here</a>.</p>
<h4 id="environment-mapping">Environment mapping</h4>
<p>We now have the entire surrounding environment mapped in a single texture object and we could use that information for more than just a skybox. Using a cubemap with an environment, we could give objects reflective or refractive properties. Techniques that use an environment cubemap like this are called environment mapping techniques and the two most popular ones are reflection and refraction.</p>
<h5 id="reflection">Reflection</h5>
<p>Reflection is the property that an object (or part of an object) reflects its surrounding environment e.g. the object&rsquo;s colors are more or less equal to its environment based on the angle of the viewer. A mirror for example is a reflective object: it reflects its surroundings based on the viewer&rsquo;s angle.</p>
<p>The basics of reflection are not that difficult. The following image shows how we can calculate a reflection vector and use that vector to sample from a cubemap:</p>
<p><a href="#R-image-bd9d1c00a5f7f974ce5cb692bf13d22a" class="lightbox-link"><img src="./assets/cubemaps_reflection_theory.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-bd9d1c00a5f7f974ce5cb692bf13d22a"><img src="./assets/cubemaps_reflection_theory.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>We calculate a reflection vector R¯�¯ around the object&rsquo;s normal vector N¯�¯ based on the view direction vector I¯�¯. We can calculate this reflection vector using GLSL&rsquo;s built-in reflect function. The resulting vector R¯�¯ is then used as a direction vector to index/sample the cubemap, returning a color value of the environment. The resulting effect is that the object seems to reflect the skybox.</p>
<p>Since we already have a skybox setup in our scene, creating reflections isn&rsquo;t too difficult. We&rsquo;ll change the fragment shader used by the container to give the container reflective properties:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">out</span> <span class="n">vec4</span> <span class="n">FragColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">in</span> <span class="n">vec3</span> <span class="n">Normal</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">in</span> <span class="n">vec3</span> <span class="n">Position</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="n">uniform</span> <span class="n">vec3</span> <span class="n">cameraPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="n">uniform</span> <span class="n">samplerCube</span> <span class="n">skybox</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="p">{</span>             
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="n">vec3</span> <span class="n">I</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">Position</span> <span class="o">-</span> <span class="n">cameraPos</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="n">vec3</span> <span class="n">R</span> <span class="o">=</span> <span class="n">reflect</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">normalize</span><span class="p">(</span><span class="n">Normal</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="n">FragColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">texture</span><span class="p">(</span><span class="n">skybox</span><span class="p">,</span> <span class="n">R</span><span class="p">).</span><span class="n">rgb</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>We first calculate the view/camera direction vector I and use this to calculate the reflect vector R which we then use to sample from the skybox cubemap. Note that we have the fragment&rsquo;s interpolated Normal and Position variable again so we&rsquo;ll need to adjust the vertex shader as well:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">aPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">aNormal</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">out</span> <span class="n">vec3</span> <span class="n">Normal</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">out</span> <span class="n">vec3</span> <span class="n">Position</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="n">uniform</span> <span class="n">mat4</span> <span class="n">model</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="n">uniform</span> <span class="n">mat4</span> <span class="n">view</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="n">uniform</span> <span class="n">mat4</span> <span class="n">projection</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="n">Normal</span> <span class="o">=</span> <span class="n">mat3</span><span class="p">(</span><span class="n">transpose</span><span class="p">(</span><span class="n">inverse</span><span class="p">(</span><span class="n">model</span><span class="p">)))</span> <span class="o">*</span> <span class="n">aNormal</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="n">Position</span> <span class="o">=</span> <span class="n">vec3</span><span class="p">(</span><span class="n">model</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">aPos</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">projection</span> <span class="o">*</span> <span class="n">view</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">Position</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>We&rsquo;re using normal vectors so we&rsquo;ll want to transform them with a normal matrix again. The Position output vector is a world-space position vector. This Position output of the vertex shader is used to calculate the view direction vector in the fragment shader.</p>
<p>Because we&rsquo;re using normals you&rsquo;ll want to update the <a href="https://learnopengl.com/code_viewer.php?code=lighting/basic_lighting_vertex_data" target="_blank">vertex data</a> and update the attribute pointers as well. Also make sure to set the cameraPos uniform.</p>
<p>Then we also want to bind the cubemap texture before rendering the container:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">cubeVAO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_CUBE_MAP</span><span class="p">,</span> <span class="n">skyboxTexture</span><span class="p">);</span>  		
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">glDrawArrays</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">36</span><span class="p">);</span>	  
</span></span></code></pre></div><p>Compiling and running your code gives you a container that acts like a perfect mirror. The surrounding skybox is perfectly reflected on the container:</p>
<p><a href="#R-image-586f7a485ef3aa5cffc07db3f0d7d4dc" class="lightbox-link"><img src="./assets/cubemaps_reflection.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-586f7a485ef3aa5cffc07db3f0d7d4dc"><img src="./assets/cubemaps_reflection.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>You can find the full source code <a href="https://learnopengl.com/code_viewer_gh.php?code=src/4.advanced_opengl/6.2.cubemaps_environment_mapping/cubemaps_environment_mapping.cpp" target="_blank">here</a>.</p>
<p>When reflection is applied to an entire object (like the container) the object looks as if it has a high reflective material like steel or chrome. If we were to load a more interesting object (like the backpack model from the <a href="https://learnopengl.com/Model-Loading/Model" target="_blank">model loading</a> chapters) we&rsquo;d get the effect that the object looks to be entirely made out of chrome:</p>
<p><a href="#R-image-d4e9498b915e1a89e80c4e30d4fd0cff" class="lightbox-link"><img src="./assets/cubemaps_reflection_nanosuit.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d4e9498b915e1a89e80c4e30d4fd0cff"><img src="./assets/cubemaps_reflection_nanosuit.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>This looks quite awesome, but in reality most models aren&rsquo;t all completely reflective. We could for instance introduce reflection maps that give the models another extra level of detail. Just like diffuse and specular maps, reflection maps are texture images that we can sample to determine the reflectivity of a fragment. Using these reflection maps we can determine which parts of the model show reflection and by what intensity.</p>
<h4 id="refraction">Refraction</h4>
<p>Another form of environment mapping is called refraction and is similar to reflection. Refraction is the change in direction of light due to the change of the material the light flows through. Refraction is what we commonly see with water-like surfaces where the light doesn&rsquo;t enter straight through, but bends a little. It&rsquo;s like looking at your arm when it&rsquo;s halfway in the water.</p>
<p>Refraction is described by <a href="http://en.wikipedia.org/wiki/Snell%27s_law" target="_blank">Snell&rsquo;s law</a> that with environment maps looks a bit like this:</p>
<p><a href="#R-image-a735fe7d69a0919d78c653f1aeade1bf" class="lightbox-link"><img src="./assets/cubemaps_refraction_theory.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a735fe7d69a0919d78c653f1aeade1bf"><img src="./assets/cubemaps_refraction_theory.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Again, we have a view vector 
<span class="math align-center">$\color{gray}{\bar{I}}$</span>, a normal vector 
<span class="math align-center">$\color{red}{\bar{N}}$</span> and this time a resulting refraction vector 
<span class="math align-center">$\color{green}{\bar{R}}$</span>. As you can see, the direction of the view vector is slightly bend. This resulting bended vector 
<span class="math align-center">$\color{green}{\bar{R}}$</span> is then used to sample from the cubemap.</p>
<p>Refraction is fairly easy to implement using GLSL&rsquo;s built-in refract function that expects a normal vector, a view direction, and a ratio between both materials&rsquo; refractive indices.</p>
<p>The refractive index determines the amount light distorts/bends in a material where each material has its own refractive index. A list of the most common refractive indices are given in the following table:</p>
<p><a href="#R-image-f550a82e57e56d45b12d6687e29db926" class="lightbox-link"><img src="./assets/20240214090811.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f550a82e57e56d45b12d6687e29db926"><img src="./assets/20240214090811.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>We use these refractive indices to calculate the ratio between both materials the light passes through. In our case, the light/view ray goes from <em>air</em> to <em>glass</em> (if we assume the object is made of glass) so the ratio becomes 
<span class="math align-center">$\frac{1.00}{1.52} = 0.658$</span>.</p>
<p>We already have the cubemap bound, supplied the vertex data with normals, and set the camera position as a uniform. The only thing we have to change is the fragment shader:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>             
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="kt">float</span> <span class="n">ratio</span> <span class="o">=</span> <span class="mf">1.00</span> <span class="o">/</span> <span class="mf">1.52</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="n">vec3</span> <span class="n">I</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">Position</span> <span class="o">-</span> <span class="n">cameraPos</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">    <span class="n">vec3</span> <span class="n">R</span> <span class="o">=</span> <span class="n">refract</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">normalize</span><span class="p">(</span><span class="n">Normal</span><span class="p">),</span> <span class="n">ratio</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">    <span class="n">FragColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">texture</span><span class="p">(</span><span class="n">skybox</span><span class="p">,</span> <span class="n">R</span><span class="p">).</span><span class="n">rgb</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>By changing the refractive indices you can create completely different visual results. Compiling the application and running the results on the container object is not so interesting though as it doesn&rsquo;t really show the effect refraction has aside that it acts as a magnifying glass right now. Using the same shaders on the loaded 3D model however does show us the effect we&rsquo;re looking for: a glass-like object.</p>
<p><a href="#R-image-93c85b56f3a1db874e44938120c27bde" class="lightbox-link"><img src="./assets/cubemaps_refraction.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-93c85b56f3a1db874e44938120c27bde"><img src="./assets/cubemaps_refraction.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>You can imagine that with the right combination of lighting, reflection, refraction and vertex movement, you can create pretty neat water graphics. Do note that for physically accurate results we should refract the light <strong>again</strong> when it leaves the object; now we simply used single-sided refraction which is fine for most purposes.</p>
<h4 id="dynamic-environment-maps">Dynamic environment maps</h4>
<p>Right now we&rsquo;ve been using a static combination of images as the skybox, which looks great, but it doesn&rsquo;t include the actual 3D scene with possibly moving objects. We didn&rsquo;t really notice this so far, because we only used a single object. If we had a mirror-like objects with multiple surrounding objects, only the skybox would be visible in the mirror as if it was the only object in the scene.</p>
<p>Using framebuffers it is possible to create a texture of the scene for all 6 different angles from the object in question and store those in a cubemap each frame. We can then use this (dynamically generated) cubemap to create realistic reflection and refractive surfaces that include all other objects. This is called dynamic environment mapping, because we dynamically create a cubemap of an object&rsquo;s surroundings and use that as its environment map.</p>
<p>While it looks great, it has one enormous disadvantage: we have to render the scene 6 times per object using an environment map, which is an enormous performance penalty on your application. Modern applications try to use the skybox as much as possible and where possible pre-render cubemaps wherever they can to still sort-of create dynamic environment maps. While dynamic environment mapping is a great technique, it requires a lot of clever tricks and hacks to get it working in an actual rendering application without too many performance drops.</p>
<h3 id="advanced-data">Advanced Data</h3>
<p>Throughout most chapters we&rsquo;ve been extensively using buffers in OpenGL to store data on the GPU. This chapter we&rsquo;ll briefly discuss a few alternative approaches to managing buffers.</p>
<p>A buffer in OpenGL is, at its core, an object that manages a certain piece of GPU memory and nothing more. We give meaning to a buffer when binding it to a specific buffer target. A buffer is only a vertex array buffer when we bind it to GL_ARRAY_BUFFER, but we could just as easily bind it to GL_ELEMENT_ARRAY_BUFFER. OpenGL internally stores a reference to the buffer per target and, based on the target, processes the buffer differently.</p>
<p>So far we&rsquo;ve been filling the buffer&rsquo;s memory by calling glBufferData, which allocates a piece of GPU memory and adds data into this memory. If we were to pass <code>NULL</code> as its data argument, the function would only allocate memory and not fill it. This is useful if we first want to <em>reserve</em> a specific amount of memory and later come back to this buffer.</p>
<p>Instead of filling the entire buffer with one function call we can also fill specific regions of the buffer by calling glBufferSubData. This function expects a buffer target, an offset, the size of the data and the actual data as its arguments. What&rsquo;s new with this function is that we can now give an offset that specifies from <em>where</em> we want to fill the buffer. This allows us to insert/update only certain parts of the buffer&rsquo;s memory. Do note that the buffer should have enough allocated memory so a call to glBufferData is necessary before calling glBufferSubData on the buffer.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glBufferSubData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span> <span class="c1">// Range: [24, 24 + sizeof(data)]
</span></span></span></code></pre></div><p>Yet another method for getting data into a buffer is to ask for a pointer to the buffer&rsquo;s memory and directly copy the data in memory yourself. By calling glMapBuffer OpenGL returns a pointer to the currently bound buffer&rsquo;s memory for us to operate on:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">float</span> <span class="n">data</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">  <span class="mf">0.5f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.35f</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  <span class="p">[...]</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="c1">// get pointer
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">glMapBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">GL_WRITE_ONLY</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="c1">// now copy data into memory
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1"></span><span class="n">memcpy</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">data</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1">// make sure to tell OpenGL we&#39;re done with the pointer
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="c1"></span><span class="n">glUnmapBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">);</span></span></span></code></pre></div><p>By telling OpenGL we&rsquo;re finished with the pointer operations via glUnmapBuffer, OpenGL knows you&rsquo;re done. By unmapping, the pointer becomes invalid and the function returns GL_TRUE if OpenGL was able to map your data successfully to the buffer.</p>
<p>Using glMapBuffer is useful for directly mapping data to a buffer, without first storing it in temporary memory. Think of directly reading data from file and copying it into the buffer&rsquo;s memory.</p>
<h4 id="batching-vertex-attributes">Batching vertex attributes</h4>
<p>Using glVertexAttribPointer we were able to specify the attribute layout of the vertex array buffer&rsquo;s content. Within the vertex array buffer we interleaved the attributes; that is, we placed the position, normal and/or texture coordinates next to each other in memory for each vertex. Now that we know a bit more about buffers we can take a different approach.</p>
<p>What we could also do is batch all the vector data into large chunks per attribute type instead of interleaving them. Instead of an interleaved layout <code>123123123123</code> we take a batched approach <code>111122223333</code>.</p>
<p>When loading vertex data from file you generally retrieve an array of positions, an array of normals and/or an array of texture coordinates. It may cost some effort to combine these arrays into one large array of interleaved data. Taking the batching approach is then an easier solution that we can easily implement using glBufferSubData:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">float</span> <span class="n">positions</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="kt">float</span> <span class="n">normals</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="kt">float</span> <span class="n">tex</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="c1">// fill buffer
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="c1"></span><span class="n">glBufferSubData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">positions</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">positions</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="n">glBufferSubData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">positions</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">normals</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">normals</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="n">glBufferSubData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">normals</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tex</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">tex</span><span class="p">);</span></span></span></code></pre></div><p>This way we can directly transfer the attribute arrays as a whole into the buffer without first having to process them. We could have also combined them in one large array and fill the buffer right away using glBufferData, but using glBufferSubData lends itself perfectly for tasks like these.</p>
<p>We&rsquo;ll also have to update the vertex attribute pointers to reflect these changes:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">positions</span><span class="p">)));</span>  
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">glVertexAttribPointer</span><span class="p">(</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">  <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">normals</span><span class="p">)));</span>  
</span></span></code></pre></div><p>Note that the <code>stride</code> parameter is equal to the size of the vertex attribute, since the next vertex attribute vector can be found directly after its 3 (or 2) components.</p>
<p>This gives us yet another approach of setting and specifying vertex attributes. Using either approach is feasible, it is mostly a more organized way to set vertex attributes. However, the interleaved approach is still the recommended approach as the vertex attributes for each vertex shader run are then closely aligned in memory.</p>
<h4 id="copying-buffers">Copying buffers</h4>
<p>Once your buffers are filled with data you may want to share that data with other buffers or perhaps copy the buffer&rsquo;s content into another buffer. The function glCopyBufferSubData allows us to copy the data from one buffer to another buffer with relative ease. The function&rsquo;s prototype is as follows:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">void</span> <span class="nf">glCopyBufferSubData</span><span class="p">(</span><span class="n">GLenum</span> <span class="n">readtarget</span><span class="p">,</span> <span class="n">GLenum</span> <span class="n">writetarget</span><span class="p">,</span> <span class="n">GLintptr</span> <span class="n">readoffset</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">                         <span class="n">GLintptr</span> <span class="n">writeoffset</span><span class="p">,</span> <span class="n">GLsizeiptr</span> <span class="n">size</span><span class="p">);</span></span></span></code></pre></div><p>The <code>readtarget</code> and <code>writetarget</code> parameters expect to give the buffer targets that we want to copy from and to. We could for example copy from a VERTEX_ARRAY_BUFFER buffer to a VERTEX_ELEMENT_ARRAY_BUFFER buffer by specifying those buffer targets as the read and write targets respectively. The buffers currently bound to those buffer targets will then be affected.</p>
<p>But what if we wanted to read and write data into two different buffers that are both vertex array buffers? We can&rsquo;t bind two buffers at the same time to the same buffer target. For this reason, and this reason alone, OpenGL gives us two more buffer targets called GL_COPY_READ_BUFFER and GL_COPY_WRITE_BUFFER. We then bind the buffers of our choice to these new buffer targets and set those targets as the <code>readtarget</code> and <code>writetarget</code> argument.</p>
<p>glCopyBufferSubData then reads data of a given <code>size</code> from a given <code>readoffset</code> and writes it into the <code>writetarget</code> buffer at <code>writeoffset</code>. An example of copying the content of two vertex array buffers is shown below:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_COPY_READ_BUFFER</span><span class="p">,</span> <span class="n">vbo1</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_COPY_WRITE_BUFFER</span><span class="p">,</span> <span class="n">vbo2</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">glCopyBufferSubData</span><span class="p">(</span><span class="n">GL_COPY_READ_BUFFER</span><span class="p">,</span> <span class="n">GL_COPY_WRITE_BUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span></span></span></code></pre></div><p>We could&rsquo;ve also done this by only binding the <code>writetarget</code> buffer to one of the new buffer target types:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">float</span> <span class="n">vertexData</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">vbo1</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_COPY_WRITE_BUFFER</span><span class="p">,</span> <span class="n">vbo2</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="n">glCopyBufferSubData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">GL_COPY_WRITE_BUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>  
</span></span></code></pre></div><p>With some extra knowledge about how to manipulate buffers we can already use them in more interesting ways. The further you get in OpenGL, the more useful these new buffer methods start to become. In the <a href="https://learnopengl.com/Advanced-OpenGL/Advanced-GLSL" target="_blank">next</a> chapter, where we&rsquo;ll discuss uniform buffer objects, we&rsquo;ll make good use of glBufferSubData.</p>
<h3 id="advanced-glsl">Advanced GLSL</h3>
<p>This chapter won&rsquo;t really show you super advanced cool new features that give an enormous boost to your scene&rsquo;s visual quality. This chapter goes more or less into some interesting aspects of GLSL and some nice tricks that may help you in your future endeavors. Basically some <em>good to knows</em> and <em>features that may make your life easier</em> when creating OpenGL applications in combination with GLSL.</p>
<p>We&rsquo;ll discuss some interesting built-in variables, new ways to organize shader input and output, and a very useful tool called uniform buffer objects.</p>
<h4 id="glsls-built-in-variables">GLSL&rsquo;s built-in variables</h4>
<p>Shaders are extremely pipelined, if we need data from any other source outside of the current shader we&rsquo;ll have to pass data around. We learned to do this via vertex attributes, uniforms, and samplers. There are however a few extra variables defined by GLSL prefixed with <code>gl_</code> that give us an extra means to gather and/or write data. We&rsquo;ve already seen two of them in the chapters so far: gl_Position that is the output vector of the vertex shader, and the fragment shader&rsquo;s gl_FragCoord.</p>
<p>We&rsquo;ll discuss a few interesting built-in input and output variables that are built-in in GLSL and explain how they may benefit us. Note that we won&rsquo;t discuss all built-in variables that exist in GLSL so if you want to see all built-in variables you can check OpenGL&rsquo;s <a href="https://www.khronos.org/opengl/wiki/Built-in_Variable_%28GLSL%29" target="_blank">wiki</a>.</p>
<h4 id="vertex-shader-variables">Vertex shader variables</h4>
<p>We&rsquo;ve already seen gl_Position which is the clip-space output position vector of the vertex shader. Setting gl_Position in the vertex shader is a strict requirement if you want to render anything on the screen. Nothing we haven&rsquo;t seen before.</p>
<h5 id="gl_pointsize">gl_PointSize</h5>
<p>One of the render primitives we&rsquo;re able to choose from is GL_POINTS in which case each single vertex is a primitive and rendered as a point. It is possible to set the size of the points being rendered via OpenGL&rsquo;s glPointSize function, but we can also influence this value in the vertex shader.</p>
<p>One output variable defined by GLSL is called gl_PointSize that is a float variable where you can set the point&rsquo;s width and height in pixels. By setting the point&rsquo;s size in the vertex shader we get per-vertex control over this point&rsquo;s dimensions.</p>
<p>Influencing the point sizes in the vertex shader is disabled by default, but if you want to enable this you&rsquo;ll have to enable OpenGL&rsquo;s GL_PROGRAM_POINT_SIZE:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glEnable</span><span class="p">(</span><span class="n">GL_PROGRAM_POINT_SIZE</span><span class="p">);</span>  
</span></span></code></pre></div><p>A simple example of influencing point sizes is by setting the point size equal to the clip-space position&rsquo;s z value which is equal to the vertex&rsquo;s distance to the viewer. The point size should then increase the further we are from the vertices as the viewer.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">projection</span> <span class="o">*</span> <span class="n">view</span> <span class="o">*</span> <span class="n">model</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">aPos</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>    
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="n">gl_PointSize</span> <span class="o">=</span> <span class="n">gl_Position</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>    
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>The result is that the points we&rsquo;ve drawn are rendered larger the more we move away from them:</p>
<p><a href="#R-image-7b880b5d914262419a7c6c81a6031a74" class="lightbox-link"><img src="./assets/advanced_glsl_pointsize.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7b880b5d914262419a7c6c81a6031a74"><img src="./assets/advanced_glsl_pointsize.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>You can imagine that varying the point size per vertex is interesting for techniques like particle generation.</p>
<h5 id="gl_vertexid">gl_VertexID</h5>
<p>The gl_Position and gl_PointSize are <em>output variables</em> since their value is read as output from the vertex shader; we can influence the result by writing to them. The vertex shader also gives us an interesting <em>input variable</em>, that we can only read from, called gl_VertexID.</p>
<p>The integer variable gl_VertexID holds the current ID of the vertex we&rsquo;re drawing. When doing <em>indexed rendering</em> (with glDrawElements) this variable holds the current index of the vertex we&rsquo;re drawing. When drawing without indices (via glDrawArrays) this variable holds the number of the currently processed vertex since the start of the render call.</p>
<h4 id="fragment-shader-variables">Fragment shader variables</h4>
<p>Within the fragment shader we also have access to some interesting variables. GLSL gives us two interesting input variables called gl_FragCoord and gl_FrontFacing.</p>
<h5 id="gl_fragcoord">gl_FragCoord</h5>
<p>We&rsquo;ve seen the gl_FragCoord a couple of times before during the discussion of depth testing, because the <code>z</code> component of the gl_FragCoord vector is equal to the depth value of that particular fragment. However, we can also use the x and y component of that vector for some interesting effects.</p>
<p>The gl_FragCoord&rsquo;s <code>x</code> and <code>y</code> component are the window- or screen-space coordinates of the fragment, originating from the bottom-left of the window. We specified a render window of 800x600 with glViewport so the screen-space coordinates of the fragment will have <code>x</code> values between 0 and 800, and <code>y</code> values between 0 and 600.</p>
<p>Using the fragment shader we could calculate a different color value based on the screen coordinate of the fragment. A common usage for the gl_FragCoord variable is for comparing visual output of different fragment calculations, as usually seen in tech demos. We could for example split the screen in two by rendering one output to the left side of the window and another output to the right side of the window. An example fragment shader that outputs a different color based on the fragment&rsquo;s screen coordinates is given below:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>             
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">gl_FragCoord</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">400</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">        <span class="n">FragColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">        <span class="n">FragColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>        
</span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>Because the width of the window is equal to 800, whenever a pixel&rsquo;s x-coordinate is less than 400 it must be at the left side of the window and we&rsquo;ll give that fragment a different color.</p>
<p><a href="#R-image-2c3dfb668bcdabf3700dd8de6c5b11ed" class="lightbox-link"><img src="./assets/advanced_glsl_fragcoord.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-2c3dfb668bcdabf3700dd8de6c5b11ed"><img src="./assets/advanced_glsl_fragcoord.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>We can now calculate two completely different fragment shader results and display each of them on a different side of the window. This is great for testing out different lighting techniques for example.</p>
<h5 id="gl_frontfacing">gl_FrontFacing</h5>
<p>Another interesting input variable in the fragment shader is the gl_FrontFacing variable. In the <a href="https://learnopengl.com/Advanced-OpenGL/Face-culling" target="_blank">face culling</a> chapter we mentioned that OpenGL is able to figure out if a face is a front or back face due to the winding order of the vertices. The gl_FrontFacing variable tells us if the current fragment is part of a front-facing or a back-facing face. We could, for example, decide to output different colors for all back faces.</p>
<p>The gl_FrontFacing variable is a bool that is <code>true</code> if the fragment is part of a front face and <code>false</code> otherwise. We could create a cube this way with a different texture on the inside than on the outside:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">out</span> <span class="n">vec4</span> <span class="n">FragColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">in</span> <span class="n">vec2</span> <span class="n">TexCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">frontTexture</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">backTexture</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="p">{</span>             
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">gl_FrontFacing</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">        <span class="n">FragColor</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">frontTexture</span><span class="p">,</span> <span class="n">TexCoords</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">        <span class="n">FragColor</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">backTexture</span><span class="p">,</span> <span class="n">TexCoords</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>If we take a peek inside the container we can now see a different texture being used.</p>
<p><a href="#R-image-05c6e129ab0076fb8a379cc0834fad80" class="lightbox-link"><img src="./assets/advanced_glsl_frontfacing.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-05c6e129ab0076fb8a379cc0834fad80"><img src="./assets/advanced_glsl_frontfacing.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Note that if you enabled face culling you won&rsquo;t be able to see any faces inside the container and using gl_FrontFacing would then be pointless.</p>
<h5 id="gl_fragdepth">gl_FragDepth</h5>
<p>The input variable gl_FragCoord is an input variable that allows us to read screen-space coordinates and get the depth value of the current fragment, but it is a read-only variable. We can&rsquo;t influence the screen-space coordinates of the fragment, but it is possible to set the depth value of the fragment. GLSL gives us an output variable called gl_FragDepth that we can use to manually set the depth value of the fragment within the shader.</p>
<p>To set the depth value in the shader we write any value between <code>0.0</code> and <code>1.0</code> to the output variable:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">gl_FragDepth</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="c1">// this fragment now has a depth value of 0.0
</span></span></span></code></pre></div><p>If the shader does not write anything to gl_FragDepth, the variable will automatically take its value from <code>gl_FragCoord.z</code>.</p>
<p>Setting the depth value manually has a major disadvantage however. That is because OpenGL disables early depth testing (as discussed in the <a href="https://learnopengl.com/Advanced-OpenGL/Depth-testing" target="_blank">depth testing</a> chapter) as soon as we write to gl_FragDepth in the fragment shader. It is disabled, because OpenGL cannot know what depth value the fragment will have <em>before</em> we run the fragment shader, since the fragment shader may actually change this value.</p>
<p>By writing to gl_FragDepth you should take this performance penalty into consideration. From OpenGL 4.2 however, we can still sort of mediate between both sides by redeclaring the gl_FragDepth variable at the top of the fragment shader with a depth condition:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">depth_</span><span class="o">&lt;</span><span class="n">condition</span><span class="o">&gt;</span><span class="p">)</span> <span class="n">out</span> <span class="kt">float</span> <span class="n">gl_FragDepth</span><span class="p">;</span></span></span></code></pre></div><p>This <code>condition</code> can take the following values:</p>
<p><a href="#R-image-bab7d37790a4af6e02ad1dfd42197ea7" class="lightbox-link"><img src="./assets/20240214093306.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-bab7d37790a4af6e02ad1dfd42197ea7"><img src="./assets/20240214093306.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>By specifying <code>greater</code> or <code>less</code> as the depth condition, OpenGL can make the assumption that you&rsquo;ll only write depth values larger or smaller than the fragment&rsquo;s depth value. This way OpenGL is still able to do early depth testing when the depth buffer value is part of the other direction of <code>gl_FragCoord.z</code>.</p>
<p>An example of where we increase the depth value in the fragment shader, but still want to preserve some of the early depth testing is shown in the fragment shader below:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="cp">#version 420 core </span><span class="c1">// note the GLSL version!
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="c1"></span><span class="n">out</span> <span class="n">vec4</span> <span class="n">FragColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">depth_greater</span><span class="p">)</span> <span class="n">out</span> <span class="kt">float</span> <span class="n">gl_FragDepth</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="p">{</span>             
</span></span><span class="line"><span class="ln">7</span><span class="cl">    <span class="n">FragColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">8</span><span class="cl">    <span class="n">gl_FragDepth</span> <span class="o">=</span> <span class="n">gl_FragCoord</span><span class="p">.</span><span class="n">z</span> <span class="o">+</span> <span class="mf">0.1</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">9</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>Do note that this feature is only available from OpenGL version 4.2 or higher.</p>
<h4 id="interface-blocks">Interface blocks</h4>
<p>So far, every time we sent data from the vertex to the fragment shader we declared several matching input/output variables. Declaring these one at a time is the easiest way to send data from one shader to another, but as applications become larger you probably want to send more than a few variables over.</p>
<p>To help us organize these variables GLSL offers us something called interface blocks that allows us to group variables together. The declaration of such an interface block looks a lot like a struct declaration, except that it is now declared using an in or out keyword based on the block being an input or an output block.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">aPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec2</span> <span class="n">aTexCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">uniform</span> <span class="n">mat4</span> <span class="n">model</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">uniform</span> <span class="n">mat4</span> <span class="n">view</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="n">uniform</span> <span class="n">mat4</span> <span class="n">projection</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="n">out</span> <span class="n">VS_OUT</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="n">vec2</span> <span class="n">TexCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="p">}</span> <span class="n">vs_out</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">projection</span> <span class="o">*</span> <span class="n">view</span> <span class="o">*</span> <span class="n">model</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">aPos</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>    
</span></span><span class="line"><span class="ln">17</span><span class="cl">    <span class="n">vs_out</span><span class="p">.</span><span class="n">TexCoords</span> <span class="o">=</span> <span class="n">aTexCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>This time we declared an interface block called vs_out that groups together all the output variables we want to send to the next shader. This is kind of a trivial example, but you can imagine that this helps organize your shaders&rsquo; inputs/outputs. It is also useful when we want to group shader input/output into arrays as we&rsquo;ll see in the <a href="https://learnopengl.com/Advanced-OpenGL/Geometry-Shader" target="_blank">next</a> chapter about geometry shaders.</p>
<p>Then we also need to declare an input interface block in the next shader which is the fragment shader. The block name (VS_OUT) should be the same in the fragment shader, but the instance name (vs_out as used in the vertex shader) can be anything we like - avoiding confusing names like vs_out for a fragment struct containing input values.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">out</span> <span class="n">vec4</span> <span class="n">FragColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">in</span> <span class="n">VS_OUT</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="n">vec2</span> <span class="n">TexCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="p">}</span> <span class="n">fs_in</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">texture</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="p">{</span>             
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="n">FragColor</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">texture</span><span class="p">,</span> <span class="n">fs_in</span><span class="p">.</span><span class="n">TexCoords</span><span class="p">);</span>   
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="p">}</span> 
</span></span></code></pre></div><p>As long as both interface block names are equal, their corresponding input and output is matched together. This is another useful feature that helps organize your code and proves useful when crossing between certain shader stages like the geometry shader.</p>
<h4 id="uniform-buffer-objects">Uniform buffer objects</h4>
<p>We&rsquo;ve been using OpenGL for quite a while now and learned some pretty cool tricks, but also a few annoyances. For example, when using more than one shader we continuously have to set uniform variables where most of them are exactly the same for each shader.</p>
<p>OpenGL gives us a tool called uniform buffer objects that allow us to declare a set of <em>global</em> uniform variables that remain the same over any number of shader programs. When using uniform buffer objects we set the relevant uniforms only <strong>once</strong> in fixed GPU memory. We do still have to manually set the uniforms that are unique per shader. Creating and configuring a uniform buffer object requires a bit of work though.</p>
<p>Because a uniform buffer object is a buffer like any other buffer we can create one via glGenBuffers, bind it to the GL_UNIFORM_BUFFER buffer target and store all the relevant uniform data into the buffer. There are certain rules as to how the data for uniform buffer objects should be stored and we&rsquo;ll get to that later. First, we&rsquo;ll take a simple vertex shader and store our projection and view matrix in a so called uniform block:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">aPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">std140</span><span class="p">)</span> <span class="n">uniform</span> <span class="n">Matrices</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="n">mat4</span> <span class="n">projection</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="n">mat4</span> <span class="n">view</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="n">uniform</span> <span class="n">mat4</span> <span class="n">model</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">projection</span> <span class="o">*</span> <span class="n">view</span> <span class="o">*</span> <span class="n">model</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">aPos</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>In most of our samples we set a projection and view uniform matrix every frame for each shader we&rsquo;re using. This is a perfect example of where uniform buffer objects become useful since now we only have to store these matrices once.</p>
<p>Here we declared a uniform block called Matrices that stores two 4x4 matrices. Variables in a uniform block can be directly accessed without the block name as a prefix. Then we store these matrix values in a buffer somewhere in the OpenGL code and each shader that declares this uniform block has access to the matrices.</p>
<p>You&rsquo;re probably wondering right now what the <code>layout</code> <code>(std140)</code> statement means. What this says is that the currently defined uniform block uses a specific memory layout for its content; this statement sets the uniform block layout.</p>
<h4 id="uniform-block-layout">Uniform block layout</h4>
<p>The content of a uniform block is stored in a buffer object, which is effectively nothing more than a reserved piece of global GPU memory. Because this piece of memory holds no information on what kind of data it holds, we need to tell OpenGL what parts of the memory correspond to which uniform variables in the shader.</p>
<p>Imagine the following uniform block in a shader:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">std140</span><span class="p">)</span> <span class="n">uniform</span> <span class="n">ExampleBlock</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="kt">float</span> <span class="n">value</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="n">vec3</span>  <span class="n">vector</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">    <span class="n">mat4</span>  <span class="n">matrix</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">    <span class="kt">float</span> <span class="n">values</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl">    <span class="kt">bool</span>  <span class="n">boolean</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">8</span><span class="cl">    <span class="kt">int</span>   <span class="n">integer</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">9</span><span class="cl"><span class="p">};</span> 
</span></span></code></pre></div><p>What we want to know is the size (in bytes) and the offset (from the start of the block) of each of these variables so we can place them in the buffer in their respective order. The size of each of the elements is clearly stated in OpenGL and directly corresponds to C++ data types; vectors and matrices being (large) arrays of floats. What OpenGL doesn&rsquo;t clearly state is the spacing between the variables. This allows the hardware to position or pad variables as it sees fit. The hardware is able to place a vec3 adjacent to a float for example. Not all hardware can handle this and pads the vec3 to an array of 4 floats before appending the float. A great feature, but inconvenient for us.</p>
<p>By default, GLSL uses a uniform memory layout called a shared layout - shared because once the offsets are defined by the hardware, they are consistently <em>shared</em> between multiple programs. With a shared layout GLSL is allowed to reposition the uniform variables for optimization as long as the variables&rsquo; order remains intact. Because we don&rsquo;t know at what offset each uniform variable will be we don&rsquo;t know how to precisely fill our uniform buffer. We can query this information with functions like glGetUniformIndices, but that&rsquo;s not the approach we&rsquo;re going to take in this chapter.</p>
<p>While a shared layout gives us some space-saving optimizations, we&rsquo;d need to query the offset for each uniform variable which translates to a lot of work. The general practice however is to not use the shared layout, but to use the std140 layout. The std140 layout <strong>explicitly</strong> states the memory layout for each variable type by standardizing their respective offsets governed by a set of rules. Since this is standardized we can manually figure out the offsets for each variable.</p>
<p>Each variable has a base alignment equal to the space a variable takes (including padding) within a uniform block using the std140 layout rules. For each variable, we calculate its aligned offset: the byte offset of a variable from the start of the block. The aligned byte offset of a variable <strong>must</strong> be equal to a multiple of its base alignment. This is a bit of a mouthful, but we&rsquo;ll get to see some examples soon enough to clear things up.</p>
<p>The exact layout rules can be found at OpenGL&rsquo;s uniform buffer specification <a href="http://www.opengl.org/registry/specs/ARB/uniform_buffer_object.txt" target="_blank">here</a>, but we&rsquo;ll list the most common rules below. Each variable type in GLSL such as int, float and bool are defined to be four-byte quantities with each entity of 4 bytes represented as <code>N</code>.</p>
<p><a href="#R-image-54081fecd1310a883406bd4536c3841c" class="lightbox-link"><img src="./assets/20240214093537.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-54081fecd1310a883406bd4536c3841c"><img src="./assets/20240214093537.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Like most of OpenGL&rsquo;s specifications it&rsquo;s easier to understand with an example. We&rsquo;re taking the uniform block called ExampleBlock we introduced earlier and calculate the aligned offset for each of its members using the std140 layout:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">std140</span><span class="p">)</span> <span class="n">uniform</span> <span class="n">ExampleBlock</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">                     <span class="c1">// base alignment  // aligned offset
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1"></span>    <span class="kt">float</span> <span class="n">value</span><span class="p">;</span>     <span class="c1">// 4               // 0 
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="c1"></span>    <span class="n">vec3</span> <span class="n">vector</span><span class="p">;</span>     <span class="c1">// 16              // 16  (offset must be multiple of 16 so 4-&gt;16)
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="c1"></span>    <span class="n">mat4</span> <span class="n">matrix</span><span class="p">;</span>     <span class="c1">// 16              // 32  (column 0)
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1"></span>                     <span class="c1">// 16              // 48  (column 1)
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="c1"></span>                     <span class="c1">// 16              // 64  (column 2)
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1"></span>                     <span class="c1">// 16              // 80  (column 3)
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1"></span>    <span class="kt">float</span> <span class="n">values</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span> <span class="c1">// 16              // 96  (values[0])
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="c1"></span>                     <span class="c1">// 16              // 112 (values[1])
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="c1"></span>                     <span class="c1">// 16              // 128 (values[2])
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="c1"></span>    <span class="kt">bool</span> <span class="n">boolean</span><span class="p">;</span>    <span class="c1">// 4               // 144
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">integer</span><span class="p">;</span>     <span class="c1">// 4               // 148
</span></span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="c1"></span><span class="p">};</span> 
</span></span></code></pre></div><p>As an exercise, try to calculate the offset values yourself and compare them to this table. With these calculated offset values, based on the rules of the std140 layout, we can fill the buffer with data at the appropriate offsets using functions like glBufferSubData. While not the most efficient, the std140 layout does guarantee us that the memory layout remains the same over each program that declared this uniform block.</p>
<p>By adding the statement <code>layout</code> <code>(std140)</code> in the definition of the uniform block we tell OpenGL that this uniform block uses the std140 layout. There are two other layouts to choose from that require us to query each offset before filling the buffers. We&rsquo;ve already seen the <code>shared</code> layout, with the other remaining layout being <code>packed</code>. When using the <code>packed</code> layout, there is no guarantee that the layout remains the same between programs (not shared) because it allows the compiler to optimize uniform variables away from the uniform block which may differ per shader.</p>
<h4 id="using-uniform-buffers">Using uniform buffers</h4>
<p>We&rsquo;ve defined uniform blocks and specified their memory layout, but we haven&rsquo;t discussed how to actually use them yet.</p>
<p>First, we need to create a uniform buffer object which is done via the familiar glGenBuffers. Once we have a buffer object we bind it to the GL_UNIFORM_BUFFER target and allocate enough memory by calling glBufferData.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">uboExampleBlock</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glGenBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uboExampleBlock</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_UNIFORM_BUFFER</span><span class="p">,</span> <span class="n">uboExampleBlock</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_UNIFORM_BUFFER</span><span class="p">,</span> <span class="mi">152</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">GL_STATIC_DRAW</span><span class="p">);</span> <span class="c1">// allocate 152 bytes of memory
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="c1"></span><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_UNIFORM_BUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span></span></span></code></pre></div><p>Now whenever we want to update or insert data into the buffer, we bind to uboExampleBlock and use glBufferSubData to update its memory. We only have to update this uniform buffer once, and all shaders that use this buffer now use its updated data. But, how does OpenGL know what uniform buffers correspond to which uniform blocks?</p>
<p>In the OpenGL context there is a number of binding points defined where we can link a uniform buffer to. Once we created a uniform buffer we link it to one of those binding points and we also link the uniform block in the shader to the same binding point, effectively linking them together. The following diagram illustrates this:</p>
<p><a href="#R-image-34d1635b4bc8888e9df85512c3ec780d" class="lightbox-link"><img src="./assets/advanced_glsl_binding_points.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-34d1635b4bc8888e9df85512c3ec780d"><img src="./assets/advanced_glsl_binding_points.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>As you can see we can bind multiple uniform buffers to different binding points. Because shader A and shader B both have a uniform block linked to the same binding point <code>0</code>, their uniform blocks share the same uniform data found in uboMatrices; a requirement being that both shaders defined the same Matrices uniform block.</p>
<p>To set a shader uniform block to a specific binding point we call glUniformBlockBinding that takes a program object, a uniform block index, and the binding point to link to. The uniform block index is a location index of the defined uniform block in the shader. This can be retrieved via a call to glGetUniformBlockIndex that accepts a program object and the name of the uniform block. We can set the Lights uniform block from the diagram to binding point <code>2</code> as follows:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lights_index</span> <span class="o">=</span> <span class="n">glGetUniformBlockIndex</span><span class="p">(</span><span class="n">shaderA</span><span class="p">.</span><span class="n">ID</span><span class="p">,</span> <span class="s">&#34;Lights&#34;</span><span class="p">);</span>   
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glUniformBlockBinding</span><span class="p">(</span><span class="n">shaderA</span><span class="p">.</span><span class="n">ID</span><span class="p">,</span> <span class="n">lights_index</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span></span></span></code></pre></div><p>Note that we have to repeat this process for <strong>each</strong> shader.</p>
<p><note>From OpenGL version 4.2 and onwards it is also possible to store the binding point of a uniform block explicitly in the shader by adding another layout specifier, saving us the calls to glGetUniformBlockIndex and glUniformBlockBinding. The following code sets the binding point of the Lights uniform block explicitly:<br><a href="#R-image-78e125f45e72e2a407a4ee9948a39ab2" class="lightbox-link"><img src="./assets/20240214093810.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-78e125f45e72e2a407a4ee9948a39ab2"><img src="./assets/20240214093810.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></note></p>
<p>hen we also need to bind the uniform buffer object to the same binding point and this can be accomplished with either glBindBufferBase or glBindBufferRange.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glBindBufferBase</span><span class="p">(</span><span class="n">GL_UNIFORM_BUFFER</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">uboExampleBlock</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="c1">// or
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="c1"></span><span class="n">glBindBufferRange</span><span class="p">(</span><span class="n">GL_UNIFORM_BUFFER</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">uboExampleBlock</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">152</span><span class="p">);</span></span></span></code></pre></div><p>The function glBindbufferBase expects a target, a binding point index and a uniform buffer object. This function links uboExampleBlock to binding point <code>2</code>; from this point on, both sides of the binding point are linked. You can also use glBindBufferRange that expects an extra offset and size parameter - this way you can bind only a specific range of the uniform buffer to a binding point. Using glBindBufferRange you could have multiple different uniform blocks linked to a single uniform buffer object.</p>
<p>Now that everything is set up, we can start adding data to the uniform buffer. We could add all the data as a single byte array, or update parts of the buffer whenever we feel like it using glBufferSubData. To update the uniform variable boolean we could update the uniform buffer object as follows:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_UNIFORM_BUFFER</span><span class="p">,</span> <span class="n">uboExampleBlock</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// bools in GLSL are represented as 4 bytes, so we store it in an integer
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="c1"></span><span class="n">glBufferSubData</span><span class="p">(</span><span class="n">GL_UNIFORM_BUFFER</span><span class="p">,</span> <span class="mi">144</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_UNIFORM_BUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span></span></span></code></pre></div><p>And the same procedure applies for all the other uniform variables inside the uniform block, but with different range arguments.</p>
<h4 id="a-simple-example">A simple example</h4>
<p>So let&rsquo;s demonstrate a real example of uniform buffer objects. If we look back at all the previous code samples we&rsquo;ve continually been using 3 matrices: the projection, view and model matrix. Of all those matrices, only the model matrix changes frequently. If we have multiple shaders that use this same set of matrices, we&rsquo;d probably be better off using uniform buffer objects.</p>
<p>We&rsquo;re going to store the projection and view matrix in a uniform block called Matrices. We&rsquo;re not going to store the model matrix in there since the model matrix tends to change frequently between shaders, so we wouldn&rsquo;t really benefit from uniform buffer objects.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">aPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">std140</span><span class="p">)</span> <span class="n">uniform</span> <span class="n">Matrices</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="n">mat4</span> <span class="n">projection</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="n">mat4</span> <span class="n">view</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="n">uniform</span> <span class="n">mat4</span> <span class="n">model</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">projection</span> <span class="o">*</span> <span class="n">view</span> <span class="o">*</span> <span class="n">model</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">aPos</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>Not much going on here, except that we now use a uniform block with a std140 layout. What we&rsquo;re going to do in our sample application is display 4 cubes where each cube is displayed with a different shader program. Each of the 4 shader programs uses the same vertex shader, but has a unique fragment shader that only outputs a single color that differs per shader.</p>
<p>First, we set the uniform block of the vertex shaders equal to binding point <code>0</code>. Note that we have to do this for each shader:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">uniformBlockIndexRed</span>    <span class="o">=</span> <span class="n">glGetUniformBlockIndex</span><span class="p">(</span><span class="n">shaderRed</span><span class="p">.</span><span class="n">ID</span><span class="p">,</span> <span class="s">&#34;Matrices&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">uniformBlockIndexGreen</span>  <span class="o">=</span> <span class="n">glGetUniformBlockIndex</span><span class="p">(</span><span class="n">shaderGreen</span><span class="p">.</span><span class="n">ID</span><span class="p">,</span> <span class="s">&#34;Matrices&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">uniformBlockIndexBlue</span>   <span class="o">=</span> <span class="n">glGetUniformBlockIndex</span><span class="p">(</span><span class="n">shaderBlue</span><span class="p">.</span><span class="n">ID</span><span class="p">,</span> <span class="s">&#34;Matrices&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">uniformBlockIndexYellow</span> <span class="o">=</span> <span class="n">glGetUniformBlockIndex</span><span class="p">(</span><span class="n">shaderYellow</span><span class="p">.</span><span class="n">ID</span><span class="p">,</span> <span class="s">&#34;Matrices&#34;</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">5</span><span class="cl">  
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="n">glUniformBlockBinding</span><span class="p">(</span><span class="n">shaderRed</span><span class="p">.</span><span class="n">ID</span><span class="p">,</span>    <span class="n">uniformBlockIndexRed</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="n">glUniformBlockBinding</span><span class="p">(</span><span class="n">shaderGreen</span><span class="p">.</span><span class="n">ID</span><span class="p">,</span>  <span class="n">uniformBlockIndexGreen</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">8</span><span class="cl"><span class="n">glUniformBlockBinding</span><span class="p">(</span><span class="n">shaderBlue</span><span class="p">.</span><span class="n">ID</span><span class="p">,</span>   <span class="n">uniformBlockIndexBlue</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">9</span><span class="cl"><span class="n">glUniformBlockBinding</span><span class="p">(</span><span class="n">shaderYellow</span><span class="p">.</span><span class="n">ID</span><span class="p">,</span> <span class="n">uniformBlockIndexYellow</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span></span></span></code></pre></div><p>Next we create the actual uniform buffer object and bind that buffer to binding point <code>0</code>:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">uboMatrices</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="nf">glGenBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uboMatrices</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">  
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_UNIFORM_BUFFER</span><span class="p">,</span> <span class="n">uboMatrices</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_UNIFORM_BUFFER</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">GL_STATIC_DRAW</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_UNIFORM_BUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl">  
</span></span><span class="line"><span class="ln">8</span><span class="cl"><span class="n">glBindBufferRange</span><span class="p">(</span><span class="n">GL_UNIFORM_BUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">uboMatrices</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">));</span></span></span></code></pre></div><p>First we allocate enough memory for our buffer which is equal to 2 times the size of glm::mat4. The size of GLM&rsquo;s matrix types correspond directly to mat4 in GLSL. Then we link a specific range of the buffer, in this case the entire buffer, to binding point <code>0</code>.</p>
<p>Now all that&rsquo;s left to do is fill the buffer. If we keep the <em>field of view</em> value constant of the projection matrix (so no more camera zoom) we only have to update it once in our application - this means we only have to insert this into the buffer only once as well. Because we already allocated enough memory in the buffer object we can use glBufferSubData to store the projection matrix before we enter the render loop:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span> <span class="n">projection</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">perspective</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">radians</span><span class="p">(</span><span class="mf">45.0f</span><span class="p">),</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">width</span><span class="o">/</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">height</span><span class="p">,</span> <span class="mf">0.1f</span><span class="p">,</span> <span class="mf">100.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_UNIFORM_BUFFER</span><span class="p">,</span> <span class="n">uboMatrices</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">glBufferSubData</span><span class="p">(</span><span class="n">GL_UNIFORM_BUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">),</span> <span class="n">glm</span><span class="o">::</span><span class="n">value_ptr</span><span class="p">(</span><span class="n">projection</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_UNIFORM_BUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  
</span></span></code></pre></div><p>Here we store the first half of the uniform buffer with the projection matrix. Then before we render the objects each frame we update the second half of the buffer with the view matrix:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span> <span class="n">view</span> <span class="o">=</span> <span class="n">camera</span><span class="p">.</span><span class="n">GetViewMatrix</span><span class="p">();</span>	       
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_UNIFORM_BUFFER</span><span class="p">,</span> <span class="n">uboMatrices</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">glBufferSubData</span><span class="p">(</span><span class="n">GL_UNIFORM_BUFFER</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">),</span> <span class="n">glm</span><span class="o">::</span><span class="n">value_ptr</span><span class="p">(</span><span class="n">view</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_UNIFORM_BUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  
</span></span></code></pre></div><p>And that&rsquo;s it for uniform buffer objects. Each vertex shader that contains a Matrices uniform block will now contain the data stored in uboMatrices. So if we now were to draw 4 cubes using 4 different shaders, their projection and view matrix should be the same:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">cubeVAO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">shaderRed</span><span class="p">.</span><span class="n">use</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span> <span class="n">model</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="n">model</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">translate</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="o">-</span><span class="mf">0.75f</span><span class="p">,</span> <span class="mf">0.75f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">));</span>	<span class="c1">// move top-left
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="c1"></span><span class="n">shaderRed</span><span class="p">.</span><span class="n">setMat4</span><span class="p">(</span><span class="s">&#34;model&#34;</span><span class="p">,</span> <span class="n">model</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="n">glDrawArrays</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">36</span><span class="p">);</span>        
</span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="c1">// ... draw Green Cube
</span></span></span><span class="line"><span class="ln">8</span><span class="cl"><span class="c1">// ... draw Blue Cube
</span></span></span><span class="line"><span class="ln">9</span><span class="cl"><span class="c1">// ... draw Yellow Cube	  
</span></span></span></code></pre></div><p>The only uniform we still need to set is the model uniform. Using uniform buffer objects in a scenario like this saves us from quite a few uniform calls per shader. The result looks something like this:</p>
<p><a href="#R-image-0353788610e27752fe2db47eb780f9a0" class="lightbox-link"><img src="./assets/advanced_glsl_uniform_buffer_objects.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-0353788610e27752fe2db47eb780f9a0"><img src="./assets/advanced_glsl_uniform_buffer_objects.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Each of the cubes is moved to one side of the window by translating the model matrix and, thanks to the different fragment shaders, their colors differ per object. This is a relatively simple scenario of where we could use uniform buffer objects, but any large rendering application can have over hundreds of shader programs active which is where uniform buffer objects really start to shine.</p>
<p>You can find the full source code of the uniform example application <a href="https://learnopengl.com/code_viewer_gh.php?code=src/4.advanced_opengl/8.advanced_glsl_ubo/advanced_glsl_ubo.cpp" target="_blank">here</a>.</p>
<p>Uniform buffer objects have several advantages over single uniforms. First, setting a lot of uniforms at once is faster than setting multiple uniforms one at a time. Second, if you want to change the same uniform over several shaders, it is much easier to change a uniform once in a uniform buffer. One last advantage that is not immediately apparent is that you can use a lot more uniforms in shaders using uniform buffer objects. OpenGL has a limit to how much uniform data it can handle which can be queried with GL_MAX_VERTEX_UNIFORM_COMPONENTS. When using uniform buffer objects, this limit is much higher. So whenever you reach a maximum number of uniforms (when doing skeletal animation for example) there&rsquo;s always uniform buffer objects.</p>
<h3 id="geometry-shader">Geometry Shader</h3>
<p>Between the vertex and the fragment shader there is an optional shader stage called the geometry shader. A geometry shader takes as input a set of vertices that form a single primitive e.g. a point or a triangle. The geometry shader can then transform these vertices as it sees fit before sending them to the next shader stage. What makes the geometry shader interesting is that it is able to convert the original primitive (set of vertices) to completely different primitives, possibly generating more vertices than were initially given.</p>
<p>We&rsquo;re going to throw you right into the deep by showing you an example of a geometry shader:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">layout</span> <span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="n">in</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">line_strip</span><span class="p">,</span> <span class="n">max_vertices</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="n">out</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>    
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">gl_in</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">gl_Position</span> <span class="o">+</span> <span class="n">vec4</span><span class="p">(</span><span class="o">-</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="n">EmitVertex</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">gl_in</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">gl_Position</span> <span class="o">+</span> <span class="n">vec4</span><span class="p">(</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="n">EmitVertex</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="n">EndPrimitive</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>At the start of a geometry shader we need to declare the type of primitive input we&rsquo;re receiving from the vertex shader. We do this by declaring a layout specifier in front of the in keyword. This input layout qualifier can take any of the following primitive values:</p>
<ul>
<li><code>points</code>: when drawing GL_POINTS primitives (<code>1</code>).</li>
<li><code>lines</code>: when drawing GL_LINES or GL_LINE_STRIP (<code>2</code>).</li>
<li><code>lines_adjacency</code>: GL_LINES_ADJACENCY or GL_LINE_STRIP_ADJACENCY (<code>4</code>).</li>
<li><code>triangles</code>: GL_TRIANGLES, GL_TRIANGLE_STRIP or GL_TRIANGLE_FAN (<code>3</code>).</li>
<li><code>triangles_adjacency </code>: GL_TRIANGLES_ADJACENCY or GL_TRIANGLE_STRIP_ADJACENCY (<code>6</code>).</li>
</ul>
<p>These are almost all the rendering primitives we&rsquo;re able to give to rendering calls like glDrawArrays. If we&rsquo;d chosen to draw vertices as GL_TRIANGLES we should set the input qualifier to <code>triangles</code>. The number within the parenthesis represents the minimal number of vertices a single primitive contains.</p>
<p>We also need to specify a primitive type that the geometry shader will output and we do this via a layout specifier in front of the out keyword. Like the input layout qualifier, the output layout qualifier can take several primitive values:</p>
<ul>
<li><code>points</code></li>
<li><code>line_strip</code></li>
<li><code>triangle_strip</code></li>
</ul>
<p>With just these 3 output specifiers we can create almost any shape we want from the input primitives. To generate a single triangle for example we&rsquo;d specify <code>triangle_strip</code> as the output and output 3 vertices.</p>
<p>The geometry shader also expects us to set a maximum number of vertices it outputs (if you exceed this number, OpenGL won&rsquo;t draw the <em>extra</em> vertices) which we can also do within the layout qualifier of the out keyword. In this particular case we&rsquo;re going to output a <code>line_strip</code> with a maximum number of 2 vertices.</p>
<p><note>In case you&rsquo;re wondering what a line strip is: a line strip binds together a set of points to form one continuous line between them with a minimum of 2 points. Each extra point results in a new line between the new point and the previous point as you can see in the following image with 5 point vertices:<br><a href="#R-image-edd34f4ed8f6b1bffd8354725164d07f" class="lightbox-link"><img src="./assets/geometry_shader_line_strip.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-edd34f4ed8f6b1bffd8354725164d07f"><img src="./assets/geometry_shader_line_strip.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></note></p>
<p>To generate meaningful results we need some way to retrieve the output from the previous shader stage. GLSL gives us a built-in variable called gl_in that internally (probably) looks something like this:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">in</span> <span class="n">gl_Vertex</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="n">vec4</span>  <span class="n">gl_Position</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="kt">float</span> <span class="n">gl_PointSize</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">    <span class="kt">float</span> <span class="n">gl_ClipDistance</span><span class="p">[];</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="p">}</span> <span class="n">gl_in</span><span class="p">[];</span>  
</span></span></code></pre></div><p>Here it is declared as an interface block (as discussed in the <a href="https://learnopengl.com/Advanced-OpenGL/Advanced-GLSL" target="_blank">previous</a> chapter) that contains a few interesting variables of which the most interesting one is gl_Position that contains the vector we set as the vertex shader&rsquo;s output.</p>
<p>Note that it is declared as an array, because most render primitives contain more than 1 vertex. The geometry shader receives <strong>all</strong> vertices of a primitive as its input.</p>
<p>Using the vertex data from the vertex shader stage we can generate new data with 2 geometry shader functions called EmitVertex and EndPrimitive. The geometry shader expects you to generate/output at least one of the primitives you specified as output. In our case we want to at least generate one line strip primitive.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">layout</span> <span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="n">in</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">line_strip</span><span class="p">,</span> <span class="n">max_vertices</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="n">out</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>    
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">gl_in</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">gl_Position</span> <span class="o">+</span> <span class="n">vec4</span><span class="p">(</span><span class="o">-</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="n">EmitVertex</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">gl_in</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">gl_Position</span> <span class="o">+</span> <span class="n">vec4</span><span class="p">(</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="n">EmitVertex</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="n">EndPrimitive</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="p">}</span>    
</span></span></code></pre></div><p>Each time we call EmitVertex, the vector currently set to gl_Position is added to the output primitive. Whenever EndPrimitive is called, all emitted vertices for this primitive are combined into the specified output render primitive. By repeatedly calling EndPrimitive, after one or more EmitVertex calls, multiple primitives can be generated. This particular case emits two vertices that were translated by a small offset from the original vertex position and then calls EndPrimitive, combining the two vertices into a single line strip of 2 vertices.</p>
<p>Now that you (sort of) know how geometry shaders work you can probably guess what this geometry shader does. This geometry shader takes a point primitive as its input and creates a horizontal line primitive with the input point at its center. If we were to render this it looks something like this:</p>
<p><a href="#R-image-b375b6f0add628359f8b517e1fa0d175" class="lightbox-link"><img src="./assets/geometry_shader_lines.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b375b6f0add628359f8b517e1fa0d175"><img src="./assets/geometry_shader_lines.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Not very impressive yet, but it&rsquo;s interesting to consider that this output was generated using just the following render call:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glDrawArrays</span><span class="p">(</span><span class="n">GL_POINTS</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>  
</span></span></code></pre></div><p>While this is a relatively simple example, it does show you how we can use geometry shaders to (dynamically) generate new shapes on the fly. Later in this chapter we&rsquo;ll discuss a few interesting effects that we can create using geometry shaders, but for now we&rsquo;re going to start with a simple example.</p>
<h4 id="using-geometry-shaders">Using geometry shaders</h4>
<p>To demonstrate the use of a geometry shader we&rsquo;re going to render a really simple scene where we draw 4 points on the z-plane in normalized device coordinates. The coordinates of the points are:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">float</span> <span class="n">points</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">	<span class="o">-</span><span class="mf">0.5f</span><span class="p">,</span>  <span class="mf">0.5f</span><span class="p">,</span> <span class="c1">// top-left
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="c1"></span>	 <span class="mf">0.5f</span><span class="p">,</span>  <span class="mf">0.5f</span><span class="p">,</span> <span class="c1">// top-right
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="c1"></span>	 <span class="mf">0.5f</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5f</span><span class="p">,</span> <span class="c1">// bottom-right
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="c1"></span>	<span class="o">-</span><span class="mf">0.5f</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5f</span>  <span class="c1">// bottom-left
</span></span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="c1"></span><span class="p">};</span>  
</span></span></code></pre></div><p>The vertex shader needs to draw the points on the z-plane so we&rsquo;ll create a basic vertex shader:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="cp"></span><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec2</span> <span class="n">aPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">aPos</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">aPos</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>And we&rsquo;ll output the color green for all points which we code directly in the fragment shader:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="cp"></span><span class="n">out</span> <span class="n">vec4</span> <span class="n">FragColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">    <span class="n">FragColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>   
</span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>Generate a VAO and a VBO for the points&rsquo; vertex data and then draw them via glDrawArrays:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">shader</span><span class="p">.</span><span class="n">use</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">VAO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">glDrawArrays</span><span class="p">(</span><span class="n">GL_POINTS</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span> 
</span></span></code></pre></div><p>The result is a dark scene with 4 (difficult to see) green points:</p>
<p><a href="#R-image-341dbe98a319361b90cecf7789f5a717" class="lightbox-link"><img src="./assets/geometry_shader_points.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-341dbe98a319361b90cecf7789f5a717"><img src="./assets/geometry_shader_points.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>But didn&rsquo;t we already learn to do all this? Yes, and now we&rsquo;re going to spice this little scene up by adding geometry shader magic to the scene.</p>
<p>For learning purposes we&rsquo;re first going to create what is called a pass-through geometry shader that takes a point primitive as its input and <em>passes</em> it to the next shader unmodified:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="cp"></span><span class="n">layout</span> <span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="n">in</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">max_vertices</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="n">out</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>    
</span></span><span class="line"><span class="ln">6</span><span class="cl">    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">gl_in</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">gl_Position</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">7</span><span class="cl">    <span class="n">EmitVertex</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">8</span><span class="cl">    <span class="n">EndPrimitive</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">9</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>By now this geometry shader should be fairly easy to understand. It simply emits the unmodified vertex position it received as input and generates a point primitive.</p>
<p>A geometry shader needs to be compiled and linked to a program just like the vertex and fragment shader, but this time we&rsquo;ll create the shader using GL_GEOMETRY_SHADER as the shader type:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">geometryShader</span> <span class="o">=</span> <span class="n">glCreateShader</span><span class="p">(</span><span class="n">GL_GEOMETRY_SHADER</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glShaderSource</span><span class="p">(</span><span class="n">geometryShader</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gShaderCode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">glCompileShader</span><span class="p">(</span><span class="n">geometryShader</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="p">[...]</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="n">glAttachShader</span><span class="p">(</span><span class="n">program</span><span class="p">,</span> <span class="n">geometryShader</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="n">glLinkProgram</span><span class="p">(</span><span class="n">program</span><span class="p">);</span>  
</span></span></code></pre></div><p>The shader compilation code is the same as the vertex and fragment shaders. Be sure to check for compile or linking errors!</p>
<p>If you&rsquo;d now compile and run you should be looking at a result that looks a bit like this:</p>
<p><a href="#R-image-d660894076dbda616294602199facbd3" class="lightbox-link"><img src="./assets/geometry_shader_points.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d660894076dbda616294602199facbd3"><img src="./assets/geometry_shader_points.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>It&rsquo;s exactly the same as without the geometry shader! It&rsquo;s a bit dull, I&rsquo;ll admit that, but the fact that we were still able to draw the points means that the geometry shader works, so now it&rsquo;s time for the more funky stuff!</p>
<h4 id="lets-build-houses">Let&rsquo;s build houses</h4>
<p>Drawing points and lines isn&rsquo;t <strong>that</strong> interesting so we&rsquo;re going to get a little creative by using the geometry shader to draw a house for us at the location of each point. We can accomplish this by setting the output of the geometry shader to triangle_strip and draw a total of three triangles: two for the square house and one for the roof.</p>
<p>A triangle strip in OpenGL is a more efficient way to draw triangles with fewer vertices. After the first triangle is drawn, each subsequent vertex generates another triangle next to the first triangle: every 3 adjacent vertices will form a triangle. If we have a total of 6 vertices that form a triangle strip we&rsquo;d get the following triangles: (1,2,3), (2,3,4), (3,4,5) and (4,5,6); forming a total of 4 triangles. A triangle strip needs at least 3 vertices and will generate N-2 triangles; with 6 vertices we created 6-2 = 4 triangles. The following image illustrates this:</p>
<p><a href="#R-image-e43a9b8487bd01492eb12a237e574047" class="lightbox-link"><img src="./assets/geometry_shader_triangle_strip.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-e43a9b8487bd01492eb12a237e574047"><img src="./assets/geometry_shader_triangle_strip.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Using a triangle strip as the output of the geometry shader we can easily create the house shape we&rsquo;re after by generating 3 adjacent triangles in the correct order. The following image shows in what order we need to draw what vertices to get the triangles we need with the blue dot being the input point:</p>
<p><a href="#R-image-2ba055552e304f28d49dfeecee3c4b0f" class="lightbox-link"><img src="./assets/geometry_shader_house.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-2ba055552e304f28d49dfeecee3c4b0f"><img src="./assets/geometry_shader_house.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>This translates to the following geometry shader:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">layout</span> <span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="n">in</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">triangle_strip</span><span class="p">,</span> <span class="n">max_vertices</span> <span class="o">=</span> <span class="mi">5</span><span class="p">)</span> <span class="n">out</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="kt">void</span> <span class="nf">build_house</span><span class="p">(</span><span class="n">vec4</span> <span class="n">position</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="p">{</span>    
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">position</span> <span class="o">+</span> <span class="n">vec4</span><span class="p">(</span><span class="o">-</span><span class="mf">0.2</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>    <span class="c1">// 1:bottom-left
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="c1"></span>    <span class="n">EmitVertex</span><span class="p">();</span>   
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">position</span> <span class="o">+</span> <span class="n">vec4</span><span class="p">(</span> <span class="mf">0.2</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>    <span class="c1">// 2:bottom-right
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1"></span>    <span class="n">EmitVertex</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">position</span> <span class="o">+</span> <span class="n">vec4</span><span class="p">(</span><span class="o">-</span><span class="mf">0.2</span><span class="p">,</span>  <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>    <span class="c1">// 3:top-left
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="c1"></span>    <span class="n">EmitVertex</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">position</span> <span class="o">+</span> <span class="n">vec4</span><span class="p">(</span> <span class="mf">0.2</span><span class="p">,</span>  <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>    <span class="c1">// 4:top-right
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="c1"></span>    <span class="n">EmitVertex</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">position</span> <span class="o">+</span> <span class="n">vec4</span><span class="p">(</span> <span class="mf">0.0</span><span class="p">,</span>  <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>    <span class="c1">// 5:top
</span></span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="c1"></span>    <span class="n">EmitVertex</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">    <span class="n">EndPrimitive</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">
</span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>    
</span></span><span class="line"><span class="ln">21</span><span class="cl">    <span class="n">build_house</span><span class="p">(</span><span class="n">gl_in</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">gl_Position</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>This geometry shader generates 5 vertices, with each vertex being the point&rsquo;s position plus an offset to form one large triangle strip. The resulting primitive is then rasterized and the fragment shader runs on the entire triangle strip, resulting in a green house for each point we&rsquo;ve rendered:</p>
<p><a href="#R-image-2ddcf33b5f6beee622e3c45f4fe08a84" class="lightbox-link"><img src="./assets/geometry_shader_houses.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-2ddcf33b5f6beee622e3c45f4fe08a84"><img src="./assets/geometry_shader_houses.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>You can see that each house indeed consists of 3 triangles - all drawn using a single point in space. The green houses do look a bit boring though, so let&rsquo;s liven it up a bit by giving each house a unique color. To do this we&rsquo;re going to add an extra vertex attribute in the vertex shader with color information per vertex and direct it to the geometry shader that further forwards it to the fragment shader.</p>
<p>The updated vertex data is given below:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">float</span> <span class="n">points</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">    <span class="o">-</span><span class="mf">0.5f</span><span class="p">,</span>  <span class="mf">0.5f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="c1">// top-left
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="c1"></span>     <span class="mf">0.5f</span><span class="p">,</span>  <span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="c1">// top-right
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="c1"></span>     <span class="mf">0.5f</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="c1">// bottom-right
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="c1"></span>    <span class="o">-</span><span class="mf">0.5f</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.0f</span>  <span class="c1">// bottom-left
</span></span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="c1"></span><span class="p">};</span>  
</span></span></code></pre></div><p>Then we update the vertex shader to forward the color attribute to the geometry shader using an interface block:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec2</span> <span class="n">aPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">aColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">out</span> <span class="n">VS_OUT</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="n">vec3</span> <span class="n">color</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="p">}</span> <span class="n">vs_out</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">aPos</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">aPos</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="n">vs_out</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">aColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>Then we also need to declare the same interface block (with a different interface name) in the geometry shader:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">in</span> <span class="n">VS_OUT</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">    <span class="n">vec3</span> <span class="n">color</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="p">}</span> <span class="n">gs_in</span><span class="p">[];</span>  
</span></span></code></pre></div><p>Because the geometry shader acts on a set of vertices as its input, its input data from the vertex shader is always represented as arrays of vertex data even though we only have a single vertex right now.</p>
<p><note>We don&rsquo;t necessarily have to use interface blocks to transfer data to the geometry shader. We could have also written it as:<br><a href="#R-image-70f772fa8e3987636fdfefa2a7ddc641" class="lightbox-link"><img src="./assets/20240214095100.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-70f772fa8e3987636fdfefa2a7ddc641"><img src="./assets/20240214095100.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a><br>This works if the vertex shader forwarded the color vector as <code>out</code> <code>vec3</code> <code>outColor</code>. However, interface blocks are easier to work with in shaders like the geometry shader. In practice, geometry shader inputs can get quite large and grouping them in one large interface block array makes a lot more sense.</note></p>
<p>We should also declare an output color vector for the next fragment shader stage:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">out</span> <span class="n">vec3</span> <span class="n">fColor</span><span class="p">;</span>  
</span></span></code></pre></div><p>Because the fragment shader expects only a single (interpolated) color it doesn&rsquo;t make sense to forward multiple colors. The fColor vector is thus not an array, but a single vector. When emitting a vertex, that vertex will store the last stored value in fColor as that vertex&rsquo;s output value. For the houses, we can fill fColor once with the color from the vertex shader before the first vertex is emitted to color the entire house:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">fColor</span> <span class="o">=</span> <span class="n">gs_in</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">color</span><span class="p">;</span> <span class="c1">// gs_in[0] since there&#39;s only one input vertex
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1"></span><span class="n">gl_Position</span> <span class="o">=</span> <span class="n">position</span> <span class="o">+</span> <span class="n">vec4</span><span class="p">(</span><span class="o">-</span><span class="mf">0.2</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>    <span class="c1">// 1:bottom-left   
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="c1"></span><span class="n">EmitVertex</span><span class="p">();</span>   
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">gl_Position</span> <span class="o">=</span> <span class="n">position</span> <span class="o">+</span> <span class="n">vec4</span><span class="p">(</span> <span class="mf">0.2</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>    <span class="c1">// 2:bottom-right
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="c1"></span><span class="n">EmitVertex</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">gl_Position</span> <span class="o">=</span> <span class="n">position</span> <span class="o">+</span> <span class="n">vec4</span><span class="p">(</span><span class="o">-</span><span class="mf">0.2</span><span class="p">,</span>  <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>    <span class="c1">// 3:top-left
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1"></span><span class="n">EmitVertex</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="n">gl_Position</span> <span class="o">=</span> <span class="n">position</span> <span class="o">+</span> <span class="n">vec4</span><span class="p">(</span> <span class="mf">0.2</span><span class="p">,</span>  <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>    <span class="c1">// 4:top-right
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1"></span><span class="n">EmitVertex</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="n">gl_Position</span> <span class="o">=</span> <span class="n">position</span> <span class="o">+</span> <span class="n">vec4</span><span class="p">(</span> <span class="mf">0.0</span><span class="p">,</span>  <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>    <span class="c1">// 5:top
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="c1"></span><span class="n">EmitVertex</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="n">EndPrimitive</span><span class="p">();</span>  
</span></span></code></pre></div><p>All the emitted vertices will have the last stored value in fColor embedded into their data, which is equal to the input vertex&rsquo;s color as we defined in its attributes. All the houses will now have a color of their own:</p>
<p><a href="#R-image-4e26fccfde4c1267971a08817afbfb08" class="lightbox-link"><img src="./assets/geometry_shader_houses_colored.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-4e26fccfde4c1267971a08817afbfb08"><img src="./assets/geometry_shader_houses_colored.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Just for fun we could also pretend it&rsquo;s winter and give their roofs a little snow by giving the last vertex a color of its own:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">fColor</span> <span class="o">=</span> <span class="n">gs_in</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">color</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="n">gl_Position</span> <span class="o">=</span> <span class="n">position</span> <span class="o">+</span> <span class="n">vec4</span><span class="p">(</span><span class="o">-</span><span class="mf">0.2</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>    <span class="c1">// 1:bottom-left   
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="c1"></span><span class="n">EmitVertex</span><span class="p">();</span>   
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">gl_Position</span> <span class="o">=</span> <span class="n">position</span> <span class="o">+</span> <span class="n">vec4</span><span class="p">(</span> <span class="mf">0.2</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>    <span class="c1">// 2:bottom-right
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="c1"></span><span class="n">EmitVertex</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">gl_Position</span> <span class="o">=</span> <span class="n">position</span> <span class="o">+</span> <span class="n">vec4</span><span class="p">(</span><span class="o">-</span><span class="mf">0.2</span><span class="p">,</span>  <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>    <span class="c1">// 3:top-left
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1"></span><span class="n">EmitVertex</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="n">gl_Position</span> <span class="o">=</span> <span class="n">position</span> <span class="o">+</span> <span class="n">vec4</span><span class="p">(</span> <span class="mf">0.2</span><span class="p">,</span>  <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>    <span class="c1">// 4:top-right
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1"></span><span class="n">EmitVertex</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="n">gl_Position</span> <span class="o">=</span> <span class="n">position</span> <span class="o">+</span> <span class="n">vec4</span><span class="p">(</span> <span class="mf">0.0</span><span class="p">,</span>  <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>    <span class="c1">// 5:top
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="c1"></span><span class="n">fColor</span> <span class="o">=</span> <span class="n">vec3</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="n">EmitVertex</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="n">EndPrimitive</span><span class="p">();</span>  
</span></span></code></pre></div><p>The result now looks something like this:</p>
<p><a href="#R-image-f6909b4262848ee9ef1c9ce3c6afcc32" class="lightbox-link"><img src="./assets/geometry_shader_houses_snow.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f6909b4262848ee9ef1c9ce3c6afcc32"><img src="./assets/geometry_shader_houses_snow.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>You can compare your source code with the OpenGL code <a href="https://learnopengl.com/code_viewer_gh.php?code=src/4.advanced_opengl/9.1.geometry_shader_houses/geometry_shader_houses.cpp" target="_blank">here</a>.</p>
<p>You can see that with geometry shaders you can get pretty creative, even with the simplest primitives. Because the shapes are generated dynamically on the ultra-fast hardware of your GPU this can be a lot more powerful than defining these shapes yourself within vertex buffers. Geometry shaders are a great tool for simple (often-repeating) shapes, like cubes in a voxel world or grass leaves on a large outdoor field.</p>
<h4 id="exploding-objects">Exploding objects</h4>
<p>While drawing houses is fun and all, it&rsquo;s not something we&rsquo;re going to use that much. That&rsquo;s why we&rsquo;re now going to take it up one notch and explode objects! That is something we&rsquo;re also probably not going to use that much either, but it&rsquo;s definitely fun to do!</p>
<p>When we say <em>exploding</em> an object we&rsquo;re not actually going to blow up our precious bundled sets of vertices, but we&rsquo;re going to move each triangle along the direction of their normal vector over a small period of time. The effect is that the entire object&rsquo;s triangles seem to <em>explode</em>. The effect of exploding triangles on the backpack model looks a bit like this:</p>
<p><a href="#R-image-1a1dfda246c05ba2e22def02d3e558f1" class="lightbox-link"><img src="./assets/geometry_shader_explosion.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-1a1dfda246c05ba2e22def02d3e558f1"><img src="./assets/geometry_shader_explosion.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>The great thing about such a geometry shader effect is that it works on all objects, regardless of their complexity.</p>
<p>Because we&rsquo;re going to translate each vertex into the direction of the triangle&rsquo;s normal vector we first need to calculate this normal vector. What we need to do is calculate a vector that is perpendicular to the surface of a triangle, using just the 3 vertices we have access to. You may remember from the <a href="https://learnopengl.com/Getting-started/Transformations" target="_blank">transformations</a> chapter that we can retrieve a vector perpendicular to two other vectors using the cross product. If we were to retrieve two vectors a and b that are parallel to the surface of a triangle we can retrieve its normal vector by doing a cross product on those vectors. The following geometry shader function does exactly this to retrieve the normal vector using 3 input vertex coordinates:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">vec3</span> <span class="nf">GetNormal</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">   <span class="n">vec3</span> <span class="n">a</span> <span class="o">=</span> <span class="n">vec3</span><span class="p">(</span><span class="n">gl_in</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">gl_Position</span><span class="p">)</span> <span class="o">-</span> <span class="n">vec3</span><span class="p">(</span><span class="n">gl_in</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">gl_Position</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">   <span class="n">vec3</span> <span class="n">b</span> <span class="o">=</span> <span class="n">vec3</span><span class="p">(</span><span class="n">gl_in</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">gl_Position</span><span class="p">)</span> <span class="o">-</span> <span class="n">vec3</span><span class="p">(</span><span class="n">gl_in</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">gl_Position</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">   <span class="k">return</span> <span class="n">normalize</span><span class="p">(</span><span class="n">cross</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>Here we retrieve two vectors a and b that are parallel to the surface of the triangle using vector subtraction. Subtracting two vectors from each other results in a vector that is the difference of the two vectors. Since all 3 points lie on the triangle plane, subtracting any of its vectors from each other results in a vector parallel to the plane. Do note that if we switched a and b in the cross function we&rsquo;d get a normal vector that points in the opposite direction - order is important here!</p>
<p>Now that we know how to calculate a normal vector we can create an explode function that takes this normal vector along with a vertex position vector. The function returns a new vector that translates the position vector along the direction of the normal vector:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">vec4</span> <span class="nf">explode</span><span class="p">(</span><span class="n">vec4</span> <span class="n">position</span><span class="p">,</span> <span class="n">vec3</span> <span class="n">normal</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="kt">float</span> <span class="n">magnitude</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="n">vec3</span> <span class="n">direction</span> <span class="o">=</span> <span class="n">normal</span> <span class="o">*</span> <span class="p">((</span><span class="n">sin</span><span class="p">(</span><span class="n">time</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">magnitude</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">5</span><span class="cl">    <span class="k">return</span> <span class="n">position</span> <span class="o">+</span> <span class="n">vec4</span><span class="p">(</span><span class="n">direction</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="p">}</span> 
</span></span></code></pre></div><p>The function itself shouldn&rsquo;t be too complicated. The sin function receives a time uniform variable as its argument that, based on the time, returns a value between <code>-1.0</code> and <code>1.0</code>. Because we don&rsquo;t want to <em>implode</em> the object we transform the sin value to the <code>[0,1]</code> range. The resulting value is then used to scale the normal vector and the resulting direction vector is added to the position vector.</p>
<p>The complete geometry shader for the explode effect, while drawing a model loaded using our <a href="https://learnopengl.com/Model-Loading/Assimp" target="_blank">model loader</a>, looks a bit like this:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">layout</span> <span class="p">(</span><span class="n">triangles</span><span class="p">)</span> <span class="n">in</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">triangle_strip</span><span class="p">,</span> <span class="n">max_vertices</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span> <span class="n">out</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">in</span> <span class="n">VS_OUT</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="n">vec2</span> <span class="n">texCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="p">}</span> <span class="n">gs_in</span><span class="p">[];</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="n">out</span> <span class="n">vec2</span> <span class="n">TexCoords</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">10</span><span class="cl">
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="n">uniform</span> <span class="kt">float</span> <span class="n">time</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="n">vec4</span> <span class="nf">explode</span><span class="p">(</span><span class="n">vec4</span> <span class="n">position</span><span class="p">,</span> <span class="n">vec3</span> <span class="n">normal</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="n">vec3</span> <span class="nf">GetNormal</span><span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">
</span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>    
</span></span><span class="line"><span class="ln">18</span><span class="cl">    <span class="n">vec3</span> <span class="n">normal</span> <span class="o">=</span> <span class="n">GetNormal</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">
</span></span><span class="line"><span class="ln">20</span><span class="cl">    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">explode</span><span class="p">(</span><span class="n">gl_in</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">gl_Position</span><span class="p">,</span> <span class="n">normal</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">    <span class="n">TexCoords</span> <span class="o">=</span> <span class="n">gs_in</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">texCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">    <span class="n">EmitVertex</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">explode</span><span class="p">(</span><span class="n">gl_in</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">gl_Position</span><span class="p">,</span> <span class="n">normal</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">    <span class="n">TexCoords</span> <span class="o">=</span> <span class="n">gs_in</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">texCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl">    <span class="n">EmitVertex</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl">    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">explode</span><span class="p">(</span><span class="n">gl_in</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">gl_Position</span><span class="p">,</span> <span class="n">normal</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl">    <span class="n">TexCoords</span> <span class="o">=</span> <span class="n">gs_in</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">texCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">28</span><span class="cl">    <span class="n">EmitVertex</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">29</span><span class="cl">    <span class="n">EndPrimitive</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">30</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>Note that we&rsquo;re also outputting the appropriate texture coordinates before emitting a vertex.</p>
<p>Also don&rsquo;t forget to actually set the time uniform in your OpenGL code:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">shader</span><span class="p">.</span><span class="n">setFloat</span><span class="p">(</span><span class="s">&#34;time&#34;</span><span class="p">,</span> <span class="n">glfwGetTime</span><span class="p">());</span>  
</span></span></code></pre></div><p>The result is a 3D model that seems to continually explode its vertices over time after which it returns to normal again. Although not exactly super useful, it does show you a more advanced use of the geometry shader. You can compare your source code with the complete source code <a href="https://learnopengl.com/code_viewer_gh.php?code=src/4.advanced_opengl/9.2.geometry_shader_exploding/geometry_shader_exploding.cpp" target="_blank">here</a>.</p>
<h4 id="visualizing-normal-vectors">Visualizing normal vectors</h4>
<p>To shake things up we&rsquo;re going to now discuss an example of using the geometry shader that is actually useful: visualizing the normal vectors of any object. When programming lighting shaders you will eventually run into weird visual outputs of which the cause is hard to determine. A common cause of lighting errors is incorrect normal vectors. Either caused by incorrectly loading vertex data, improperly specifying them as vertex attributes, or by incorrectly managing them in the shaders. What we want is some way to detect if the normal vectors we supplied are correct. A great way to determine if your normal vectors are correct is by visualizing them, and it just so happens that the geometry shader is an extremely useful tool for this purpose.</p>
<p>The idea is as follows: we first draw the scene as normal without a geometry shader and then we draw the scene a second time, but this time only displaying normal vectors that we generate via a geometry shader. The geometry shader takes as input a triangle primitive and generates 3 lines from them in the directions of their normal - one normal vector for each vertex. In code it&rsquo;ll look something like this:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">shader</span><span class="p">.</span><span class="n">use</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">DrawScene</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">normalDisplayShader</span><span class="p">.</span><span class="n">use</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="n">DrawScene</span><span class="p">();</span></span></span></code></pre></div><p>This time we&rsquo;re creating a geometry shader that uses the vertex normals supplied by the model instead of generating it ourself. To accommodate for scaling and rotations (due to the view and model matrix) we&rsquo;ll transform the normals with a normal matrix. The geometry shader receives its position vectors as view-space coordinates so we should also transform the normal vectors to the same space. This can all be done in the vertex shader:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">aPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">aNormal</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">out</span> <span class="n">VS_OUT</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="n">vec3</span> <span class="n">normal</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="p">}</span> <span class="n">vs_out</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="n">uniform</span> <span class="n">mat4</span> <span class="n">view</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="n">uniform</span> <span class="n">mat4</span> <span class="n">model</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">view</span> <span class="o">*</span> <span class="n">model</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">aPos</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="n">mat3</span> <span class="n">normalMatrix</span> <span class="o">=</span> <span class="n">mat3</span><span class="p">(</span><span class="n">transpose</span><span class="p">(</span><span class="n">inverse</span><span class="p">(</span><span class="n">view</span> <span class="o">*</span> <span class="n">model</span><span class="p">)));</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="n">vs_out</span><span class="p">.</span><span class="n">normal</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">vec3</span><span class="p">(</span><span class="n">vec4</span><span class="p">(</span><span class="n">normalMatrix</span> <span class="o">*</span> <span class="n">aNormal</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)));</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>The transformed view-space normal vector is then passed to the next shader stage via an interface block. The geometry shader then takes each vertex (with a position and a normal vector) and draws a normal vector from each position vector:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">layout</span> <span class="p">(</span><span class="n">triangles</span><span class="p">)</span> <span class="n">in</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">line_strip</span><span class="p">,</span> <span class="n">max_vertices</span> <span class="o">=</span> <span class="mi">6</span><span class="p">)</span> <span class="n">out</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">in</span> <span class="n">VS_OUT</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="n">vec3</span> <span class="n">normal</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="p">}</span> <span class="n">gs_in</span><span class="p">[];</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="k">const</span> <span class="kt">float</span> <span class="n">MAGNITUDE</span> <span class="o">=</span> <span class="mf">0.4</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">  
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="n">uniform</span> <span class="n">mat4</span> <span class="n">projection</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="kt">void</span> <span class="nf">GenerateLine</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">projection</span> <span class="o">*</span> <span class="n">gl_in</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">gl_Position</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="n">EmitVertex</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">projection</span> <span class="o">*</span> <span class="p">(</span><span class="n">gl_in</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">gl_Position</span> <span class="o">+</span> 
</span></span><span class="line"><span class="ln">18</span><span class="cl">                                <span class="n">vec4</span><span class="p">(</span><span class="n">gs_in</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">normal</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">MAGNITUDE</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">    <span class="n">EmitVertex</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">    <span class="n">EndPrimitive</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">
</span></span><span class="line"><span class="ln">23</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl">    <span class="n">GenerateLine</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// first vertex normal
</span></span></span><span class="line"><span class="ln">26</span><span class="cl"><span class="c1"></span>    <span class="n">GenerateLine</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// second vertex normal
</span></span></span><span class="line"><span class="ln">27</span><span class="cl"><span class="c1"></span>    <span class="n">GenerateLine</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="c1">// third vertex normal
</span></span></span><span class="line"><span class="ln">28</span><span class="cl"><span class="c1"></span><span class="p">}</span>  
</span></span></code></pre></div><p>The contents of geometry shaders like these should be self-explanatory by now. Note that we&rsquo;re multiplying the normal vector by a MAGNITUDE vector to restrain the size of the displayed normal vectors (otherwise they&rsquo;d be a bit too large).</p>
<p>Since visualizing normals are mostly used for debugging purposes we can just display them as mono-colored lines (or super-fancy lines if you feel like it) with the help of the fragment shader:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="cp"></span><span class="n">out</span> <span class="n">vec4</span> <span class="n">FragColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">    <span class="n">FragColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>Now rendering your model with normal shaders first and then with the special <em>normal-visualizing</em> shader you&rsquo;ll see something like this:</p>
<p><a href="#R-image-af256b5ed53f554164fb362a5d9580ec" class="lightbox-link"><img src="./assets/geometry_shader_normals.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-af256b5ed53f554164fb362a5d9580ec"><img src="./assets/geometry_shader_normals.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Apart from the fact that our backpack now looks a bit hairy, it gives us a really useful method for determining if the normal vectors of a model are indeed correct. You can imagine that geometry shaders like this could also be used for adding fur to objects.</p>
<p>You can find the OpenGL&rsquo;s source code <a href="https://learnopengl.com/code_viewer_gh.php?code=src/4.advanced_opengl/9.3.geometry_shader_normals/normal_visualization.cpp" target="_blank">here</a>.</p>
<h3 id="instancing">Instancing</h3>
<p>Say you have a scene where you&rsquo;re drawing a lot of models where most of these models contain the same set of vertex data, but with different world transformations. Think of a scene filled with grass leaves: each grass leave is a small model that consists of only a few triangles. You&rsquo;ll probably want to draw quite a few of them and your scene may end up with thousands or maybe tens of thousands of grass leaves that you need to render each frame. Because each leaf is only a few triangles, the leaf is rendered almost instantly. However, the thousands of render calls you&rsquo;ll have to make will drastically reduce performance.</p>
<p>If we were to actually render such a large amount of objects it will look a bit like this in code:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">amount_of_models_to_draw</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="n">DoSomePreparations</span><span class="p">();</span> <span class="c1">// bind VAO, bind textures, set uniforms etc.
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="c1"></span>    <span class="n">glDrawArrays</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">amount_of_vertices</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>When drawing many instances of your model like this you&rsquo;ll quickly reach a performance bottleneck because of the many draw calls. Compared to rendering the actual vertices, telling the GPU to render your vertex data with functions like glDrawArrays or glDrawElements eats up quite some performance since OpenGL must make necessary preparations before it can draw your vertex data (like telling the GPU which buffer to read data from, where to find vertex attributes and all this over the relatively slow CPU to GPU bus). So even though rendering your vertices is super fast, giving your GPU the commands to render them isn&rsquo;t.</p>
<p>It would be much more convenient if we could send data over to the GPU once, and then tell OpenGL to draw multiple objects using this data with a single drawing call. Enter instancing.</p>
<p>Instancing is a technique where we draw many (equal mesh data) objects at once with a single render call, saving us all the CPU -&gt; GPU communications each time we need to render an object. To render using instancing all we need to do is change the render calls glDrawArrays and glDrawElements to glDrawArraysInstanced and glDrawElementsInstanced respectively. These <em>instanced</em> versions of the classic rendering functions take an extra parameter called the instance count that sets the number of instances we want to render. We sent all the required data to the GPU once, and then tell the GPU how it should draw all these instances with a single call. The GPU then renders all these instances without having to continually communicate with the CPU.</p>
<p>By itself this function is a bit useless. Rendering the same object a thousand times is of no use to us since each of the rendered objects is rendered exactly the same and thus also at the same location; we would only see one object! For this reason GLSL added another built-in variable in the vertex shader called gl_InstanceID.</p>
<p>When drawing with one of the instanced rendering calls, gl_InstanceID is incremented for each instance being rendered starting from <code>0</code>. If we were to render the 43th instance for example, gl_InstanceID would have the value <code>42</code> in the vertex shader. Having a unique value per instance means we could now for example index into a large array of position values to position each instance at a different location in the world.</p>
<p>To get a feel for instanced drawing we&rsquo;re going to demonstrate a simple example that renders a hundred 2D quads in normalized device coordinates with just one render call. We accomplish this by uniquely positioning each instanced quad by indexing a uniform array of <code>100</code> offset vectors. The result is a neatly organized grid of quads that fill the entire window:</p>
<p><a href="#R-image-841c47d498949c015faacf6a40244057" class="lightbox-link"><img src="./assets/instancing_quads.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-841c47d498949c015faacf6a40244057"><img src="./assets/instancing_quads.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Each quad consists of 2 triangles with a total of 6 vertices. Each vertex contains a 2D NDC position vector and a color vector. Below is the vertex data used for this example - the triangles are small enough to properly fit the screen when there&rsquo;s a 100 of them:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">float</span> <span class="n">quadVertices</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    <span class="c1">// positions     // colors
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="c1"></span>    <span class="o">-</span><span class="mf">0.05f</span><span class="p">,</span>  <span class="mf">0.05f</span><span class="p">,</span>  <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">     <span class="mf">0.05f</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.05f</span><span class="p">,</span>  <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="o">-</span><span class="mf">0.05f</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.05f</span><span class="p">,</span>  <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="o">-</span><span class="mf">0.05f</span><span class="p">,</span>  <span class="mf">0.05f</span><span class="p">,</span>  <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">     <span class="mf">0.05f</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.05f</span><span class="p">,</span>  <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span>   
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">     <span class="mf">0.05f</span><span class="p">,</span>  <span class="mf">0.05f</span><span class="p">,</span>  <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">1.0f</span>		    		
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="p">};</span>  
</span></span></code></pre></div><p>The quads are colored in the fragment shader that receives a color vector from the vertex shader and sets it as its output:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="cp"></span><span class="n">out</span> <span class="n">vec4</span> <span class="n">FragColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">  
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="n">in</span> <span class="n">vec3</span> <span class="n">fColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">8</span><span class="cl">    <span class="n">FragColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">fColor</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">9</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>Nothing new so far, but at the vertex shader it&rsquo;s starting to get interesting:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec2</span> <span class="n">aPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">aColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">out</span> <span class="n">vec3</span> <span class="n">fColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="n">uniform</span> <span class="n">vec2</span> <span class="n">offsets</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="n">vec2</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">offsets</span><span class="p">[</span><span class="n">gl_InstanceID</span><span class="p">];</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">aPos</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="n">fColor</span> <span class="o">=</span> <span class="n">aColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>Here we defined a uniform array called offsets that contain a total of <code>100</code> offset vectors. Within the vertex shader we retrieve an offset vector for each instance by indexing the offsets array using gl_InstanceID. If we now were to draw <code>100</code> quads with instanced drawing we&rsquo;d get <code>100</code> quads located at different positions.</p>
<p>We do need to actually set the offset positions that we calculate in a nested for-loop before we enter the render loop:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">vec2</span> <span class="n">translations</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="kt">float</span> <span class="n">offset</span> <span class="o">=</span> <span class="mf">0.1f</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="o">-</span><span class="mi">10</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">y</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="mi">10</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">x</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        <span class="n">glm</span><span class="o">::</span><span class="n">vec2</span> <span class="n">translation</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">        <span class="n">translation</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">x</span> <span class="o">/</span> <span class="mf">10.0f</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">        <span class="n">translation</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">y</span> <span class="o">/</span> <span class="mf">10.0f</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">        <span class="n">translations</span><span class="p">[</span><span class="n">index</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">translation</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>Here we create a set of <code>100</code> translation vectors that contains an offset vector for all positions in a 10x10 grid. In addition to generating the translations array, we&rsquo;d also need to transfer the data to the vertex shader&rsquo;s uniform array:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">shader</span><span class="p">.</span><span class="n">use</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="n">shader</span><span class="p">.</span><span class="n">setVec2</span><span class="p">((</span><span class="s">&#34;offsets[&#34;</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#34;]&#34;</span><span class="p">)),</span> <span class="n">translations</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>Within this snippet of code we transform the for-loop counter i to a string to dynamically create a location string for querying the uniform location. For each item in the offsets uniform array we then set the corresponding translation vector.</p>
<p>Now that all the preparations are finished we can start rendering the quads. To draw via instanced rendering we call glDrawArraysInstanced or glDrawElementsInstanced. Since we&rsquo;re not using an element index buffer we&rsquo;re going to call the glDrawArrays version:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">quadVAO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glDrawArraysInstanced</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>  
</span></span></code></pre></div><p>The parameters of glDrawArraysInstanced are exactly the same as glDrawArrays except the last parameter that sets the number of instances we want to draw. Since we want to display <code>100</code> quads in a 10x10 grid we set it equal to <code>100</code>. Running the code should now give you the familiar image of <code>100</code> colorful quads.</p>
<h4 id="instanced-arrays">Instanced arrays</h4>
<p>While the previous implementation works fine for this specific use case, whenever we are rendering a lot more than <code>100</code> instances (which is quite common) we will eventually hit a <a href="https://www.khronos.org/opengl/wiki/GLSL_Uniform#Implementation_limits" target="_blank">limit</a> on the amount of uniform data we can send to the shaders. One alternative option is known as instanced arrays. Instanced arrays are defined as a vertex attribute (allowing us to store much more data) that are updated per instance instead of per vertex.</p>
<p>With vertex attributes, at the start of each run of the vertex shader, the GPU will retrieve the next set of vertex attributes that belong to the current vertex. When defining a vertex attribute as an instanced array however, the vertex shader only updates the content of the vertex attribute per instance. This allows us to use the standard vertex attributes for data per vertex and use the instanced array for storing data that is unique per instance.</p>
<p>To give you an example of an instanced array we&rsquo;re going to take the previous example and convert the offset uniform array to an instanced array. We&rsquo;ll have to update the vertex shader by adding another vertex attribute:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec2</span> <span class="n">aPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">aColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec2</span> <span class="n">aOffset</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">out</span> <span class="n">vec3</span> <span class="n">fColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">aPos</span> <span class="o">+</span> <span class="n">aOffset</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="n">fColor</span> <span class="o">=</span> <span class="n">aColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>We no longer use gl_InstanceID and can directly use the offset attribute without first indexing into a large uniform array.</p>
<p>Because an instanced array is a vertex attribute, just like the position and color variables, we need to store its content in a vertex buffer object and configure its attribute pointer. We&rsquo;re first going to store the translations array (from the previous section) in a new buffer object:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">instanceVBO</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glGenBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">instanceVBO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">instanceVBO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">vec2</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">translations</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">GL_STATIC_DRAW</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> 
</span></span></code></pre></div><p>Then we also need to set its vertex attribute pointer and enable the vertex attribute:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">instanceVBO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>	
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="n">glVertexAttribDivisor</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>  
</span></span></code></pre></div><p>What makes this code interesting is the last line where we call glVertexAttribDivisor. This function tells OpenGL <strong>when</strong> to update the content of a vertex attribute to the next element. Its first parameter is the vertex attribute in question and the second parameter the attribute divisor. By default, the attribute divisor is <code>0</code> which tells OpenGL to update the content of the vertex attribute each iteration of the vertex shader. By setting this attribute to <code>1</code> we&rsquo;re telling OpenGL that we want to update the content of the vertex attribute when we start to render a new instance. By setting it to <code>2</code> we&rsquo;d update the content every 2 instances and so on. By setting the attribute divisor to <code>1</code> we&rsquo;re effectively telling OpenGL that the vertex attribute at attribute location <code>2</code> is an instanced array.</p>
<p>If we now were to render the quads again with glDrawArraysInstanced we&rsquo;d get the following output:</p>
<p><a href="#R-image-c62f0a48bee49a89f27d55a6c8617b79" class="lightbox-link"><img src="./assets/instancing_quads.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c62f0a48bee49a89f27d55a6c8617b79"><img src="./assets/instancing_quads.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>This is exactly the same as the previous example, but now with instanced arrays, which allows us to pass a lot more data (as much as memory allows us) to the vertex shader for instanced drawing.</p>
<p>For fun we could slowly downscale each quad from top-right to bottom-left using gl_InstanceID again, because why not?</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="n">vec2</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">aPos</span> <span class="o">*</span> <span class="p">(</span><span class="n">gl_InstanceID</span> <span class="o">/</span> <span class="mf">100.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">aOffset</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">    <span class="n">fColor</span> <span class="o">=</span> <span class="n">aColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="p">}</span> 
</span></span></code></pre></div><p>The result is that the first instances of the quads are drawn extremely small and the further we&rsquo;re in the process of drawing the instances, the closer gl_InstanceID gets to <code>100</code> and thus the more the quads regain their original size. It&rsquo;s perfectly legal to use instanced arrays together with gl_InstanceID like this.</p>
<p><a href="#R-image-79b321200ddc6926bfe96873ab53b5c9" class="lightbox-link"><img src="./assets/instancing_quads_arrays.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-79b321200ddc6926bfe96873ab53b5c9"><img src="./assets/instancing_quads_arrays.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>If you&rsquo;re still a bit unsure about how instanced rendering works or want to see how everything fits together you can find the full source code of the application <a href="https://learnopengl.com/code_viewer_gh.php?code=src/4.advanced_opengl/10.1.instancing_quads/instancing_quads.cpp" target="_blank">here</a>.</p>
<p>While fun and all, these examples aren&rsquo;t really good examples of instancing. Yes, they do give you an easy overview of how instancing works, but instancing gets most of its power when drawing an enormous amount of similar objects. For that reason we&rsquo;re going to venture into space.</p>
<h4 id="an-asteroid-field">An asteroid field</h4>
<p>Imagine a scene where we have one large planet that&rsquo;s at the center of a large asteroid ring. Such an asteroid ring could contain thousands or tens of thousands of rock formations and quickly becomes un-renderable on any decent graphics card. This scenario proves itself particularly useful for instanced rendering, since all the asteroids can be represented with a single model. Each single asteroid then gets its variation from a transformation matrix unique to each asteroid.</p>
<p>To demonstrate the impact of instanced rendering we&rsquo;re first going to render a scene of asteroids hovering around a planet <em>without</em> instanced rendering. The scene will contain a large planet model that can be downloaded from <a href="https://learnopengl.com/data/models/planet.zip" target="_blank">here</a> and a large set of asteroid rocks that we properly position around the planet. The asteroid rock model can be downloaded <a href="https://learnopengl.com/data/models/rock.zip" target="_blank">here</a>.</p>
<p>Within the code samples we load the models using the model loader we&rsquo;ve previously defined in the <a href="https://learnopengl.com/Model-Loading/Assimp" target="_blank">model loading</a> chapters.</p>
<p>To achieve the effect we&rsquo;re looking for we&rsquo;ll be generating a model transformation matrix for each asteroid. The transformation matrix first translates the rock somewhere in the asteroid ring - then we&rsquo;ll add a small random displacement value to the offset to make the ring look more natural. From there we also apply a random scale and a random rotation. The result is a transformation matrix that translates each asteroid somewhere around the planet while also giving it a more natural and unique look compared to the other asteroids.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">amount</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span> <span class="o">*</span><span class="n">modelMatrices</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">modelMatrices</span> <span class="o">=</span> <span class="k">new</span> <span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">[</span><span class="n">amount</span><span class="p">];</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">srand</span><span class="p">(</span><span class="n">glfwGetTime</span><span class="p">());</span> <span class="c1">// initialize random seed	
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="c1"></span><span class="kt">float</span> <span class="n">radius</span> <span class="o">=</span> <span class="mf">50.0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="kt">float</span> <span class="n">offset</span> <span class="o">=</span> <span class="mf">2.5f</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">amount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="n">glm</span><span class="o">::</span><span class="n">mat4</span> <span class="n">model</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="c1">// 1. translation: displace along circle with &#39;radius&#39; in range [-offset, offset]
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="c1"></span>    <span class="kt">float</span> <span class="n">angle</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">i</span> <span class="o">/</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">amount</span> <span class="o">*</span> <span class="mf">360.0f</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="kt">float</span> <span class="n">displacement</span> <span class="o">=</span> <span class="p">(</span><span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">offset</span> <span class="o">*</span> <span class="mi">100</span><span class="p">))</span> <span class="o">/</span> <span class="mf">100.0f</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="kt">float</span> <span class="n">x</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span> <span class="o">*</span> <span class="n">radius</span> <span class="o">+</span> <span class="n">displacement</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="n">displacement</span> <span class="o">=</span> <span class="p">(</span><span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">offset</span> <span class="o">*</span> <span class="mi">100</span><span class="p">))</span> <span class="o">/</span> <span class="mf">100.0f</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="kt">float</span> <span class="n">y</span> <span class="o">=</span> <span class="n">displacement</span> <span class="o">*</span> <span class="mf">0.4f</span><span class="p">;</span> <span class="c1">// keep height of field smaller compared to width of x and z
</span></span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="c1"></span>    <span class="n">displacement</span> <span class="o">=</span> <span class="p">(</span><span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">offset</span> <span class="o">*</span> <span class="mi">100</span><span class="p">))</span> <span class="o">/</span> <span class="mf">100.0f</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">    <span class="kt">float</span> <span class="n">z</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span> <span class="o">*</span> <span class="n">radius</span> <span class="o">+</span> <span class="n">displacement</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">    <span class="n">model</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">translate</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">
</span></span><span class="line"><span class="ln">20</span><span class="cl">    <span class="c1">// 2. scale: scale between 0.05 and 0.25f
</span></span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="c1"></span>    <span class="kt">float</span> <span class="n">scale</span> <span class="o">=</span> <span class="p">(</span><span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">20</span><span class="p">)</span> <span class="o">/</span> <span class="mf">100.0f</span> <span class="o">+</span> <span class="mf">0.05</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">    <span class="n">model</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">scale</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="n">scale</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">
</span></span><span class="line"><span class="ln">24</span><span class="cl">    <span class="c1">// 3. rotation: add random rotation around a (semi)randomly picked rotation axis vector
</span></span></span><span class="line"><span class="ln">25</span><span class="cl"><span class="c1"></span>    <span class="kt">float</span> <span class="n">rotAngle</span> <span class="o">=</span> <span class="p">(</span><span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">360</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl">    <span class="n">model</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">rotate</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">rotAngle</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.4f</span><span class="p">,</span> <span class="mf">0.6f</span><span class="p">,</span> <span class="mf">0.8f</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl">
</span></span><span class="line"><span class="ln">28</span><span class="cl">    <span class="c1">// 4. now add to list of matrices
</span></span></span><span class="line"><span class="ln">29</span><span class="cl"><span class="c1"></span>    <span class="n">modelMatrices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">model</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">30</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>This piece of code may look a little daunting, but we basically transform the x and z position of the asteroid along a circle with a radius defined by radius and randomly displace each asteroid a little around the circle by -offset and offset. We give the <code>y</code> displacement less of an impact to create a more flat asteroid ring. Then we apply scale and rotation transformations and store the resulting transformation matrix in modelMatrices that is of size amount. Here we generate <code>1000</code> model matrices, one per asteroid.</p>
<p>After loading the planet and rock models and compiling a set of shaders, the rendering code then looks a bit like this:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="c1">// draw planet
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1"></span><span class="n">shader</span><span class="p">.</span><span class="n">use</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span> <span class="n">model</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">model</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">translate</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">));</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">model</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">scale</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">4.0f</span><span class="p">,</span> <span class="mf">4.0f</span><span class="p">,</span> <span class="mf">4.0f</span><span class="p">));</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">shader</span><span class="p">.</span><span class="n">setMat4</span><span class="p">(</span><span class="s">&#34;model&#34;</span><span class="p">,</span> <span class="n">model</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="n">planet</span><span class="p">.</span><span class="n">Draw</span><span class="p">(</span><span class="n">shader</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1">// draw meteorites
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1"></span><span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">amount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="n">shader</span><span class="p">.</span><span class="n">setMat4</span><span class="p">(</span><span class="s">&#34;model&#34;</span><span class="p">,</span> <span class="n">modelMatrices</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="n">rock</span><span class="p">.</span><span class="n">Draw</span><span class="p">(</span><span class="n">shader</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>First we draw the planet model, that we translate and scale a bit to accommodate the scene, and then we draw a number of rock models equal to the amount of transformations we generated previously. Before we draw each rock however, we first set the corresponding model transformation matrix within the shader.</p>
<p>The result is then a space-like scene where we can see a natural-looking asteroid ring around a planet:</p>
<p><a href="#R-image-c6e9c50746c2dd590fabb6e38145e0f0" class="lightbox-link"><img src="./assets/instancing_asteroids.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c6e9c50746c2dd590fabb6e38145e0f0"><img src="./assets/instancing_asteroids.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>This scene contains a total of <code>1001</code> rendering calls per frame of which <code>1000</code> are of the rock model. You can find the source code for this scene <a href="https://learnopengl.com/code_viewer_gh.php?code=src/4.advanced_opengl/10.2.asteroids/asteroids.cpp" target="_blank">here</a>.</p>
<p>As soon as we start to increase this number we will quickly notice that the scene stops running smoothly and the number of frames we&rsquo;re able to render per second reduces drastically. As soon as we set amount to something close to <code>2000</code> the scene already becomes so slow on our GPU that it becomes difficult to move around.</p>
<p>Let&rsquo;s now try to render the same scene, but this time with instanced rendering. We first need to adjust the vertex shader a little:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">aPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec2</span> <span class="n">aTexCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span> <span class="n">in</span> <span class="n">mat4</span> <span class="n">instanceMatrix</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">out</span> <span class="n">vec2</span> <span class="n">TexCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="n">uniform</span> <span class="n">mat4</span> <span class="n">projection</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="n">uniform</span> <span class="n">mat4</span> <span class="n">view</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">projection</span> <span class="o">*</span> <span class="n">view</span> <span class="o">*</span> <span class="n">instanceMatrix</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">aPos</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="n">TexCoords</span> <span class="o">=</span> <span class="n">aTexCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>We&rsquo;re no longer using a model uniform variable, but instead declare a mat4 as a vertex attribute so we can store an instanced array of transformation matrices. However, when we declare a datatype as a vertex attribute that is greater than a vec4 things work a bit differently. The maximum amount of data allowed for a vertex attribute is equal to a vec4. Because a mat4 is basically 4 vec4s, we have to reserve 4 vertex attributes for this specific matrix. Because we assigned it a location of <code>3</code>, the columns of the matrix will have vertex attribute locations of <code>3</code>, <code>4</code>, <code>5</code>, and <code>6</code>.</p>
<p>We then have to set each of the attribute pointers of those <code>4</code> vertex attributes and configure them as instanced arrays:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="c1">// vertex buffer object
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1"></span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">buffer</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">glGenBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buffer</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">amount</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">modelMatrices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">GL_STATIC_DRAW</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rock</span><span class="p">.</span><span class="n">meshes</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">VAO</span> <span class="o">=</span> <span class="n">rock</span><span class="p">.</span><span class="n">meshes</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">VAO</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">VAO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="c1">// vertex attributes
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">vec4Size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">vec4</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">vec4Size</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">vec4Size</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)(</span><span class="mi">1</span> <span class="o">*</span> <span class="n">vec4Size</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">    <span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">18</span><span class="cl">    <span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">vec4Size</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">vec4Size</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">    <span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">20</span><span class="cl">    <span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">vec4Size</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">vec4Size</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">
</span></span><span class="line"><span class="ln">22</span><span class="cl">    <span class="n">glVertexAttribDivisor</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">    <span class="n">glVertexAttribDivisor</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">    <span class="n">glVertexAttribDivisor</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl">    <span class="n">glVertexAttribDivisor</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl">
</span></span><span class="line"><span class="ln">27</span><span class="cl">    <span class="n">glBindVertexArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">28</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>Note that we cheated a little by declaring the VAO variable of the Mesh as a public variable instead of a private variable so we could access its vertex array object. This is not the cleanest solution, but just a simple modification to suit this example. Aside from the little hack, this code should be clear. We&rsquo;re basically declaring how OpenGL should interpret the buffer for each of the matrix&rsquo;s vertex attributes and that each of those vertex attributes is an instanced array.</p>
<p>Next we take the VAO of the mesh(es) again and this time draw using glDrawElementsInstanced:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="c1">// draw meteorites
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="c1"></span><span class="n">instanceShader</span><span class="p">.</span><span class="n">use</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rock</span><span class="p">.</span><span class="n">meshes</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">    <span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">rock</span><span class="p">.</span><span class="n">meshes</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">VAO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">    <span class="n">glDrawElementsInstanced</span><span class="p">(</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl">        <span class="n">GL_TRIANGLES</span><span class="p">,</span> <span class="n">rock</span><span class="p">.</span><span class="n">meshes</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">indices</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">GL_UNSIGNED_INT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">amount</span>
</span></span><span class="line"><span class="ln">8</span><span class="cl">    <span class="p">);</span>
</span></span><span class="line"><span class="ln">9</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>Here we draw the same amount of asteroids as the previous example, but this time with instanced rendering. The results should be exactly the same, but once we increase the amount you&rsquo;ll really start to see the power of instanced rendering. Without instanced rendering we were able to smoothly render around <code>1000</code> to <code>1500</code> asteroids. With instanced rendering we can now set this value to <code>100000</code>. This, with the rock model having <code>576</code> vertices, would equal around <code>57</code> million vertices drawn each frame without significant performance drops; and only 2 draw calls!</p>
<p><a href="#R-image-677f736fb84c1a22b8329fa54ad2392b" class="lightbox-link"><img src="./assets/instancing_asteroids_quantity.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-677f736fb84c1a22b8329fa54ad2392b"><img src="./assets/instancing_asteroids_quantity.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>This image was rendered with <code>100000</code> asteroids with a radius of <code>150.0f</code> and an offset equal to <code>25.0f</code>. You can find the source code of the instanced rendering demo <a href="https://learnopengl.com/code_viewer_gh.php?code=src/4.advanced_opengl/10.3.asteroids_instanced/asteroids_instanced.cpp" target="_blank">here</a>.</p>
<p><note>On different machines an asteroid count of <code>100000</code> may be a bit too high, so try tweaking the values till you reach an acceptable framerate.</note></p>
<p>As you can see, with the right type of environments, instanced rendering can make an enormous difference to the rendering capabilities of your application. For this reason, instanced rendering is commonly used for grass, flora, particles, and scenes like this - basically any scene with many repeating shapes can benefit from instanced rendering.</p>
<h3 id="anti-aliasing">Anti Aliasing</h3>
<p>Somewhere in your adventurous rendering journey you probably came across some jagged saw-like patterns along the edges of your models. The reason these jagged edges appear is due to how the rasterizer transforms the vertex data into actual fragments behind the scene. An example of what these jagged edges look like can already be seen when drawing a simple cube:</p>
<p><a href="#R-image-041c7b73a14698a21f0493d8cfb1a9ad" class="lightbox-link"><img src="./assets/anti_aliasing_aliasing.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-041c7b73a14698a21f0493d8cfb1a9ad"><img src="./assets/anti_aliasing_aliasing.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>While not immediately visible, if you take a closer look at the edges of the cube you&rsquo;ll see a jagged pattern. If we zoom in you&rsquo;d see the following:</p>
<p><a href="#R-image-b8cb4c4ad1949ae9a42e7e078fda8458" class="lightbox-link"><img src="./assets/anti_aliasing_zoomed.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b8cb4c4ad1949ae9a42e7e078fda8458"><img src="./assets/anti_aliasing_zoomed.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>This is clearly not something we want in a final version of an application. This effect, of clearly seeing the pixel formations an edge is composed of, is called aliasing. There are quite a few techniques out there called anti-aliasing techniques that fight this aliasing behavior by producing <em>smoother</em> edges.</p>
<p>At first we had a technique called super sample anti-aliasing (SSAA) that temporarily uses a much higher resolution render buffer to render the scene in (super sampling). Then when the full scene is rendered, the resolution is downsampled back to the normal resolution. This <em>extra</em> resolution was used to prevent these jagged edges. While it did provide us with a solution to the aliasing problem, it came with a major performance drawback since we have to draw <strong>a lot</strong> more fragments than usual. This technique therefore only had a short glory moment.</p>
<p>This technique did give birth to a more modern technique called multisample anti-aliasing or MSAA that borrows from the concepts behind SSAA while implementing a much more efficient approach. In this chapter we&rsquo;ll be extensively discussing this MSAA technique that is built-in in OpenGL.</p>
<h4 id="multisampling">Multisampling</h4>
<p>To understand what multisampling is and how it works into solving the aliasing problem we first need to delve a bit further into the inner workings of OpenGL&rsquo;s rasterizer.</p>
<p>The rasterizer is the combination of all algorithms and processes that sit between your final processed vertices and the fragment shader. The rasterizer takes all vertices belonging to a single primitive and transforms this to a set of fragments. Vertex coordinates can theoretically have any coordinate, but fragments can&rsquo;t since they are bound by the resolution of your screen. There will almost never be a one-on-one mapping between vertex coordinates and fragments, so the rasterizer has to determine in some way what fragment/screen-coordinate each specific vertex will end up at.</p>
<p><a href="#R-image-0f11de983213f4cbe77921d3b3f82a9c" class="lightbox-link"><img src="./assets/anti_aliasing_rasterization.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-0f11de983213f4cbe77921d3b3f82a9c"><img src="./assets/anti_aliasing_rasterization.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Here we see a grid of screen pixels where the center of each pixel contains a sample point that is used to determine if a pixel is covered by the triangle. The red sample points are covered by the triangle and a fragment will be generated for that covered pixel. Even though some parts of the triangle edges still enter certain screen pixels, the pixel&rsquo;s sample point is not covered by the inside of the triangle so this pixel won&rsquo;t be influenced by any fragment shader.</p>
<p>You can probably already figure out the origin of aliasing right now. The complete rendered version of the triangle would look like this on your screen:</p>
<p><a href="#R-image-34d730c778ef7387755e73ce270f9e0e" class="lightbox-link"><img src="./assets/anti_aliasing_rasterization_filled.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-34d730c778ef7387755e73ce270f9e0e"><img src="./assets/anti_aliasing_rasterization_filled.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Due to the limited amount of screen pixels, some pixels will be rendered along an edge and some won&rsquo;t. The result is that we&rsquo;re rendering primitives with non-smooth edges giving rise to the jagged edges we&rsquo;ve seen before.</p>
<p>What multisampling does, is not use a single sampling point for determining coverage of the triangle, but multiple sample points (guess where it got its name from). Instead of a single sample point at the center of each pixel we&rsquo;re going to place <code>4</code> subsamples in a general pattern and use those to determine pixel coverage.</p>
<p><a href="#R-image-a43a9e0a437c00000b90cb99b0dc577f" class="lightbox-link"><img src="./assets/anti_aliasing_sample_points.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a43a9e0a437c00000b90cb99b0dc577f"><img src="./assets/anti_aliasing_sample_points.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>The left side of the image shows how we would normally determine the coverage of a triangle. This specific pixel won&rsquo;t run a fragment shader (and thus remains blank) since its sample point wasn&rsquo;t covered by the triangle. The right side of the image shows a multisampled version where each pixel contains <code>4</code> sample points. Here we can see that only <code>2</code> of the sample points cover the triangle.</p>
<p><note>The amount of sample points can be any number we&rsquo;d like with more samples giving us better coverage precision.</note></p>
<p>This is where multisampling becomes interesting. We determined that <code>2</code> subsamples were covered by the triangle so the next step is to determine a color for this specific pixel. Our initial guess would be that we run the fragment shader for each covered subsample and later average the colors of each subsample per pixel. In this case we&rsquo;d run the fragment shader twice on the interpolated vertex data at each subsample and store the resulting color in those sample points. This is (fortunately) <strong>not</strong> how it works, because this would mean we need to run a lot more fragment shaders than without multisampling, drastically reducing performance.</p>
<p>How MSAA really works is that the fragment shader is only run <strong>once</strong> per pixel (for each primitive) regardless of how many subsamples the triangle covers; the fragment shader runs with the vertex data interpolated to the <strong>center</strong> of the pixel. MSAA then uses a larger depth/stencil buffer to determine subsample coverage. The number of subsamples covered determines how much the pixel color contributes to the framebuffer. Because only 2 of the 4 samples were covered in the previous image, half of the triangle&rsquo;s color is mixed with the framebuffer color (in this case the clear color) resulting in a light blue-ish color.</p>
<p>The result is a higher resolution buffer (with higher resolution depth/stencil) where all the primitive edges now produce a smoother pattern. Let&rsquo;s see what multisampling looks like when we determine the coverage of the earlier triangle:</p>
<p><a href="#R-image-7dfe856cc59bdfd36d3c6e20b5ea2219" class="lightbox-link"><img src="./assets/anti_aliasing_rasterization_samples.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7dfe856cc59bdfd36d3c6e20b5ea2219"><img src="./assets/anti_aliasing_rasterization_samples.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Here each pixel contains 4 subsamples (the irrelevant samples were hidden) where the blue subsamples are covered by the triangle and the gray sample points aren&rsquo;t. Within the inner region of the triangle all pixels will run the fragment shader once where its color output is stored directly in the framebuffer (assuming no blending). At the inner edges of the triangle however not all subsamples will be covered so the result of the fragment shader won&rsquo;t fully contribute to the framebuffer. Based on the number of covered samples, more or less of the triangle fragment&rsquo;s color ends up at that pixel.</p>
<p>For each pixel, the less subsamples are part of the triangle, the less it takes the color of the triangle. If we were to fill in the actual pixel colors we get the following image:</p>
<p><a href="#R-image-1d66b5b2f7bcea2962dc4e3a9f671a46" class="lightbox-link"><img src="./assets/anti_aliasing_rasterization_samples_filled.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-1d66b5b2f7bcea2962dc4e3a9f671a46"><img src="./assets/anti_aliasing_rasterization_samples_filled.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>The hard edges of the triangle are now surrounded by colors slightly lighter than the actual edge color, which causes the edge to appear smooth when viewed from a distance.</p>
<p>Depth and stencil values are stored per subsample and, even though we only run the fragment shader once, color values are stored per subsample as well for the case of multiple triangles overlapping a single pixel. For depth testing the vertex&rsquo;s depth value is interpolated to each subsample before running the depth test, and for stencil testing we store the stencil values per subsample. This does mean that the size of the buffers are now increased by the amount of subsamples per pixel.</p>
<p>What we&rsquo;ve discussed so far is a basic overview of how multisampled anti-aliasing works behind the scenes. The actual logic behind the rasterizer is a bit more complicated, but this brief description should be enough to understand the concept and logic behind multisampled anti-aliasing; enough to delve into the practical aspects.</p>
<h4 id="msaa-in-opengl">MSAA in OpenGL</h4>
<p>If we want to use MSAA in OpenGL we need to use a buffer that is able to store more than one sample value per pixel. We need a new type of buffer that can store a given amount of multisamples and this is called a multisample buffer.</p>
<p>Most windowing systems are able to provide us a multisample buffer instead of a default buffer. GLFW also gives us this functionality and all we need to do is <em>hint</em> GLFW that we&rsquo;d like to use a multisample buffer with N samples instead of a normal buffer by calling glfwWindowHint before creating the window:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glfwWindowHint</span><span class="p">(</span><span class="n">GLFW_SAMPLES</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span></span></span></code></pre></div><p>When we now call glfwCreateWindow we create a rendering window, but this time with a buffer containing 4 subsamples per screen coordinate. This does mean that the size of the buffer is increased by 4.</p>
<p>Now that we asked GLFW for multisampled buffers we need to enable multisampling by calling glEnable with GL_MULTISAMPLE. On most OpenGL drivers, multisampling is enabled by default so this call is then a bit redundant, but it&rsquo;s usually a good idea to enable it anyways. This way all OpenGL implementations have multisampling enabled.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glEnable</span><span class="p">(</span><span class="n">GL_MULTISAMPLE</span><span class="p">);</span>  
</span></span></code></pre></div><p>Because the actual multisampling algorithms are implemented in the rasterizer in your OpenGL drivers there&rsquo;s not much else we need to do. If we now were to render the green cube from the start of this chapter we should see smoother edges:</p>
<p><a href="#R-image-c4805868f581b340bb00d18417988e22" class="lightbox-link"><img src="./assets/anti_aliasing_multisampled.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c4805868f581b340bb00d18417988e22"><img src="./assets/anti_aliasing_multisampled.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>The cube does indeed look a lot smoother and the same will apply for any other object you&rsquo;re drawing in your scene. You can find the source code for this simple example <a href="https://learnopengl.com/code_viewer_gh.php?code=src/4.advanced_opengl/11.1.anti_aliasing_msaa/anti_aliasing_msaa.cpp" target="_blank">here</a>.</p>
<h4 id="off-screen-msaa">Off-screen MSAA</h4>
<p>Because GLFW takes care of creating the multisampled buffers, enabling MSAA is quite easy. If we want to use our own framebuffers however, we have to generate the multisampled buffers ourselves; now we <strong>do</strong> need to take care of creating multisampled buffers.</p>
<p>There are two ways we can create multisampled buffers to act as attachments for framebuffers: texture attachments and renderbuffer attachments. Quite similar to normal attachments like we&rsquo;ve discussed in the <a href="https://learnopengl.com/Advanced-OpenGL/Framebuffers" target="_blank">framebuffers</a> chapter.</p>
<h5 id="multisampled-texture-attachments">Multisampled texture attachments</h5>
<p>To create a texture that supports storage of multiple sample points we use glTexImage2DMultisample instead of glTexImage2D that accepts GL_TEXTURE_2D_MULTISAPLE as its texture target:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D_MULTISAMPLE</span><span class="p">,</span> <span class="n">tex</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glTexImage2DMultisample</span><span class="p">(</span><span class="n">GL_TEXTURE_2D_MULTISAMPLE</span><span class="p">,</span> <span class="n">samples</span><span class="p">,</span> <span class="n">GL_RGB</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">GL_TRUE</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D_MULTISAMPLE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  
</span></span></code></pre></div><p>The second argument sets the number of samples we&rsquo;d like the texture to have. If the last argument is set to GL_TRUE, the image will use identical sample locations and the same number of subsamples for each texel.</p>
<p>To attach a multisampled texture to a framebuffer we use glFramebufferTexture2D, but this time with GL_TEXTURE_2D_MULTISAMPLE as the texture type:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glFramebufferTexture2D</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">GL_COLOR_ATTACHMENT0</span><span class="p">,</span> <span class="n">GL_TEXTURE_2D_MULTISAMPLE</span><span class="p">,</span> <span class="n">tex</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> 
</span></span></code></pre></div><p>The currently bound framebuffer now has a multisampled color buffer in the form of a texture image.</p>
<h5 id="multisampled-renderbuffer-objects">Multisampled renderbuffer objects</h5>
<p>Like textures, creating a multisampled renderbuffer object isn&rsquo;t difficult. It is even quite easy since all we need to change is glRenderbufferStorage to glRenderbufferStorageMultisample when we configure the (currently bound) renderbuffer&rsquo;s memory storage:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glRenderbufferStorageMultisample</span><span class="p">(</span><span class="n">GL_RENDERBUFFER</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">GL_DEPTH24_STENCIL8</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">);</span>  
</span></span></code></pre></div><p>The one thing that changed here is the extra second parameter where we set the amount of samples we&rsquo;d like to use; 4 in this particular case.</p>
<h5 id="render-to-multisampled-framebuffer">Render to multisampled framebuffer</h5>
<p>Rendering to a multisampled framebuffer is straightforward. Whenever we draw anything while the framebuffer object is bound, the rasterizer will take care of all the multisample operations. However, because a multisampled buffer is a bit special, we can&rsquo;t directly use the buffer for other operations like sampling it in a shader.</p>
<p>A multisampled image contains much more information than a normal image so what we need to do is downscale or resolve the image. Resolving a multisampled framebuffer is generally done through glBlitFramebuffer that copies a region from one framebuffer to the other while also resolving any multisampled buffers.</p>
<p>glBlitFramebuffer transfers a given source region defined by 4 screen-space coordinates to a given target region also defined by 4 screen-space coordinates. You may remember from the <a href="https://learnopengl.com/Advanced-OpenGL/Framebuffers" target="_blank">framebuffers</a> chapter that if we bind to GL_FRAMEBUFFER we&rsquo;re binding to both the read and draw framebuffer targets. We could also bind to those targets individually by binding framebuffers to GL_READ_FRAMEBUFFER and GL_DRAW_FRAMEBUFFER respectively. The glBlitFramebuffer function reads from those two targets to determine which is the source and which is the target framebuffer. We could then transfer the multisampled framebuffer output to the actual screen by blitting the image to the default framebuffer like so:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_READ_FRAMEBUFFER</span><span class="p">,</span> <span class="n">multisampledFBO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_DRAW_FRAMEBUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">glBlitFramebuffer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">GL_COLOR_BUFFER_BIT</span><span class="p">,</span> <span class="n">GL_NEAREST</span><span class="p">);</span> 
</span></span></code></pre></div><p>If we then were to render the same application we should get the same output: a lime-green cube displayed with MSAA and again showing significantly less jagged edges:</p>
<p><a href="#R-image-89250b3f249210219a3e82f83158dcd2" class="lightbox-link"><img src="./assets/anti_aliasing_multisampled.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-89250b3f249210219a3e82f83158dcd2"><img src="./assets/anti_aliasing_multisampled.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>You can find the source code <a href="https://learnopengl.com/code_viewer_gh.php?code=src/4.advanced_opengl/11.2.anti_aliasing_offscreen/anti_aliasing_offscreen.cpp" target="_blank">here</a>.</p>
<p>But what if we wanted to use the texture result of a multisampled framebuffer to do stuff like post-processing? We can&rsquo;t directly use the multisampled texture(s) in the fragment shader. What we can do however is blit the multisampled buffer(s) to a different FBO with a non-multisampled texture attachment. We then use this ordinary color attachment texture for post-processing, effectively post-processing an image rendered via multisampling. This does mean we have to generate a new FBO that acts solely as an intermediate framebuffer object to resolve the multisampled buffer into; a normal 2D texture we can use in the fragment shader. This process looks a bit like this in pseudocode:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">msFBO</span> <span class="o">=</span> <span class="n">CreateFBOWithMultiSampledAttachments</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1">// then create another FBO with a normal texture color attachment
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="c1"></span><span class="p">[...]</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">glFramebufferTexture2D</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">GL_COLOR_ATTACHMENT0</span><span class="p">,</span> <span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">screenTexture</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="p">[...]</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">glfwWindowShouldClose</span><span class="p">(</span><span class="n">window</span><span class="p">))</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="p">[...]</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">msFBO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="n">ClearFrameBuffer</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="n">DrawScene</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="c1">// now resolve multisampled buffer(s) into intermediate FBO
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="c1"></span>    <span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_READ_FRAMEBUFFER</span><span class="p">,</span> <span class="n">msFBO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_DRAW_FRAMEBUFFER</span><span class="p">,</span> <span class="n">intermediateFBO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="n">glBlitFramebuffer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">GL_COLOR_BUFFER_BIT</span><span class="p">,</span> <span class="n">GL_NEAREST</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">    <span class="c1">// now scene is stored as 2D texture image, so use that image for post-processing
</span></span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="c1"></span>    <span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">    <span class="n">ClearFramebuffer</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">    <span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">screenTexture</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">    <span class="n">DrawPostProcessingQuad</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln">22</span><span class="cl">  
</span></span><span class="line"><span class="ln">23</span><span class="cl">    <span class="p">[...]</span> 
</span></span><span class="line"><span class="ln">24</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>If we then implement this into the post-processing code of the <a href="https://learnopengl.com/Advanced-OpenGL/Framebuffers" target="_blank">framebuffers</a> chapter we&rsquo;re able to create all kinds of cool post-processing effects on a texture of a scene with (almost) no jagged edges. With a grayscale postprocessing filter applied it&rsquo;ll look something like this:</p>
<p><a href="#R-image-2e43b572c983f34f895e7b68a5b50ef2" class="lightbox-link"><img src="./assets/anti_aliasing_post_processing.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-2e43b572c983f34f895e7b68a5b50ef2"><img src="./assets/anti_aliasing_post_processing.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><note>Because the screen texture is a normal (non-multisampled) texture again, some post-processing filters like <em>edge-detection</em> will introduce jagged edges again. To accommodate for this you could blur the texture afterwards or create your own anti-aliasing algorithm.</note></p>
<p>You can see that when we want to combine multisampling with off-screen rendering we need to take care of some extra steps. The steps are worth the extra effort though since multisampling significantly boosts the visual quality of your scene. Do note that enabling multisampling can noticeably reduce performance the more samples you use.</p>
<h4 id="custom-anti-aliasing-algorithm">Custom Anti-Aliasing algorithm</h4>
<p>It is possible to directly pass a multisampled texture image to a fragment shader instead of first resolving it. GLSL gives us the option to sample the texture image per subsample so we can create our own custom anti-aliasing algorithms.</p>
<p>To get a texture value per subsample you&rsquo;d have to define the texture uniform sampler as a sampler2DMS instead of the usual sampler2D:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">uniform</span> <span class="n">sampler2DMS</span> <span class="n">screenTextureMS</span><span class="p">;</span>    
</span></span></code></pre></div><p>Using the texelFetch function it is then possible to retrieve the color value per sample:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">vec4</span> <span class="n">colorSample</span> <span class="o">=</span> <span class="n">texelFetch</span><span class="p">(</span><span class="n">screenTextureMS</span><span class="p">,</span> <span class="n">TexCoords</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>  <span class="c1">// 4th subsample
</span></span></span></code></pre></div><p>We won&rsquo;t go into the details of creating custom anti-aliasing techniques here, but this may be enough to get started on building one yourself.</p>
<h2 id="advanced-lighting">Advanced Lighting</h2>
<h3 id="advanced-lighting-1">Advanced Lighting</h3>
<p>In the <a href="https://learnopengl.com/Lighting/Basic-Lighting" target="_blank">lighting</a> chapters we briefly introduced the Phong lighting model to bring a basic amount of realism into our scenes. The Phong model looks nice, but has a few nuances we&rsquo;ll focus on in this chapter.</p>
<h4 id="blinn-phong">Blinn-Phong</h4>
<p>Phong lighting is a great and very efficient approximation of lighting, but its specular reflections break down in certain conditions, specifically when the shininess property is low resulting in a large (rough) specular area. The image below shows what happens when we use a specular shininess exponent of <code>1.0</code> on a flat textured plane:</p>
<p><a href="#R-image-4d6df06c2deb2aaff10de795898c1ef8" class="lightbox-link"><img src="./assets/advanced_lighting_phong_limit.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-4d6df06c2deb2aaff10de795898c1ef8"><img src="./assets/advanced_lighting_phong_limit.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>You can see at the edges that the specular area is immediately cut off. The reason this happens is because the angle between the view and reflection vector doesn&rsquo;t go over 90 degrees. If the angle is larger than 90 degrees, the resulting dot product becomes negative and this results in a specular exponent of <code>0.0</code>. You&rsquo;re probably thinking this won&rsquo;t be a problem since we shouldn&rsquo;t get any light with angles higher than 90 degrees anyways, right?</p>
<p>Wrong, this only applies to the diffuse component where an angle higher than 90 degrees between the normal and light source means the light source is below the lighted surface and thus the light&rsquo;s diffuse contribution should equal <code>0.0</code>. However, with specular lighting we&rsquo;re not measuring the angle between the light source and the normal, but between the view and reflection vector. Take a look at the following two images:</p>
<p><a href="#R-image-538941f0c401413486cecde972a59a8c" class="lightbox-link"><img src="./assets/advanced_lighting_over_90.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-538941f0c401413486cecde972a59a8c"><img src="./assets/advanced_lighting_over_90.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Here the issue should become apparent. The left image shows Phong reflections as familiar, with θ� being less than 90 degrees. In the right image we can see that the angle θ� between the view and reflection vector is larger than 90 degrees which as a result nullifies the specular contribution. This generally isn&rsquo;t a problem since the view direction is far from the reflection direction, but if we use a low specular exponent the specular radius is large enough to have a contribution under these conditions. Since we&rsquo;re nullifying this contribution at angles larger than 90 degrees we get the artifact as seen in the first image.</p>
<p>In 1977 the Blinn-Phong shading model was introduced by James F. Blinn as an extension to the Phong shading we&rsquo;ve used so far. The Blinn-Phong model is largely similar, but approaches the specular model slightly different which as a result overcomes our problem. Instead of relying on a reflection vector we&rsquo;re using a so called halfway vector that is a unit vector exactly halfway between the view direction and the light direction. The closer this halfway vector aligns with the surface&rsquo;s normal vector, the higher the specular contribution.</p>
<p><a href="#R-image-b88be3d0831795804475ab2d396135b5" class="lightbox-link"><img src="./assets/advanced_lighting_halfway_vector.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b88be3d0831795804475ab2d396135b5"><img src="./assets/advanced_lighting_halfway_vector.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>When the view direction is perfectly aligned with the (now imaginary) reflection vector, the halfway vector aligns perfectly with the normal vector. The closer the view direction is to the original reflection direction, the stronger the specular highlight.</p>
<p>Here you can see that whatever direction the viewer looks from, the angle between the halfway vector and the surface normal never exceeds 90 degrees (unless the light is far below the surface of course). The results are slightly different from Phong reflections, but generally more visually plausible, especially with low specular exponents. The Blinn-Phong shading model is also the exact shading model used in the earlier fixed function pipeline of OpenGL.</p>
<p>Getting the halfway vector is easy, we add the light&rsquo;s direction vector and view vector together and normalize the result:\bar{H} = \frac{\bar{L} + \bar{V}}{||\bar{L} + \bar{V}||}</p>

<span class="math align-center">$$
\bar{H} = \frac{\bar{L} + \bar{V}}{||\bar{L} + \bar{V}||}
$$</span><p>This translates to GLSL code as follows:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">vec3</span> <span class="n">lightDir</span>   <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">lightPos</span> <span class="o">-</span> <span class="n">FragPos</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">vec3</span> <span class="n">viewDir</span>    <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">viewPos</span> <span class="o">-</span> <span class="n">FragPos</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">vec3</span> <span class="n">halfwayDir</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">lightDir</span> <span class="o">+</span> <span class="n">viewDir</span><span class="p">);</span></span></span></code></pre></div><p>Then the actual calculation of the specular term becomes a clamped dot product between the surface normal and the halfway vector to get the cosine angle between them that we again raise to a specular shininess exponent:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">float</span> <span class="n">spec</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="n">halfwayDir</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">),</span> <span class="n">shininess</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">vec3</span> <span class="n">specular</span> <span class="o">=</span> <span class="n">lightColor</span> <span class="o">*</span> <span class="n">spec</span><span class="p">;</span></span></span></code></pre></div><p>And there is nothing more to Blinn-Phong than what we just described. The only difference between Blinn-Phong and Phong specular reflection is that we now measure the angle between the normal and halfway vector instead of the angle between the view and reflection vector.</p>
<p>With the introduction of the halfway vector we should no longer have the specular cutoff issue of Phong shading. The image below shows the specular area of both methods with a specular exponent of <code>0.5</code>:</p>
<p><a href="#R-image-3af0e45638e2b5f84441cbcb4600fe5b" class="lightbox-link"><img src="./assets/advanced_lighting_comparrison.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-3af0e45638e2b5f84441cbcb4600fe5b"><img src="./assets/advanced_lighting_comparrison.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Another subtle difference between Phong and Blinn-Phong shading is that the angle between the halfway vector and the surface normal is often shorter than the angle between the view and reflection vector. As a result, to get visuals similar to Phong shading the specular shininess exponent has to be set a bit higher. A general rule of thumb is to set it between 2 and 4 times the Phong shininess exponent.</p>
<p>Below is a comparison between both specular reflection models with the Phong exponent set to <code>8.0</code> and the Blinn-Phong component set to <code>32.0</code>:</p>
<p><a href="#R-image-ebcc134d36256dc480081919b3deaaac" class="lightbox-link"><img src="./assets/advanced_lighting_comparrison2.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-ebcc134d36256dc480081919b3deaaac"><img src="./assets/advanced_lighting_comparrison2.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>You can see that the Blinn-Phong specular exponent is bit sharper compared to Phong. It usually requires a bit of tweaking to get similar results as to what you previously had with Phong shading. It&rsquo;s worth it though as Blinn-Phong shading is generally more realistic compared to default Phong shading.</p>
<p>Here we used a simple fragment shader that switches between regular Phong reflections and Blinn-Phong reflections:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="p">[...]</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="kt">float</span> <span class="n">spec</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">blinn</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">        <span class="n">vec3</span> <span class="n">halfwayDir</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">lightDir</span> <span class="o">+</span> <span class="n">viewDir</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        <span class="n">spec</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="n">halfwayDir</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">),</span> <span class="mf">16.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">        <span class="n">vec3</span> <span class="n">reflectDir</span> <span class="o">=</span> <span class="n">reflect</span><span class="p">(</span><span class="o">-</span><span class="n">lightDir</span><span class="p">,</span> <span class="n">normal</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">        <span class="n">spec</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">viewDir</span><span class="p">,</span> <span class="n">reflectDir</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">),</span> <span class="mf">8.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="p">}</span></span></span></code></pre></div><p>You can find the source code for the simple demo <a href="https://learnopengl.com/code_viewer_gh.php?code=src/5.advanced_lighting/1.advanced_lighting/advanced_lighting.cpp" target="_blank">here</a>. By pressing the <code>b</code> key, the demo switches from Phong to Blinn-Phong lighting and vica versa.</p>
<h3 id="gamma-correction">Gamma Correction</h3>
<p>As soon as we compute the final pixel colors of the scene we will have to display them on a monitor. In the old days of digital imaging most monitors were cathode-ray tube (CRT) monitors. These monitors had the physical property that twice the input voltage did not result in twice the amount of brightness. Doubling the input voltage resulted in a brightness equal to an exponential relationship of roughly 2.2 known as the gamma of a monitor. This happens to (coincidently) also closely match how human beings measure brightness as brightness is also displayed with a similar (inverse) power relationship. To better understand what this all means take a look at the following image:</p>
<p><a href="#R-image-43adccb3eb01a1bbe7cfd24f7c1da82d" class="lightbox-link"><img src="./assets/gamma_correction_brightness.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-43adccb3eb01a1bbe7cfd24f7c1da82d"><img src="./assets/gamma_correction_brightness.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>The top line looks like the correct brightness scale to the human eye, doubling the brightness (from 0.1 to 0.2 for example) does indeed look like it&rsquo;s twice as bright with nice consistent differences. However, when we&rsquo;re talking about the physical brightness of light e.g. amount of photons leaving a light source, the bottom scale actually displays the correct brightness. At the bottom scale, doubling the brightness returns the correct physical brightness, but since our eyes perceive brightness differently (more susceptible to changes in dark colors) it looks weird.</p>
<p>Because the human eyes prefer to see brightness colors according to the top scale, monitors (still today) use a power relationship for displaying output colors so that the original physical brightness colors are mapped to the non-linear brightness colors in the top scale.</p>
<p>This non-linear mapping of monitors does output more pleasing brightness results for our eyes, but when it comes to rendering graphics there is one issue: all the color and brightness options we configure in our applications are based on what we perceive from the monitor and thus all the options are actually non-linear brightness/color options. Take a look at the graph below:</p>
<p><a href="#R-image-11ebe213adccd1e61ea6f44b71b9738b" class="lightbox-link"><img src="./assets/gamma_correction_gamma_curves.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-11ebe213adccd1e61ea6f44b71b9738b"><img src="./assets/gamma_correction_gamma_curves.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>The dotted line represents color/light values in linear space and the solid line represents the color space that monitors display. If we double a color in linear space, its result is indeed double the value. For instance, take a light&rsquo;s color vector (0.5, 0.0, 0.0) which represents a semi-dark red light. If we would double this light in linear space it would become (1.0, 0.0, 0.0) as you can see in the graph. However, the original color gets displayed on the monitor as (0.218, 0.0, 0.0) as you can see from the graph. Here&rsquo;s where the issues start to rise: once we double the dark-red light in linear space, it actually becomes more than 4.5 times as bright on the monitor!</p>
<p>Up until this chapter we have assumed we were working in linear space, but we&rsquo;ve actually been working in the monitor&rsquo;s output space so all colors and lighting variables we configured weren&rsquo;t physically correct, but merely looked (sort of) right on our monitor. For this reason, we (and artists) generally set lighting values way brighter than they should be (since the monitor darkens them) which as a result makes most linear-space calculations incorrect. Note that the monitor (CRT) and linear graph both start and end at the same position; it is the intermediate values that are darkened by the display.</p>
<p>Because colors are configured based on the display&rsquo;s output, all intermediate (lighting) calculations in linear-space are physically incorrect. This becomes more obvious as more advanced lighting algorithms are in place, as you can see in the image below:</p>
<p><a href="#R-image-4b1e6fd079519e1903568e29b23e3968" class="lightbox-link"><img src="./assets/gamma_correction_example.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-4b1e6fd079519e1903568e29b23e3968"><img src="./assets/gamma_correction_example.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>You can see that with gamma correction, the (updated) color values work more nicely together and darker areas show more details. Overall, a better image quality with a few small modifications.</p>
<p>Without properly correcting this monitor gamma, the lighting looks wrong and artists will have a hard time getting realistic and good-looking results. The solution is to apply gamma correction.</p>
<h4 id="gamma-correction-1">Gamma correction</h4>
<p>The idea of gamma correction is to apply the inverse of the monitor&rsquo;s gamma to the final output color before displaying to the monitor. Looking back at the gamma curve graph earlier this chapter we see another <em>dashed</em> line that is the inverse of the monitor&rsquo;s gamma curve. We multiply each of the linear output colors by this inverse gamma curve (making them brighter) and as soon as the colors are displayed on the monitor, the monitor&rsquo;s gamma curve is applied and the resulting colors become linear. We effectively brighten the intermediate colors so that as soon as the monitor darkens them, it balances all out.</p>
<p>Let&rsquo;s give another example. Say we again have the dark-red color 
<span class="math align-center">$(0.5,0.0,0.0)$</span>. Before displaying this color to the monitor we first apply the gamma correction curve to the color value. Linear colors displayed by a monitor are roughly scaled to a power of 
<span class="math align-center">$2.2$</span> so the inverse requires scaling the colors by a power of 
<span class="math align-center">$1/2.2$</span>. The gamma-corrected dark-red color thus becomes 
<span class="math align-center">$(0.5, 0.0, 0.0)^{1/2.2} = (0.5, 0.0, 0.0)^{0.45} = (0.73, 0.0, 0.0)$</span>. The corrected colors are then fed to the monitor and as a result the color is displayed as 
<span class="math align-center">$(0.73, 0.0, 0.0)^{2.2} = (0.5, 0.0, 0.0)$</span>. You can see that by using gamma-correction, the monitor now finally displays the colors as we linearly set them in the application.</p>
<p><note>A gamma value of 2.2 is a default gamma value that roughly estimates the average gamma of most displays. The color space as a result of this gamma of 2.2 is called the sRGB color space (not 100% exact, but close). Each monitor has their own gamma curves, but a gamma value of 2.2 gives good results on most monitors. For this reason, games often allow players to change the game&rsquo;s gamma setting as it varies slightly per monitor.</note></p>
<p>There are two ways to apply gamma correction to your scene:</p>
<ul>
<li>By using OpenGL&rsquo;s built-in sRGB framebuffer support.</li>
<li>By doing the gamma correction ourselves in the fragment shader(s).</li>
</ul>
<p>The first option is probably the easiest, but also gives you less control. By enabling GL_FRAMEBUFFER_SRGB you tell OpenGL that each subsequent drawing command should first gamma correct colors (from the sRGB color space) before storing them in color buffer(s). The sRGB is a color space that roughly corresponds to a gamma of 2.2 and a standard for most devices. After enabling GL_FRAMEBUFFER_SRGB, OpenGL automatically performs gamma correction after each fragment shader run to all subsequent framebuffers, including the default framebuffer.</p>
<p>Enabling GL_FRAMEBUFFER_SRGB is as simple as calling glEnable:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glEnable</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER_SRGB</span><span class="p">);</span> 
</span></span></code></pre></div><p>From now on your rendered images will be gamma corrected and as this is done by the hardware it is completely free. Something you should keep in mind with this approach (and the other approach) is that gamma correction (also) transforms the colors from linear space to non-linear space so it is very important you only do gamma correction at the last and final step. If you gamma-correct your colors before the final output, all subsequent operations on those colors will operate on incorrect values. For instance, if you use multiple framebuffers you probably want intermediate results passed in between framebuffers to remain in linear-space and only have the last framebuffer apply gamma correction before being sent to the monitor.</p>
<p>The second approach requires a bit more work, but also gives us complete control over the gamma operations. We apply gamma correction at the end of each relevant fragment shader run so the final colors end up gamma corrected before being sent out to the monitor:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="c1">// do super fancy lighting in linear space
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="c1"></span>    <span class="p">[...]</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">    <span class="c1">// apply gamma correction
</span></span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="c1"></span>    <span class="kt">float</span> <span class="n">gamma</span> <span class="o">=</span> <span class="mf">2.2</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl">    <span class="n">FragColor</span><span class="p">.</span><span class="n">rgb</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">fragColor</span><span class="p">.</span><span class="n">rgb</span><span class="p">,</span> <span class="n">vec3</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">gamma</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">8</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>The last line of code effectively raises each individual color component of fragColor to <code>1.0/gamma</code>, correcting the output color of this fragment shader run.</p>
<p>An issue with this approach is that in order to be consistent you have to apply gamma correction to each fragment shader that contributes to the final output. If you have a dozen fragment shaders for multiple objects, you have to add the gamma correction code to each of these shaders. An easier solution would be to introduce a post-processing stage in your render loop and apply gamma correction on the post-processed quad as a final step which you&rsquo;d only have to do once.</p>
<p>That one line represents the technical implementation of gamma correction. Not all too impressive, but there are a few extra things you have to consider when doing gamma correction.</p>
<h4 id="srgb-textures">sRGB textures</h4>
<p>Because monitors display colors with gamma applied, whenever you draw, edit, or paint a picture on your computer you are picking colors based on what you see on the monitor. This effectively means all the pictures you create or edit are not in linear space, but in sRGB space e.g. doubling a dark-red color on your screen based on perceived brightness, does not equal double the red component.</p>
<p>As a result, when texture artists create art by eye, all the textures&rsquo; values are in sRGB space so if we use those textures as they are in our rendering application we have to take this into account. Before we knew about gamma correction this wasn&rsquo;t really an issue, because the textures looked good in sRGB space which is the same space we worked in; the textures were displayed exactly as they are which was fine. However, now that we&rsquo;re displaying everything in linear space, the texture colors will be off as the following image shows:</p>
<p><a href="#R-image-3045ea58a897524b2231727f59fc8b8a" class="lightbox-link"><img src="./assets/gamma_correction_srgbtextures.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-3045ea58a897524b2231727f59fc8b8a"><img src="./assets/gamma_correction_srgbtextures.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>The texture image is way too bright and this happens because it is actually gamma corrected twice! Think about it, when we create an image based on what we see on the monitor, we effectively gamma correct the color values of an image so that it looks right on the monitor. Because we then again gamma correct in the renderer, the image ends up way too bright.</p>
<p>To fix this issue we have to make sure texture artists work in linear space. However, since it&rsquo;s easier to work in sRGB space and most tools don&rsquo;t even properly support linear texturing, this is probably not the preferred solution.</p>
<p>The other solution is to re-correct or transform these sRGB textures to linear space before doing any calculations on their color values. We can do this as follows:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">float</span> <span class="n">gamma</span> <span class="o">=</span> <span class="mf">2.2</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">vec3</span> <span class="n">diffuseColor</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">texture</span><span class="p">(</span><span class="n">diffuse</span><span class="p">,</span> <span class="n">texCoords</span><span class="p">).</span><span class="n">rgb</span><span class="p">,</span> <span class="n">vec3</span><span class="p">(</span><span class="n">gamma</span><span class="p">));</span></span></span></code></pre></div><p>To do this for each texture in sRGB space is quite troublesome though. Luckily OpenGL gives us yet another solution to our problems by giving us the GL_SRGB and GL_SRGB_ALPHA internal texture formats.</p>
<p>If we create a texture in OpenGL with any of these two sRGB texture formats, OpenGL will automatically correct the colors to linear-space as soon as we use them, allowing us to properly work in linear space. We can specify a texture as an sRGB texture as follows:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glTexImage2D</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_SRGB</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGB</span><span class="p">,</span> <span class="n">GL_UNSIGNED_BYTE</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>  
</span></span></code></pre></div><p>If you also want to include alpha components in your texture you&rsquo;ll have to specify the texture&rsquo;s internal format as GL_SRGB_ALPHA.</p>
<p>You should be careful when specifying your textures in sRGB space as not all textures will actually be in sRGB space. Textures used for coloring objects (like diffuse textures) are almost always in sRGB space. Textures used for retrieving lighting parameters (like <a href="https://learnopengl.com/Lighting/Lighting-maps" target="_blank">specular maps</a> and <a href="https://learnopengl.com/Advanced-Lighting/Normal-Mapping" target="_blank">normal maps</a>) are almost always in linear space, so if you were to configure these as sRGB textures the lighting will look odd. Be careful in which textures you specify as sRGB.</p>
<p>With our diffuse textures specified as sRGB textures you get the visual output you&rsquo;d expect again, but this time everything is gamma corrected only once.</p>
<h4 id="attenuation-1">Attenuation</h4>
<p>Something else that&rsquo;s different with gamma correction is lighting attenuation. In the real physical world, lighting attenuates closely inversely proportional to the squared distance from a light source. In normal English it simply means that the light strength is reduced over the distance to the light source squared, like below:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">float</span> <span class="n">attenuation</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">distance</span> <span class="o">*</span> <span class="n">distance</span><span class="p">);</span></span></span></code></pre></div><p>However, when using this equation the attenuation effect is usually way too strong, giving lights a small radius that doesn&rsquo;t look physically right. For that reason other attenuation functions were used (like we discussed in the <a href="https://learnopengl.com/Lighting/Basic-Lighting" target="_blank">basic lighting</a> chapter) that give much more control, or the linear equivalent is used:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">float</span> <span class="n">attenuation</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">distance</span><span class="p">;</span>  
</span></span></code></pre></div><p>The linear equivalent gives more plausible results compared to its quadratic variant without gamma correction, but when we enable gamma correction the linear attenuation looks too weak and the physically correct quadratic attenuation suddenly gives the better results. The image below shows the differences:</p>
<p><a href="#R-image-30f1c20d86627380b02f879918451bae" class="lightbox-link"><img src="./assets/gamma_correction_attenuation.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-30f1c20d86627380b02f879918451bae"><img src="./assets/gamma_correction_attenuation.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>The cause of this difference is that light attenuation functions change brightness, and as we weren&rsquo;t visualizing our scene in linear space we chose the attenuation functions that looked best on our monitor, but weren&rsquo;t physically correct. Think of the squared attenuation function: if we were to use this function without gamma correction, the attenuation function effectively becomes: 
<span class="math align-center">$(1.0 / distance^2)^{2.2}$</span> when displayed on a monitor. This creates a much larger attenuation from what we originally anticipated. This also explains why the linear equivalent makes much more sense without gamma correction as this effectively becomes 
<span class="math align-center">$(1.0 / distance)^{2.2} = 1.0 / distance^{2.2}$</span> which resembles its physical equivalent a lot more.</p>
<p><note>The more advanced attenuation function we discussed in the <a href="https://learnopengl.com/Lighting/Basic-Lighting" target="_blank">basic lighting</a> chapter still has its place in gamma corrected scenes as it gives more control over the exact attenuation (but of course requires different parameters in a gamma corrected scene).</note></p>
<p>You can find the source code of this simple demo scene <a href="https://learnopengl.com/code_viewer_gh.php?code=src/5.advanced_lighting/2.gamma_correction/gamma_correction.cpp" target="_blank">here</a>. By pressing the spacebar we switch between a gamma corrected and un-corrected scene with both scenes using their texture and attenuation equivalents. It&rsquo;s not the most impressive demo, but it does show how to actually apply all techniques.</p>
<p>To summarize, gamma correction allows us to do all our shader/lighting calculations in linear space. Because linear space makes sense in the physical world, most physical equations now actually give good results (like real light attenuation). The more advanced your lighting becomes, the easier it is to get good looking (and realistic) results with gamma correction. That is also why it&rsquo;s advised to only really tweak your lighting parameters as soon as you have gamma correction in place.</p>
<h4 id="additional-resources-3">Additional resources</h4>
<ul>
<li><a href="http://blog.johnnovak.net/2016/09/21/what-every-coder-should-know-about-gamma/" target="_blank">What every coder should know about gamma</a>: a well written in-depth article by John Novak about gamma correction.</li>
<li><a href="http://www.cambridgeincolour.com/tutorials/gamma-correction.htm" target="_blank">www.cambridgeincolour.com</a>: more about gamma and gamma correction.</li>
<li><a href="http://blog.wolfire.com/2010/02/Gamma-correct-lighting" target="_blank">blog.wolfire.com</a>: blog post by David Rosen about the benefit of gamma correction in graphics rendering.</li>
<li><a href="http://renderwonk.com/blog/index.php/archive/adventures-with-gamma-correct-rendering/" target="_blank">renderwonk.com</a>: some extra practical considerations.</li>
</ul>
<h3 id="shadows">Shadows</h3>
<h4 id="shadow-mapping">Shadow Mapping</h4>
<p>Shadows are a result of the absence of light due to occlusion. When a light source&rsquo;s light rays do not hit an object because it gets occluded by some other object, the object is in shadow. Shadows add a great deal of realism to a lit scene and make it easier for a viewer to observe spatial relationships between objects. They give a greater sense of depth to our scene and objects. For example, take a look at the following image of a scene with and without shadows:</p>
<p><a href="#R-image-84c2ba5763357a0cfe8eca6d5e8ac002" class="lightbox-link"><img src="./assets/shadow_mapping_with_without.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-84c2ba5763357a0cfe8eca6d5e8ac002"><img src="./assets/shadow_mapping_with_without.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>You can see that with shadows it becomes much more obvious how the objects relate to each other. For instance, the fact that one of the cubes is floating above the others is only really noticeable when we have shadows.</p>
<p>Shadows are a bit tricky to implement though, specifically because in current real-time (rasterized graphics) research a perfect shadow algorithm hasn&rsquo;t been developed yet. There are several good shadow approximation techniques, but they all have their little quirks and annoyances which we have to take into account.</p>
<p>One technique used by most videogames that gives decent results and is relatively easy to implement is shadow mapping. Shadow mapping is not too difficult to understand, doesn&rsquo;t cost too much in performance and quite easily extends into more advanced algorithms (like <a href="https://learnopengl.com/Advanced-Lighting/Shadows/Point-Shadows" target="_blank">Omnidirectional Shadow Maps</a> and <a href="https://learnopengl.com/Guest-Articles/2021/CSM" target="_blank">Cascaded Shadow Maps</a>).</p>
<h4 id="shadow-mapping-1">Shadow mapping</h4>
<p>The idea behind shadow mapping is quite simple: we render the scene from the light&rsquo;s point of view and everything we see from the light&rsquo;s perspective is lit and everything we can&rsquo;t see must be in shadow. Imagine a floor section with a large box between itself and a light source. Since the light source will see this box and not the floor section when looking in its direction that specific floor section should be in shadow.</p>
<p><a href="#R-image-05b74461e2ab7b63c64f1d450ba92c9c" class="lightbox-link"><img src="./assets/shadow_mapping_theory.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-05b74461e2ab7b63c64f1d450ba92c9c"><img src="./assets/shadow_mapping_theory.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Here all the blue lines represent the fragments that the light source can see. The occluded fragments are shown as black lines: these are rendered as being shadowed. If we were to draw a line or ray from the light source to a fragment on the right-most box we can see the ray first hits the floating container before hitting the right-most container. As a result, the floating container&rsquo;s fragment is lit and the right-most container&rsquo;s fragment is not lit and thus in shadow.</p>
<p>We want to get the point on the ray where it first hit an object and compare this <em>closest point</em> to other points on this ray. We then do a basic test to see if a test point&rsquo;s ray position is further down the ray than the closest point and if so, the test point must be in shadow. Iterating through possibly thousands of light rays from such a light source is an extremely inefficient approach and doesn&rsquo;t lend itself too well for real-time rendering. We can do something similar, but without casting light rays. Instead, we use something we&rsquo;re quite familiar with: the depth buffer.</p>
<p>You may remember from the <a href="https://learnopengl.com/Advanced-OpenGL/Depth-testing" target="_blank">depth testing</a> chapter that a value in the depth buffer corresponds to the depth of a fragment clamped to [0,1] from the camera&rsquo;s point of view. What if we were to render the scene from the light&rsquo;s perspective and store the resulting depth values in a texture? This way, we can sample the closest depth values as seen from the light&rsquo;s perspective. After all, the depth values show the first fragment visible from the light&rsquo;s perspective. We store all these depth values in a texture that we call a depth map or shadow map.</p>
<p><a href="#R-image-b9918c90c689d4d24cb1a1308365df00" class="lightbox-link"><img src="./assets/shadow_mapping_theory_spaces.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b9918c90c689d4d24cb1a1308365df00"><img src="./assets/shadow_mapping_theory_spaces.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>The left image shows a directional light source (all light rays are parallel) casting a shadow on the surface below the cube. Using the depth values stored in the depth map we find the closest point and use that to determine whether fragments are in shadow. We create the depth map by rendering the scene (from the light&rsquo;s perspective) using a view and projection matrix specific to that light source. This projection and view matrix together form a transformation 
<span class="math align-center">$T$</span> that transforms any 3D position to the light&rsquo;s (visible) coordinate space.</p>
<p><note>A directional light doesn&rsquo;t have a position as it&rsquo;s modelled to be infinitely far away. However, for the sake of shadow mapping we need to render the scene from a light&rsquo;s perspective and thus render the scene from a position somewhere along the lines of the light direction.</note></p>
<p>In the right image we see the same directional light and the viewer. We render a fragment at point 
<span class="math align-center">$\bar{\color{red}{P}}$</span> for which we have to determine whether it is in shadow. To do this, we first transform point 
<span class="math align-center">$\bar{\color{red}{P}}$</span> to the light&rsquo;s coordinate space using 
<span class="math align-center">$T$</span>. Since point 
<span class="math align-center">$\bar{\color{red}{P}}$</span> is now as seen from the light&rsquo;s perspective, its <code>z</code> coordinate corresponds to its depth which in this example is <code>0.9</code>. Using point 
<span class="math align-center">$\bar{\color{red}{P}}$</span> we can also index the depth/shadow map to obtain the closest visible depth from the light&rsquo;s perspective, which is at point 
<span class="math align-center">$\bar{\color{green}{C}}$</span> with a sampled depth of <code>0.4</code>. Since indexing the depth map returns a depth smaller than the depth at point 
<span class="math align-center">$\bar{\color{red}{P}}$</span> we can conclude point 
<span class="math align-center">$\bar{\color{red}{P}}$</span> is occluded and thus in shadow.</p>
<p>Shadow mapping therefore consists of two passes: first we render the depth map, and in the second pass we render the scene as normal and use the generated depth map to calculate whether fragments are in shadow. It may sound a bit complicated, but as soon as we walk through the technique step-by-step it&rsquo;ll likely start to make sense.</p>
<h4 id="the-depth-map">The depth map</h4>
<p>The first pass requires us to generate a depth map. The depth map is the depth texture as rendered from the light&rsquo;s perspective that we&rsquo;ll be using for testing for shadows. Because we need to store the rendered result of a scene into a texture we&rsquo;re going to need <a href="https://learnopengl.com/Advanced-OpenGL/Framebuffers" target="_blank">framebuffers</a> again.</p>
<p>First we&rsquo;ll create a framebuffer object for rendering the depth map:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">depthMapFBO</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glGenFramebuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">depthMapFBO</span><span class="p">);</span>  
</span></span></code></pre></div><p>Next we create a 2D texture that we&rsquo;ll use as the framebuffer&rsquo;s depth buffer:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">SHADOW_WIDTH</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">,</span> <span class="n">SHADOW_HEIGHT</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">depthMap</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">glGenTextures</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">depthMap</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">depthMap</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">glTexImage2D</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_DEPTH_COMPONENT</span><span class="p">,</span> 
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">             <span class="n">SHADOW_WIDTH</span><span class="p">,</span> <span class="n">SHADOW_HEIGHT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_DEPTH_COMPONENT</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MIN_FILTER</span><span class="p">,</span> <span class="n">GL_NEAREST</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MAG_FILTER</span><span class="p">,</span> <span class="n">GL_NEAREST</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_S</span><span class="p">,</span> <span class="n">GL_REPEAT</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_T</span><span class="p">,</span> <span class="n">GL_REPEAT</span><span class="p">);</span>  
</span></span></code></pre></div><p>Generating the depth map shouldn&rsquo;t look too complicated. Because we only care about depth values we specify the texture&rsquo;s formats as GL_DEPTH_COMPONENT. We also give the texture a width and height of <code>1024</code>: this is the resolution of the depth map.</p>
<p>With the generated depth texture we can attach it as the framebuffer&rsquo;s depth buffer:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">depthMapFBO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glFramebufferTexture2D</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">GL_DEPTH_ATTACHMENT</span><span class="p">,</span> <span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">depthMap</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">glDrawBuffer</span><span class="p">(</span><span class="n">GL_NONE</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="n">glReadBuffer</span><span class="p">(</span><span class="n">GL_NONE</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  
</span></span></code></pre></div><p>We only need the depth information when rendering the scene from the light&rsquo;s perspective so there is no need for a color buffer. A framebuffer object however is not complete without a color buffer so we need to explicitly tell OpenGL we&rsquo;re not going to render any color data. We do this by setting both the read and draw buffer to GL_NONE with glDrawBuffer and glReadbuffer.</p>
<p>With a properly configured framebuffer that renders depth values to a texture we can start the first pass: generate the depth map. When combined with the second pass, the complete rendering stage will look a bit like this:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="c1">// 1. first render to depth map
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1"></span><span class="n">glViewport</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SHADOW_WIDTH</span><span class="p">,</span> <span class="n">SHADOW_HEIGHT</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">depthMapFBO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="n">glClear</span><span class="p">(</span><span class="n">GL_DEPTH_BUFFER_BIT</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="n">ConfigureShaderAndMatrices</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="n">RenderScene</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="c1">// 2. then render scene as normal with shadow mapping (using depth map)
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1"></span><span class="n">glViewport</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SCR_WIDTH</span><span class="p">,</span> <span class="n">SCR_HEIGHT</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="n">glClear</span><span class="p">(</span><span class="n">GL_COLOR_BUFFER_BIT</span> <span class="o">|</span> <span class="n">GL_DEPTH_BUFFER_BIT</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="n">ConfigureShaderAndMatrices</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">depthMap</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="n">RenderScene</span><span class="p">();</span></span></span></code></pre></div><p>This code left out some details, but it&rsquo;ll give you the general idea of shadow mapping. What is important to note here are the calls to glViewport. Because shadow maps often have a different resolution compared to what we originally render the scene in (usually the window resolution), we need to change the viewport parameters to accommodate for the size of the shadow map. If we forget to update the viewport parameters, the resulting depth map will be either incomplete or too small.</p>
<h5 id="light-space-transform">Light space transform</h5>
<p>An unknown in the previous snippet of code is the ConfigureShaderAndMatrices function. In the second pass this is business as usual: make sure proper projection and view matrices are set, and set the relevant model matrices per object. However, in the first pass we need to use a different projection and view matrix to render the scene from the light&rsquo;s point of view.</p>
<p>Because we&rsquo;re modelling a directional light source, all its light rays are parallel. For this reason, we&rsquo;re going to use an orthographic projection matrix for the light source where there is no perspective deform:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">float</span> <span class="n">near_plane</span> <span class="o">=</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="n">far_plane</span> <span class="o">=</span> <span class="mf">7.5f</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span> <span class="n">lightProjection</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">ortho</span><span class="p">(</span><span class="o">-</span><span class="mf">10.0f</span><span class="p">,</span> <span class="mf">10.0f</span><span class="p">,</span> <span class="o">-</span><span class="mf">10.0f</span><span class="p">,</span> <span class="mf">10.0f</span><span class="p">,</span> <span class="n">near_plane</span><span class="p">,</span> <span class="n">far_plane</span><span class="p">);</span>  
</span></span></code></pre></div><p>Here is an example orthographic projection matrix as used in this chapter&rsquo;s demo scene. Because a projection matrix indirectly determines the range of what is visible (e.g. what is not clipped) you want to make sure the size of the projection frustum correctly contains the objects you want to be in the depth map. When objects or fragments are not in the depth map they will not produce shadows.</p>
<p>To create a view matrix to transform each object so they&rsquo;re visible from the light&rsquo;s point of view, we&rsquo;re going to use the infamous glm::lookAt function; this time with the light source&rsquo;s position looking at the scene&rsquo;s center.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span> <span class="n">lightView</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">lookAt</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="o">-</span><span class="mf">2.0f</span><span class="p">,</span> <span class="mf">4.0f</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0f</span><span class="p">),</span> 
</span></span><span class="line"><span class="ln">2</span><span class="cl">                                  <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span>  <span class="mf">0.0f</span><span class="p">),</span> 
</span></span><span class="line"><span class="ln">3</span><span class="cl">                                  <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span>  <span class="mf">0.0f</span><span class="p">));</span> 
</span></span></code></pre></div><p>Combining these two gives us a light space transformation matrix that transforms each world-space vector into the space as visible from the light source; exactly what we need to render the depth map.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span> <span class="n">lightSpaceMatrix</span> <span class="o">=</span> <span class="n">lightProjection</span> <span class="o">*</span> <span class="n">lightView</span><span class="p">;</span> 
</span></span></code></pre></div><p>This lightSpaceMatrix is the transformation matrix that we earlier denoted as 
<span class="math align-center">$T$</span>. With this lightSpaceMatrix, we can render the scene as usual as long as we give each shader the light-space equivalents of the projection and view matrices. However, we only care about depth values and not all the expensive fragment (lighting) calculations. To save performance we&rsquo;re going to use a different, but much simpler shader for rendering to the depth map.</p>
<h5 id="render-to-depth-map">Render to depth map</h5>
<p>When we render the scene from the light&rsquo;s perspective we&rsquo;d much rather use a simple shader that only transforms the vertices to light space and not much more. For such a simple shader called simpleDepthShader we&rsquo;ll use the following vertex shader:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">aPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">uniform</span> <span class="n">mat4</span> <span class="n">lightSpaceMatrix</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">uniform</span> <span class="n">mat4</span> <span class="n">model</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">lightSpaceMatrix</span> <span class="o">*</span> <span class="n">model</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">aPos</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>This vertex shader takes a per-object model, a vertex, and transforms all vertices to light space using lightSpaceMatrix.</p>
<p>Since we have no color buffer and disabled the draw and read buffers, the resulting fragments do not require any processing so we can simply use an empty fragment shader:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="p">{</span>             
</span></span><span class="line"><span class="ln">5</span><span class="cl">    <span class="c1">// gl_FragDepth = gl_FragCoord.z;
</span></span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="c1"></span><span class="p">}</span>  
</span></span></code></pre></div><p>This empty fragment shader does no processing whatsoever, and at the end of its run the depth buffer is updated. We could explicitly set the depth by uncommenting its one line, but this is effectively what happens behind the scene anyways.</p>
<p>Rendering the depth/shadow map now effectively becomes:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">simpleDepthShader</span><span class="p">.</span><span class="n">use</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glUniformMatrix4fv</span><span class="p">(</span><span class="n">lightSpaceMatrixLocation</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">value_ptr</span><span class="p">(</span><span class="n">lightSpaceMatrix</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="n">glViewport</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SHADOW_WIDTH</span><span class="p">,</span> <span class="n">SHADOW_HEIGHT</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">depthMapFBO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">    <span class="n">glClear</span><span class="p">(</span><span class="n">GL_DEPTH_BUFFER_BIT</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl">    <span class="n">RenderScene</span><span class="p">(</span><span class="n">simpleDepthShader</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">8</span><span class="cl"><span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  
</span></span></code></pre></div><p>Here the RenderScene function takes a shader program, calls all relevant drawing functions and sets the corresponding model matrices where necessary.</p>
<p>The result is a nicely filled depth buffer holding the closest depth of each visible fragment from the light&rsquo;s perspective. By rendering this texture onto a 2D quad that fills the screen (similar to what we did in the post-processing section at the end of the <a href="https://learnopengl.com/Advanced-OpenGL/Framebuffers" target="_blank">framebuffers</a> chapter) we get something like this:</p>
<p><a href="#R-image-6c5b1b07123f736562b15974ef75a3f4" class="lightbox-link"><img src="./assets/shadow_mapping_depth_map.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-6c5b1b07123f736562b15974ef75a3f4"><img src="./assets/shadow_mapping_depth_map.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>For rendering the depth map onto a quad we used the following fragment shader:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">out</span> <span class="n">vec4</span> <span class="n">FragColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">in</span> <span class="n">vec2</span> <span class="n">TexCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">depthMap</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="p">{</span>             
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="kt">float</span> <span class="n">depthValue</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">depthMap</span><span class="p">,</span> <span class="n">TexCoords</span><span class="p">).</span><span class="n">r</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="n">FragColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">vec3</span><span class="p">(</span><span class="n">depthValue</span><span class="p">),</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>Note that there are some subtle changes when displaying depth using a perspective projection matrix instead of an orthographic projection matrix as depth is non-linear when using perspective projection. At the end of this chapter we&rsquo;ll discuss some of these subtle differences.</p>
<p>You can find the source code for rendering a scene to a depth map <a href="https://learnopengl.com/code_viewer_gh.php?code=src/5.advanced_lighting/3.1.1.shadow_mapping_depth/shadow_mapping_depth.cpp" target="_blank">here</a>.</p>
<h4 id="rendering-shadows">Rendering shadows</h4>
<p>With a properly generated depth map we can start rendering the actual shadows. The code to check if a fragment is in shadow is (quite obviously) executed in the fragment shader, but we do the light-space transformation in the vertex shader:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">aPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">aNormal</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec2</span> <span class="n">aTexCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">out</span> <span class="n">VS_OUT</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="n">vec3</span> <span class="n">FragPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="n">vec3</span> <span class="n">Normal</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="n">vec2</span> <span class="n">TexCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="n">vec4</span> <span class="n">FragPosLightSpace</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="p">}</span> <span class="n">vs_out</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="n">uniform</span> <span class="n">mat4</span> <span class="n">projection</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="n">uniform</span> <span class="n">mat4</span> <span class="n">view</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="n">uniform</span> <span class="n">mat4</span> <span class="n">model</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="n">uniform</span> <span class="n">mat4</span> <span class="n">lightSpaceMatrix</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">
</span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="p">{</span>    
</span></span><span class="line"><span class="ln">20</span><span class="cl">    <span class="n">vs_out</span><span class="p">.</span><span class="n">FragPos</span> <span class="o">=</span> <span class="n">vec3</span><span class="p">(</span><span class="n">model</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">aPos</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">    <span class="n">vs_out</span><span class="p">.</span><span class="n">Normal</span> <span class="o">=</span> <span class="n">transpose</span><span class="p">(</span><span class="n">inverse</span><span class="p">(</span><span class="n">mat3</span><span class="p">(</span><span class="n">model</span><span class="p">)))</span> <span class="o">*</span> <span class="n">aNormal</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">    <span class="n">vs_out</span><span class="p">.</span><span class="n">TexCoords</span> <span class="o">=</span> <span class="n">aTexCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">    <span class="n">vs_out</span><span class="p">.</span><span class="n">FragPosLightSpace</span> <span class="o">=</span> <span class="n">lightSpaceMatrix</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">vs_out</span><span class="p">.</span><span class="n">FragPos</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">projection</span> <span class="o">*</span> <span class="n">view</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">vs_out</span><span class="p">.</span><span class="n">FragPos</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>What is new here is the extra output vector FragPosLightSpace. We take the same lightSpaceMatrix (used to transform vertices to light space in the depth map stage) and transform the world-space vertex position to light space for use in the fragment shader.</p>
<p>The main fragment shader we&rsquo;ll use to render the scene uses the Blinn-Phong lighting model. Within the fragment shader we then calculate a shadow value that is either <code>1.0</code> when the fragment is in shadow or <code>0.0</code> when not in shadow. The resulting diffuse and specular components are then multiplied by this shadow component. Because shadows are rarely completely dark (due to light scattering) we leave the ambient component out of the shadow multiplications.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">out</span> <span class="n">vec4</span> <span class="n">FragColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">in</span> <span class="n">VS_OUT</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="n">vec3</span> <span class="n">FragPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="n">vec3</span> <span class="n">Normal</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="n">vec2</span> <span class="n">TexCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="n">vec4</span> <span class="n">FragPosLightSpace</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="p">}</span> <span class="n">fs_in</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">diffuseTexture</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">shadowMap</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="n">uniform</span> <span class="n">vec3</span> <span class="n">lightPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="n">uniform</span> <span class="n">vec3</span> <span class="n">viewPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">
</span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="kt">float</span> <span class="nf">ShadowCalculation</span><span class="p">(</span><span class="n">vec4</span> <span class="n">fragPosLightSpace</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">    <span class="p">[...]</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">
</span></span><span class="line"><span class="ln">22</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl"><span class="p">{</span>           
</span></span><span class="line"><span class="ln">24</span><span class="cl">    <span class="n">vec3</span> <span class="n">color</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">diffuseTexture</span><span class="p">,</span> <span class="n">fs_in</span><span class="p">.</span><span class="n">TexCoords</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl">    <span class="n">vec3</span> <span class="n">normal</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">fs_in</span><span class="p">.</span><span class="n">Normal</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl">    <span class="n">vec3</span> <span class="n">lightColor</span> <span class="o">=</span> <span class="n">vec3</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl">    <span class="c1">// ambient
</span></span></span><span class="line"><span class="ln">28</span><span class="cl"><span class="c1"></span>    <span class="n">vec3</span> <span class="n">ambient</span> <span class="o">=</span> <span class="mf">0.15</span> <span class="o">*</span> <span class="n">lightColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">29</span><span class="cl">    <span class="c1">// diffuse
</span></span></span><span class="line"><span class="ln">30</span><span class="cl"><span class="c1"></span>    <span class="n">vec3</span> <span class="n">lightDir</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">lightPos</span> <span class="o">-</span> <span class="n">fs_in</span><span class="p">.</span><span class="n">FragPos</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">31</span><span class="cl">    <span class="kt">float</span> <span class="n">diff</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">lightDir</span><span class="p">,</span> <span class="n">normal</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">32</span><span class="cl">    <span class="n">vec3</span> <span class="n">diffuse</span> <span class="o">=</span> <span class="n">diff</span> <span class="o">*</span> <span class="n">lightColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">33</span><span class="cl">    <span class="c1">// specular
</span></span></span><span class="line"><span class="ln">34</span><span class="cl"><span class="c1"></span>    <span class="n">vec3</span> <span class="n">viewDir</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">viewPos</span> <span class="o">-</span> <span class="n">fs_in</span><span class="p">.</span><span class="n">FragPos</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">35</span><span class="cl">    <span class="kt">float</span> <span class="n">spec</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">36</span><span class="cl">    <span class="n">vec3</span> <span class="n">halfwayDir</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">lightDir</span> <span class="o">+</span> <span class="n">viewDir</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">37</span><span class="cl">    <span class="n">spec</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="n">halfwayDir</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">),</span> <span class="mf">64.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">38</span><span class="cl">    <span class="n">vec3</span> <span class="n">specular</span> <span class="o">=</span> <span class="n">spec</span> <span class="o">*</span> <span class="n">lightColor</span><span class="p">;</span>    
</span></span><span class="line"><span class="ln">39</span><span class="cl">    <span class="c1">// calculate shadow
</span></span></span><span class="line"><span class="ln">40</span><span class="cl"><span class="c1"></span>    <span class="kt">float</span> <span class="n">shadow</span> <span class="o">=</span> <span class="n">ShadowCalculation</span><span class="p">(</span><span class="n">fs_in</span><span class="p">.</span><span class="n">FragPosLightSpace</span><span class="p">);</span>       
</span></span><span class="line"><span class="ln">41</span><span class="cl">    <span class="n">vec3</span> <span class="n">lighting</span> <span class="o">=</span> <span class="p">(</span><span class="n">ambient</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">shadow</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">diffuse</span> <span class="o">+</span> <span class="n">specular</span><span class="p">))</span> <span class="o">*</span> <span class="n">color</span><span class="p">;</span>    
</span></span><span class="line"><span class="ln">42</span><span class="cl">    
</span></span><span class="line"><span class="ln">43</span><span class="cl">    <span class="n">FragColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">lighting</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">44</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>The fragment shader is largely a copy from what we used in the <a href="https://learnopengl.com/Advanced-Lighting/Advanced-Lighting" target="_blank">advanced lighting</a> chapter, but with an added shadow calculation. We declared a function ShadowCalculation that does most of the shadow work. At the end of the fragment shader, we multiply the diffuse and specular contributions by the inverse of the shadow component e.g. how much the fragment is <em>not</em> in shadow. This fragment shader takes as extra input the light-space fragment position and the depth map generated from the first render pass.</p>
<p>The first thing to do to check whether a fragment is in shadow, is transform the light-space fragment position in clip-space to normalized device coordinates. When we output a clip-space vertex position to gl_Position in the vertex shader, OpenGL automatically does a perspective divide e.g. transform clip-space coordinates in the range [<code>-w</code>,<code>w</code>] to [<code>-1</code>,<code>1</code>] by dividing the <code>x</code>, <code>y</code> and <code>z</code> component by the vector&rsquo;s <code>w</code> component. As the clip-space FragPosLightSpace is not passed to the fragment shader through gl_Position, we have to do this perspective divide ourselves:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">float</span> <span class="nf">ShadowCalculation</span><span class="p">(</span><span class="n">vec4</span> <span class="n">fragPosLightSpace</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="c1">// perform perspective divide
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="c1"></span>    <span class="n">vec3</span> <span class="n">projCoords</span> <span class="o">=</span> <span class="n">fragPosLightSpace</span><span class="p">.</span><span class="n">xyz</span> <span class="o">/</span> <span class="n">fragPosLightSpace</span><span class="p">.</span><span class="n">w</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">    <span class="p">[...]</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>This returns the fragment&rsquo;s light-space position in the range [<code>-1</code>,<code>1</code>].</p>
<p><note>When using an orthographic projection matrix the <code>w</code> component of a vertex remains untouched so this step is actually quite meaningless. However, it is necessary when using perspective projection so keeping this line ensures it works with both projection matrices.</note></p>
<p>Because the depth from the depth map is in the range [<code>0</code>,<code>1</code>] and we also want to use projCoords to sample from the depth map, we transform the NDC coordinates to the range [<code>0</code>,<code>1</code>]:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">projCoords</span> <span class="o">=</span> <span class="n">projCoords</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">;</span> 
</span></span></code></pre></div><p>With these projected coordinates we can sample the depth map as the resulting [<code>0</code>,<code>1</code>] coordinates from projCoords directly correspond to the transformed NDC coordinates from the first render pass. This gives us the closest depth from the light&rsquo;s point of view:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">float</span> <span class="n">closestDepth</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">shadowMap</span><span class="p">,</span> <span class="n">projCoords</span><span class="p">.</span><span class="n">xy</span><span class="p">).</span><span class="n">r</span><span class="p">;</span>   
</span></span></code></pre></div><p>To get the current depth at this fragment we simply retrieve the projected vector&rsquo;s <code>z</code> coordinate which equals the depth of this fragment from the light&rsquo;s perspective.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">float</span> <span class="n">currentDepth</span> <span class="o">=</span> <span class="n">projCoords</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>  
</span></span></code></pre></div><p>The actual comparison is then simply a check whether currentDepth is higher than closestDepth and if so, the fragment is in shadow:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">float</span> <span class="n">shadow</span> <span class="o">=</span> <span class="n">currentDepth</span> <span class="o">&gt;</span> <span class="n">closestDepth</span>  <span class="o">?</span> <span class="mf">1.0</span> <span class="o">:</span> <span class="mf">0.0</span><span class="p">;</span>  
</span></span></code></pre></div><p>The complete ShadowCalculation function then becomes:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">float</span> <span class="nf">ShadowCalculation</span><span class="p">(</span><span class="n">vec4</span> <span class="n">fragPosLightSpace</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="c1">// perform perspective divide
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1"></span>    <span class="n">vec3</span> <span class="n">projCoords</span> <span class="o">=</span> <span class="n">fragPosLightSpace</span><span class="p">.</span><span class="n">xyz</span> <span class="o">/</span> <span class="n">fragPosLightSpace</span><span class="p">.</span><span class="n">w</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="c1">// transform to [0,1] range
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="c1"></span>    <span class="n">projCoords</span> <span class="o">=</span> <span class="n">projCoords</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="c1">// get closest depth value from light&#39;s perspective (using [0,1] range fragPosLight as coords)
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="c1"></span>    <span class="kt">float</span> <span class="n">closestDepth</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">shadowMap</span><span class="p">,</span> <span class="n">projCoords</span><span class="p">.</span><span class="n">xy</span><span class="p">).</span><span class="n">r</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="c1">// get depth of current fragment from light&#39;s perspective
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1"></span>    <span class="kt">float</span> <span class="n">currentDepth</span> <span class="o">=</span> <span class="n">projCoords</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="c1">// check whether current frag pos is in shadow
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="c1"></span>    <span class="kt">float</span> <span class="n">shadow</span> <span class="o">=</span> <span class="n">currentDepth</span> <span class="o">&gt;</span> <span class="n">closestDepth</span>  <span class="o">?</span> <span class="mf">1.0</span> <span class="o">:</span> <span class="mf">0.0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="k">return</span> <span class="n">shadow</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>Activating this shader, binding the proper textures, and activating the default projection and view matrices in the second render pass should give you a result similar to the image below:</p>
<p><a href="#R-image-28e71a80804ef22910ec7c6813a0fb1d" class="lightbox-link"><img src="./assets/shadow_mapping_shadows.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-28e71a80804ef22910ec7c6813a0fb1d"><img src="./assets/shadow_mapping_shadows.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>If you did things right you should indeed see (albeit with quite a few artifacts) shadows on the floor and the cubes. You can find the source code of the demo application <a href="https://learnopengl.com/code_viewer_gh.php?code=src/5.advanced_lighting/3.1.2.shadow_mapping_base/shadow_mapping_base.cpp" target="_blank">here</a>.</p>
<h4 id="improving-shadow-maps">Improving shadow maps</h4>
<p>We managed to get the basics of shadow mapping working, but as you can we&rsquo;re not there yet due to several (clearly visible) artifacts related to shadow mapping we need to fix. We&rsquo;ll focus on fixing these artifacts in the next sections.</p>
<h5 id="shadow-acne">Shadow acne</h5>
<p>It is obvious something is wrong from the previous image. A closer zoom shows us a very obvious Moiré-like pattern:</p>
<p><a href="#R-image-951cacfb966591f323853575c3526d73" class="lightbox-link"><img src="./assets/shadow_mapping_acne.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-951cacfb966591f323853575c3526d73"><img src="./assets/shadow_mapping_acne.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>We can see a large part of the floor quad rendered with obvious black lines in an alternating fashion. This shadow mapping artifact is called shadow acne and can be explained by the following image:</p>
<p><a href="#R-image-b3ab22d238714def0e2373bf9ef2cbd6" class="lightbox-link"><img src="./assets/shadow_mapping_acne_diagram.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b3ab22d238714def0e2373bf9ef2cbd6"><img src="./assets/shadow_mapping_acne_diagram.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Because the shadow map is limited by resolution, multiple fragments can sample the same value from the depth map when they&rsquo;re relatively far away from the light source. The image shows the floor where each yellow tilted panel represents a single texel of the depth map. As you can see, several fragments sample the same depth sample.</p>
<p>While this is generally okay, it becomes an issue when the light source looks at an angle towards the surface as in that case the depth map is also rendered from an angle. Several fragments then access the same tilted depth texel while some are above and some below the floor; we get a shadow discrepancy. Because of this, some fragments are considered to be in shadow and some are not, giving the striped pattern from the image.</p>
<p>We can solve this issue with a small little hack called a shadow bias where we simply offset the depth of the surface (or the shadow map) by a small bias amount such that the fragments are not incorrectly considered above the surface.</p>
<p><a href="#R-image-99b410f15b1986c0d5135b82add0081f" class="lightbox-link"><img src="./assets/shadow_mapping_acne_bias.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-99b410f15b1986c0d5135b82add0081f"><img src="./assets/shadow_mapping_acne_bias.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>With the bias applied, all the samples get a depth smaller than the surface&rsquo;s depth and thus the entire surface is correctly lit without any shadows. We can implement such a bias as follows:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">float</span> <span class="n">bias</span> <span class="o">=</span> <span class="mf">0.005</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="kt">float</span> <span class="n">shadow</span> <span class="o">=</span> <span class="n">currentDepth</span> <span class="o">-</span> <span class="n">bias</span> <span class="o">&gt;</span> <span class="n">closestDepth</span>  <span class="o">?</span> <span class="mf">1.0</span> <span class="o">:</span> <span class="mf">0.0</span><span class="p">;</span>  
</span></span></code></pre></div><p>A shadow bias of <code>0.005</code> solves the issues of our scene by a large extent, but you can imagine the bias value is highly dependent on the angle between the light source and the surface. If the surface would have a steep angle to the light source, the shadows may still display shadow acne. A more solid approach would be to change the amount of bias based on the surface angle towards the light: something we can solve with the dot product:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">float</span> <span class="n">bias</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="mf">0.05</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">dot</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="n">lightDir</span><span class="p">)),</span> <span class="mf">0.005</span><span class="p">);</span>  
</span></span></code></pre></div><p>Here we have a maximum bias of <code>0.05</code> and a minimum of <code>0.005</code> based on the surface&rsquo;s normal and light direction. This way, surfaces like the floor that are almost perpendicular to the light source get a small bias, while surfaces like the cube&rsquo;s side-faces get a much larger bias. The following image shows the same scene but now with a shadow bias:</p>
<p><a href="#R-image-aea0b610f127c3ecf75cd96ed2d5e0ab" class="lightbox-link"><img src="./assets/shadow_mapping_with_bias.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-aea0b610f127c3ecf75cd96ed2d5e0ab"><img src="./assets/shadow_mapping_with_bias.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Choosing the correct bias value(s) requires some tweaking as this will be different for each scene, but most of the time it&rsquo;s simply a matter of slowly incrementing the bias until all acne is removed.</p>
<h5 id="peter-panning">Peter panning</h5>
<p>A disadvantage of using a shadow bias is that you&rsquo;re applying an offset to the actual depth of objects. As a result, the bias may become large enough to see a visible offset of shadows compared to the actual object locations as you can see below (with an exaggerated bias value):</p>
<p><a href="#R-image-89a263959deb31959f07c4601e67d233" class="lightbox-link"><img src="./assets/shadow_mapping_peter_panning.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-89a263959deb31959f07c4601e67d233"><img src="./assets/shadow_mapping_peter_panning.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>This shadow artifact is called peter panning since objects seem slightly <em>detached</em> from their shadows. We can use a little trick to solve most of the peter panning issue by using front face culling when rendering the depth map. You may remember from the <a href="https://learnopengl.com/Advanced-OpenGL/Face-Culling" target="_blank">face culling</a> chapter that OpenGL by default culls back-faces. By telling OpenGL we want to cull front faces during the shadow map stage we&rsquo;re switching that order around.</p>
<p>Because we only need depth values for the depth map it shouldn&rsquo;t matter for solid objects whether we take the depth of their front faces or their back faces. Using their back face depths doesn&rsquo;t give wrong results as it doesn&rsquo;t matter if we have shadows inside objects; we can&rsquo;t see there anyways.</p>
<p><a href="#R-image-d66f2a1c1e454be6920be210174ad1e8" class="lightbox-link"><img src="./assets/shadow_mapping_culling.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d66f2a1c1e454be6920be210174ad1e8"><img src="./assets/shadow_mapping_culling.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>To fix peter panning we cull all front faces during the shadow map generation. Note that you need to enable GL_CULL_FACE first.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glCullFace</span><span class="p">(</span><span class="n">GL_FRONT</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">RenderSceneToDepthMap</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">glCullFace</span><span class="p">(</span><span class="n">GL_BACK</span><span class="p">);</span> <span class="c1">// don&#39;t forget to reset original culling face
</span></span></span></code></pre></div><p>This effectively solves the peter panning issues, but <strong>only for solid</strong> objects that actually have an inside without openings. In our scene for example, this works perfectly fine on the cubes. However, on the floor it won&rsquo;t work as well as culling the front face completely removes the floor from the equation. The floor is a single plane and would thus be completely culled. If one wants to solve peter panning with this trick, care has to be taken to only cull the front faces of objects where it makes sense.</p>
<p>Another consideration is that objects that are close to the shadow receiver (like the distant cube) may still give incorrect results. However, with normal bias values you can generally avoid peter panning.</p>
<h5 id="over-sampling">Over sampling</h5>
<p>Another visual discrepancy which you may like or dislike is that regions outside the light&rsquo;s visible frustum are considered to be in shadow while they&rsquo;re (usually) not. This happens because projected coordinates outside the light&rsquo;s frustum are higher than <code>1.0</code> and will thus sample the depth texture outside its default range of [<code>0</code>,<code>1</code>]. Based on the texture&rsquo;s wrapping method, we will get incorrect depth results not based on the real depth values from the light source.</p>
<p><a href="#R-image-5c528de318e182158abe1063b040b3c8" class="lightbox-link"><img src="./assets/shadow_mapping_outside_frustum.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-5c528de318e182158abe1063b040b3c8"><img src="./assets/shadow_mapping_outside_frustum.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>You can see in the image that there is some sort of imaginary region of light, and a large part outside this area is in shadow; this area represents the size of the depth map projected onto the floor. The reason this happens is that we earlier set the depth map&rsquo;s wrapping options to GL_REPEAT.</p>
<p>What we&rsquo;d rather have is that all coordinates outside the depth map&rsquo;s range have a depth of <code>1.0</code> which as a result means these coordinates will never be in shadow (as no object will have a depth larger than <code>1.0</code>). We can do this by configuring a texture border color and set the depth map&rsquo;s texture wrap options to GL_CLAMP_TO_BORDER:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_S</span><span class="p">,</span> <span class="n">GL_CLAMP_TO_BORDER</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_T</span><span class="p">,</span> <span class="n">GL_CLAMP_TO_BORDER</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="kt">float</span> <span class="n">borderColor</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">1.0f</span> <span class="p">};</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="n">glTexParameterfv</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_BORDER_COLOR</span><span class="p">,</span> <span class="n">borderColor</span><span class="p">);</span>  
</span></span></code></pre></div><p>Now whenever we sample outside the depth map&rsquo;s [<code>0</code>,<code>1</code>] coordinate range, the texture function will always return a depth of <code>1.0</code>, producing a shadow value of <code>0.0</code>. The result now looks more plausible:</p>
<p><a href="#R-image-9bec9128fab44df4e58b88c3a57014d2" class="lightbox-link"><img src="./assets/shadow_mapping_clamp_edge.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-9bec9128fab44df4e58b88c3a57014d2"><img src="./assets/shadow_mapping_clamp_edge.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>There seems to still be one part showing a dark region. Those are the coordinates outside the far plane of the light&rsquo;s orthographic frustum. You can see that this dark region always occurs at the far end of the light source&rsquo;s frustum by looking at the shadow directions.</p>
<p>A light-space projected fragment coordinate is further than the light&rsquo;s far plane when its <code>z</code> coordinate is larger than <code>1.0</code>. In that case the GL_CLAMP_TO_BORDER wrapping method doesn&rsquo;t work anymore as we compare the coordinate&rsquo;s <code>z</code> component with the depth map values; this always returns true for <code>z</code> larger than <code>1.0</code>.</p>
<p>The fix for this is also relatively easy as we simply force the shadow value to <code>0.0</code> whenever the projected vector&rsquo;s <code>z</code> coordinate is larger than <code>1.0</code>:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">float</span> <span class="nf">ShadowCalculation</span><span class="p">(</span><span class="n">vec4</span> <span class="n">fragPosLightSpace</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="p">[...]</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">projCoords</span><span class="p">.</span><span class="n">z</span> <span class="o">&gt;</span> <span class="mf">1.0</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">        <span class="n">shadow</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">    
</span></span><span class="line"><span class="ln">7</span><span class="cl">    <span class="k">return</span> <span class="n">shadow</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">8</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>Checking the far plane and clamping the depth map to a manually specified border color solves the over-sampling of the depth map. This finally gives us the result we are looking for:</p>
<p><a href="#R-image-7b144f8222b5b09a7a312a1a3dbe5bc8" class="lightbox-link"><img src="./assets/shadow_mapping_over_sampling_fixed.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7b144f8222b5b09a7a312a1a3dbe5bc8"><img src="./assets/shadow_mapping_over_sampling_fixed.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>The result of all this does mean that we only have shadows where the projected fragment coordinates sit inside the depth map range so anything outside the light frustum will have no visible shadows. As games usually make sure this only occurs in the distance it is a much more plausible effect than the obvious black regions we had before.</p>
<h4 id="pcf">PCF</h4>
<p>The shadows right now are a nice addition to the scenery, but it&rsquo;s still not exactly what we want. If you were to zoom in on the shadows the resolution dependency of shadow mapping quickly becomes apparent.</p>
<p><a href="#R-image-76360f49820ec8a37c813fad7f1abf69" class="lightbox-link"><img src="./assets/shadow_mapping_zoom.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-76360f49820ec8a37c813fad7f1abf69"><img src="./assets/shadow_mapping_zoom.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Because the depth map has a fixed resolution, the depth frequently usually spans more than one fragment per texel. As a result, multiple fragments sample the same depth value from the depth map and come to the same shadow conclusions, which produces these jagged blocky edges.</p>
<p>You can reduce these blocky shadows by increasing the depth map resolution, or by trying to fit the light frustum as closely to the scene as possible.</p>
<p>Another (partial) solution to these jagged edges is called PCF, or percentage-closer filtering, which is a term that hosts many different filtering functions that produce <em>softer</em> shadows, making them appear less blocky or hard. The idea is to sample more than once from the depth map, each time with slightly different texture coordinates. For each individual sample we check whether it is in shadow or not. All the sub-results are then combined and averaged and we get a nice soft looking shadow.</p>
<p>One simple implementation of PCF is to simply sample the surrounding texels of the depth map and average the results:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">float</span> <span class="n">shadow</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="n">vec2</span> <span class="n">texelSize</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">textureSize</span><span class="p">(</span><span class="n">shadowMap</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">x</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">y</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">        <span class="kt">float</span> <span class="n">pcfDepth</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">shadowMap</span><span class="p">,</span> <span class="n">projCoords</span><span class="p">.</span><span class="n">xy</span> <span class="o">+</span> <span class="n">vec2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="n">texelSize</span><span class="p">).</span><span class="n">r</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        <span class="n">shadow</span> <span class="o">+=</span> <span class="n">currentDepth</span> <span class="o">-</span> <span class="n">bias</span> <span class="o">&gt;</span> <span class="n">pcfDepth</span> <span class="o">?</span> <span class="mf">1.0</span> <span class="o">:</span> <span class="mf">0.0</span><span class="p">;</span>        
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="p">}</span>    
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="n">shadow</span> <span class="o">/=</span> <span class="mf">9.0</span><span class="p">;</span></span></span></code></pre></div><p>Here textureSize returns a <code>vec2</code> of the width and height of the given sampler texture at mipmap level <code>0</code>. 1 divided over this returns the size of a single texel that we use to offset the texture coordinates, making sure each new sample samples a different depth value. Here we sample 9 values around the projected coordinate&rsquo;s <code>x</code> and <code>y</code> value, test for shadow occlusion, and finally average the results by the total number of samples taken.</p>
<p>By using more samples and/or varying the texelSize variable you can increase the quality of the soft shadows. Below you can see the shadows with simple PCF applied:</p>
<p><a href="#R-image-146342b887dfa331c092a57c2e29aeda" class="lightbox-link"><img src="./assets/shadow_mapping_soft_shadows.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-146342b887dfa331c092a57c2e29aeda"><img src="./assets/shadow_mapping_soft_shadows.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>From a distance the shadows look a lot better and less hard. If you zoom in you can still see the resolution artifacts of shadow mapping, but in general this gives good results for most applications.</p>
<p>You can find the complete source code of the example <a href="https://learnopengl.com/code_viewer_gh.php?code=src/5.advanced_lighting/3.1.3.shadow_mapping/shadow_mapping.cpp" target="_blank">here</a>.</p>
<p>There is actually much more to PCF and quite a few techniques to considerably improve the quality of soft shadows, but for the sake of this chapter&rsquo;s length we&rsquo;ll leave that for a later discussion.</p>
<h4 id="orthographic-vs-perspective">Orthographic vs perspective</h4>
<p>There is a difference between rendering the depth map with an orthographic or a perspective projection matrix. An orthographic projection matrix does not deform the scene with perspective so all view/light rays are parallel. This makes it a great projection matrix for directional lights. A perspective projection matrix however does deform all vertices based on perspective which gives different results. The following image shows the different shadow regions of both projection methods:</p>
<p><a href="#R-image-5c45a70bf8eac41aa39bc2666944e018" class="lightbox-link"><img src="./assets/shadow_mapping_projection.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-5c45a70bf8eac41aa39bc2666944e018"><img src="./assets/shadow_mapping_projection.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Perspective projections make most sense for light sources that have actual locations, unlike directional lights. Perspective projections are most often used with spotlights and point lights, while orthographic projections are used for directional lights.</p>
<p>Another subtle difference with using a perspective projection matrix is that visualizing the depth buffer will often give an almost completely white result. This happens because with perspective projection the depth is transformed to non-linear depth values with most of its noticeable range close to the near plane. To be able to properly view the depth values as we did with the orthographic projection you first want to transform the non-linear depth values to linear as we discussed in the <a href="https://learnopengl.com/Advanced-OpenGL/Depth-testing" target="_blank">depth testing</a> chapter:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">out</span> <span class="n">vec4</span> <span class="n">FragColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">in</span> <span class="n">vec2</span> <span class="n">TexCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">depthMap</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="n">uniform</span> <span class="kt">float</span> <span class="n">near_plane</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="n">uniform</span> <span class="kt">float</span> <span class="n">far_plane</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="kt">float</span> <span class="nf">LinearizeDepth</span><span class="p">(</span><span class="kt">float</span> <span class="n">depth</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="kt">float</span> <span class="n">z</span> <span class="o">=</span> <span class="n">depth</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">;</span> <span class="c1">// Back to NDC 
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">near_plane</span> <span class="o">*</span> <span class="n">far_plane</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">far_plane</span> <span class="o">+</span> <span class="n">near_plane</span> <span class="o">-</span> <span class="n">z</span> <span class="o">*</span> <span class="p">(</span><span class="n">far_plane</span> <span class="o">-</span> <span class="n">near_plane</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">
</span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="p">{</span>             
</span></span><span class="line"><span class="ln">18</span><span class="cl">    <span class="kt">float</span> <span class="n">depthValue</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">depthMap</span><span class="p">,</span> <span class="n">TexCoords</span><span class="p">).</span><span class="n">r</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">    <span class="n">FragColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">vec3</span><span class="p">(</span><span class="n">LinearizeDepth</span><span class="p">(</span><span class="n">depthValue</span><span class="p">)</span> <span class="o">/</span> <span class="n">far_plane</span><span class="p">),</span> <span class="mf">1.0</span><span class="p">);</span> <span class="c1">// perspective
</span></span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="c1"></span>    <span class="c1">// FragColor = vec4(vec3(depthValue), 1.0); // orthographic
</span></span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="c1"></span><span class="p">}</span>  
</span></span></code></pre></div><p>This shows depth values similar to what we&rsquo;ve seen with orthographic projection. Note that this is only useful for debugging; the depth checks remain the same with orthographic or projection matrices as the relative depths do not change.</p>
<h4 id="additional-resources-4">Additional resources</h4>
<ul>
<li><a href="http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/" target="_blank">Tutorial 16 : Shadow mapping</a>: similar shadow mapping tutorial by opengl-tutorial.org with a few extra notes.</li>
<li><a href="http://ogldev.atspace.co.uk/www/tutorial23/tutorial23.html" target="_blank">Shadow Mapping - Part 1</a>: another shadow mapping tutorial by ogldev.</li>
<li><a href="https://www.youtube.com/watch?v=EsccgeUpdsM" target="_blank">How Shadow Mapping Works</a>: a 3-part YouTube tutorial by TheBennyBox on shadow mapping and its implementation.</li>
<li><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ee416324%28v=vs.85%29.aspx" target="_blank">Common Techniques to Improve Shadow Depth Maps</a>: a great article by Microsoft listing a large number of techniques to improve the quality of shadow maps.</li>
<li><a href="https://www.youtube.com/watch?v=uueB2kVvbHo" target="_blank">How I Implemented Shadows in my Game Engine</a>: great video by ThinMatrix on his methods of improving shadow maps.</li>
</ul>
<h4 id="point-shadows">Point Shadows</h4>
<p>In the last chapter we learned to create dynamic shadows with shadow mapping. It works great, but it&rsquo;s mostly suited for directional (or spot) lights as the shadows are generated only in the direction of the light source. It is therefore also known as directional shadow mapping as the depth (or shadow) map is generated from only the direction the light is looking at.</p>
<p>What this chapter will focus on is the generation of dynamic shadows in all surrounding directions. The technique we&rsquo;re using is perfect for point lights as a real point light would cast shadows in all directions. This technique is known as point (light) shadows or more formerly as omnidirectional shadow maps.</p>
<p><note>This chapter builds upon the previous <a href="https://learnopengl.com/Advanced-Lighting/Shadows/Shadow-Mapping" target="_blank">shadow mapping</a> chapter so unless you&rsquo;re familiar with traditional shadow mapping it is advised to read the shadow mapping chapter first.</note></p>
<p>The technique is mostly similar to directional shadow mapping: we generate a depth map from the light&rsquo;s perspective(s), sample the depth map based on the current fragment position, and compare each fragment with the stored depth value to see whether it is in shadow. The main difference between directional shadow mapping and omnidirectional shadow mapping is the depth map we use.</p>
<p>The depth map we need requires rendering a scene from all surrounding directions of a point light and as such a normal 2D depth map won&rsquo;t work; what if we were to use a <a href="https://learnopengl.com/Advanced-OpenGL/Cubemaps" target="_blank">cubemap</a> instead? Because a cubemap can store full environment data with only 6 faces, it is possible to render the entire scene to each of the faces of a cubemap and sample these as the point light&rsquo;s surrounding depth values.</p>
<p><a href="#R-image-58db270c6ec1cfbaa5702a84a449d15c" class="lightbox-link"><img src="./assets/point_shadows_diagram.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-58db270c6ec1cfbaa5702a84a449d15c"><img src="./assets/point_shadows_diagram.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>The generated depth cubemap is then passed to the lighting fragment shader that samples the cubemap with a direction vector to obtain the closest depth (from the light&rsquo;s perspective) at that fragment. Most of the complicated stuff we&rsquo;ve already discussed in the shadow mapping chapter. What makes this technique a bit more difficult is the depth cubemap generation.</p>
<h4 id="generating-the-depth-cubemap">Generating the depth cubemap</h4>
<p>To create a cubemap of a light&rsquo;s surrounding depth values we have to render the scene 6 times: once for each face. One (quite obvious) way to do this, is render the scene 6 times with 6 different view matrices, each time attaching a different cubemap face to the framebuffer object. This would look something like this:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="n">GLenum</span> <span class="n">face</span> <span class="o">=</span> <span class="n">GL_TEXTURE_CUBE_MAP_POSITIVE_X</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="n">glFramebufferTexture2D</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">GL_DEPTH_ATTACHMENT</span><span class="p">,</span> <span class="n">face</span><span class="p">,</span> <span class="n">depthCubemap</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">    <span class="n">BindViewMatrix</span><span class="p">(</span><span class="n">lightViewMatrices</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">    <span class="n">RenderScene</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>This can be quite expensive though as a lot of render calls are necessary for this single depth map. In this chapter we&rsquo;re going to use an alternative (more organized) approach using a little trick in the geometry shader that allows us to build the depth cubemap with just a single render pass.</p>
<p>First, we&rsquo;ll need to create a cubemap:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">depthCubemap</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glGenTextures</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">depthCubemap</span><span class="p">);</span></span></span></code></pre></div><p>And assign each of the single cubemap faces a 2D depth-valued texture image:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">SHADOW_WIDTH</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">,</span> <span class="n">SHADOW_HEIGHT</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_CUBE_MAP</span><span class="p">,</span> <span class="n">depthCubemap</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">        <span class="n">glTexImage2D</span><span class="p">(</span><span class="n">GL_TEXTURE_CUBE_MAP_POSITIVE_X</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_DEPTH_COMPONENT</span><span class="p">,</span> 
</span></span><span class="line"><span class="ln">5</span><span class="cl">                     <span class="n">SHADOW_WIDTH</span><span class="p">,</span> <span class="n">SHADOW_HEIGHT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_DEPTH_COMPONENT</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span></span></span></code></pre></div><p>And don&rsquo;t forget to set the texture parameters:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_CUBE_MAP</span><span class="p">,</span> <span class="n">GL_TEXTURE_MAG_FILTER</span><span class="p">,</span> <span class="n">GL_NEAREST</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_CUBE_MAP</span><span class="p">,</span> <span class="n">GL_TEXTURE_MIN_FILTER</span><span class="p">,</span> <span class="n">GL_NEAREST</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_CUBE_MAP</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_S</span><span class="p">,</span> <span class="n">GL_CLAMP_TO_EDGE</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_CUBE_MAP</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_T</span><span class="p">,</span> <span class="n">GL_CLAMP_TO_EDGE</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_CUBE_MAP</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_R</span><span class="p">,</span> <span class="n">GL_CLAMP_TO_EDGE</span><span class="p">);</span>  
</span></span></code></pre></div><p>Normally we&rsquo;d attach a single face of a cubemap texture to the framebuffer object and render the scene 6 times, each time switching the depth buffer target of the framebuffer to a different cubemap face. Since we&rsquo;re going to use a geometry shader, that allows us to render to all faces in a single pass, we can directly attach the cubemap as a framebuffer&rsquo;s depth attachment with glFramebufferTexture:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">depthMapFBO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glFramebufferTexture</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">GL_DEPTH_ATTACHMENT</span><span class="p">,</span> <span class="n">depthCubemap</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">glDrawBuffer</span><span class="p">(</span><span class="n">GL_NONE</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="n">glReadBuffer</span><span class="p">(</span><span class="n">GL_NONE</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  
</span></span></code></pre></div><p>Again, note the call to glDrawBuffer and glReadBuffer: we only care about depth values when generating a depth cubemap so we have to explicitly tell OpenGL this framebuffer object does not render to a color buffer.</p>
<p>With omnidirectional shadow maps we have two render passes: first, we generate the depth cubemap and second, we use the depth cubemap in the normal render pass to add shadows to the scene. This process looks a bit like this:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="c1">// 1. first render to depth cubemap
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1"></span><span class="n">glViewport</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SHADOW_WIDTH</span><span class="p">,</span> <span class="n">SHADOW_HEIGHT</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">depthMapFBO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="n">glClear</span><span class="p">(</span><span class="n">GL_DEPTH_BUFFER_BIT</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="n">ConfigureShaderAndMatrices</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="n">RenderScene</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="c1">// 2. then render scene as normal with shadow mapping (using depth cubemap)
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1"></span><span class="n">glViewport</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SCR_WIDTH</span><span class="p">,</span> <span class="n">SCR_HEIGHT</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="n">glClear</span><span class="p">(</span><span class="n">GL_COLOR_BUFFER_BIT</span> <span class="o">|</span> <span class="n">GL_DEPTH_BUFFER_BIT</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="n">ConfigureShaderAndMatrices</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_CUBE_MAP</span><span class="p">,</span> <span class="n">depthCubemap</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="n">RenderScene</span><span class="p">();</span></span></span></code></pre></div><p>The process is exactly the same as with default shadow mapping, although this time we render to and use a cubemap depth texture compared to a 2D depth texture.</p>
<h5 id="light-space-transform-1">Light space transform</h5>
<p>With the framebuffer and cubemap set, we need some way to transform all the scene&rsquo;s geometry to the relevant light spaces in all 6 directions of the light. Just like the <a href="https://learnopengl.com/Advanced-Lighting/Shadows/Shadow-Mapping" target="_blank">shadow mapping</a> chapter we&rsquo;re going to need a light space transformation matrix T�, but this time one for each face.</p>
<p>Each light space transformation matrix contains both a projection and a view matrix. For the projection matrix we&rsquo;re going to use a perspective projection matrix; the light source represents a point in space so perspective projection makes most sense. Each light space transformation matrix uses the same projection matrix:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">float</span> <span class="n">aspect</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">SHADOW_WIDTH</span><span class="o">/</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">SHADOW_HEIGHT</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="kt">float</span> <span class="n">near</span> <span class="o">=</span> <span class="mf">1.0f</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="kt">float</span> <span class="n">far</span> <span class="o">=</span> <span class="mf">25.0f</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span> <span class="n">shadowProj</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">perspective</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">radians</span><span class="p">(</span><span class="mf">90.0f</span><span class="p">),</span> <span class="n">aspect</span><span class="p">,</span> <span class="n">near</span><span class="p">,</span> <span class="n">far</span><span class="p">);</span> 
</span></span></code></pre></div><p>Important to note here is the field of view parameter of glm::perspective that we set to 90 degrees. By setting this to 90 degrees we make sure the viewing field is exactly large enough to fill a single face of the cubemap such that all faces align correctly to each other at the edges.</p>
<p>As the projection matrix does not change per direction we can re-use it for each of the 6 transformation matrices. We do need a different view matrix per direction. With glm::lookAt we create 6 view directions, each looking at one face direction of the cubemap in the order: right, left, top, bottom, near and far.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="o">&gt;</span> <span class="n">shadowTransforms</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="n">shadowTransforms</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">shadowProj</span> <span class="o">*</span> 
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">                 <span class="n">glm</span><span class="o">::</span><span class="n">lookAt</span><span class="p">(</span><span class="n">lightPos</span><span class="p">,</span> <span class="n">lightPos</span> <span class="o">+</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">));</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">shadowTransforms</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">shadowProj</span> <span class="o">*</span> 
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">                 <span class="n">glm</span><span class="o">::</span><span class="n">lookAt</span><span class="p">(</span><span class="n">lightPos</span><span class="p">,</span> <span class="n">lightPos</span> <span class="o">+</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">));</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">shadowTransforms</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">shadowProj</span> <span class="o">*</span> 
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">                 <span class="n">glm</span><span class="o">::</span><span class="n">lookAt</span><span class="p">(</span><span class="n">lightPos</span><span class="p">,</span> <span class="n">lightPos</span> <span class="o">+</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">));</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="n">shadowTransforms</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">shadowProj</span> <span class="o">*</span> 
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">                 <span class="n">glm</span><span class="o">::</span><span class="n">lookAt</span><span class="p">(</span><span class="n">lightPos</span><span class="p">,</span> <span class="n">lightPos</span> <span class="o">+</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span> <span class="mf">0.0</span><span class="p">,</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span><span class="o">-</span><span class="mf">1.0</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="n">shadowTransforms</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">shadowProj</span> <span class="o">*</span> 
</span></span><span class="line"><span class="ln">11</span><span class="cl">                 <span class="n">glm</span><span class="o">::</span><span class="n">lookAt</span><span class="p">(</span><span class="n">lightPos</span><span class="p">,</span> <span class="n">lightPos</span> <span class="o">+</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="n">shadowTransforms</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">shadowProj</span> <span class="o">*</span> 
</span></span><span class="line"><span class="ln">13</span><span class="cl">                 <span class="n">glm</span><span class="o">::</span><span class="n">lookAt</span><span class="p">(</span><span class="n">lightPos</span><span class="p">,</span> <span class="n">lightPos</span> <span class="o">+</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span><span class="o">-</span><span class="mf">1.0</span><span class="p">),</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">));</span></span></span></code></pre></div><p>Here we create 6 view matrices and multiply them with the projection matrix to get a total of 6 different light space transformation matrices. The <code>target</code> parameter of glm::lookAt each looks into the direction of a single cubemap face.</p>
<p>These transformation matrices are sent to the shaders that render the depth into the cubemap.</p>
<h5 id="depth-shaders">Depth shaders</h5>
<p>To render depth values to a depth cubemap we&rsquo;re going to need a total of three shaders: a vertex and fragment shader, and a <a href="https://learnopengl.com/Advanced-OpenGL/Geometry-Shader" target="_blank">geometry shader</a> in between.</p>
<p>The geometry shader will be the shader responsible for transforming all world-space vertices to the 6 different light spaces. Therefore, the vertex shader simply transforms vertices to world-space and directs them to the geometry shader:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="cp"></span><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">aPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="n">uniform</span> <span class="n">mat4</span> <span class="n">model</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">8</span><span class="cl">    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">model</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">aPos</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">9</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>The geometry shader will take as input 3 triangle vertices and a uniform array of light space transformation matrices. The geometry shader is responsible for transforming the vertices to the light spaces; this is also where it gets interesting.</p>
<p>The geometry shader has a built-in variable called gl_Layer that specifies which cubemap face to emit a primitive to. When left alone, the geometry shader just sends its primitives further down the pipeline as usual, but when we update this variable we can control to which cubemap face we render to for each primitive. This of course only works when we have a cubemap texture attached to the active framebuffer.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">layout</span> <span class="p">(</span><span class="n">triangles</span><span class="p">)</span> <span class="n">in</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">triangle_strip</span><span class="p">,</span> <span class="n">max_vertices</span><span class="o">=</span><span class="mi">18</span><span class="p">)</span> <span class="n">out</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">uniform</span> <span class="n">mat4</span> <span class="n">shadowMatrices</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="n">out</span> <span class="n">vec4</span> <span class="n">FragPos</span><span class="p">;</span> <span class="c1">// FragPos from GS (output per emitvertex)
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">face</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">face</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="o">++</span><span class="n">face</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">        <span class="n">gl_Layer</span> <span class="o">=</span> <span class="n">face</span><span class="p">;</span> <span class="c1">// built-in variable that specifies to which face we render.
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="c1"></span>        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="c1">// for each triangle vertex
</span></span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="c1"></span>        <span class="p">{</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">            <span class="n">FragPos</span> <span class="o">=</span> <span class="n">gl_in</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">gl_Position</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">            <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">shadowMatrices</span><span class="p">[</span><span class="n">face</span><span class="p">]</span> <span class="o">*</span> <span class="n">FragPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">            <span class="n">EmitVertex</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">        <span class="p">}</span>    
</span></span><span class="line"><span class="ln">20</span><span class="cl">        <span class="n">EndPrimitive</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>This geometry shader is relatively straightforward. We take as input a triangle, and output a total of 6 triangles (6 * 3 equals 18 vertices). In the main function we iterate over 6 cubemap faces where we specify each face as the output face by storing the face integer into gl_Layer. We then generate the output triangles by transforming each world-space input vertex to the relevant light space by multiplying FragPos with the face&rsquo;s light-space transformation matrix. Note that we also sent the resulting FragPos variable to the fragment shader that we&rsquo;ll need to calculate a depth value.</p>
<p>In the last chapter we used an empty fragment shader and let OpenGL figure out the depth values of the depth map. This time we&rsquo;re going to calculate our own (linear) depth as the linear distance between each closest fragment position and the light source&rsquo;s position. Calculating our own depth values makes the later shadow calculations a bit more intuitive.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">in</span> <span class="n">vec4</span> <span class="n">FragPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">uniform</span> <span class="n">vec3</span> <span class="n">lightPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">uniform</span> <span class="kt">float</span> <span class="n">far_plane</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="c1">// get distance between fragment and light source
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1"></span>    <span class="kt">float</span> <span class="n">lightDistance</span> <span class="o">=</span> <span class="n">length</span><span class="p">(</span><span class="n">FragPos</span><span class="p">.</span><span class="n">xyz</span> <span class="o">-</span> <span class="n">lightPos</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="c1">// map to [0;1] range by dividing by far_plane
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="c1"></span>    <span class="n">lightDistance</span> <span class="o">=</span> <span class="n">lightDistance</span> <span class="o">/</span> <span class="n">far_plane</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">    
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="c1">// write this as modified depth
</span></span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="c1"></span>    <span class="n">gl_FragDepth</span> <span class="o">=</span> <span class="n">lightDistance</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>The fragment shader takes as input the FragPos from the geometry shader, the light&rsquo;s position vector, and the frustum&rsquo;s far plane value. Here we take the distance between the fragment and the light source, map it to the [<code>0</code>,<code>1</code>] range and write it as the fragment&rsquo;s depth value.</p>
<p>Rendering the scene with these shaders and the cubemap-attached framebuffer object active should give you a completely filled depth cubemap for the second pass&rsquo;s shadow calculations.</p>
<h4 id="omnidirectional-shadow-maps">Omnidirectional shadow maps</h4>
<p>With everything set up it is time to render the actual omnidirectional shadows. The procedure is similar to the directional shadow mapping chapter, although this time we bind a cubemap texture instead of a 2D texture and also pass the light projection&rsquo;s far plane variable to the shaders.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glViewport</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SCR_WIDTH</span><span class="p">,</span> <span class="n">SCR_HEIGHT</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glClear</span><span class="p">(</span><span class="n">GL_COLOR_BUFFER_BIT</span> <span class="o">|</span> <span class="n">GL_DEPTH_BUFFER_BIT</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">shader</span><span class="p">.</span><span class="n">use</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="c1">// ... send uniforms to shader (including light&#39;s far_plane value)
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="c1"></span><span class="n">glActiveTexture</span><span class="p">(</span><span class="n">GL_TEXTURE0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_CUBE_MAP</span><span class="p">,</span> <span class="n">depthCubemap</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="c1">// ... bind other textures
</span></span></span><span class="line"><span class="ln">8</span><span class="cl"><span class="c1"></span><span class="n">RenderScene</span><span class="p">();</span></span></span></code></pre></div><p>Here the renderScene function renders a few cubes in a large cube room scattered around a light source at the center of the scene.</p>
<p>The vertex and fragment shader are mostly similar to the original shadow mapping shaders: the difference being that the fragment shader no longer requires a fragment position in light space as we can now sample the depth values with a direction vector.</p>
<p>Because of this, the vertex shader doesn&rsquo;t needs to transform its position vectors to light space so we can remove the FragPosLightSpace variable:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">aPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">aNormal</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec2</span> <span class="n">aTexCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">out</span> <span class="n">vec2</span> <span class="n">TexCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="n">out</span> <span class="n">VS_OUT</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="n">vec3</span> <span class="n">FragPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="n">vec3</span> <span class="n">Normal</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="n">vec2</span> <span class="n">TexCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="p">}</span> <span class="n">vs_out</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="n">uniform</span> <span class="n">mat4</span> <span class="n">projection</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="n">uniform</span> <span class="n">mat4</span> <span class="n">view</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="n">uniform</span> <span class="n">mat4</span> <span class="n">model</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">
</span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">    <span class="n">vs_out</span><span class="p">.</span><span class="n">FragPos</span> <span class="o">=</span> <span class="n">vec3</span><span class="p">(</span><span class="n">model</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">aPos</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">    <span class="n">vs_out</span><span class="p">.</span><span class="n">Normal</span> <span class="o">=</span> <span class="n">transpose</span><span class="p">(</span><span class="n">inverse</span><span class="p">(</span><span class="n">mat3</span><span class="p">(</span><span class="n">model</span><span class="p">)))</span> <span class="o">*</span> <span class="n">aNormal</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">    <span class="n">vs_out</span><span class="p">.</span><span class="n">TexCoords</span> <span class="o">=</span> <span class="n">aTexCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">projection</span> <span class="o">*</span> <span class="n">view</span> <span class="o">*</span> <span class="n">model</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">aPos</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>The fragment shader&rsquo;s Blinn-Phong lighting code is exactly the same as we had before with a shadow multiplication at the end:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">out</span> <span class="n">vec4</span> <span class="n">FragColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">in</span> <span class="n">VS_OUT</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="n">vec3</span> <span class="n">FragPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="n">vec3</span> <span class="n">Normal</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="n">vec2</span> <span class="n">TexCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="p">}</span> <span class="n">fs_in</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">diffuseTexture</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="n">uniform</span> <span class="n">samplerCube</span> <span class="n">depthMap</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="n">uniform</span> <span class="n">vec3</span> <span class="n">lightPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="n">uniform</span> <span class="n">vec3</span> <span class="n">viewPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">
</span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="n">uniform</span> <span class="kt">float</span> <span class="n">far_plane</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">
</span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="kt">float</span> <span class="nf">ShadowCalculation</span><span class="p">(</span><span class="n">vec3</span> <span class="n">fragPos</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">    <span class="p">[...]</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">
</span></span><span class="line"><span class="ln">23</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl"><span class="p">{</span>           
</span></span><span class="line"><span class="ln">25</span><span class="cl">    <span class="n">vec3</span> <span class="n">color</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">diffuseTexture</span><span class="p">,</span> <span class="n">fs_in</span><span class="p">.</span><span class="n">TexCoords</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl">    <span class="n">vec3</span> <span class="n">normal</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">fs_in</span><span class="p">.</span><span class="n">Normal</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl">    <span class="n">vec3</span> <span class="n">lightColor</span> <span class="o">=</span> <span class="n">vec3</span><span class="p">(</span><span class="mf">0.3</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">28</span><span class="cl">    <span class="c1">// ambient
</span></span></span><span class="line"><span class="ln">29</span><span class="cl"><span class="c1"></span>    <span class="n">vec3</span> <span class="n">ambient</span> <span class="o">=</span> <span class="mf">0.3</span> <span class="o">*</span> <span class="n">color</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">30</span><span class="cl">    <span class="c1">// diffuse
</span></span></span><span class="line"><span class="ln">31</span><span class="cl"><span class="c1"></span>    <span class="n">vec3</span> <span class="n">lightDir</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">lightPos</span> <span class="o">-</span> <span class="n">fs_in</span><span class="p">.</span><span class="n">FragPos</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">32</span><span class="cl">    <span class="kt">float</span> <span class="n">diff</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">lightDir</span><span class="p">,</span> <span class="n">normal</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">33</span><span class="cl">    <span class="n">vec3</span> <span class="n">diffuse</span> <span class="o">=</span> <span class="n">diff</span> <span class="o">*</span> <span class="n">lightColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">34</span><span class="cl">    <span class="c1">// specular
</span></span></span><span class="line"><span class="ln">35</span><span class="cl"><span class="c1"></span>    <span class="n">vec3</span> <span class="n">viewDir</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">viewPos</span> <span class="o">-</span> <span class="n">fs_in</span><span class="p">.</span><span class="n">FragPos</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">36</span><span class="cl">    <span class="n">vec3</span> <span class="n">reflectDir</span> <span class="o">=</span> <span class="n">reflect</span><span class="p">(</span><span class="o">-</span><span class="n">lightDir</span><span class="p">,</span> <span class="n">normal</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">37</span><span class="cl">    <span class="kt">float</span> <span class="n">spec</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">38</span><span class="cl">    <span class="n">vec3</span> <span class="n">halfwayDir</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">lightDir</span> <span class="o">+</span> <span class="n">viewDir</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">39</span><span class="cl">    <span class="n">spec</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="n">halfwayDir</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">),</span> <span class="mf">64.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">40</span><span class="cl">    <span class="n">vec3</span> <span class="n">specular</span> <span class="o">=</span> <span class="n">spec</span> <span class="o">*</span> <span class="n">lightColor</span><span class="p">;</span>    
</span></span><span class="line"><span class="ln">41</span><span class="cl">    <span class="c1">// calculate shadow
</span></span></span><span class="line"><span class="ln">42</span><span class="cl"><span class="c1"></span>    <span class="kt">float</span> <span class="n">shadow</span> <span class="o">=</span> <span class="n">ShadowCalculation</span><span class="p">(</span><span class="n">fs_in</span><span class="p">.</span><span class="n">FragPos</span><span class="p">);</span>                      
</span></span><span class="line"><span class="ln">43</span><span class="cl">    <span class="n">vec3</span> <span class="n">lighting</span> <span class="o">=</span> <span class="p">(</span><span class="n">ambient</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">shadow</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">diffuse</span> <span class="o">+</span> <span class="n">specular</span><span class="p">))</span> <span class="o">*</span> <span class="n">color</span><span class="p">;</span>    
</span></span><span class="line"><span class="ln">44</span><span class="cl">    
</span></span><span class="line"><span class="ln">45</span><span class="cl">    <span class="n">FragColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">lighting</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">46</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>There are a few subtle differences: the lighting code is the same, but we now have a <code>samplerCube</code> uniform and the ShadowCalculation function takes the current fragment&rsquo;s position as its argument instead of the fragment position in light space. We now also include the light frustum&rsquo;s far_plane value that we&rsquo;ll later need.</p>
<p>The biggest difference is in the content of the ShadowCalculation function that now samples depth values from a cubemap instead of a 2D texture. Let&rsquo;s discuss its content step by step.</p>
<p>The first thing we have to do is retrieve the depth of the cubemap. You may remember from the cubemap section of this chapter that we stored the depth as the linear distance between the fragment and the light position; we&rsquo;re taking a similar approach here:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">float</span> <span class="nf">ShadowCalculation</span><span class="p">(</span><span class="n">vec3</span> <span class="n">fragPos</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="n">vec3</span> <span class="n">fragToLight</span> <span class="o">=</span> <span class="n">fragPos</span> <span class="o">-</span> <span class="n">lightPos</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="kt">float</span> <span class="n">closestDepth</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">depthMap</span><span class="p">,</span> <span class="n">fragToLight</span><span class="p">).</span><span class="n">r</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>Here we take the difference vector between the fragment&rsquo;s position and the light&rsquo;s position and use that vector as a direction vector to sample the cubemap. The direction vector doesn&rsquo;t need to be a unit vector to sample from a cubemap so there&rsquo;s no need to normalize it. The resulting closestDepth value is the normalized depth value between the light source and its closest visible fragment.</p>
<p>The closestDepth value is currently in the range [<code>0</code>,<code>1</code>] so we first transform it back to [<code>0</code>,<code>far_plane</code>] by multiplying it with far_plane.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">closestDepth</span> <span class="o">*=</span> <span class="n">far_plane</span><span class="p">;</span>  
</span></span></code></pre></div><p>Next we retrieve the depth value between the current fragment and the light source, which we can easily obtain by taking the length of fragToLight due to how we calculated depth values in the cubemap:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">float</span> <span class="n">currentDepth</span> <span class="o">=</span> <span class="n">length</span><span class="p">(</span><span class="n">fragToLight</span><span class="p">);</span>  
</span></span></code></pre></div><p>This returns a depth value in the same (or larger) range as closestDepth.</p>
<p>Now we can compare both depth values to see which is closer than the other and determine whether the current fragment is in shadow. We also include a shadow bias so we don&rsquo;t get shadow acne as discussed in the <a href="https://learnopengl.com/Advanced-Lighting/Shadows/Shadow-Mapping" target="_blank">previous</a> chapter.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">float</span> <span class="n">bias</span> <span class="o">=</span> <span class="mf">0.05</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="kt">float</span> <span class="n">shadow</span> <span class="o">=</span> <span class="n">currentDepth</span> <span class="o">-</span>  <span class="n">bias</span> <span class="o">&gt;</span> <span class="n">closestDepth</span> <span class="o">?</span> <span class="mf">1.0</span> <span class="o">:</span> <span class="mf">0.0</span><span class="p">;</span> 
</span></span></code></pre></div><p>The complete ShadowCalculation then becomes:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">float</span> <span class="nf">ShadowCalculation</span><span class="p">(</span><span class="n">vec3</span> <span class="n">fragPos</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="c1">// get vector between fragment position and light position
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1"></span>    <span class="n">vec3</span> <span class="n">fragToLight</span> <span class="o">=</span> <span class="n">fragPos</span> <span class="o">-</span> <span class="n">lightPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="c1">// use the light to fragment vector to sample from the depth map    
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="c1"></span>    <span class="kt">float</span> <span class="n">closestDepth</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">depthMap</span><span class="p">,</span> <span class="n">fragToLight</span><span class="p">).</span><span class="n">r</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="c1">// it is currently in linear range between [0,1]. Re-transform back to original value
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="c1"></span>    <span class="n">closestDepth</span> <span class="o">*=</span> <span class="n">far_plane</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="c1">// now get current linear depth as the length between the fragment and light position
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1"></span>    <span class="kt">float</span> <span class="n">currentDepth</span> <span class="o">=</span> <span class="n">length</span><span class="p">(</span><span class="n">fragToLight</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="c1">// now test for shadows
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="c1"></span>    <span class="kt">float</span> <span class="n">bias</span> <span class="o">=</span> <span class="mf">0.05</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="kt">float</span> <span class="n">shadow</span> <span class="o">=</span> <span class="n">currentDepth</span> <span class="o">-</span>  <span class="n">bias</span> <span class="o">&gt;</span> <span class="n">closestDepth</span> <span class="o">?</span> <span class="mf">1.0</span> <span class="o">:</span> <span class="mf">0.0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="k">return</span> <span class="n">shadow</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>With these shaders we already get pretty good shadows and this time in all surrounding directions from a point light. With a point light positioned at the center of a simple scene it&rsquo;ll look a bit like this:</p>
<p><a href="#R-image-679e039e81cfa6779141a65f723cb7fc" class="lightbox-link"><img src="./assets/point_shadows.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-679e039e81cfa6779141a65f723cb7fc"><img src="./assets/point_shadows.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>You can find the source code of this demo <a href="https://learnopengl.com/code_viewer_gh.php?code=src/5.advanced_lighting/3.2.1.point_shadows/point_shadows.cpp" target="_blank">here</a>.</p>
<h5 id="visualizing-cubemap-depth-buffer">Visualizing cubemap depth buffer</h5>
<p>If you&rsquo;re somewhat like me you probably didn&rsquo;t get this right on the first try so it makes sense to do some debugging, with one of the obvious checks being validating whether the depth map was built correctly. A simple trick to visualize the depth buffer is to take the closestDepth variable in the ShadowCalculation function and display that variable as:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">FragColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">vec3</span><span class="p">(</span><span class="n">closestDepth</span> <span class="o">/</span> <span class="n">far_plane</span><span class="p">),</span> <span class="mf">1.0</span><span class="p">);</span>  
</span></span></code></pre></div><p>The result is a grayed out scene where each color represents the linear depth values of the scene:</p>
<p><a href="#R-image-161d8a1eed7f4eccf5ac72cdaf903efb" class="lightbox-link"><img src="./assets/point_shadows_depth_cubemap.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-161d8a1eed7f4eccf5ac72cdaf903efb"><img src="./assets/point_shadows_depth_cubemap.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>You can also see the to-be shadowed regions on the outside wall. If it looks somewhat similar, you know the depth cubemap was properly generated.</p>
<h4 id="pcf-1">PCF</h4>
<p>Since omnidirectional shadow maps are based on the same principles of traditional shadow mapping it also has the same resolution dependent artifacts. If you zoom in close enough you can again see jagged edges. Percentage-closer filtering or PCF allows us to smooth out these jagged edges by filtering multiple samples around the fragment position and average the results.</p>
<p>If we take the same simple PCF filter of the previous chapter and add a third dimension we get:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">float</span> <span class="n">shadow</span>  <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="kt">float</span> <span class="n">bias</span>    <span class="o">=</span> <span class="mf">0.05</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="kt">float</span> <span class="n">samples</span> <span class="o">=</span> <span class="mf">4.0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="kt">float</span> <span class="n">offset</span>  <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="k">for</span><span class="p">(</span><span class="kt">float</span> <span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="n">offset</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">offset</span><span class="p">;</span> <span class="n">x</span> <span class="o">+=</span> <span class="n">offset</span> <span class="o">/</span> <span class="p">(</span><span class="n">samples</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">))</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">float</span> <span class="n">y</span> <span class="o">=</span> <span class="o">-</span><span class="n">offset</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">offset</span><span class="p">;</span> <span class="n">y</span> <span class="o">+=</span> <span class="n">offset</span> <span class="o">/</span> <span class="p">(</span><span class="n">samples</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">))</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="kt">float</span> <span class="n">z</span> <span class="o">=</span> <span class="o">-</span><span class="n">offset</span><span class="p">;</span> <span class="n">z</span> <span class="o">&lt;</span> <span class="n">offset</span><span class="p">;</span> <span class="n">z</span> <span class="o">+=</span> <span class="n">offset</span> <span class="o">/</span> <span class="p">(</span><span class="n">samples</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">))</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">            <span class="kt">float</span> <span class="n">closestDepth</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">depthMap</span><span class="p">,</span> <span class="n">fragToLight</span> <span class="o">+</span> <span class="n">vec3</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)).</span><span class="n">r</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">12</span><span class="cl">            <span class="n">closestDepth</span> <span class="o">*=</span> <span class="n">far_plane</span><span class="p">;</span>   <span class="c1">// undo mapping [0;1]
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="c1"></span>            <span class="k">if</span><span class="p">(</span><span class="n">currentDepth</span> <span class="o">-</span> <span class="n">bias</span> <span class="o">&gt;</span> <span class="n">closestDepth</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">                <span class="n">shadow</span> <span class="o">+=</span> <span class="mf">1.0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="n">shadow</span> <span class="o">/=</span> <span class="p">(</span><span class="n">samples</span> <span class="o">*</span> <span class="n">samples</span> <span class="o">*</span> <span class="n">samples</span><span class="p">);</span></span></span></code></pre></div><p>The code isn&rsquo;t that different from the traditional shadow mapping code. We calculate and add texture offsets dynamically for each axis based on a fixed number of samples. For each sample we repeat the original shadow process on the offsetted sample direction and average the results at the end.</p>
<p>The shadows now look more soft and smooth and give more plausible results.</p>
<p><a href="#R-image-92c55384c2a37d4894144ad0d7e18511" class="lightbox-link"><img src="./assets/point_shadows_soft.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-92c55384c2a37d4894144ad0d7e18511"><img src="./assets/point_shadows_soft.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>However, with samples set to <code>4.0</code> we take a total of <code>64</code> samples each fragment which is a lot!</p>
<p>As most of these samples are redundant in that they sample close to the original direction vector it may make more sense to only sample in perpendicular directions of the sample direction vector. However as there is no (easy) way to figure out which sub-directions are redundant this becomes difficult. One trick we can use is to take an array of offset directions that are all roughly separable e.g. each of them points in completely different directions. This will significantly reduce the number of sub-directions that are close together. Below we have such an array of a maximum of <code>20</code> offset directions:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">vec3</span> <span class="n">sampleOffsetDirections</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span> <span class="o">=</span> <span class="n">vec3</span><span class="p">[]</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">(</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">   <span class="n">vec3</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">),</span> <span class="n">vec3</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">),</span> <span class="n">vec3</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">),</span> <span class="n">vec3</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">),</span> 
</span></span><span class="line"><span class="ln">4</span><span class="cl">   <span class="n">vec3</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">vec3</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">vec3</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">vec3</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">   <span class="n">vec3</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">),</span> <span class="n">vec3</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">),</span> <span class="n">vec3</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">),</span> <span class="n">vec3</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">),</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">   <span class="n">vec3</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">1</span><span class="p">),</span> <span class="n">vec3</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">1</span><span class="p">),</span> <span class="n">vec3</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">vec3</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl">   <span class="n">vec3</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">),</span> <span class="n">vec3</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">),</span> <span class="n">vec3</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">vec3</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">8</span><span class="cl"><span class="p">);</span>   
</span></span></code></pre></div><p>From this we can adapt the PCF algorithm to take a fixed amount of samples from sampleOffsetDirections and use these to sample the cubemap. The advantage here is that we need a lot less samples to get visually similar results.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">float</span> <span class="n">shadow</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="kt">float</span> <span class="n">bias</span>   <span class="o">=</span> <span class="mf">0.15</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="kt">int</span> <span class="n">samples</span>  <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="kt">float</span> <span class="n">viewDistance</span> <span class="o">=</span> <span class="n">length</span><span class="p">(</span><span class="n">viewPos</span> <span class="o">-</span> <span class="n">fragPos</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="kt">float</span> <span class="n">diskRadius</span> <span class="o">=</span> <span class="mf">0.05</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">samples</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="kt">float</span> <span class="n">closestDepth</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">depthMap</span><span class="p">,</span> <span class="n">fragToLight</span> <span class="o">+</span> <span class="n">sampleOffsetDirections</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">diskRadius</span><span class="p">).</span><span class="n">r</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="n">closestDepth</span> <span class="o">*=</span> <span class="n">far_plane</span><span class="p">;</span>   <span class="c1">// undo mapping [0;1]
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">currentDepth</span> <span class="o">-</span> <span class="n">bias</span> <span class="o">&gt;</span> <span class="n">closestDepth</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">        <span class="n">shadow</span> <span class="o">+=</span> <span class="mf">1.0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="n">shadow</span> <span class="o">/=</span> <span class="kt">float</span><span class="p">(</span><span class="n">samples</span><span class="p">);</span>  
</span></span></code></pre></div><p>Here we add multiple offsets, scaled by some diskRadius, around the original fragToLight direction vector to sample from the cubemap.</p>
<p>Another interesting trick we can apply here is that we can change diskRadius based on the distance of the viewer to the fragment, making the shadows softer when far away and sharper when close by.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">float</span> <span class="n">diskRadius</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="p">(</span><span class="n">viewDistance</span> <span class="o">/</span> <span class="n">far_plane</span><span class="p">))</span> <span class="o">/</span> <span class="mf">25.0</span><span class="p">;</span>  
</span></span></code></pre></div><p>The results of the updated PCF algorithm gives just as good, if not better, results of soft shadows:</p>
<p><a href="#R-image-bf76cf5d8608721c72b6fe957e5f8b07" class="lightbox-link"><img src="./assets/point_shadows_soft_better.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-bf76cf5d8608721c72b6fe957e5f8b07"><img src="./assets/point_shadows_soft_better.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Of course, the bias we add to each sample is highly based on context and will always require tweaking based on the scene you&rsquo;re working with. Play around with all the values and see how they affect the scene.</p>
<p>You can find the final code here: <a href="https://learnopengl.com/code_viewer_gh.php?code=src/5.advanced_lighting/3.2.2.point_shadows_soft/point_shadows_soft.cpp" target="_blank">here</a>.</p>
<p>I should mention that using geometry shaders to generate a depth map isn&rsquo;t necessarily faster than rendering the scene 6 times for each face. Using a geometry shader like this has its own performance penalties that may outweigh the performance gain of using one in the first place. This of course depends on the type of environment, the specific video card drivers, and plenty of other factors. So if you really care about pushing the most out of your system, make sure to profile both methods and select the more efficient one for your scene.</p>
<h4 id="additional-resources-5">Additional resources</h4>
<ul>
<li><a href="http://www.sunandblackcat.com/tipFullView.php?l=eng&amp;topicid=36" target="_blank">Shadow Mapping for point light sources in OpenGL</a>: omnidirectional shadow mapping tutorial by sunandblackcat.</li>
<li><a href="http://ogldev.atspace.co.uk/www/tutorial43/tutorial43.html" target="_blank">Multipass Shadow Mapping With Point Lights</a>: omnidirectional shadow mapping tutorial by ogldev.</li>
<li><a href="http://www.cg.tuwien.ac.at/~husky/RTR/OmnidirShadows-whyCaps.pdf" target="_blank">Omni-directional Shadows</a>: a nice set of slides about omnidirectional shadow mapping by Peter Houska.</li>
</ul>
<h3 id="normal-mapping">Normal Mapping</h3>
<p>All of our scenes are filled with meshes, each consisting of hundreds or maybe thousands of triangles. We boosted the realism by wrapping 2D textures on these flat triangles, hiding the fact that the polygons are just tiny flat triangles. Textures help, but when you take a good close look at the meshes it is still quite easy to see the underlying flat surfaces. Most real-life surface aren&rsquo;t flat however and exhibit a lot of (bumpy) details.</p>
<p>For instance, take a brick surface. A brick surface is quite a rough surface and obviously not completely flat: it contains sunken cement stripes and a lot of detailed little holes and cracks. If we were to view such a brick surface in a lit scene the immersion gets easily broken. Below we can see a brick texture applied to a flat surface lit by a point light.</p>
<p><a href="#R-image-a111ceca0248b8e37300259a0c4ed342" class="lightbox-link"><img src="./assets/normal_mapping_flat.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a111ceca0248b8e37300259a0c4ed342"><img src="./assets/normal_mapping_flat.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>The lighting doesn&rsquo;t take any of the small cracks and holes into account and completely ignores the deep stripes between the bricks; the surface looks perfectly flat. We can partly fix the flat look by using a specular map to pretend some surfaces are less lit due to depth or other details, but that&rsquo;s more of a hack than a real solution. What we need is some way to inform the lighting system about all the little depth-like details of the surface.</p>
<p>If we think about this from a light&rsquo;s perspective: how comes the surface is lit as a completely flat surface? The answer is the surface&rsquo;s normal vector. From the lighting technique&rsquo;s point of view, the only way it determines the shape of an object is by its perpendicular normal vector. The brick surface only has a single normal vector, and as a result the surface is uniformly lit based on this normal vector&rsquo;s direction. What if we, instead of a per-surface normal that is the same for each fragment, use a per-fragment normal that is different for each fragment? This way we can slightly deviate the normal vector based on a surface&rsquo;s little details; this gives the illusion the surface is a lot more complex:</p>
<p><a href="#R-image-1165ff589c831781a5423f8c0d6822e7" class="lightbox-link"><img src="./assets/normal_mapping_surfaces.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-1165ff589c831781a5423f8c0d6822e7"><img src="./assets/normal_mapping_surfaces.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>By using per-fragment normals we can trick the lighting into believing a surface consists of tiny little planes (perpendicular to the normal vectors) giving the surface an enormous boost in detail. This technique to use per-fragment normals compared to per-surface normals is called normal mapping or bump mapping. Applied to the brick plane it looks a bit like this:</p>
<p><a href="#R-image-3520bc6b8dc548f9c6769c488724ed8e" class="lightbox-link"><img src="./assets/normal_mapping_compare.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-3520bc6b8dc548f9c6769c488724ed8e"><img src="./assets/normal_mapping_compare.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>As you can see, it gives an enormous boost in detail and for a relatively low cost. Since we only change the normal vectors per fragment there is no need to change the lighting equation. We now pass a per-fragment normal, instead of an interpolated surface normal, to the lighting algorithm. The lighting then does the rest.</p>
<h4 id="normal-mapping-1">Normal mapping</h4>
<p>To get normal mapping to work we&rsquo;re going to need a per-fragment normal. Similar to what we did with diffuse and specular maps we can use a 2D texture to store per-fragment normal data. This way we can sample a 2D texture to get a normal vector for that specific fragment.</p>
<p>While normal vectors are geometric entities and textures are generally only used for color information, storing normal vectors in a texture may not be immediately obvious. If you think about color vectors in a texture they are represented as a 3D vector with an <code>r</code>, <code>g</code>, and <code>b</code> component. We can similarly store a normal vector&rsquo;s <code>x</code>, <code>y</code> and <code>z</code> component in the respective color components. Normal vectors range between <code>-1</code> and <code>1</code> so they&rsquo;re first mapped to [<code>0</code>,<code>1</code>]:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">vec3</span> <span class="n">rgb_normal</span> <span class="o">=</span> <span class="n">normal</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">;</span> <span class="c1">// transforms from [-1,1] to [0,1]  
</span></span></span></code></pre></div><p>With normal vectors transformed to an RGB color component like this, we can store a per-fragment normal derived from the shape of a surface onto a 2D texture. An example normal map of the brick surface at the start of this chapter is shown below:</p>
<p><a href="#R-image-0f314865d3d18731a5362e8e5cc7110a" class="lightbox-link"><img src="./assets/normal_mapping_normal_map.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-0f314865d3d18731a5362e8e5cc7110a"><img src="./assets/normal_mapping_normal_map.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>This (and almost all normal maps you find online) will have a blue-ish tint. This is because the normals are all closely pointing outwards towards the positive z-axis 
<span class="math align-center">$(0,0,1)$</span>: a blue-ish color. The deviations in color represent normal vectors that are slightly offset from the general positive z direction, giving a sense of depth to the texture. For example, you can see that at the top of each brick the color tends to be more greenish, which makes sense as the top side of a brick would have normals pointing more in the positive y direction 
<span class="math align-center">$(0,1,0)$</span> which happens to be the color green!</p>
<p>With a simple plane, looking at the positive z-axis, we can take <a href="https://learnopengl.com/img/textures/brickwall.jpg" target="_blank">this</a> diffuse texture and <a href="https://learnopengl.com/img/textures/brickwall_normal.jpg" target="_blank">this</a> normal map to render the image from the previous section. Note that the linked normal map is different from the one shown above. The reason for this is that OpenGL reads texture coordinates with the y (or v) coordinate reversed from how textures are generally created. The linked normal map thus has its y (or green) component inversed (you can see the green colors are now pointing downwards); if you fail to take this into account, the lighting will be incorrect. Load both textures, bind them to the proper texture units, and render a plane with the following changes in the lighting fragment shader:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">normalMap</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="p">{</span>           
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="c1">// obtain normal from normal map in range [0,1]
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="c1"></span>    <span class="n">normal</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">normalMap</span><span class="p">,</span> <span class="n">fs_in</span><span class="p">.</span><span class="n">TexCoords</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="c1">// transform normal vector to range [-1,1]
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="c1"></span>    <span class="n">normal</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">normal</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">);</span>   
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="p">[...]</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="c1">// proceed with lighting as normal
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="c1"></span><span class="p">}</span>  
</span></span></code></pre></div><p>Here we reverse the process of mapping normals to RGB colors by remapping the sampled normal color from [<code>0</code>,<code>1</code>] back to [<code>-1</code>,<code>1</code>] and then use the sampled normal vectors for the upcoming lighting calculations. In this case we used a Blinn-Phong shader.</p>
<p>By slowly moving the light source over time you really get a sense of depth using the normal map. Running this normal mapping example gives the exact results as shown at the start of this chapter:</p>
<p><a href="#R-image-fb13d554ddb9cdc85a0d9c1d95472f58" class="lightbox-link"><img src="./assets/normal_mapping_correct.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-fb13d554ddb9cdc85a0d9c1d95472f58"><img src="./assets/normal_mapping_correct.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>There is one issue however that greatly limits this use of normal maps. The normal map we used had normal vectors that all pointed somewhat in the positive z direction. This worked because the plane&rsquo;s surface normal was also pointing in the positive z direction. However, what would happen if we used the same normal map on a plane laying on the ground with a surface normal vector pointing in the positive y direction?</p>
<p><a href="#R-image-71d41559633ed099db2279e2698344a3" class="lightbox-link"><img src="./assets/normal_mapping_ground.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-71d41559633ed099db2279e2698344a3"><img src="./assets/normal_mapping_ground.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>The lighting doesn&rsquo;t look right! This happens because the sampled normals of this plane still roughly point in the positive z direction even though they should mostly point in the positive y direction. As a result, the lighting thinks the surface&rsquo;s normals are the same as before when the plane was pointing towards the positive z direction; the lighting is incorrect. The image below shows what the sampled normals approximately look like on this surface:</p>
<p><a href="#R-image-3b25ee5e0e9d29826aebebce6197c9c2" class="lightbox-link"><img src="./assets/normal_mapping_ground_normals.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-3b25ee5e0e9d29826aebebce6197c9c2"><img src="./assets/normal_mapping_ground_normals.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>You can see that all the normals point somewhat in the positive z direction even though they should be pointing towards the positive y direction. One solution to this problem is to define a normal map for each possible direction of the surface; in the case of a cube we would need 6 normal maps. However, with advanced meshes that can have more than hundreds of possible surface directions this becomes an infeasible approach.</p>
<p>A different solution exists that does all the lighting in a different coordinate space: a coordinate space where the normal map vectors always point towards the positive z direction; all other lighting vectors are then transformed relative to this positive z direction. This way we can always use the same normal map, regardless of orientation. This coordinate space is called tangent space.</p>
<h4 id="tangent-space">Tangent space</h4>
<p>Normal vectors in a normal map are expressed in tangent space where normals always point roughly in the positive z direction. Tangent space is a space that&rsquo;s local to the surface of a triangle: the normals are relative to the local reference frame of the individual triangles. Think of it as the local space of the normal map&rsquo;s vectors; they&rsquo;re all defined pointing in the positive z direction regardless of the final transformed direction. Using a specific matrix we can then transform normal vectors from this <em>local</em> tangent space to world or view coordinates, orienting them along the final mapped surface&rsquo;s direction.</p>
<p>Let&rsquo;s say we have the incorrect normal mapped surface from the previous section looking in the positive y direction. The normal map is defined in tangent space, so one way to solve the problem is to calculate a matrix to transform normals from tangent space to a different space such that they&rsquo;re aligned with the surface&rsquo;s normal direction: the normal vectors are then all pointing roughly in the positive y direction. The great thing about tangent space is that we can calculate this matrix for any type of surface so that we can properly align the tangent space&rsquo;s z direction to the surface&rsquo;s normal direction.</p>
<p>Such a matrix is called a TBN matrix where the letters depict a Tangent, Bitangent and Normal vector. These are the vectors we need to construct this matrix. To construct such a <em>change-of-basis</em> matrix, that transforms a tangent-space vector to a different coordinate space, we need three perpendicular vectors that are aligned along the surface of a normal map: an up, right, and forward vector; similar to what we did in the <a href="https://learnopengl.com/Getting-Started/Camera" target="_blank">camera</a> chapter.</p>
<p>We already know the up vector, which is the surface&rsquo;s normal vector. The right and forward vector are the tangent and bitangent vector respectively. The following image of a surface shows all three vectors on a surface:</p>
<p><a href="#R-image-41a7af807a0817aa7a6f687fb3c8cfe1" class="lightbox-link"><img src="./assets/normal_mapping_tbn_vectors.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-41a7af807a0817aa7a6f687fb3c8cfe1"><img src="./assets/normal_mapping_tbn_vectors.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Calculating the tangent and bitangent vectors is not as straightforward as the normal vector. We can see from the image that the direction of the normal map&rsquo;s tangent and bitangent vector align with the direction in which we define a surface&rsquo;s texture coordinates. We&rsquo;ll use this fact to calculate tangent and bitangent vectors for each surface. Retrieving them does require a bit of math; take a look at the following image:</p>
<p><a href="#R-image-9a7d295ba316da01df800c8fe810caaf" class="lightbox-link"><img src="./assets/normal_mapping_surface_edges.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-9a7d295ba316da01df800c8fe810caaf"><img src="./assets/normal_mapping_surface_edges.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>From the image we can see that the texture coordinate differences of an edge 
<span class="math align-center">$E_2$</span> of a triangle (denoted as 
<span class="math align-center">$\Delta U_2$</span> and 
<span class="math align-center">$\Delta V_2$</span>) are expressed in the same direction as the tangent vector 
<span class="math align-center">$T$</span> and bitangent vector 
<span class="math align-center">$B$</span>. Because of this we can write both displayed edges 
<span class="math align-center">$E_1$</span> and 
<span class="math align-center">$E_2$</span> of the triangle as a linear combination of the tangent vector 
<span class="math align-center">$T$</span> and the bitangent vector 
<span class="math align-center">$B$</span>:</p>

<span class="math align-center">$$
E_1 = \Delta U_1T + \Delta V_1B
$$</span>
<span class="math align-center">$$
E_2 = \Delta U_2T + \Delta V_2B
$$</span><p>Which we can also write as:</p>

<span class="math align-center">$$
(E_{1x}, E_{1y}, E_{1z}) = \Delta U_1(T_x, T_y, T_z) + \Delta V_1(B_x, B_y, B_z)
$$</span>
<span class="math align-center">$$
(E_{2x}, E_{2y}, E_{2z}) = \Delta U_2(T_x, T_y, T_z) + \Delta V_2(B_x, B_y, B_z)
$$</span><p>We can calculate 
<span class="math align-center">$E$</span> as the difference vector between two triangle positions, and 
<span class="math align-center">$\Delta U$</span> and 
<span class="math align-center">$\Delta V$</span> as their texture coordinate differences. We&rsquo;re then left with two unknowns (tangent 
<span class="math align-center">$T$</span> and bitangent 
<span class="math align-center">$B$</span>) and two equations. You may remember from your algebra classes that this allows us to solve for 
<span class="math align-center">$T$</span> and 
<span class="math align-center">$B$</span>.</p>
<p>The last equation allows us to write it in a different form: that of matrix multiplication:</p>

<span class="math align-center">$$
\begin{bmatrix} E_{1x} & E_{1y} & E_{1z} \\ E_{2x} & E_{2y} & E_{2z} \end{bmatrix} = \begin{bmatrix} \Delta U_1 & \Delta V_1 \\ \Delta U_2 & \Delta V_2 \end{bmatrix} \begin{bmatrix} T_x & T_y & T_z \\ B_x & B_y & B_z \end{bmatrix}
$$</span><p>Try to visualize the matrix multiplications in your head and confirm that this is indeed the same equation. An advantage of rewriting the equations in matrix form is that solving for 
<span class="math align-center">$T$</span> and 
<span class="math align-center">$B$</span> is easier to understand. If we multiply both sides of the equations by the inverse of the 
<span class="math align-center">$\Delta U\Delta V$</span> matrix we get:</p>

<span class="math align-center">$$
\begin{bmatrix} \Delta U_1 & \Delta V_1 \\ \Delta U_2 & \Delta V_2 \end{bmatrix}^{-1} \begin{bmatrix} E_{1x} & E_{1y} & E_{1z} \\ E_{2x} & E_{2y} & E_{2z} \end{bmatrix} = \begin{bmatrix} T_x & T_y & T_z \\ B_x & B_y & B_z \end{bmatrix}
$$</span><p>This allows us to solve for 
<span class="math align-center">$T$</span> and 
<span class="math align-center">$B$</span>. This does require us to calculate the inverse of the delta texture coordinate matrix. I won&rsquo;t go into the mathematical details of calculating a matrix&rsquo; inverse, but it roughly translates to 1 over the determinant of the matrix, multiplied by its adjugate matrix:</p>

<span class="math align-center">$$
\begin{bmatrix} T_x & T_y & T_z \\ B_x & B_y & B_z \end{bmatrix}  = \frac{1}{\Delta U_1 \Delta V_2 - \Delta U_2 \Delta V_1} \begin{bmatrix} \Delta V_2 & -\Delta V_1 \\ -\Delta U_2 & \Delta U_1 \end{bmatrix} \begin{bmatrix} E_{1x} & E_{1y} & E_{1z} \\ E_{2x} & E_{2y} & E_{2z} \end{bmatrix}
$$</span><p>This final equation gives us a formula for calculating the tangent vector 
<span class="math align-center">$T$</span> and bitangent vector 
<span class="math align-center">$B$</span> from a triangle&rsquo;s two edges and its texture coordinates.</p>
<p>Don&rsquo;t worry if you do not fully understand the mathematics behind this. As long as you understand that we can calculate tangents and bitangents from a triangle&rsquo;s vertices and its texture coordinates (since texture coordinates are in the same space as tangent vectors) you&rsquo;re halfway there.</p>
<h4 id="manual-calculation-of-tangents-and-bitangents">Manual calculation of tangents and bitangents</h4>
<p>In the previous demo we had a simple normal mapped plane facing the positive z direction. This time we want to implement normal mapping using tangent space so we can orient this plane however we want and normal mapping would still work. Using the previously discussed mathematics we&rsquo;re going to manually calculate this surface&rsquo;s tangent and bitangent vectors.</p>
<p>Let&rsquo;s assume the plane is built up from the following vectors (with 1, 2, 3 and 1, 3, 4 as its two triangles):</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="c1">// positions
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1"></span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">pos1</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span>  <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">pos2</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">pos3</span><span class="p">(</span> <span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">pos4</span><span class="p">(</span> <span class="mf">1.0</span><span class="p">,</span>  <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="c1">// texture coordinates
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1"></span><span class="n">glm</span><span class="o">::</span><span class="n">vec2</span> <span class="n">uv1</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">vec2</span> <span class="n">uv2</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">vec2</span> <span class="n">uv3</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">vec2</span> <span class="n">uv4</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="c1">// normal vector
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="c1"></span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">nm</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>  
</span></span></code></pre></div><p>We first calculate the first triangle&rsquo;s edges and delta UV coordinates:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">edge1</span> <span class="o">=</span> <span class="n">pos2</span> <span class="o">-</span> <span class="n">pos1</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">edge2</span> <span class="o">=</span> <span class="n">pos3</span> <span class="o">-</span> <span class="n">pos1</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">vec2</span> <span class="n">deltaUV1</span> <span class="o">=</span> <span class="n">uv2</span> <span class="o">-</span> <span class="n">uv1</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">vec2</span> <span class="n">deltaUV2</span> <span class="o">=</span> <span class="n">uv3</span> <span class="o">-</span> <span class="n">uv1</span><span class="p">;</span>  
</span></span></code></pre></div><p>With the required data for calculating tangents and bitangents we can start following the equation from the previous section:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">float</span> <span class="n">f</span> <span class="o">=</span> <span class="mf">1.0f</span> <span class="o">/</span> <span class="p">(</span><span class="n">deltaUV1</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">deltaUV2</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">deltaUV2</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">deltaUV1</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">tangent1</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">f</span> <span class="o">*</span> <span class="p">(</span><span class="n">deltaUV2</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">edge1</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">deltaUV1</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">edge2</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">tangent1</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">f</span> <span class="o">*</span> <span class="p">(</span><span class="n">deltaUV2</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">edge1</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">deltaUV1</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">edge2</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">tangent1</span><span class="p">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">f</span> <span class="o">*</span> <span class="p">(</span><span class="n">deltaUV2</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">edge1</span><span class="p">.</span><span class="n">z</span> <span class="o">-</span> <span class="n">deltaUV1</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">edge2</span><span class="p">.</span><span class="n">z</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="n">bitangent1</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">f</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">deltaUV2</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">edge1</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">deltaUV1</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">edge2</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="n">bitangent1</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">f</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">deltaUV2</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">edge1</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">deltaUV1</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">edge2</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="n">bitangent1</span><span class="p">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">f</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">deltaUV2</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">edge1</span><span class="p">.</span><span class="n">z</span> <span class="o">+</span> <span class="n">deltaUV1</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">edge2</span><span class="p">.</span><span class="n">z</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">  
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="p">[...]</span> <span class="c1">// similar procedure for calculating tangent/bitangent for plane&#39;s second triangle
</span></span></span></code></pre></div><p>Here we first pre-calculate the fractional part of the equation as f and then for each vector component we do the corresponding matrix multiplication multiplied by f. If you compare this code with the final equation you can see it is a direct translation. Because a triangle is always a flat shape, we only need to calculate a single tangent/bitangent pair per triangle as they will be the same for each of the triangle&rsquo;s vertices.</p>
<p>The resulting tangent and bitangent vector should have a value of (<code>1</code>,<code>0</code>,<code>0</code>) and (<code>0</code>,<code>1</code>,<code>0</code>) respectively that together with the normal (<code>0</code>,<code>0</code>,<code>1</code>) forms an orthogonal TBN matrix. Visualized on the plane, the TBN vectors would look like this:</p>
<p><a href="#R-image-821a9f68371681c684a9e0e3838377e0" class="lightbox-link"><img src="./assets/normal_mapping_tbn_shown.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-821a9f68371681c684a9e0e3838377e0"><img src="./assets/normal_mapping_tbn_shown.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>With tangent and bitangent vectors defined per vertex we can start implementing <em>proper</em> normal mapping.</p>
<h4 id="tangent-space-normal-mapping">Tangent space normal mapping</h4>
<p>To get normal mapping working, we first have to create a TBN matrix in the shaders. To do that, we pass the earlier calculated tangent and bitangent vectors to the vertex shader as vertex attributes:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="cp"></span><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">aPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">aNormal</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec2</span> <span class="n">aTexCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">aTangent</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">4</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">aBitangent</span><span class="p">;</span>  
</span></span></code></pre></div><p>Then within the vertex shader&rsquo;s main function we create the TBN matrix:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">   <span class="p">[...]</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">   <span class="n">vec3</span> <span class="n">T</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">vec3</span><span class="p">(</span><span class="n">model</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">aTangent</span><span class="p">,</span>   <span class="mf">0.0</span><span class="p">)));</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">   <span class="n">vec3</span> <span class="n">B</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">vec3</span><span class="p">(</span><span class="n">model</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">aBitangent</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)));</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">   <span class="n">vec3</span> <span class="n">N</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">vec3</span><span class="p">(</span><span class="n">model</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">aNormal</span><span class="p">,</span>    <span class="mf">0.0</span><span class="p">)));</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl">   <span class="n">mat3</span> <span class="n">TBN</span> <span class="o">=</span> <span class="n">mat3</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">N</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">8</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>Here we first transform all the TBN vectors to the coordinate system we&rsquo;d like to work in, which in this case is world-space as we multiply them with the model matrix. Then we create the actual TBN matrix by directly supplying mat3&rsquo;s constructor with the relevant column vectors. Note that if we want to be really precise, we would multiply the TBN vectors with the normal matrix as we only care about the orientation of the vectors.</p>
<p><note>Technically there is no need for the bitangent variable in the vertex shader. All three TBN vectors are perpendicular to each other so we can calculate the bitangent ourselves in the vertex shader by taking the cross product of the T and N vector: <code>vec3 B = cross(N, T);</code></note></p>
<p>So now that we have a TBN matrix, how are we going to use it? There are two ways we can use a TBN matrix for normal mapping, and we&rsquo;ll demonstrate both of them:</p>
<ol>
<li>We take the TBN matrix that transforms any vector from tangent to world space, give it to the fragment shader, and transform the sampled normal from tangent space to world space using the TBN matrix; the normal is then in the same space as the other lighting variables.</li>
<li>We take the inverse of the TBN matrix that transforms any vector from world space to tangent space, and use this matrix to transform not the normal, but the other relevant lighting variables to tangent space; the normal is then again in the same space as the other lighting variables.</li>
</ol>
<p>Let&rsquo;s review the first case. The normal vector we sample from the normal map is expressed in tangent space whereas the other lighting vectors (light and view direction) are expressed in world space. By passing the TBN matrix to the fragment shader we can multiply the sampled tangent space normal with this TBN matrix to transform the normal vector to the same reference space as the other lighting vectors. This way, all the lighting calculations (specifically the dot product) make sense.</p>
<p>Sending the TBN matrix to the fragment shader is easy:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">out</span> <span class="n">VS_OUT</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    <span class="n">vec3</span> <span class="n">FragPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="n">vec2</span> <span class="n">TexCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="n">mat3</span> <span class="n">TBN</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="p">}</span> <span class="n">vs_out</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="p">[...]</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="n">vs_out</span><span class="p">.</span><span class="n">TBN</span> <span class="o">=</span> <span class="n">mat3</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">N</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>In the fragment shader we similarly take a <code>mat3</code> as an input variable:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">in</span> <span class="n">VS_OUT</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">    <span class="n">vec3</span> <span class="n">FragPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="n">vec2</span> <span class="n">TexCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="n">mat3</span> <span class="n">TBN</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="p">}</span> <span class="n">fs_in</span><span class="p">;</span>  
</span></span></code></pre></div><p>With this TBN matrix we can now update the normal mapping code to include the tangent-to-world space transformation:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">normal</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">normalMap</span><span class="p">,</span> <span class="n">fs_in</span><span class="p">.</span><span class="n">TexCoords</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">normal</span> <span class="o">=</span> <span class="n">normal</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">;</span>   
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">normal</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">fs_in</span><span class="p">.</span><span class="n">TBN</span> <span class="o">*</span> <span class="n">normal</span><span class="p">);</span> 
</span></span></code></pre></div><p>Because the resulting normal is now in world space, there is no need to change any of the other fragment shader code as the lighting code assumes the normal vector to be in world space.</p>
<p>Let&rsquo;s also review the second case, where we take the inverse of the TBN matrix to transform all relevant world-space vectors to the space the sampled normal vectors are in: tangent space. The construction of the TBN matrix remains the same, but we first invert the matrix before sending it to the fragment shader:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">vs_out</span><span class="p">.</span><span class="n">TBN</span> <span class="o">=</span> <span class="n">transpose</span><span class="p">(</span><span class="n">mat3</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">N</span><span class="p">));</span>   
</span></span></code></pre></div><p>Note that we use the transpose function instead of the inverse function here. A great property of orthogonal matrices (each axis is a perpendicular unit vector) is that the transpose of an orthogonal matrix equals its inverse. This is a great property as inverse is expensive and a transpose isn&rsquo;t.</p>
<p>Within the fragment shader we do not transform the normal vector, but we transform the other relevant vectors to tangent space, namely the lightDir and viewDir vectors. That way, each vector is in the same coordinate space: tangent space.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>           
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="n">vec3</span> <span class="n">normal</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">normalMap</span><span class="p">,</span> <span class="n">fs_in</span><span class="p">.</span><span class="n">TexCoords</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="n">normal</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">normal</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">);</span>   
</span></span><span class="line"><span class="ln">5</span><span class="cl">   
</span></span><span class="line"><span class="ln">6</span><span class="cl">    <span class="n">vec3</span> <span class="n">lightDir</span> <span class="o">=</span> <span class="n">fs_in</span><span class="p">.</span><span class="n">TBN</span> <span class="o">*</span> <span class="n">normalize</span><span class="p">(</span><span class="n">lightPos</span> <span class="o">-</span> <span class="n">fs_in</span><span class="p">.</span><span class="n">FragPos</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl">    <span class="n">vec3</span> <span class="n">viewDir</span>  <span class="o">=</span> <span class="n">fs_in</span><span class="p">.</span><span class="n">TBN</span> <span class="o">*</span> <span class="n">normalize</span><span class="p">(</span><span class="n">viewPos</span> <span class="o">-</span> <span class="n">fs_in</span><span class="p">.</span><span class="n">FragPos</span><span class="p">);</span>    
</span></span><span class="line"><span class="ln">8</span><span class="cl">    <span class="p">[...]</span>
</span></span><span class="line"><span class="ln">9</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>The second approach looks like more work and also requires matrix multiplications in the fragment shader, so why would we bother with the second approach?</p>
<p>Well, transforming vectors from world to tangent space has an added advantage in that we can transform all the relevant lighting vectors to tangent space in the vertex shader instead of in the fragment shader. This works, because lightPos and viewPos don&rsquo;t update every fragment run, and for fs_in.FragPos we can calculate its tangent-space position in the vertex shader and let fragment interpolation do its work. There is effectively no need to transform a vector to tangent space in the fragment shader, while it is necessary with the first approach as sampled normal vectors are specific to each fragment shader run.</p>
<p>So instead of sending the inverse of the TBN matrix to the fragment shader, we send a tangent-space light position, view position, and vertex position to the fragment shader. This saves us from having to do matrix multiplications in the fragment shader. This is a nice optimization as the vertex shader runs considerably less often than the fragment shader. This is also the reason why this approach is often the preferred approach.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">out</span> <span class="n">VS_OUT</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    <span class="n">vec3</span> <span class="n">FragPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="n">vec2</span> <span class="n">TexCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="n">vec3</span> <span class="n">TangentLightPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="n">vec3</span> <span class="n">TangentViewPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="n">vec3</span> <span class="n">TangentFragPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="p">}</span> <span class="n">vs_out</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="n">uniform</span> <span class="n">vec3</span> <span class="n">lightPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="n">uniform</span> <span class="n">vec3</span> <span class="n">viewPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"> 
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="p">[...]</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">  
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="kt">void</span> <span class="n">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="p">{</span>    
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="p">[...]</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">    <span class="n">mat3</span> <span class="n">TBN</span> <span class="o">=</span> <span class="n">transpose</span><span class="p">(</span><span class="n">mat3</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">N</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">    <span class="n">vs_out</span><span class="p">.</span><span class="n">TangentLightPos</span> <span class="o">=</span> <span class="n">TBN</span> <span class="o">*</span> <span class="n">lightPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">    <span class="n">vs_out</span><span class="p">.</span><span class="n">TangentViewPos</span>  <span class="o">=</span> <span class="n">TBN</span> <span class="o">*</span> <span class="n">viewPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">    <span class="n">vs_out</span><span class="p">.</span><span class="n">TangentFragPos</span>  <span class="o">=</span> <span class="n">TBN</span> <span class="o">*</span> <span class="n">vec3</span><span class="p">(</span><span class="n">model</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">aPos</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>In the fragment shader we then use these new input variables to calculate lighting in tangent space. As the normal vector is already in tangent space, the lighting makes sense.</p>
<p>With normal mapping applied in tangent space, we should get similar results to what we had at the start of this chapter. This time however, we can orient our plane in any way we&rsquo;d like and the lighting would still be correct:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span> <span class="n">model</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">model</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">rotate</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">glfwGetTime</span><span class="p">()</span> <span class="o">*</span> <span class="o">-</span><span class="mf">10.0f</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">normalize</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)));</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">shader</span><span class="p">.</span><span class="n">setMat4</span><span class="p">(</span><span class="s">&#34;model&#34;</span><span class="p">,</span> <span class="n">model</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="n">RenderQuad</span><span class="p">();</span></span></span></code></pre></div><p>Which indeed looks like proper normal mapping:</p>
<p><a href="#R-image-783b686b7d0df7f0a1aa7c7d0d4a0908" class="lightbox-link"><img src="./assets/normal_mapping_correct_tangent.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-783b686b7d0df7f0a1aa7c7d0d4a0908"><img src="./assets/normal_mapping_correct_tangent.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>You can find the source code <a href="https://learnopengl.com/code_viewer_gh.php?code=src/5.advanced_lighting/4.normal_mapping/normal_mapping.cpp" target="_blank">here</a>.</p>
<h4 id="complex-objects">Complex objects</h4>
<p>We&rsquo;ve demonstrated how we can use normal mapping, together with tangent space transformations, by manually calculating the tangent and bitangent vectors. Luckily for us, having to manually calculate these tangent and bitangent vectors is not something we do too often. Most of the time you implement it once in a custom model loader, or in our case use a <a href="https://learnopengl.com/Model-Loading/Assimp" target="_blank">model loader</a> using Assimp.</p>
<p>Assimp has a very useful configuration bit we can set when loading a model called aiProcess_CalcTangentSpace. When the aiProcess_CalcTangentSpace bit is supplied to Assimp&rsquo;s ReadFile function, Assimp calculates smooth tangent and bitangent vectors for each of the loaded vertices, similarly to how we did it in this chapter.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">const</span> <span class="n">aiScene</span> <span class="o">*</span><span class="n">scene</span> <span class="o">=</span> <span class="n">importer</span><span class="p">.</span><span class="n">ReadFile</span><span class="p">(</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">    <span class="n">path</span><span class="p">,</span> <span class="n">aiProcess_Triangulate</span> <span class="o">|</span> <span class="n">aiProcess_FlipUVs</span> <span class="o">|</span> <span class="n">aiProcess_CalcTangentSpace</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="p">);</span>  
</span></span></code></pre></div><p>Within Assimp we can then retrieve the calculated tangents via:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">vector</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">-&gt;</span><span class="n">mTangents</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">vector</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">-&gt;</span><span class="n">mTangents</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">vector</span><span class="p">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">-&gt;</span><span class="n">mTangents</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">z</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="n">vertex</span><span class="p">.</span><span class="n">Tangent</span> <span class="o">=</span> <span class="n">vector</span><span class="p">;</span>  
</span></span></code></pre></div><p>Then you&rsquo;ll have to update the model loader to also load normal maps from a textured model. The wavefront object format (.obj) exports normal maps slightly different from Assimp&rsquo;s conventions as aiTextureType_NORMAL doesn&rsquo;t load normal maps, while aiTextureType_HEIGHT does:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="n">Texture</span><span class="o">&gt;</span> <span class="n">normalMaps</span> <span class="o">=</span> <span class="n">loadMaterialTextures</span><span class="p">(</span><span class="n">material</span><span class="p">,</span> <span class="n">aiTextureType_HEIGHT</span><span class="p">,</span> <span class="s">&#34;texture_normal&#34;</span><span class="p">);</span>  
</span></span></code></pre></div><p>Of course, this is different for each type of loaded model and file format.</p>
<p>Running the application on a model with specular and normal maps, using an updated model loader, gives the following result:</p>
<p><a href="#R-image-643d676ccdce344794836193b9f338ac" class="lightbox-link"><img src="./assets/normal_mapping_complex_compare.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-643d676ccdce344794836193b9f338ac"><img src="./assets/normal_mapping_complex_compare.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>As you can see, normal mapping boosts the detail of an object by an incredible amount without too much extra cost.</p>
<p>Using normal maps is also a great way to boost performance. Before normal mapping, you had to use a large number of vertices to get a high number of detail on a mesh. With normal mapping, we can get the same level of detail on a mesh using a lot less vertices. The image below from Paolo Cignoni shows a nice comparison of both methods:</p>
<p><a href="#R-image-dad611406525a045528101dcb9a62d0e" class="lightbox-link"><img src="./assets/normal_mapping_comparison.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-dad611406525a045528101dcb9a62d0e"><img src="./assets/normal_mapping_comparison.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>The details on both the high-vertex mesh and the low-vertex mesh with normal mapping are almost indistinguishable. So normal mapping doesn&rsquo;t only look nice, it&rsquo;s a great tool to replace high-vertex meshes with low-vertex meshes without losing (too much) detail.</p>
<h4 id="one-last-thing-2">One last thing</h4>
<p>There is one last trick left to discuss that slightly improves quality without too much extra cost.</p>
<p>When tangent vectors are calculated on larger meshes that share a considerable amount of vertices, the tangent vectors are generally averaged to give nice and smooth results. A problem with this approach is that the three TBN vectors could end up non-perpendicular, which means the resulting TBN matrix would no longer be orthogonal. Normal mapping would only be slightly off with a non-orthogonal TBN matrix, but it&rsquo;s still something we can improve.</p>
<p>Using a mathematical trick called the Gram-Schmidt process, we can re-orthogonalize the TBN vectors such that each vector is again perpendicular to the other vectors. Within the vertex shader we would do it like this:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">vec3</span> <span class="n">T</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">vec3</span><span class="p">(</span><span class="n">model</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">aTangent</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)));</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">vec3</span> <span class="n">N</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">vec3</span><span class="p">(</span><span class="n">model</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">aNormal</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)));</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="c1">// re-orthogonalize T with respect to N
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="c1"></span><span class="n">T</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">T</span> <span class="o">-</span> <span class="n">dot</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span> <span class="o">*</span> <span class="n">N</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="c1">// then retrieve perpendicular vector B with the cross product of T and N
</span></span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="c1"></span><span class="n">vec3</span> <span class="n">B</span> <span class="o">=</span> <span class="n">cross</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">T</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl">
</span></span><span class="line"><span class="ln">8</span><span class="cl"><span class="n">mat3</span> <span class="n">TBN</span> <span class="o">=</span> <span class="n">mat3</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>  
</span></span></code></pre></div><p>This, albeit by a little, generally improves the normal mapping results with a little extra cost. Take a look at the end of the <em>Normal Mapping Mathematics</em> video in the additional resources for a great explanation of how this process actually works.</p>
<h4 id="additional-resources-6">Additional resources</h4>
<ul>
<li><a href="http://ogldev.atspace.co.uk/www/tutorial26/tutorial26.html" target="_blank">Tutorial 26: Normal Mapping</a>: normal mapping tutorial by ogldev.</li>
<li><a href="https://www.youtube.com/watch?v=LIOPYmknj5Q" target="_blank">How Normal Mapping Works</a>: a nice video tutorial of how normal mapping works by TheBennyBox.</li>
<li><a href="https://www.youtube.com/watch?v=4FaWLgsctqY" target="_blank">Normal Mapping Mathematics</a>: a similar video by TheBennyBox about the mathematics behind normal mapping.</li>
<li><a href="http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-13-normal-mapping/" target="_blank">Tutorial 13: Normal Mapping</a>: normal mapping tutorial by opengl-tutorial.org.</li>
</ul>
<h3 id="parallax-mapping">Parallax Mapping</h3>
<p>Parallax mapping is a technique similar to normal mapping, but based on different principles. Just like normal mapping it is a technique that significantly boosts a textured surface&rsquo;s detail and gives it a sense of depth. While also an illusion, parallax mapping is a lot better in conveying a sense of depth and together with normal mapping gives incredibly realistic results. While parallax mapping isn&rsquo;t necessarily a technique directly related to (advanced) lighting, I&rsquo;ll still discuss it here as the technique is a logical follow-up of normal mapping. Note that getting an understanding of normal mapping, specifically tangent space, is strongly advised before learning parallax mapping.</p>
<p>Parallax mapping is closely related to the family of displacement mapping techniques that <em>displace</em> or <em>offset</em> vertices based on geometrical information stored inside a texture. One way to do this, is to take a plane with roughly 1000 vertices and displace each of these vertices based on a value in a texture that tells us the height of the plane at that specific area. Such a texture that contains height values per texel is called a height map. An example height map derived from the geometric properties of a simple brick surface looks a bit like this:</p>
<p><a href="#R-image-fdc527242b280a6c3711050b90059bca" class="lightbox-link"><img src="./assets/parallax_mapping_height_map.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-fdc527242b280a6c3711050b90059bca"><img src="./assets/parallax_mapping_height_map.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>When spanned over a plane, each vertex is displaced based on the sampled height value in the height map, transforming a flat plane to a rough bumpy surface based on a material&rsquo;s geometric properties. For instance, taking a flat plane displaced with the above heightmap results in the following image:</p>
<p><a href="#R-image-8529ad2a6387d7c72bc60f706a391892" class="lightbox-link"><img src="./assets/parallax_mapping_plane_heightmap.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-8529ad2a6387d7c72bc60f706a391892"><img src="./assets/parallax_mapping_plane_heightmap.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>A problem with displacing vertices this way is that a plane needs to contain a huge amount of triangles to get a realistic displacement, otherwise the displacement looks too blocky. As each flat surface may then require over 10000 vertices this quickly becomes computationally infeasible. What if we could somehow achieve similar realism without the need of extra vertices? In fact, what if I were to tell you that the previously shown displaced surface is actually rendered with only 2 triangles. This brick surface shown is rendered with parallax mapping, a displacement mapping technique that doesn&rsquo;t require extra vertex data to convey depth, but (similar to normal mapping) uses a clever technique to trick the user.</p>
<p>The idea behind parallax mapping is to alter the texture coordinates in such a way that it looks like a fragment&rsquo;s surface is higher or lower than it actually is, all based on the view direction and a heightmap. To understand how it works, take a look at the following image of our brick surface:</p>
<p><a href="#R-image-48cd0adcb10c0daf54698049a3e43ba3" class="lightbox-link"><img src="./assets/parallax_mapping_plane_height.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-48cd0adcb10c0daf54698049a3e43ba3"><img src="./assets/parallax_mapping_plane_height.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Here the rough red line represents the values in the heightmap as the geometric surface representation of the brick surface and the vector 
<span class="math align-center">$\color{orange}{\bar{V}}$</span> represents the surface to view direction (viewDir). If the plane would have actual displacement, the viewer would see the surface at point 
<span class="math align-center">$\color{blue}B$</span>. However, as our plane has no actual displacement the view direction is calculated from point 
<span class="math align-center">$\color{green}A$</span> as we&rsquo;d expect. Parallax mapping aims to offset the texture coordinates at fragment position 
<span class="math align-center">$\color{green}A$</span> in such a way that we get texture coordinates at point 
<span class="math align-center">$\color{blue}B$</span>. We then use the texture coordinates at point 
<span class="math align-center">$\color{blue}B$</span> for all subsequent texture samples, making it look like the viewer is actually looking at point 
<span class="math align-center">$\color{blue}B$</span>.</p>
<p>The trick is to figure out how to get the texture coordinates at point 
<span class="math align-center">$\color{blue}B$</span> from point 
<span class="math align-center">$\color{green}A$</span>. Parallax mapping tries to solve this by scaling the fragment-to-view direction vector 
<span class="math align-center">$\color{orange}{\bar{V}}$</span> by the height at fragment 
<span class="math align-center">$\color{green}A$</span>. So we&rsquo;re scaling the length of 
<span class="math align-center">$\color{orange}{\bar{V}}$</span> to be equal to a sampled value from the heightmap 
<span class="math align-center">$\color{green}{H(A)}$</span> at fragment position 
<span class="math align-center">$\color{green}A$</span>. The image below shows this scaled vector 
<span class="math align-center">$\color{brown}{\bar{P}}$</span>:</p>
<p><a href="#R-image-025b2dfdf28be06411d65be1519d5b84" class="lightbox-link"><img src="./assets/parallax_mapping_scaled_height.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-025b2dfdf28be06411d65be1519d5b84"><img src="./assets/parallax_mapping_scaled_height.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>We then take this vector 
<span class="math align-center">$\color{brown}{\bar{P}}$</span> and take its vector coordinates that align with the plane as the texture coordinate offset. This works because vector 
<span class="math align-center">$\color{brown}{\bar{P}}$</span> is calculated using a height value from the heightmap. So the higher a fragment&rsquo;s height, the more it effectively gets displaced.</p>
<p>This little trick gives good results most of the time, but it is still a really crude approximation to get to point 
<span class="math align-center">$\color{blue}B$</span>. When heights change rapidly over a surface the results tend to look unrealistic as the vector 
<span class="math align-center">$\color{brown}{\bar{P}}$</span> will not end up close to 
<span class="math align-center">$\color{blue}B$</span> as you can see below:</p>
<p><a href="#R-image-34e870c9a527ae0c5610c9bddbaa25b6" class="lightbox-link"><img src="./assets/parallax_mapping_incorrect_p.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-34e870c9a527ae0c5610c9bddbaa25b6"><img src="./assets/parallax_mapping_incorrect_p.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Another issue with parallax mapping is that it&rsquo;s difficult to figure out which coordinates to retrieve from 
<span class="math align-center">$\color{brown}{\bar{P}}$</span> when the surface is arbitrarily rotated in some way. We&rsquo;d rather do this in a different coordinate space where the <code>x</code> and <code>y</code> component of vector 
<span class="math align-center">$\color{brown}{\bar{P}}$</span> always align with the texture&rsquo;s surface. If you&rsquo;ve followed along in the <a href="https://learnopengl.com/Advanced-Lighting/Normal-Mapping" target="_blank">normal mapping</a> chapter you probably guessed how we can accomplish this. And yes, we would like to do parallax mapping in tangent space.</p>
<p>By transforming the fragment-to-view direction vector 
<span class="math align-center">$\color{orange}{\bar{V}}$</span> to tangent space, the transformed 
<span class="math align-center">$\color{brown}{\bar{P}}$</span> vector will have its <code>x</code> and <code>y</code> component aligned to the surface&rsquo;s tangent and bitangent vectors. As the tangent and bitangent vectors are pointing in the same direction as the surface&rsquo;s texture coordinates we can take the <code>x</code> and <code>y</code> components of 
<span class="math align-center">$\color{brown}{\bar{P}}$</span> as the texture coordinate offset, regardless of the surface&rsquo;s orientation.</p>
<p>But enough about the theory, let&rsquo;s get our feet wet and start implementing actual parallax mapping.</p>
<h4 id="parallax-mapping-1">Parallax mapping</h4>
<p>For parallax mapping we&rsquo;re going to use a simple 2D plane for which we calculated its tangent and bitangent vectors before sending it to the GPU; similar to what we did in the normal mapping chapter. Onto the plane we&rsquo;re going to attach a <a href="https://learnopengl.com/img/textures/bricks2.jpg" target="_blank">diffuse texture</a>, a <a href="https://learnopengl.com/img/textures/bricks2_normal.jpg" target="_blank">normal map</a>, and a <a href="https://learnopengl.com/img/textures/bricks2_disp.jpg" target="_blank">displacement map</a> that you can download from their urls. For this example we&rsquo;re going to use parallax mapping in conjunction with normal mapping. Because parallax mapping gives the illusion of displacing a surface, the illusion breaks when the lighting doesn&rsquo;t match. As normal maps are often generated from heightmaps, using a normal map together with the heightmap makes sure the lighting is in place with the displacement.</p>
<p>You may have already noted that the displacement map linked above is the inverse of the heightmap shown at the start of this chapter. With parallax mapping it makes more sense to use the inverse of the heightmap as it&rsquo;s easier to fake depth than height on flat surfaces. This slightly changes how we perceive parallax mapping as shown below:</p>
<p><a href="#R-image-f5b190325ec70a6c6f20601a77593eb2" class="lightbox-link"><img src="./assets/parallax_mapping_depth.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f5b190325ec70a6c6f20601a77593eb2"><img src="./assets/parallax_mapping_depth.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>We again have a points 
<span class="math align-center">$\color{green}A$</span> and B�, but this time we obtain vector 
<span class="math align-center">$\color{brown}{\bar{P}}$</span> by <strong>subtracting</strong> vector 
<span class="math align-center">$\color{orange}{\bar{V}}$</span> from the texture coordinates at point 
<span class="math align-center">$\color{green}A$</span>. We can obtain depth values instead of height values by subtracting the sampled heightmap values from <code>1.0</code> in the shaders, or by simply inversing its texture values in image-editing software as we did with the depthmap linked above.</p>
<p>Parallax mapping is implemented in the fragment shader as the displacement effect is different all over a triangle&rsquo;s surface. In the fragment shader we&rsquo;re then going to need to calculate the fragment-to-view direction vector 
<span class="math align-center">$\color{orange}{\bar{V}}$</span> so we need the view position and a fragment position in tangent space. In the normal mapping chapter we already had a vertex shader that sends these vectors in tangent space so we can take an exact copy of that chapter&rsquo;s vertex shader:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">aPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">aNormal</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec2</span> <span class="n">aTexCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">aTangent</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">4</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">aBitangent</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="n">out</span> <span class="n">VS_OUT</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="n">vec3</span> <span class="n">FragPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="n">vec2</span> <span class="n">TexCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="n">vec3</span> <span class="n">TangentLightPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="n">vec3</span> <span class="n">TangentViewPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="n">vec3</span> <span class="n">TangentFragPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="p">}</span> <span class="n">vs_out</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">
</span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="n">uniform</span> <span class="n">mat4</span> <span class="n">projection</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="n">uniform</span> <span class="n">mat4</span> <span class="n">view</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="n">uniform</span> <span class="n">mat4</span> <span class="n">model</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">
</span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="n">uniform</span> <span class="n">vec3</span> <span class="n">lightPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="n">uniform</span> <span class="n">vec3</span> <span class="n">viewPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">
</span></span><span class="line"><span class="ln">23</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl">    <span class="n">gl_Position</span>      <span class="o">=</span> <span class="n">projection</span> <span class="o">*</span> <span class="n">view</span> <span class="o">*</span> <span class="n">model</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">aPos</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl">    <span class="n">vs_out</span><span class="p">.</span><span class="n">FragPos</span>   <span class="o">=</span> <span class="n">vec3</span><span class="p">(</span><span class="n">model</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">aPos</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">));</span>   
</span></span><span class="line"><span class="ln">27</span><span class="cl">    <span class="n">vs_out</span><span class="p">.</span><span class="n">TexCoords</span> <span class="o">=</span> <span class="n">aTexCoords</span><span class="p">;</span>    
</span></span><span class="line"><span class="ln">28</span><span class="cl">    
</span></span><span class="line"><span class="ln">29</span><span class="cl">    <span class="n">vec3</span> <span class="n">T</span>   <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">mat3</span><span class="p">(</span><span class="n">model</span><span class="p">)</span> <span class="o">*</span> <span class="n">aTangent</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">30</span><span class="cl">    <span class="n">vec3</span> <span class="n">B</span>   <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">mat3</span><span class="p">(</span><span class="n">model</span><span class="p">)</span> <span class="o">*</span> <span class="n">aBitangent</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">31</span><span class="cl">    <span class="n">vec3</span> <span class="n">N</span>   <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">mat3</span><span class="p">(</span><span class="n">model</span><span class="p">)</span> <span class="o">*</span> <span class="n">aNormal</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">32</span><span class="cl">    <span class="n">mat3</span> <span class="n">TBN</span> <span class="o">=</span> <span class="n">transpose</span><span class="p">(</span><span class="n">mat3</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">N</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">33</span><span class="cl">
</span></span><span class="line"><span class="ln">34</span><span class="cl">    <span class="n">vs_out</span><span class="p">.</span><span class="n">TangentLightPos</span> <span class="o">=</span> <span class="n">TBN</span> <span class="o">*</span> <span class="n">lightPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">35</span><span class="cl">    <span class="n">vs_out</span><span class="p">.</span><span class="n">TangentViewPos</span>  <span class="o">=</span> <span class="n">TBN</span> <span class="o">*</span> <span class="n">viewPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">36</span><span class="cl">    <span class="n">vs_out</span><span class="p">.</span><span class="n">TangentFragPos</span>  <span class="o">=</span> <span class="n">TBN</span> <span class="o">*</span> <span class="n">vs_out</span><span class="p">.</span><span class="n">FragPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">37</span><span class="cl"><span class="p">}</span>   
</span></span></code></pre></div><p>Within the fragment shader we then implement the parallax mapping logic. The fragment shader looks a bit like this:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">out</span> <span class="n">vec4</span> <span class="n">FragColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">in</span> <span class="n">VS_OUT</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="n">vec3</span> <span class="n">FragPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="n">vec2</span> <span class="n">TexCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="n">vec3</span> <span class="n">TangentLightPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="n">vec3</span> <span class="n">TangentViewPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="n">vec3</span> <span class="n">TangentFragPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="p">}</span> <span class="n">fs_in</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">diffuseMap</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">normalMap</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">depthMap</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">  
</span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="n">uniform</span> <span class="kt">float</span> <span class="n">height_scale</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">  
</span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="n">vec2</span> <span class="nf">ParallaxMapping</span><span class="p">(</span><span class="n">vec2</span> <span class="n">texCoords</span><span class="p">,</span> <span class="n">vec3</span> <span class="n">viewDir</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">  
</span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="p">{</span>           
</span></span><span class="line"><span class="ln">22</span><span class="cl">    <span class="c1">// offset texture coordinates with Parallax Mapping
</span></span></span><span class="line"><span class="ln">23</span><span class="cl"><span class="c1"></span>    <span class="n">vec3</span> <span class="n">viewDir</span>   <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">fs_in</span><span class="p">.</span><span class="n">TangentViewPos</span> <span class="o">-</span> <span class="n">fs_in</span><span class="p">.</span><span class="n">TangentFragPos</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">    <span class="n">vec2</span> <span class="n">texCoords</span> <span class="o">=</span> <span class="n">ParallaxMapping</span><span class="p">(</span><span class="n">fs_in</span><span class="p">.</span><span class="n">TexCoords</span><span class="p">,</span>  <span class="n">viewDir</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl">
</span></span><span class="line"><span class="ln">26</span><span class="cl">    <span class="c1">// then sample textures with new texture coords
</span></span></span><span class="line"><span class="ln">27</span><span class="cl"><span class="c1"></span>    <span class="n">vec3</span> <span class="n">diffuse</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">diffuseMap</span><span class="p">,</span> <span class="n">texCoords</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">28</span><span class="cl">    <span class="n">vec3</span> <span class="n">normal</span>  <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">normalMap</span><span class="p">,</span> <span class="n">texCoords</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">29</span><span class="cl">    <span class="n">normal</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">normal</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">30</span><span class="cl">    <span class="c1">// proceed with lighting code
</span></span></span><span class="line"><span class="ln">31</span><span class="cl"><span class="c1"></span>    <span class="p">[...]</span>    
</span></span><span class="line"><span class="ln">32</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">33</span><span class="cl">  
</span></span></code></pre></div><p>We defined a function called ParallaxMapping that takes as input the fragment&rsquo;s texture coordinates and the fragment-to-view direction 
<span class="math align-center">$\color{orange}{\bar{V}}$</span> in tangent space. The function returns the displaced texture coordinates. We then use these <em>displaced</em> texture coordinates as the texture coordinates for sampling the diffuse and normal map. As a result, the fragment&rsquo;s diffuse and normal vector correctly corresponds to the surface&rsquo;s displaced geometry.</p>
<p>Let&rsquo;s take a look inside the ParallaxMapping function:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">vec2</span> <span class="nf">ParallaxMapping</span><span class="p">(</span><span class="n">vec2</span> <span class="n">texCoords</span><span class="p">,</span> <span class="n">vec3</span> <span class="n">viewDir</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="kt">float</span> <span class="n">height</span> <span class="o">=</span>  <span class="n">texture</span><span class="p">(</span><span class="n">depthMap</span><span class="p">,</span> <span class="n">texCoords</span><span class="p">).</span><span class="n">r</span><span class="p">;</span>    
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="n">vec2</span> <span class="n">p</span> <span class="o">=</span> <span class="n">viewDir</span><span class="p">.</span><span class="n">xy</span> <span class="o">/</span> <span class="n">viewDir</span><span class="p">.</span><span class="n">z</span> <span class="o">*</span> <span class="p">(</span><span class="n">height</span> <span class="o">*</span> <span class="n">height_scale</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">    <span class="k">return</span> <span class="n">texCoords</span> <span class="o">-</span> <span class="n">p</span><span class="p">;</span>    
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="p">}</span> 
</span></span></code></pre></div><p>This relatively simple function is a direct translation of what we&rsquo;ve discussed so far. We take the original texture coordinates texCoords and use these to sample the height (or depth) from the depthMap at the current fragment 
<span class="math align-center">$\color{green}A$</span> as 
<span class="math align-center">$\color{green}{H(A)}$</span>. We then calculate 
<span class="math align-center">$\color{brown}{\bar{P}}$</span> as the <code>x</code> and <code>y</code> component of the tangent-space viewDir vector divided by its <code>z</code> component and scaled by 
<span class="math align-center">$\color{green}{H(A)}$</span>. We also introduced a height_scale uniform for some extra control as the parallax effect is usually too strong without an extra scale parameter. We then subtract this vector 
<span class="math align-center">$\color{brown}{\bar{P}}$</span> from the texture coordinates to get the final displaced texture coordinates.</p>
<p>What is interesting to note here is the division of viewDir.xy by viewDir.z. As the viewDir vector is normalized, viewDir.z will be somewhere in the range between <code>0.0</code> and <code>1.0</code>. When viewDir is largely parallel to the surface, its <code>z</code> component is close to <code>0.0</code> and the division returns a much larger vector 
<span class="math align-center">$\color{brown}{\bar{P}}$</span> compared to when viewDir is largely perpendicular to the surface. We&rsquo;re adjusting the size of 
<span class="math align-center">$\color{brown}{\bar{P}}$</span> in such a way that it offsets the texture coordinates at a larger scale when looking at a surface from an angle compared to when looking at it from the top; this gives more realistic results at angles.
Some prefer to leave the division by viewDir.z out of the equation as default Parallax Mapping could produce undesirable results at angles; the technique is then called Parallax Mapping with Offset Limiting. Choosing which technique to pick is usually a matter of personal preference.</p>
<p>The resulting texture coordinates are then used to sample the other textures (diffuse and normal) and this gives a very neat displaced effect as you can see below with a height_scale of roughly <code>0.1</code>:</p>
<p><a href="#R-image-818b408a3f5ea51542b66663513fd1e3" class="lightbox-link"><img src="./assets/parallax_mapping.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-818b408a3f5ea51542b66663513fd1e3"><img src="./assets/parallax_mapping.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Here you can see the difference between normal mapping and parallax mapping combined with normal mapping. Because parallax mapping tries to simulate depth it is actually possible to have bricks overlap other bricks based on the direction you view them.</p>
<p>You can still see a few weird border artifacts at the edge of the parallax mapped plane. This happens because at the edges of the plane the displaced texture coordinates can oversample outside the range [<code>0</code>, <code>1</code>]. This gives unrealistic results based on the texture&rsquo;s wrapping mode(s). A cool trick to solve this issue is to discard the fragment whenever it samples outside the default texture coordinate range:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">texCoords</span> <span class="o">=</span> <span class="n">ParallaxMapping</span><span class="p">(</span><span class="n">fs_in</span><span class="p">.</span><span class="n">TexCoords</span><span class="p">,</span>  <span class="n">viewDir</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="k">if</span><span class="p">(</span><span class="n">texCoords</span><span class="p">.</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mf">1.0</span> <span class="o">||</span> <span class="n">texCoords</span><span class="p">.</span><span class="n">y</span> <span class="o">&gt;</span> <span class="mf">1.0</span> <span class="o">||</span> <span class="n">texCoords</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mf">0.0</span> <span class="o">||</span> <span class="n">texCoords</span><span class="p">.</span><span class="n">y</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="n">discard</span><span class="p">;</span></span></span></code></pre></div><p>All fragments with (displaced) texture coordinates outside the default range are discarded and Parallax Mapping then gives proper result around the edges of a surface. Note that this trick doesn&rsquo;t work on all types of surfaces, but when applied to a plane it gives great results:</p>
<p><a href="#R-image-747aefb84467907643087cd249ea87ed" class="lightbox-link"><img src="./assets/parallax_mapping_edge_fix.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-747aefb84467907643087cd249ea87ed"><img src="./assets/parallax_mapping_edge_fix.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>You can find the source code <a href="https://learnopengl.com/code_viewer_gh.php?code=src/5.advanced_lighting/5.1.parallax_mapping/parallax_mapping.cpp" target="_blank">here</a>.</p>
<p>It looks great and is quite fast as well as we only need a single extra texture sample for parallax mapping to work. It does come with a few issues though as it sort of breaks down when looking at it from an angle (similar to normal mapping) and gives incorrect results with steep height changes, as you can see below:</p>
<p><a href="#R-image-0297375eeadb6a9e0139dc4545cb659a" class="lightbox-link"><img src="./assets/parallax_mapping_issues.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-0297375eeadb6a9e0139dc4545cb659a"><img src="./assets/parallax_mapping_issues.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>The reason that it doesn&rsquo;t work properly at times is that it&rsquo;s just a crude approximation of displacement mapping. There are some extra tricks however that still allows us to get almost perfect results with steep height changes, even when looking at an angle. For instance, what if we instead of one sample take multiple samples to find the closest point to 
<span class="math align-center">$\color{blue}B$</span>?</p>
<h4 id="steep-parallax-mapping">Steep Parallax Mapping</h4>
<p>Steep Parallax Mapping is an extension on top of Parallax Mapping in that it uses the same principles, but instead of 1 sample it takes multiple samples to better pinpoint vector 
<span class="math align-center">$\color{brown}{\bar{P}}$</span> to 
<span class="math align-center">$\color{blue}B$</span>. This gives much better results, even with steep height changes, as the accuracy of the technique is improved by the number of samples.</p>
<p>The general idea of Steep Parallax Mapping is that it divides the total depth range into multiple layers of the same height/depth. For each of these layers we sample the depthmap, shifting the texture coordinates along the direction of 
<span class="math align-center">$\color{brown}{\bar{P}}$</span>, until we find a sampled depth value that is less than the depth value of the current layer. Take a look at the following image:</p>
<p><a href="#R-image-9a6242155d3cd3c3ccd3751646f583cb" class="lightbox-link"><img src="./assets/parallax_mapping_steep_parallax_mapping_diagram.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-9a6242155d3cd3c3ccd3751646f583cb"><img src="./assets/parallax_mapping_steep_parallax_mapping_diagram.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>We traverse the depth layers from the top down and for each layer we compare its depth value to the depth value stored in the depthmap. If the layer&rsquo;s depth value is less than the depthmap&rsquo;s value it means this layer&rsquo;s part of vector 
<span class="math align-center">$\color{brown}{\bar{P}}$</span> is not below the surface. We continue this process until the layer&rsquo;s depth is higher than the value stored in the depthmap: this point is then below the (displaced) geometric surface.</p>
<p>In this example we can see that the depthmap value at the second layer (D(2) = 0.73) is lower than the second layer&rsquo;s depth value <code>0.4</code> so we continue. In the next iteration, the layer&rsquo;s depth value <code>0.6</code> is higher than the depthmap&rsquo;s sampled depth value (D(3) = 0.37). We can thus assume vector 
<span class="math align-center">$\color{brown}{\bar{P}}$</span> at the third layer to be the most viable position of the displaced geometry. We then take the texture coordinate offset 
<span class="math align-center">$T_3$</span> from vector 
<span class="math align-center">$\color{brown}{\bar{P_3}}$</span> to displace the fragment&rsquo;s texture coordinates. You can see how the accuracy increases with more depth layers.</p>
<p>To implement this technique we only have to change the ParallaxMapping function as we already have all the variables we need:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">vec2</span> <span class="nf">ParallaxMapping</span><span class="p">(</span><span class="n">vec2</span> <span class="n">texCoords</span><span class="p">,</span> <span class="n">vec3</span> <span class="n">viewDir</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="c1">// number of depth layers
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1"></span>    <span class="k">const</span> <span class="kt">float</span> <span class="n">numLayers</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="c1">// calculate the size of each layer
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="c1"></span>    <span class="kt">float</span> <span class="n">layerDepth</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">numLayers</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="c1">// depth of current layer
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="c1"></span>    <span class="kt">float</span> <span class="n">currentLayerDepth</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="c1">// the amount to shift the texture coordinates per layer (from vector P)
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1"></span>    <span class="n">vec2</span> <span class="n">P</span> <span class="o">=</span> <span class="n">viewDir</span><span class="p">.</span><span class="n">xy</span> <span class="o">*</span> <span class="n">height_scale</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="n">vec2</span> <span class="n">deltaTexCoords</span> <span class="o">=</span> <span class="n">P</span> <span class="o">/</span> <span class="n">numLayers</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">  
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="p">[...]</span>     
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="p">}</span>   
</span></span></code></pre></div><p>Here we first set things up: we specify the number of layers, calculate the depth offset of each layer, and finally calculate the texture coordinate offset that we have to shift along the direction of 
<span class="math align-center">$\color{brown}{\bar{P}}$</span> per layer.</p>
<p>We then iterate through all the layers, starting from the top, until we find a depthmap value less than the layer&rsquo;s depth value:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="c1">// get initial values
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1"></span><span class="n">vec2</span>  <span class="n">currentTexCoords</span>     <span class="o">=</span> <span class="n">texCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="kt">float</span> <span class="n">currentDepthMapValue</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">depthMap</span><span class="p">,</span> <span class="n">currentTexCoords</span><span class="p">).</span><span class="n">r</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="k">while</span><span class="p">(</span><span class="n">currentLayerDepth</span> <span class="o">&lt;</span> <span class="n">currentDepthMapValue</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="c1">// shift texture coordinates along direction of P
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="c1"></span>    <span class="n">currentTexCoords</span> <span class="o">-=</span> <span class="n">deltaTexCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="c1">// get depthmap value at current texture coordinates
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1"></span>    <span class="n">currentDepthMapValue</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">depthMap</span><span class="p">,</span> <span class="n">currentTexCoords</span><span class="p">).</span><span class="n">r</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="c1">// get depth of next layer
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="c1"></span>    <span class="n">currentLayerDepth</span> <span class="o">+=</span> <span class="n">layerDepth</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="k">return</span> <span class="n">currentTexCoords</span><span class="p">;</span></span></span></code></pre></div><p>Here we loop over each depth layer and stop until we find the texture coordinate offset along vector 
<span class="math align-center">$\color{brown}{\bar{P}}$</span> that first returns a depth that&rsquo;s below the (displaced) surface. The resulting offset is subtracted from the fragment&rsquo;s texture coordinates to get a final displaced texture coordinate vector, this time with much more accuracy compared to traditional parallax mapping.</p>
<p>With around <code>10</code> samples the brick surface already looks more viable even when looking at it from an angle, but steep parallax mapping really shines when having a complex surface with steep height changes; like the earlier displayed wooden toy surface:</p>
<p><a href="#R-image-a48b32ea1b5834fe416e6c9c4c66a382" class="lightbox-link"><img src="./assets/parallax_mapping_steep_parallax_mapping.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a48b32ea1b5834fe416e6c9c4c66a382"><img src="./assets/parallax_mapping_steep_parallax_mapping.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>We can improve the algorithm a bit by exploiting one of Parallax Mapping&rsquo;s properties. When looking straight onto a surface there isn&rsquo;t much texture displacement going on while there is a lot of displacement when looking at a surface from an angle (visualize the view direction on both cases). By taking less samples when looking straight at a surface and more samples when looking at an angle we only sample the necessary amount:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">const</span> <span class="kt">float</span> <span class="n">minLayers</span> <span class="o">=</span> <span class="mf">8.0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="k">const</span> <span class="kt">float</span> <span class="n">maxLayers</span> <span class="o">=</span> <span class="mf">32.0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="kt">float</span> <span class="n">numLayers</span> <span class="o">=</span> <span class="n">mix</span><span class="p">(</span><span class="n">maxLayers</span><span class="p">,</span> <span class="n">minLayers</span><span class="p">,</span> <span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span> <span class="n">viewDir</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">));</span>  
</span></span></code></pre></div><p>Here we take the dot product of viewDir and the positive z direction and use its result to align the number of samples to minLayers or maxLayers based on the angle we&rsquo;re looking towards a surface (note that the positive z direction equals the surface&rsquo;s normal vector in tangent space). If we were to look at a direction parallel to the surface we&rsquo;d use a total of <code>32</code> layers.</p>
<p>You can find the updated source code <a href="https://learnopengl.com/code_viewer_gh.php?code=src/5.advanced_lighting/5.2.steep_parallax_mapping/steep_parallax_mapping.cpp" target="_blank">here</a>. You can also find the wooden toy box surface here: <a href="https://learnopengl.com/img/textures/wood.png" target="_blank">diffuse</a>, <a href="https://learnopengl.com/img/textures/toy_box_normal.png" target="_blank">normal</a> and <a href="https://learnopengl.com/img/textures/toy_box_disp.png" target="_blank">depth</a>.</p>
<p>Steep Parallax Mapping also comes with its problems though. Because the technique is based on a finite number of samples, we get aliasing effects and the clear distinctions between layers can easily be spotted:</p>
<p><a href="#R-image-5f20393b3e24ca8447727be21f7f4534" class="lightbox-link"><img src="./assets/parallax_mapping_steep_artifact.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-5f20393b3e24ca8447727be21f7f4534"><img src="./assets/parallax_mapping_steep_artifact.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>We can reduce the issue by taking a larger number of samples, but this quickly becomes too heavy a burden on performance. There are several approaches that aim to fix this issue by not taking the first position that&rsquo;s below the (displaced) surface, but by <em>interpolating</em> between the position&rsquo;s two closest depth layers to find a much closer match to 
<span class="math align-center">$\color{blue}B$</span>.</p>
<p>Two of the more popular of these approaches are called Relief Parallax Mapping and Parallax Occlusion Mapping of which Relief Parallax Mapping gives the most accurate results, but is also more performance heavy compared to Parallax Occlusion Mapping. Because Parallax Occlusion Mapping gives almost the same results as Relief Parallax Mapping and is also more efficient it is often the preferred approach.</p>
<h4 id="parallax-occlusion-mapping">Parallax Occlusion Mapping</h4>
<p>Parallax Occlusion Mapping is based on the same principles as Steep Parallax Mapping, but instead of taking the texture coordinates of the first depth layer after a collision, we&rsquo;re going to linearly interpolate between the depth layer after and before the collision. We base the weight of the linear interpolation on how far the surface&rsquo;s height is from the depth layer&rsquo;s value of both layers. Take a look at the following picture to get a grasp of how it works:</p>
<p><a href="#R-image-a178725a093ce23055abbfe8b9dca92b" class="lightbox-link"><img src="./assets/parallax_mapping_parallax_occlusion_mapping_diagram.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a178725a093ce23055abbfe8b9dca92b"><img src="./assets/parallax_mapping_parallax_occlusion_mapping_diagram.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>As you can see, it&rsquo;s largely similar to Steep Parallax Mapping with as an extra step the linear interpolation between the two depth layers&rsquo; texture coordinates surrounding the intersected point. This is again an approximation, but significantly more accurate than Steep Parallax Mapping.</p>
<p>The code for Parallax Occlusion Mapping is an extension on top of Steep Parallax Mapping and not too difficult:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="p">[...]</span> <span class="c1">// steep parallax mapping code here
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1"></span>  
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="c1">// get texture coordinates before collision (reverse operations)
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1"></span><span class="n">vec2</span> <span class="n">prevTexCoords</span> <span class="o">=</span> <span class="n">currentTexCoords</span> <span class="o">+</span> <span class="n">deltaTexCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="c1">// get depth after and before collision for linear interpolation
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1"></span><span class="kt">float</span> <span class="n">afterDepth</span>  <span class="o">=</span> <span class="n">currentDepthMapValue</span> <span class="o">-</span> <span class="n">currentLayerDepth</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="kt">float</span> <span class="n">beforeDepth</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">depthMap</span><span class="p">,</span> <span class="n">prevTexCoords</span><span class="p">).</span><span class="n">r</span> <span class="o">-</span> <span class="n">currentLayerDepth</span> <span class="o">+</span> <span class="n">layerDepth</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"> 
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1">// interpolation of texture coordinates
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="c1"></span><span class="kt">float</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">afterDepth</span> <span class="o">/</span> <span class="p">(</span><span class="n">afterDepth</span> <span class="o">-</span> <span class="n">beforeDepth</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="n">vec2</span> <span class="n">finalTexCoords</span> <span class="o">=</span> <span class="n">prevTexCoords</span> <span class="o">*</span> <span class="n">weight</span> <span class="o">+</span> <span class="n">currentTexCoords</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">weight</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="k">return</span> <span class="n">finalTexCoords</span><span class="p">;</span>  
</span></span></code></pre></div><p>After we found the depth layer after intersecting the (displaced) surface geometry, we also retrieve the texture coordinates of the depth layer before intersection. Then we calculate the distance of the (displaced) geometry&rsquo;s depth from the corresponding depth layers and interpolate between these two values. The linear interpolation is a basic interpolation between both layer&rsquo;s texture coordinates. The function then finally returns the final interpolated texture coordinates.</p>
<p>Parallax Occlusion Mapping gives surprisingly good results and although some slight artifacts and aliasing issues are still visible, it&rsquo;s a generally a good trade-off and only really visible when heavily zoomed in or looking at very steep angles.</p>
<p><a href="#R-image-5ab3a542d285b4e8b7aadc79861da069" class="lightbox-link"><img src="./assets/parallax_mapping_parallax_occlusion_mapping.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-5ab3a542d285b4e8b7aadc79861da069"><img src="./assets/parallax_mapping_parallax_occlusion_mapping.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>You can find the source code <a href="https://learnopengl.com/code_viewer_gh.php?code=src/5.advanced_lighting/5.3.parallax_occlusion_mapping/parallax_occlusion_mapping.cpp" target="_blank">here</a>.</p>
<p>Parallax Mapping is a great technique to boost the detail of your scene, but does come with a few artifacts you&rsquo;ll have to consider when using it. Most often, parallax mapping is used on floor or wall-like surfaces where it&rsquo;s not as easy to determine the surface&rsquo;s outline and the viewing angle is most often roughly perpendicular to the surface. This way, the artifacts of Parallax Mapping aren&rsquo;t as noticeable and make it an incredibly interesting technique for boosting your objects&rsquo; details.</p>
<h4 id="additional-resources-7">Additional resources</h4>
<ul>
<li><a href="http://sunandblackcat.com/tipFullView.php?topicid=28" target="_blank">Parallax Occlusion Mapping in GLSL</a>: great parallax mapping tutorial by sunandblackcat.com.</li>
<li><a href="https://www.youtube.com/watch?v=xvOT62L-fQI" target="_blank">How Parallax Displacement Mapping Works</a>: a nice video tutorial of how parallax mapping works by TheBennyBox.</li>
</ul>
<h3 id="hdr">HDR</h3>
<p>Brightness and color values, by default, are clamped between <code>0.0</code> and <code>1.0</code> when stored into a framebuffer. This, at first seemingly innocent, statement caused us to always specify light and color values somewhere in this range, trying to make them fit into the scene. This works oké and gives decent results, but what happens if we walk in a really bright area with multiple bright light sources that as a total sum exceed <code>1.0</code>? The answer is that all fragments that have a brightness or color sum over <code>1.0</code> get clamped to <code>1.0</code>, which isn&rsquo;t pretty to look at:</p>
<p><a href="#R-image-50ef42a3efb3ff9ea3e312b7c8706303" class="lightbox-link"><img src="./assets/hdr_clamped.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-50ef42a3efb3ff9ea3e312b7c8706303"><img src="./assets/hdr_clamped.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Due to a large number of fragments&rsquo; color values getting clamped to <code>1.0</code>, each of the bright fragments have the exact same white color value in large regions, losing a significant amount of detail and giving it a fake look.</p>
<p>A solution to this problem would be to reduce the strength of the light sources and ensure no area of fragments in your scene ends up brighter than <code>1.0</code>; this is not a good solution as this forces you to use unrealistic lighting parameters. A better approach is to allow color values to temporarily exceed <code>1.0</code> and transform them back to the original range of <code>0.0</code> and <code>1.0</code> as a final step, but without losing detail.</p>
<p>Monitors (non-HDR) are limited to display colors in the range of <code>0.0</code> and <code>1.0</code>, but there is no such limitation in lighting equations. By allowing fragment colors to exceed <code>1.0</code> we have a much higher range of color values available to work in known as high dynamic range (HDR). With high dynamic range, bright things can be really bright, dark things can be really dark, and details can be seen in both.</p>
<p>High dynamic range was originally only used for photography where a photographer takes multiple pictures of the same scene with varying exposure levels, capturing a large range of color values. Combining these forms a HDR image where a large range of details are visible based on the combined exposure levels, or a specific exposure it is viewed with. For instance, the following image (credits to Colin Smith) shows a lot of detail at brightly lit regions with a low exposure (look at the window), but these details are gone with a high exposure. However, a high exposure now reveals a great amount of detail at darker regions that weren&rsquo;t previously visible.</p>
<p><a href="#R-image-c200c6a5ee07c4765b5e1deb4201553c" class="lightbox-link"><img src="./assets/hdr_image.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c200c6a5ee07c4765b5e1deb4201553c"><img src="./assets/hdr_image.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>This is also very similar to how the human eye works and the basis of high dynamic range rendering. When there is little light, the human eye adapts itself so the darker parts become more visible and similarly for bright areas. It&rsquo;s like the human eye has an automatic exposure slider based on the scene&rsquo;s brightness.</p>
<p>High dynamic range rendering works a bit like that. We allow for a much larger range of color values to render to, collecting a large range of dark and bright details of a scene, and at the end we transform all the HDR values back to the low dynamic range (LDR) of [<code>0.0</code>, <code>1.0</code>]. This process of converting HDR values to LDR values is called tone mapping and a large collection of tone mapping algorithms exist that aim to preserve most HDR details during the conversion process. These tone mapping algorithms often involve an exposure parameter that selectively favors dark or bright regions.</p>
<p>When it comes to real-time rendering, high dynamic range allows us to not only exceed the LDR range of [<code>0.0</code>, <code>1.0</code>] and preserve more detail, but also gives us the ability to specify a light source&rsquo;s intensity by their <em>real</em> intensities. For instance, the sun has a much higher intensity than something like a flashlight so why not configure the sun as such (e.g. a diffuse brightness of <code>100.0</code>). This allows us to more properly configure a scene&rsquo;s lighting with more realistic lighting parameters, something that wouldn&rsquo;t be possible with LDR rendering as they&rsquo;d then directly get clamped to <code>1.0</code>.</p>
<p>As (non-HDR) monitors only display colors in the range between <code>0.0</code> and <code>1.0</code> we do need to transform the currently high dynamic range of color values back to the monitor&rsquo;s range. Simply re-transforming the colors back with a simple average wouldn&rsquo;t do us much good as brighter areas then become a lot more dominant. What we can do, is use different equations and/or curves to transform the HDR values back to LDR that give us complete control over the scene&rsquo;s brightness. This is the process earlier denoted as tone mapping and the final step of HDR rendering.</p>
<h4 id="floating-point-framebuffers">Floating point framebuffers</h4>
<p>To implement high dynamic range rendering we need some way to prevent color values getting clamped after each fragment shader run. When framebuffers use a normalized fixed-point color format (like GL_RGB) as their color buffer&rsquo;s internal format, OpenGL automatically clamps the values between <code>0.0</code> and <code>1.0</code> before storing them in the framebuffer. This operation holds for most types of framebuffer formats, except for floating point formats.</p>
<p>When the internal format of a framebuffer&rsquo;s color buffer is specified as GL_RGB16F, GL_RGBA16F, GL_RGB32F, or GL_RGBA32F the framebuffer is known as a floating point framebuffer that can store floating point values outside the default range of <code>0.0</code> and <code>1.0</code>. This is perfect for rendering in high dynamic range!</p>
<p>To create a floating point framebuffer the only thing we need to change is its color buffer&rsquo;s internal format parameter:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">colorBuffer</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glTexImage2D</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGBA16F</span><span class="p">,</span> <span class="n">SCR_WIDTH</span><span class="p">,</span> <span class="n">SCR_HEIGHT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGBA</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span></span></span></code></pre></div><p>The default framebuffer of OpenGL (by default) only takes up 8 bits per color component. With a floating point framebuffer with 32 bits per color component (when using GL_RGB32F or GL_RGBA32F) we&rsquo;re using 4 times more memory for storing color values. As 32 bits isn&rsquo;t really necessary (unless you need a high level of precision) using GL_RGBA16F will suffice.</p>
<p>With a floating point color buffer attached to a framebuffer we can now render the scene into this framebuffer knowing color values won&rsquo;t get clamped between <code>0.0</code> and <code>1.0</code>. In this chapter&rsquo;s example demo we first render a lit scene into the floating point framebuffer and then display the framebuffer&rsquo;s color buffer on a screen-filled quad; it&rsquo;ll look a bit like this:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">hdrFBO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    <span class="n">glClear</span><span class="p">(</span><span class="n">GL_COLOR_BUFFER_BIT</span> <span class="o">|</span> <span class="n">GL_DEPTH_BUFFER_BIT</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="c1">// [...] render (lit) scene 
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1"></span><span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="c1">// now render hdr color buffer to 2D screen-filling quad with tone mapping shader
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1"></span><span class="n">hdrShader</span><span class="p">.</span><span class="n">use</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="n">glActiveTexture</span><span class="p">(</span><span class="n">GL_TEXTURE0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">hdrColorBufferTexture</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="n">RenderQuad</span><span class="p">();</span></span></span></code></pre></div><p>Here a scene&rsquo;s color values are filled into a floating point color buffer which can contain any arbitrary color value, possibly exceeding <code>1.0</code>. For this chapter, a simple demo scene was created with a large stretched cube acting as a tunnel with four point lights, one being extremely bright positioned at the tunnel&rsquo;s end:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="o">&gt;</span> <span class="n">lightColors</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">lightColors</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">200.0f</span><span class="p">,</span> <span class="mf">200.0f</span><span class="p">,</span> <span class="mf">200.0f</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">lightColors</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.1f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="n">lightColors</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.2f</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="n">lightColors</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.1f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">));</span>  
</span></span></code></pre></div><p>Rendering to a floating point framebuffer is exactly the same as we would normally render into a framebuffer. What is new is hdrShader&rsquo;s fragment shader that renders the final 2D quad with the floating point color buffer texture attached. Let&rsquo;s first define a simple pass-through fragment shader:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">out</span> <span class="n">vec4</span> <span class="n">FragColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">in</span> <span class="n">vec2</span> <span class="n">TexCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">hdrBuffer</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="p">{</span>             
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="n">vec3</span> <span class="n">hdrColor</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">hdrBuffer</span><span class="p">,</span> <span class="n">TexCoords</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="n">FragColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">hdrColor</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>Here we directly sample the floating point color buffer and use its color value as the fragment shader&rsquo;s output. However, as the 2D quad&rsquo;s output is directly rendered into the default framebuffer, all the fragment shader&rsquo;s output values will still end up clamped between <code>0.0</code> and <code>1.0</code> even though we have several values in the floating point color texture exceeding <code>1.0</code>.</p>
<p><a href="#R-image-3c2178986e5b979f69355c4e4b492d99" class="lightbox-link"><img src="./assets/hdr_direct.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-3c2178986e5b979f69355c4e4b492d99"><img src="./assets/hdr_direct.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>It becomes clear the intense light values at the end of the tunnel are clamped to <code>1.0</code> as a large portion of it is completely white, effectively losing all lighting details in the process. As we directly write HDR values to an LDR output buffer it is as if we have no HDR enabled in the first place. What we need to do is transform all the floating point color values into the <code>0.0</code> - <code>1.0</code> range without losing any of its details. We need to apply a process called tone mapping.</p>
<h4 id="tone-mapping">Tone mapping</h4>
<p>Tone mapping is the process of transforming floating point color values to the expected [<code>0.0</code>, <code>1.0</code>] range known as low dynamic range without losing too much detail, often accompanied with a specific stylistic color balance.</p>
<p>One of the more simple tone mapping algorithms is Reinhard tone mapping that involves dividing the entire HDR color values to LDR color values. The Reinhard tone mapping algorithm evenly balances out all brightness values onto LDR. We include Reinhard tone mapping into the previous fragment shader and also add a <a href="https://learnopengl.com/Advanced-Lighting/Gamma-Correction" target="_blank">gamma correction</a> filter for good measure (including the use of sRGB textures):</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>             
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="k">const</span> <span class="kt">float</span> <span class="n">gamma</span> <span class="o">=</span> <span class="mf">2.2</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="n">vec3</span> <span class="n">hdrColor</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">hdrBuffer</span><span class="p">,</span> <span class="n">TexCoords</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="c1">// reinhard tone mapping
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1"></span>    <span class="n">vec3</span> <span class="n">mapped</span> <span class="o">=</span> <span class="n">hdrColor</span> <span class="o">/</span> <span class="p">(</span><span class="n">hdrColor</span> <span class="o">+</span> <span class="n">vec3</span><span class="p">(</span><span class="mf">1.0</span><span class="p">));</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="c1">// gamma correction 
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1"></span>    <span class="n">mapped</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">mapped</span><span class="p">,</span> <span class="n">vec3</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">gamma</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">  
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="n">FragColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">mapped</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="p">}</span>    
</span></span></code></pre></div><p>With Reinhard tone mapping applied we no longer lose any detail at the bright areas of our scene. It does tend to slightly favor brighter areas, making darker regions seem less detailed and distinct:</p>
<p><a href="#R-image-9bf8eeaf9f32e01a5bdb1e248a45840f" class="lightbox-link"><img src="./assets/hdr_reinhard.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-9bf8eeaf9f32e01a5bdb1e248a45840f"><img src="./assets/hdr_reinhard.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Here you can again see details at the end of the tunnel as the wood texture pattern becomes visible again. With this relatively simple tone mapping algorithm we can properly see the entire range of HDR values stored in the floating point framebuffer, giving us precise control over the scene&rsquo;s lighting without losing details.</p>
<p><note>Note that we could also directly tone map at the end of our lighting shader, not needing any floating point framebuffer at all! However, as scenes get more complex you&rsquo;ll frequently find the need to store intermediate HDR results as floating point buffers so this is a good exercise.</note></p>
<p>Another interesting use of tone mapping is to allow the use of an exposure parameter. You probably remember from the introduction that HDR images contain a lot of details visible at different exposure levels. If we have a scene that features a day and night cycle it makes sense to use a lower exposure at daylight and a higher exposure at night time, similar to how the human eye adapts. With such an exposure parameter it allows us to configure lighting parameters that work both at day and night under different lighting conditions as we only have to change the exposure parameter.</p>
<p>A relatively simple exposure tone mapping algorithm looks as follows:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">uniform</span> <span class="kt">float</span> <span class="n">exposure</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="p">{</span>             
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="k">const</span> <span class="kt">float</span> <span class="n">gamma</span> <span class="o">=</span> <span class="mf">2.2</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="n">vec3</span> <span class="n">hdrColor</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">hdrBuffer</span><span class="p">,</span> <span class="n">TexCoords</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="c1">// exposure tone mapping
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1"></span>    <span class="n">vec3</span> <span class="n">mapped</span> <span class="o">=</span> <span class="n">vec3</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span> <span class="o">-</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">hdrColor</span> <span class="o">*</span> <span class="n">exposure</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="c1">// gamma correction 
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="c1"></span>    <span class="n">mapped</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">mapped</span><span class="p">,</span> <span class="n">vec3</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">gamma</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">  
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="n">FragColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">mapped</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>Here we defined an exposure uniform that defaults at <code>1.0</code> and allows us to more precisely specify whether we&rsquo;d like to focus more on dark or bright regions of the HDR color values. For instance, with high exposure values the darker areas of the tunnel show significantly more detail. In contrast, a low exposure largely removes the dark region details, but allows us to see more detail in the bright areas of a scene. Take a look at the image below to see the tunnel at multiple exposure levels:</p>
<p><a href="#R-image-9a9231810dbdf9c09b277f6e4baaeeea" class="lightbox-link"><img src="./assets/hdr_exposure.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-9a9231810dbdf9c09b277f6e4baaeeea"><img src="./assets/hdr_exposure.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>This image clearly shows the benefit of high dynamic range rendering. By changing the exposure level we get to see a lot of details of our scene, that would&rsquo;ve been otherwise lost with low dynamic range rendering. Take the end of the tunnel for example. With a normal exposure the wood structure is barely visible, but with a low exposure the detailed wooden patterns are clearly visible. The same holds for the wooden patterns close by that are more visible with a high exposure.</p>
<p>You can find the source code of the demo <a href="https://learnopengl.com/code_viewer_gh.php?code=src/5.advanced_lighting/6.hdr/hdr.cpp" target="_blank">here</a>.</p>
<h4 id="more-hdr">More HDR</h4>
<p>The two tone mapping algorithms shown are only a few of a large collection of (more advanced) tone mapping algorithms of which each has their own strengths and weaknesses. Some tone mapping algorithms favor certain colors/intensities above others and some algorithms display both the low and high exposure colors at the same time to create more colorful and detailed images. There is also a collection of techniques known as automatic exposure adjustment or eye adaptation techniques that determine the brightness of the scene in the previous frame and (slowly) adapt the exposure parameter such that the scene gets brighter in dark areas or darker in bright areas mimicking the human eye.</p>
<p>The real benefit of HDR rendering really shows itself in large and complex scenes with heavy lighting algorithms. As it is difficult to create such a complex demo scene for teaching purposes while keeping it accessible, the chapter&rsquo;s demo scene is small and lacks detail. While relatively simple it does show some of the benefits of HDR rendering: no details are lost in high and dark regions as they can be restored with tone mapping, the addition of multiple lights doesn&rsquo;t cause clamped regions, and light values can be specified by real brightness values not being limited by LDR values. Furthermore, HDR rendering also makes several other interesting effects more feasible and realistic; one of these effects is bloom that we&rsquo;ll discuss in the next <a href="https://learnopengl.com/Advanced-Lighting/Bloom" target="_blank">next</a> chapter.</p>
<h4 id="additional-resources-8">Additional resources</h4>
<ul>
<li><a href="http://gamedev.stackexchange.com/questions/62836/does-hdr-rendering-have-any-benefits-if-bloom-wont-be-applied" target="_blank">Does HDR rendering have any benefits if bloom won&rsquo;t be applied?</a>: a stackexchange question that features a great lengthy answer describing some of the benefits of HDR rendering.</li>
<li><a href="http://photo.stackexchange.com/questions/7630/what-is-tone-mapping-how-does-it-relate-to-hdr" target="_blank">What is tone mapping? How does it relate to HDR?</a>: another interesting answer with great reference images to explain tone mapping.</li>
</ul>
<h3 id="bloom">Bloom</h3>
<p>Bright light sources and brightly lit regions are often difficult to convey to the viewer as the intensity range of a monitor is limited. One way to distinguish bright light sources on a monitor is by making them glow; the light then <em>bleeds</em> around the light source. This effectively gives the viewer the illusion these light sources or bright regions are intensely bright.</p>
<p>This light bleeding, or glow effect, is achieved with a post-processing effect called Bloom. Bloom gives all brightly lit regions of a scene a glow-like effect. An example of a scene with and without glow can be seen below (image courtesy of Epic Games):</p>
<p><a href="#R-image-82c6453298600c4ddf4a98d4be4577a8" class="lightbox-link"><img src="./assets/bloom_example.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-82c6453298600c4ddf4a98d4be4577a8"><img src="./assets/bloom_example.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Bloom gives noticeable visual cues about the brightness of objects. When done in a subtle fashion (which some games drastically fail to do) Bloom significantly boosts the lighting of your scene and allows for a large range of dramatic effects.</p>
<p>Bloom works best in combination with <a href="https://learnopengl.com/Advanced-Lighting/HDR" target="_blank">HDR</a> rendering. A common misconception is that HDR is the same as Bloom as many people use the terms interchangeably. They are however completely different techniques used for different purposes. It is possible to implement Bloom with default 8-bit precision framebuffers, just as it is possible to use HDR without the Bloom effect. It is simply that HDR makes Bloom more effective to implement (as we&rsquo;ll later see).</p>
<p>To implement Bloom, we render a lit scene as usual and extract both the scene&rsquo;s HDR color buffer and an image of the scene with only its bright regions visible. This extracted brightness image is then blurred and the result added on top of the original HDR scene image.</p>
<p>Let&rsquo;s illustrate this process in a step by step fashion. We render a scene filled with 4 bright light sources, visualized as colored cubes. The colored light cubes have a brightness values between <code>1.5</code> and <code>15.0</code>. If we were to render this to an HDR color buffer the scene looks as follows:</p>
<p><a href="#R-image-e5d8e3b6e44e64fdc04e444c72780ddf" class="lightbox-link"><img src="./assets/bloom_scene.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-e5d8e3b6e44e64fdc04e444c72780ddf"><img src="./assets/bloom_scene.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>We take this HDR color buffer texture and extract all the fragments that exceed a certain brightness. This gives us an image that only show the bright colored regions as their fragment intensities exceeded a certain threshold:</p>
<p><a href="#R-image-af2b5bf7c35c4ba1a65a27a52fe30be1" class="lightbox-link"><img src="./assets/bloom_extracted.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-af2b5bf7c35c4ba1a65a27a52fe30be1"><img src="./assets/bloom_extracted.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>We then take this thresholded brightness texture and blur the result. The strength of the bloom effect is largely determined by the range and strength of the blur filter used.</p>
<p><a href="#R-image-5df028064d2720fc935cef8ca33e238e" class="lightbox-link"><img src="./assets/bloom_blurred.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-5df028064d2720fc935cef8ca33e238e"><img src="./assets/bloom_blurred.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>The resulting blurred texture is what we use to get the glow or light-bleeding effect. This blurred texture is added on top of the original HDR scene texture. Because the bright regions are extended in both width and height due to the blur filter, the bright regions of the scene appear to glow or <em>bleed</em> light.</p>
<p><a href="#R-image-2d5f36488a06712db52326d2546442a3" class="lightbox-link"><img src="./assets/bloom_small.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-2d5f36488a06712db52326d2546442a3"><img src="./assets/bloom_small.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Bloom by itself isn&rsquo;t a complicated technique, but difficult to get exactly right. Most of its visual quality is determined by the quality and type of blur filter used for blurring the extracted brightness regions. Simply tweaking the blur filter can drastically change the quality of the Bloom effect.</p>
<p>Following these steps gives us the Bloom post-processing effect. The next image briefly summarizes the required steps for implementing Bloom:</p>
<p><a href="#R-image-6e31c610701e2e0c61243ccb352b3ecb" class="lightbox-link"><img src="./assets/bloom_steps.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-6e31c610701e2e0c61243ccb352b3ecb"><img src="./assets/bloom_steps.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>The first step requires us to extract all the bright colors of a scene based on some threshold. Let&rsquo;s first delve into that.</p>
<h4 id="extracting-bright-color">Extracting bright color</h4>
<p>The first step requires us to extract two images from a rendered scene. We could render the scene twice, both rendering to a different framebuffer with different shaders, but we can also use a neat little trick called Multiple Render Targets (MRT) that allows us to specify more than one fragment shader output; this gives us the option to extract the first two images in a single render pass. By specifying a layout location specifier before a fragment shader&rsquo;s output we can control to which color buffer a fragment shader writes to:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">out</span> <span class="n">vec4</span> <span class="n">FragColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="n">out</span> <span class="n">vec4</span> <span class="n">BrightColor</span><span class="p">;</span>  
</span></span></code></pre></div><p>This only works if we actually have multiple buffers to write to. As a requirement for using multiple fragment shader outputs we need multiple color buffers attached to the currently bound framebuffer object. You may remember from the <a href="https://learnopengl.com/Advanced-OpenGL/Framebuffers" target="_blank">framebuffers</a> chapter that we can specify a color attachment number when linking a texture as a framebuffer&rsquo;s color buffer. Up until now we&rsquo;ve always used GL_COLOR_ATTACHMENT0, but by also using GL_COLOR_ATTACHMENT1 we can have two color buffers attached to a framebuffer object:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="c1">// set up floating point framebuffer to render scene to
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1"></span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hdrFBO</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">glGenFramebuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hdrFBO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">hdrFBO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">colorBuffers</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">glGenTextures</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">colorBuffers</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">colorBuffers</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="n">glTexImage2D</span><span class="p">(</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">        <span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGBA16F</span><span class="p">,</span> <span class="n">SCR_WIDTH</span><span class="p">,</span> <span class="n">SCR_HEIGHT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGBA</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="nb">NULL</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="p">);</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MIN_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MAG_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_S</span><span class="p">,</span> <span class="n">GL_CLAMP_TO_EDGE</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_T</span><span class="p">,</span> <span class="n">GL_CLAMP_TO_EDGE</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">    <span class="c1">// attach texture to framebuffer
</span></span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="c1"></span>    <span class="n">glFramebufferTexture2D</span><span class="p">(</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">        <span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">GL_COLOR_ATTACHMENT0</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">colorBuffers</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">    <span class="p">);</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>We do have to explicitly tell OpenGL we&rsquo;re rendering to multiple colorbuffers via glDrawBuffers. OpenGL, by default, only renders to a framebuffer&rsquo;s first color attachment, ignoring all others. We can do this by passing an array of color attachment enums that we&rsquo;d like to render to in subsequent operations:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">attachments</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">GL_COLOR_ATTACHMENT0</span><span class="p">,</span> <span class="n">GL_COLOR_ATTACHMENT1</span> <span class="p">};</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glDrawBuffers</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">attachments</span><span class="p">);</span>  
</span></span></code></pre></div><p>When rendering into this framebuffer, whenever a fragment shader uses the layout location specifier, the respective color buffer is used to render the fragment to. This is great as this saves us an extra render pass for extracting bright regions as we can now directly extract them from the to-be-rendered fragment:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">out</span> <span class="n">vec4</span> <span class="n">FragColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="n">out</span> <span class="n">vec4</span> <span class="n">BrightColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="p">[...]</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="kt">void</span> <span class="n">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="p">{</span>            
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="p">[...]</span> <span class="c1">// first do normal lighting calculations and output results
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1"></span>    <span class="n">FragColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">lighting</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="c1">// check whether fragment output is higher than threshold, if so output as brightness color
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="c1"></span>    <span class="kt">float</span> <span class="n">brightness</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">FragColor</span><span class="p">.</span><span class="n">rgb</span><span class="p">,</span> <span class="n">vec3</span><span class="p">(</span><span class="mf">0.2126</span><span class="p">,</span> <span class="mf">0.7152</span><span class="p">,</span> <span class="mf">0.0722</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">brightness</span> <span class="o">&gt;</span> <span class="mf">1.0</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">        <span class="n">BrightColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">FragColor</span><span class="p">.</span><span class="n">rgb</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">        <span class="n">BrightColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>Here we first calculate lighting as normal and pass it to the first fragment shader&rsquo;s output variable FragColor. Then we use what is currently stored in FragColor to determine if its brightness exceeds a certain threshold. We calculate the brightness of a fragment by properly transforming it to grayscale first (by taking the dot product of both vectors we effectively multiply each individual component of both vectors and add the results together). If the brightness exceeds a certain threshold, we output the color to the second color buffer. We do the same for the light cubes.</p>
<p>This also shows why Bloom works incredibly well with HDR rendering. Because we render in high dynamic range, color values can exceed <code>1.0</code> which allows us to specify a brightness threshold outside the default range, giving us much more control over what is considered bright. Without HDR we&rsquo;d have to set the threshold lower than <code>1.0</code>, which is still possible, but regions are much quicker considered bright. This sometimes leads to the glow effect becoming too dominant (think of white glowing snow for example).</p>
<p>With these two color buffers we have an image of the scene as normal, and an image of the extracted bright regions; all generated in a single render pass.</p>
<p><a href="#R-image-38efce19ad6f86f6be62a9de08d70bfb" class="lightbox-link"><img src="./assets/bloom_attachments.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-38efce19ad6f86f6be62a9de08d70bfb"><img src="./assets/bloom_attachments.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>With an image of the extracted bright regions we now need to blur the image. We can do this with a simple box filter as we&rsquo;ve done in the post-processing section of the framebufers chapter, but we&rsquo;d rather use a more advanced (and better-looking) blur filter called Gaussian blur.</p>
<h4 id="gaussian-blur">Gaussian blur</h4>
<p>In the post-processing chapter&rsquo;s blur we took the average of all surrounding pixels of an image. While it does give us an easy blur, it doesn&rsquo;t give the best results. A Gaussian blur is based on the Gaussian curve which is commonly described as a <em>bell-shaped curve</em> giving high values close to its center that gradually wear off over distance. The Gaussian curve can be mathematically represented in different forms, but generally has the following shape:</p>
<p><a href="#R-image-4813fe8086e105f536bb3c9bdd1b9eb7" class="lightbox-link"><img src="./assets/bloom_gaussian.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-4813fe8086e105f536bb3c9bdd1b9eb7"><img src="./assets/bloom_gaussian.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>As the Gaussian curve has a larger area close to its center, using its values as weights to blur an image give more natural results as samples close by have a higher precedence. If we for instance sample a 32x32 box around a fragment, we use progressively smaller weights the larger the distance to the fragment; this gives a better and more realistic blur which is known as a Gaussian blur.</p>
<p>To implement a Gaussian blur filter we&rsquo;d need a two-dimensional box of weights that we can obtain from a 2 dimensional Gaussian curve equation. The problem with this approach however is that it quickly becomes extremely heavy on performance. Take a blur kernel of 32 by 32 for example, this would require us to sample a texture a total of 1024 times for each fragment!</p>
<p>Luckily for us, the Gaussian equation has a very neat property that allows us to separate the two-dimensional equation into two smaller one-dimensional equations: one that describes the horizontal weights and the other that describes the vertical weights. We&rsquo;d then first do a horizontal blur with the horizontal weights on the scene texture, and then on the resulting texture do a vertical blur. Due to this property the results are exactly the same, but this time saving us an incredible amount of performance as we&rsquo;d now only have to do 32 + 32 samples compared to 1024! This is known as two-pass Gaussian blur.</p>
<p><a href="#R-image-0b063e42db48183b146ce8b5e080bffe" class="lightbox-link"><img src="./assets/bloom_gaussian_two_pass.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-0b063e42db48183b146ce8b5e080bffe"><img src="./assets/bloom_gaussian_two_pass.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>This does mean we need to blur an image at least two times and this works best with the use of framebuffer objects. Specifically for the two-pass Gaussian blur we&rsquo;re going to implement <em>ping-pong</em> framebuffers. That is a pair of framebuffers where we render and swap, a given number of times, the other framebuffer&rsquo;s color buffer into the current framebuffer&rsquo;s color buffer with an alternating shader effect. We basically continuously switch the framebuffer to render to and the texture to draw with. This allows us to first blur the scene&rsquo;s texture in the first framebuffer, then blur the first framebuffer&rsquo;s color buffer into the second framebuffer, and then the second framebuffer&rsquo;s color buffer into the first, and so on.</p>
<p>Before we delve into the framebuffers let&rsquo;s first discuss the Gaussian blur&rsquo;s fragment shader:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">out</span> <span class="n">vec4</span> <span class="n">FragColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">in</span> <span class="n">vec2</span> <span class="n">TexCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">image</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="n">uniform</span> <span class="kt">bool</span> <span class="n">horizontal</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="n">uniform</span> <span class="kt">float</span> <span class="n">weight</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="kt">float</span><span class="p">[]</span> <span class="p">(</span><span class="mf">0.227027</span><span class="p">,</span> <span class="mf">0.1945946</span><span class="p">,</span> <span class="mf">0.1216216</span><span class="p">,</span> <span class="mf">0.054054</span><span class="p">,</span> <span class="mf">0.016216</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="p">{</span>             
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="n">vec2</span> <span class="n">tex_offset</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">textureSize</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// gets size of single texel
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="c1"></span>    <span class="n">vec3</span> <span class="n">result</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">TexCoords</span><span class="p">).</span><span class="n">rgb</span> <span class="o">*</span> <span class="n">weight</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">// current fragment&#39;s contribution
</span></span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">horizontal</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">            <span class="n">result</span> <span class="o">+=</span> <span class="n">texture</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">TexCoords</span> <span class="o">+</span> <span class="n">vec2</span><span class="p">(</span><span class="n">tex_offset</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">i</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)).</span><span class="n">rgb</span> <span class="o">*</span> <span class="n">weight</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">            <span class="n">result</span> <span class="o">+=</span> <span class="n">texture</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">TexCoords</span> <span class="o">-</span> <span class="n">vec2</span><span class="p">(</span><span class="n">tex_offset</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">i</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)).</span><span class="n">rgb</span> <span class="o">*</span> <span class="n">weight</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl">            <span class="n">result</span> <span class="o">+=</span> <span class="n">texture</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">TexCoords</span> <span class="o">+</span> <span class="n">vec2</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">tex_offset</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">i</span><span class="p">)).</span><span class="n">rgb</span> <span class="o">*</span> <span class="n">weight</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="ln">28</span><span class="cl">            <span class="n">result</span> <span class="o">+=</span> <span class="n">texture</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">TexCoords</span> <span class="o">-</span> <span class="n">vec2</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">tex_offset</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">i</span><span class="p">)).</span><span class="n">rgb</span> <span class="o">*</span> <span class="n">weight</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="ln">29</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln">30</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">31</span><span class="cl">    <span class="n">FragColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">32</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>Here we take a relatively small sample of Gaussian weights that we each use to assign a specific weight to the horizontal or vertical samples around the current fragment. You can see that we split the blur filter into a horizontal and vertical section based on whatever value we set the horizontal uniform. We base the offset distance on the exact size of a texel obtained by the division of <code>1.0</code> over the size of the texture (a <code>vec2</code> from textureSize).</p>
<p>For blurring an image we create two basic framebuffers, each with only a color buffer texture:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pingpongFBO</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pingpongBuffer</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">glGenFramebuffers</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">pingpongFBO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">glGenTextures</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">pingpongBuffer</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">pingpongFBO</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">pingpongBuffer</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="n">glTexImage2D</span><span class="p">(</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">        <span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGBA16F</span><span class="p">,</span> <span class="n">SCR_WIDTH</span><span class="p">,</span> <span class="n">SCR_HEIGHT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGBA</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="nb">NULL</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="p">);</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MIN_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MAG_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_S</span><span class="p">,</span> <span class="n">GL_CLAMP_TO_EDGE</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_T</span><span class="p">,</span> <span class="n">GL_CLAMP_TO_EDGE</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="n">glFramebufferTexture2D</span><span class="p">(</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">        <span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">GL_COLOR_ATTACHMENT0</span><span class="p">,</span> <span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">pingpongBuffer</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">    <span class="p">);</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>Then after we&rsquo;ve obtained an HDR texture and an extracted brightness texture, we first fill one of the ping-pong framebuffers with the brightness texture and then blur the image 10 times (5 times horizontally and 5 times vertically):</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">bool</span> <span class="n">horizontal</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span> <span class="n">first_iteration</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="kt">int</span> <span class="n">amount</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">shaderBlur</span><span class="p">.</span><span class="n">use</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">amount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">pingpongFBO</span><span class="p">[</span><span class="n">horizontal</span><span class="p">]);</span> 
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="n">shaderBlur</span><span class="p">.</span><span class="n">setInt</span><span class="p">(</span><span class="s">&#34;horizontal&#34;</span><span class="p">,</span> <span class="n">horizontal</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="n">glBindTexture</span><span class="p">(</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">        <span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">first_iteration</span> <span class="o">?</span> <span class="n">colorBuffers</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">:</span> <span class="n">pingpongBuffers</span><span class="p">[</span><span class="o">!</span><span class="n">horizontal</span><span class="p">]</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="p">);</span> 
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="n">RenderQuad</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="n">horizontal</span> <span class="o">=</span> <span class="o">!</span><span class="n">horizontal</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">first_iteration</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">        <span class="n">first_iteration</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> 
</span></span></code></pre></div><p>Each iteration we bind one of the two framebuffers based on whether we want to blur horizontally or vertically and bind the other framebuffer&rsquo;s color buffer as the texture to blur. The first iteration we specifically bind the texture we&rsquo;d like to blur (brightnessTexture) as both color buffers would else end up empty. By repeating this process 10 times, the brightness image ends up with a complete Gaussian blur that was repeated 5 times. This construct allows us to blur any image as often as we&rsquo;d like; the more Gaussian blur iterations, the stronger the blur.</p>
<p>By blurring the extracted brightness texture 5 times, we get a properly blurred image of all bright regions of a scene.</p>
<p><a href="#R-image-f27997734a4422e12ac369112b9c24ed" class="lightbox-link"><img src="./assets/bloom_blurred_large.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f27997734a4422e12ac369112b9c24ed"><img src="./assets/bloom_blurred_large.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>The last step to complete the Bloom effect is to combine this blurred brightness texture with the original scene&rsquo;s HDR texture.</p>
<h4 id="blending-both-textures">Blending both textures</h4>
<p>With the scene&rsquo;s HDR texture and a blurred brightness texture of the scene we only need to combine the two to achieve the infamous Bloom or glow effect. In the final fragment shader (largely similar to the one we used in the <a href="https://learnopengl.com/Advanced-Lighting/HDR" target="_blank">HDR</a> chapter) we additively blend both textures:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">out</span> <span class="n">vec4</span> <span class="n">FragColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">in</span> <span class="n">vec2</span> <span class="n">TexCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">scene</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">bloomBlur</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="n">uniform</span> <span class="kt">float</span> <span class="n">exposure</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="p">{</span>             
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="k">const</span> <span class="kt">float</span> <span class="n">gamma</span> <span class="o">=</span> <span class="mf">2.2</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="n">vec3</span> <span class="n">hdrColor</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">scene</span><span class="p">,</span> <span class="n">TexCoords</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>      
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="n">vec3</span> <span class="n">bloomColor</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">bloomBlur</span><span class="p">,</span> <span class="n">TexCoords</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="n">hdrColor</span> <span class="o">+=</span> <span class="n">bloomColor</span><span class="p">;</span> <span class="c1">// additive blending
</span></span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="c1"></span>    <span class="c1">// tone mapping
</span></span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="c1"></span>    <span class="n">vec3</span> <span class="n">result</span> <span class="o">=</span> <span class="n">vec3</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span> <span class="o">-</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">hdrColor</span> <span class="o">*</span> <span class="n">exposure</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">    <span class="c1">// also gamma correct while we&#39;re at it       
</span></span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="c1"></span>    <span class="n">result</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">vec3</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">gamma</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">    <span class="n">FragColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>Interesting to note here is that we add the Bloom effect before we apply tone mapping. This way, the added brightness of bloom is also softly transformed to LDR range with better relative lighting as a result.</p>
<p>With both textures added together, all bright areas of our scene now get a proper glow effect:</p>
<p><a href="#R-image-6e06de4d4d96cdae01782b2cdf944055" class="lightbox-link"><img src="./assets/bloom.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-6e06de4d4d96cdae01782b2cdf944055"><img src="./assets/bloom.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>The colored cubes now appear much more bright and give a better illusion as light emitting objects. This is a relatively simple scene so the Bloom effect isn&rsquo;t too impressive here, but in well lit scenes it can make a significant difference when properly configured. You can find the source code of this simple demo <a href="https://learnopengl.com/code_viewer_gh.php?code=src/5.advanced_lighting/7.bloom/bloom.cpp" target="_blank">here</a>.</p>
<p>For this chapter we used a relatively simple Gaussian blur filter where we only take 5 samples in each direction. By taking more samples along a larger radius or repeating the blur filter an extra number of times we can improve the blur effect. As the quality of the blur directly correlates to the quality of the Bloom effect, improving the blur step can make a significant improvement. Some of these improvements combine blur filters with varying sized blur kernels or use multiple Gaussian curves to selectively combine weights. The additional resources from Kalogirou and Epic Games discuss how to significantly improve the Bloom effect by improving the Gaussian blur.</p>
<h4 id="additional-resources-9">Additional resources</h4>
<ul>
<li><a href="http://rastergrid.com/blog/2010/09/efficient-gaussian-blur-with-linear-sampling/" target="_blank">Efficient Gaussian Blur with linear sampling</a>: descirbes the Gaussian blur very well and how to improve its performance using OpenGL&rsquo;s bilinear texture sampling.</li>
<li><a href="https://udk-legacy.unrealengine.com/udk/Three/Bloom.html" target="_blank">Bloom Post Process Effect</a>: article from Epic Games about improving the Bloom effect by combining multiple Gaussian curves for its weights.</li>
<li><a href="http://kalogirou.net/2006/05/20/how-to-do-good-bloom-for-hdr-rendering/" target="_blank">How to do good Bloom for HDR rendering</a>: Article from Kalogirou that describes how to improve the Bloom effect using a better Gaussian blur method.</li>
</ul>
<h3 id="deferred-shading">Deferred Shading</h3>
<p>The way we did lighting so far was called forward rendering or forward shading. A straightforward approach where we render an object and light it according to all light sources in a scene. We do this for every object individually for each object in the scene. While quite easy to understand and implement it is also quite heavy on performance as each rendered object has to iterate over each light source for every rendered fragment, which is a lot! Forward rendering also tends to waste a lot of fragment shader runs in scenes with a high depth complexity (multiple objects cover the same screen pixel) as fragment shader outputs are overwritten.</p>
<p>Deferred shading or deferred rendering aims to overcome these issues by drastically changing the way we render objects. This gives us several new options to significantly optimize scenes with large numbers of lights, allowing us to render hundreds (or even thousands) of lights with an acceptable framerate. The following image is a scene with 1847 point lights rendered with deferred shading (image courtesy of Hannes Nevalainen); something that wouldn&rsquo;t be possible with forward rendering.</p>
<p><a href="#R-image-de8a949675f80377b34a805b5690d35a" class="lightbox-link"><img src="./assets/deferred_example.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-de8a949675f80377b34a805b5690d35a"><img src="./assets/deferred_example.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Deferred shading is based on the idea that we <em>defer</em> or <em>postpone</em> most of the heavy rendering (like lighting) to a later stage. Deferred shading consists of two passes: in the first pass, called the geometry pass, we render the scene once and retrieve all kinds of geometrical information from the objects that we store in a collection of textures called the G-buffer; think of position vectors, color vectors, normal vectors, and/or specular values. The geometric information of a scene stored in the G-buffer is then later used for (more complex) lighting calculations. Below is the content of a G-buffer of a single frame:</p>
<p><a href="#R-image-58afb366c04dc31306be7c556d31f014" class="lightbox-link"><img src="./assets/deferred_g_buffer.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-58afb366c04dc31306be7c556d31f014"><img src="./assets/deferred_g_buffer.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>We use the textures from the G-buffer in a second pass called the lighting pass where we render a screen-filled quad and calculate the scene&rsquo;s lighting for each fragment using the geometrical information stored in the G-buffer; pixel by pixel we iterate over the G-buffer. Instead of taking each object all the way from the vertex shader to the fragment shader, we decouple its advanced fragment processes to a later stage. The lighting calculations are exactly the same, but this time we take all required input variables from the corresponding G-buffer textures, instead of the vertex shader (plus some uniform variables).</p>
<p>The image below nicely illustrates the process of deferred shading.</p>
<p><a href="#R-image-fb0fc25b4bed592c8ba64659b642bed1" class="lightbox-link"><img src="./assets/deferred_overview.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-fb0fc25b4bed592c8ba64659b642bed1"><img src="./assets/deferred_overview.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>A major advantage of this approach is that whatever fragment ends up in the G-buffer is the actual fragment information that ends up as a screen pixel. The depth test already concluded this fragment to be the last and top-most fragment. This ensures that for each pixel we process in the lighting pass, we only calculate lighting once. Furthermore, deferred rendering opens up the possibility for further optimizations that allow us to render a much larger amount of light sources compared to forward rendering.</p>
<p>It also comes with some disadvantages though as the G-buffer requires us to store a relatively large amount of scene data in its texture color buffers. This eats memory, especially since scene data like position vectors require a high precision. Another disadvantage is that it doesn&rsquo;t support blending (as we only have information of the top-most fragment) and MSAA no longer works. There are several workarounds for this that we&rsquo;ll get to at the end of the chapter.</p>
<p>Filling the G-buffer (in the geometry pass) isn&rsquo;t too expensive as we directly store object information like position, color, or normals into a framebuffer with a small or zero amount of processing. By using multiple render targets (MRT) we can even do all of this in a single render pass.</p>
<h4 id="the-g-buffer">The G-buffer</h4>
<p>The G-buffer is the collective term of all textures used to store lighting-relevant data for the final lighting pass. Let&rsquo;s take this moment to briefly review all the data we need to light a fragment with forward rendering:</p>
<ul>
<li>A 3D world-space <strong>position</strong> vector to calculate the (interpolated) fragment position variable used for lightDir and viewDir.</li>
<li>An RGB diffuse <strong>color</strong> vector also known as albedo.</li>
<li>A 3D <strong>normal</strong> vector for determining a surface&rsquo;s slope.</li>
<li>A <strong>specular intensity</strong> float.</li>
<li>All light source position and color vectors.</li>
<li>The player or viewer&rsquo;s position vector.</li>
</ul>
<p>With these (per-fragment) variables at our disposal we are able to calculate the (Blinn-)Phong lighting we&rsquo;re accustomed to. The light source positions and colors, and the player&rsquo;s view position, can be configured using uniform variables, but the other variables are all fragment specific. If we can somehow pass the exact same data to the final deferred lighting pass we can calculate the same lighting effects, even though we&rsquo;re rendering fragments of a 2D quad.</p>
<p>There is no limit in OpenGL to what we can store in a texture so it makes sense to store all per-fragment data in one or multiple screen-filled textures of the G-buffer and use these later in the lighting pass. As the G-buffer textures will have the same size as the lighting pass&rsquo;s 2D quad, we get the exact same fragment data we&rsquo;d had in a forward rendering setting, but this time in the lighting pass; there is a one on one mapping.</p>
<p>In pseudocode the entire process will look a bit like this:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">while</span><span class="p">(...)</span> <span class="c1">// render loop
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="c1">// 1. geometry pass: render all geometric/color data to g-buffer 
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1"></span>    <span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">gBuffer</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="n">glClearColor</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span> <span class="c1">// keep it black so it doesn&#39;t leak into g-buffer
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="c1"></span>    <span class="n">glClear</span><span class="p">(</span><span class="n">GL_COLOR_BUFFER_BIT</span> <span class="o">|</span> <span class="n">GL_DEPTH_BUFFER_BIT</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="n">gBufferShader</span><span class="p">.</span><span class="n">use</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="n">Object</span> <span class="nl">obj</span> <span class="p">:</span> <span class="n">Objects</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">        <span class="n">ConfigureShaderTransformsAndUniforms</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">        <span class="n">obj</span><span class="p">.</span><span class="n">Draw</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="p">}</span>  
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="c1">// 2. lighting pass: use g-buffer to calculate the scene&#39;s lighting
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="c1"></span>    <span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="n">lightingPassShader</span><span class="p">.</span><span class="n">use</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="n">BindAllGBufferTextures</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">    <span class="n">SetLightingUniforms</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">    <span class="n">RenderQuad</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>The data we&rsquo;ll need to store of each fragment is a <strong>position</strong> vector, a <strong>normal</strong> vector, a <strong>color</strong> vector, and a <strong>specular intensity</strong> value. In the geometry pass we need to render all objects of the scene and store these data components in the G-buffer. We can again use multiple render targets to render to multiple color buffers in a single render pass; this was briefly discussed in the <a href="https://learnopengl.com/Advanced-Lighting/Bloom" target="_blank">Bloom</a> chapter.</p>
<p>For the geometry pass we&rsquo;ll need to initialize a framebuffer object that we&rsquo;ll call gBuffer that has multiple color buffers attached and a single depth renderbuffer object. For the position and normal texture we&rsquo;d preferably use a high-precision texture (16 or 32-bit float per component). For the albedo and specular values we&rsquo;ll be fine with the default texture precision (8-bit precision per component). Note that we use GL_RGBA16F over GL_RGB16F as GPUs generally prefer 4-component formats over 3-component formats due to byte alignment; some drivers may fail to complete the framebuffer otherwise.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gBuffer</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="n">glGenFramebuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gBuffer</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">gBuffer</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gPosition</span><span class="p">,</span> <span class="n">gNormal</span><span class="p">,</span> <span class="n">gColorSpec</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="c1">// - position color buffer
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1"></span><span class="n">glGenTextures</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gPosition</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">gPosition</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="n">glTexImage2D</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGBA16F</span><span class="p">,</span> <span class="n">SCR_WIDTH</span><span class="p">,</span> <span class="n">SCR_HEIGHT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGBA</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MIN_FILTER</span><span class="p">,</span> <span class="n">GL_NEAREST</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MAG_FILTER</span><span class="p">,</span> <span class="n">GL_NEAREST</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="n">glFramebufferTexture2D</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">GL_COLOR_ATTACHMENT0</span><span class="p">,</span> <span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">gPosition</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">  
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="c1">// - normal color buffer
</span></span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="c1"></span><span class="n">glGenTextures</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gNormal</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">gNormal</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="n">glTexImage2D</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGBA16F</span><span class="p">,</span> <span class="n">SCR_WIDTH</span><span class="p">,</span> <span class="n">SCR_HEIGHT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGBA</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MIN_FILTER</span><span class="p">,</span> <span class="n">GL_NEAREST</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MAG_FILTER</span><span class="p">,</span> <span class="n">GL_NEAREST</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="n">glFramebufferTexture2D</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">GL_COLOR_ATTACHMENT1</span><span class="p">,</span> <span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">gNormal</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">  
</span></span><span class="line"><span class="ln">22</span><span class="cl"><span class="c1">// - color + specular color buffer
</span></span></span><span class="line"><span class="ln">23</span><span class="cl"><span class="c1"></span><span class="n">glGenTextures</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gAlbedoSpec</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl"><span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">gAlbedoSpec</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl"><span class="n">glTexImage2D</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGBA</span><span class="p">,</span> <span class="n">SCR_WIDTH</span><span class="p">,</span> <span class="n">SCR_HEIGHT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGBA</span><span class="p">,</span> <span class="n">GL_UNSIGNED_BYTE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MIN_FILTER</span><span class="p">,</span> <span class="n">GL_NEAREST</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MAG_FILTER</span><span class="p">,</span> <span class="n">GL_NEAREST</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">28</span><span class="cl"><span class="n">glFramebufferTexture2D</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">GL_COLOR_ATTACHMENT2</span><span class="p">,</span> <span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">gAlbedoSpec</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">29</span><span class="cl">  
</span></span><span class="line"><span class="ln">30</span><span class="cl"><span class="c1">// - tell OpenGL which color attachments we&#39;ll use (of this framebuffer) for rendering 
</span></span></span><span class="line"><span class="ln">31</span><span class="cl"><span class="c1"></span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">attachments</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">GL_COLOR_ATTACHMENT0</span><span class="p">,</span> <span class="n">GL_COLOR_ATTACHMENT1</span><span class="p">,</span> <span class="n">GL_COLOR_ATTACHMENT2</span> <span class="p">};</span>
</span></span><span class="line"><span class="ln">32</span><span class="cl"><span class="n">glDrawBuffers</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">attachments</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">33</span><span class="cl">  
</span></span><span class="line"><span class="ln">34</span><span class="cl"><span class="c1">// then also add render buffer object as depth buffer and check for completeness.
</span></span></span><span class="line"><span class="ln">35</span><span class="cl"><span class="c1"></span><span class="p">[...]</span></span></span></code></pre></div><p>Since we use multiple render targets, we have to explicitly tell OpenGL which of the color buffers associated with GBuffer we&rsquo;d like to render to with glDrawBuffers. Also interesting to note here is we combine the color and specular intensity data in a single <code>RGBA</code> texture; this saves us from having to declare an additional color buffer texture. As your deferred shading pipeline gets more complex and needs more data you&rsquo;ll quickly find new ways to combine data in individual textures.</p>
<p>Next we need to render into the G-buffer. Assuming each object has a diffuse, normal, and specular texture we&rsquo;d use something like the following fragment shader to render into the G-buffer:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">out</span> <span class="n">vec3</span> <span class="n">gPosition</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="n">out</span> <span class="n">vec3</span> <span class="n">gNormal</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="n">out</span> <span class="n">vec4</span> <span class="n">gAlbedoSpec</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">in</span> <span class="n">vec2</span> <span class="n">TexCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="n">in</span> <span class="n">vec3</span> <span class="n">FragPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="n">in</span> <span class="n">vec3</span> <span class="n">Normal</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">texture_diffuse1</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">texture_specular1</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="p">{</span>    
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="c1">// store the fragment position vector in the first gbuffer texture
</span></span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="c1"></span>    <span class="n">gPosition</span> <span class="o">=</span> <span class="n">FragPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">    <span class="c1">// also store the per-fragment normals into the gbuffer
</span></span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="c1"></span>    <span class="n">gNormal</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">Normal</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">    <span class="c1">// and the diffuse per-fragment color
</span></span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="c1"></span>    <span class="n">gAlbedoSpec</span><span class="p">.</span><span class="n">rgb</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">texture_diffuse1</span><span class="p">,</span> <span class="n">TexCoords</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">    <span class="c1">// store specular intensity in gAlbedoSpec&#39;s alpha component
</span></span></span><span class="line"><span class="ln">22</span><span class="cl"><span class="c1"></span>    <span class="n">gAlbedoSpec</span><span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">texture_specular1</span><span class="p">,</span> <span class="n">TexCoords</span><span class="p">).</span><span class="n">r</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>As we use multiple render targets, the layout specifier tells OpenGL to which color buffer of the active framebuffer we render to. Note that we do not store the specular intensity into a single color buffer texture as we can store its single float value in the alpha component of one of the other color buffer textures.</p>
<p><warning>Keep in mind that with lighting calculations it is extremely important to keep all relevant variables in the same coordinate space. In this case we store (and calculate) all variables in world-space.<warning></p>
<p>If we&rsquo;d now were to render a large collection of backpack objects into the gBuffer framebuffer and visualize its content by projecting each color buffer one by one onto a screen-filled quad we&rsquo;d see something like this:</p>
<p><a href="#R-image-0a23e2a6a553f975a8ddc54319785732" class="lightbox-link"><img src="./assets/deferred_g_buffer.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-0a23e2a6a553f975a8ddc54319785732"><img src="./assets/deferred_g_buffer.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Try to visualize that the world-space position and normal vectors are indeed correct. For instance, the normal vectors pointing to the right would be more aligned to a red color, similarly for position vectors that point from the scene&rsquo;s origin to the right. As soon as you&rsquo;re satisfied with the content of the G-buffer it&rsquo;s time to move to the next step: the lighting pass.</p>
<h4 id="the-deferred-lighting-pass">The deferred lighting pass</h4>
<p>With a large collection of fragment data in the G-Buffer at our disposal we have the option to completely calculate the scene&rsquo;s final lit colors. We do this by iterating over each of the G-Buffer textures pixel by pixel and use their content as input to the lighting algorithms. Because the G-buffer texture values all represent the final transformed fragment values we only have to do the expensive lighting operations once per pixel. This is especially useful in complex scenes where we&rsquo;d easily invoke multiple expensive fragment shader calls per pixel in a forward rendering setting.</p>
<p>For the lighting pass we&rsquo;re going to render a 2D screen-filled quad (a bit like a post-processing effect) and execute an expensive lighting fragment shader on each pixel:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">glClear</span><span class="p">(</span><span class="n">GL_COLOR_BUFFER_BIT</span> <span class="o">|</span> <span class="n">GL_DEPTH_BUFFER_BIT</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="n">glActiveTexture</span><span class="p">(</span><span class="n">GL_TEXTURE0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">gPosition</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">glActiveTexture</span><span class="p">(</span><span class="n">GL_TEXTURE1</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">gNormal</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">glActiveTexture</span><span class="p">(</span><span class="n">GL_TEXTURE2</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">gAlbedoSpec</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="c1">// also send light relevant uniforms
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1"></span><span class="n">shaderLightingPass</span><span class="p">.</span><span class="n">use</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="n">SendAllLightUniformsToShader</span><span class="p">(</span><span class="n">shaderLightingPass</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="n">shaderLightingPass</span><span class="p">.</span><span class="n">setVec3</span><span class="p">(</span><span class="s">&#34;viewPos&#34;</span><span class="p">,</span> <span class="n">camera</span><span class="p">.</span><span class="n">Position</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="n">RenderQuad</span><span class="p">();</span>  
</span></span></code></pre></div><p>We bind all relevant textures of the G-buffer before rendering and also send the lighting-relevant uniform variables to the shader.</p>
<p>The fragment shader of the lighting pass is largely similar to the lighting chapter shaders we&rsquo;ve used so far. What is new is the method in which we obtain the lighting&rsquo;s input variables, which we now directly sample from the G-buffer:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">out</span> <span class="n">vec4</span> <span class="n">FragColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">in</span> <span class="n">vec2</span> <span class="n">TexCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">gPosition</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">gNormal</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">gAlbedoSpec</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="k">struct</span> <span class="nc">Light</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="n">vec3</span> <span class="n">Position</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="n">vec3</span> <span class="n">Color</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">NR_LIGHTS</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="n">uniform</span> <span class="n">Light</span> <span class="n">lights</span><span class="p">[</span><span class="n">NR_LIGHTS</span><span class="p">];</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="n">uniform</span> <span class="n">vec3</span> <span class="n">viewPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">
</span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="p">{</span>             
</span></span><span class="line"><span class="ln">20</span><span class="cl">    <span class="c1">// retrieve data from G-buffer
</span></span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="c1"></span>    <span class="n">vec3</span> <span class="n">FragPos</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">gPosition</span><span class="p">,</span> <span class="n">TexCoords</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">    <span class="n">vec3</span> <span class="n">Normal</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">gNormal</span><span class="p">,</span> <span class="n">TexCoords</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">    <span class="n">vec3</span> <span class="n">Albedo</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">gAlbedoSpec</span><span class="p">,</span> <span class="n">TexCoords</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">    <span class="kt">float</span> <span class="n">Specular</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">gAlbedoSpec</span><span class="p">,</span> <span class="n">TexCoords</span><span class="p">).</span><span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl">    
</span></span><span class="line"><span class="ln">26</span><span class="cl">    <span class="c1">// then calculate lighting as usual
</span></span></span><span class="line"><span class="ln">27</span><span class="cl"><span class="c1"></span>    <span class="n">vec3</span> <span class="n">lighting</span> <span class="o">=</span> <span class="n">Albedo</span> <span class="o">*</span> <span class="mf">0.1</span><span class="p">;</span> <span class="c1">// hard-coded ambient component
</span></span></span><span class="line"><span class="ln">28</span><span class="cl"><span class="c1"></span>    <span class="n">vec3</span> <span class="n">viewDir</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">viewPos</span> <span class="o">-</span> <span class="n">FragPos</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">29</span><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NR_LIGHTS</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">30</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln">31</span><span class="cl">        <span class="c1">// diffuse
</span></span></span><span class="line"><span class="ln">32</span><span class="cl"><span class="c1"></span>        <span class="n">vec3</span> <span class="n">lightDir</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">lights</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Position</span> <span class="o">-</span> <span class="n">FragPos</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">33</span><span class="cl">        <span class="n">vec3</span> <span class="n">diffuse</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">Normal</span><span class="p">,</span> <span class="n">lightDir</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">Albedo</span> <span class="o">*</span> <span class="n">lights</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Color</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">34</span><span class="cl">        <span class="n">lighting</span> <span class="o">+=</span> <span class="n">diffuse</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">35</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">36</span><span class="cl">    
</span></span><span class="line"><span class="ln">37</span><span class="cl">    <span class="n">FragColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">lighting</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">38</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>The lighting pass shader accepts 3 uniform textures that represent the G-buffer and hold all the data we&rsquo;ve stored in the geometry pass. If we were to sample these with the current fragment&rsquo;s texture coordinates we&rsquo;d get the exact same fragment values as if we were rendering the geometry directly. Note that we retrieve both the Albedo color and the Specular intensity from the single gAlbedoSpec texture.</p>
<p>As we now have the per-fragment variables (and the relevant uniform variables) necessary to calculate Blinn-Phong lighting, we don&rsquo;t have to make any changes to the lighting code. The only thing we change in deferred shading here is the method of obtaining lighting input variables.</p>
<p>Running a simple demo with a total of <code>32</code> small lights looks a bit like this:</p>
<p><a href="#R-image-0b27ec997fd5dca80163051da1fe8b5c" class="lightbox-link"><img src="./assets/deferred_shading.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-0b27ec997fd5dca80163051da1fe8b5c"><img src="./assets/deferred_shading.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>One of the disadvantages of deferred shading is that it is not possible to do <a href="https://learnopengl.com/Advanced-OpenGL/Blending" target="_blank">blending</a> as all values in the G-buffer are from single fragments, and blending operates on the combination of multiple fragments. Another disadvantage is that deferred shading forces you to use the same lighting algorithm for most of your scene&rsquo;s lighting; you can somehow alleviate this a bit by including more material-specific data in the G-buffer.</p>
<p>To overcome these disadvantages (especially blending) we often split the renderer into two parts: one deferred rendering part, and the other a forward rendering part specifically meant for blending or special shader effects not suited for a deferred rendering pipeline. To illustrate how this works, we&rsquo;ll render the light sources as small cubes using a forward renderer as the light cubes require a special shader (simply output a single light color).</p>
<h4 id="combining-deferred-rendering-with-forward-rendering">Combining deferred rendering with forward rendering</h4>
<p>Say we want to render each of the light sources as a 3D cube positioned at the light source&rsquo;s position emitting the color of the light. A first idea that comes to mind is to simply forward render all the light sources on top of the deferred lighting quad at the end of the deferred shading pipeline. So basically render the cubes as we&rsquo;d normally do, but only after we&rsquo;ve finished the deferred rendering operations. In code this will look a bit like this:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="c1">// deferred lighting pass
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1"></span><span class="p">[...]</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">RenderQuad</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="c1">// now render all light cubes with forward rendering as we&#39;d normally do
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="c1"></span><span class="n">shaderLightBox</span><span class="p">.</span><span class="n">use</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="n">shaderLightBox</span><span class="p">.</span><span class="n">setMat4</span><span class="p">(</span><span class="s">&#34;projection&#34;</span><span class="p">,</span> <span class="n">projection</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="n">shaderLightBox</span><span class="p">.</span><span class="n">setMat4</span><span class="p">(</span><span class="s">&#34;view&#34;</span><span class="p">,</span> <span class="n">view</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">lightPositions</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="n">model</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="n">model</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">translate</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">lightPositions</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="n">model</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">scale</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.25f</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="n">shaderLightBox</span><span class="p">.</span><span class="n">setMat4</span><span class="p">(</span><span class="s">&#34;model&#34;</span><span class="p">,</span> <span class="n">model</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="n">shaderLightBox</span><span class="p">.</span><span class="n">setVec3</span><span class="p">(</span><span class="s">&#34;lightColor&#34;</span><span class="p">,</span> <span class="n">lightColors</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="n">RenderCube</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>However, these rendered cubes do not take any of the stored geometry depth of the deferred renderer into account and are, as a result, always rendered on top of the previously rendered objects; this isn&rsquo;t the result we were looking for.</p>
<p><a href="#R-image-0c82b3e3f947d0ec9c1c1bfd5f2745ce" class="lightbox-link"><img src="./assets/deferred_lights_no_depth.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-0c82b3e3f947d0ec9c1c1bfd5f2745ce"><img src="./assets/deferred_lights_no_depth.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>What we need to do, is first copy the depth information stored in the geometry pass into the default framebuffer&rsquo;s depth buffer and only then render the light cubes. This way the light cubes&rsquo; fragments are only rendered when on top of the previously rendered geometry.</p>
<p>We can copy the content of a framebuffer to the content of another framebuffer with the help of glBlitFramebuffer, a function we also used in the <a href="https://learnopengl.com/Advanced-OpenGL/Anti-Aliasing" target="_blank">anti-aliasing</a> chapter to resolve multisampled framebuffers. The glBlitFramebuffer function allows us to copy a user-defined region of a framebuffer to a user-defined region of another framebuffer.</p>
<p>We stored the depth of all the objects rendered in the deferred geometry pass in the gBuffer FBO. If we were to copy the content of its depth buffer to the depth buffer of the default framebuffer, the light cubes would then render as if all of the scene&rsquo;s geometry was rendered with forward rendering. As briefly explained in the anti-aliasing chapter, we have to specify a framebuffer as the read framebuffer and similarly specify a framebuffer as the write framebuffer:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_READ_FRAMEBUFFER</span><span class="p">,</span> <span class="n">gBuffer</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_DRAW_FRAMEBUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// write to default framebuffer
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="c1"></span><span class="n">glBlitFramebuffer</span><span class="p">(</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">  <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SCR_WIDTH</span><span class="p">,</span> <span class="n">SCR_HEIGHT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SCR_WIDTH</span><span class="p">,</span> <span class="n">SCR_HEIGHT</span><span class="p">,</span> <span class="n">GL_DEPTH_BUFFER_BIT</span><span class="p">,</span> <span class="n">GL_NEAREST</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="c1">// now render light cubes as before
</span></span></span><span class="line"><span class="ln">8</span><span class="cl"><span class="c1"></span><span class="p">[...]</span> 
</span></span></code></pre></div><p>Here we copy the entire read framebuffer&rsquo;s depth buffer content to the default framebuffer&rsquo;s depth buffer; this can similarly be done for color buffers and stencil buffers. If we then render the light cubes, the cubes indeed render correctly over the scene&rsquo;s geometry:</p>
<p><a href="#R-image-4eb02dddb043b62fa012f4b88526111f" class="lightbox-link"><img src="./assets/deferred_lights_depth.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-4eb02dddb043b62fa012f4b88526111f"><img src="./assets/deferred_lights_depth.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>You can find the full source code of the demo <a href="https://learnopengl.com/code_viewer_gh.php?code=src/5.advanced_lighting/8.1.deferred_shading/deferred_shading.cpp" target="_blank">here</a>.</p>
<p>With this approach we can easily combine deferred shading with forward shading. This is great as we can now still apply blending and render objects that require special shader effects, something that isn&rsquo;t possible in a pure deferred rendering context.</p>
<h4 id="a-larger-number-of-lights">A larger number of lights</h4>
<p>What deferred rendering is often praised for, is its ability to render an enormous amount of light sources without a heavy cost on performance. Deferred rendering by itself doesn&rsquo;t allow for a very large amount of light sources as we&rsquo;d still have to calculate each fragment&rsquo;s lighting component for each of the scene&rsquo;s light sources. What makes a large amount of light sources possible is a very neat optimization we can apply to the deferred rendering pipeline: that of light volumes.</p>
<p>Normally when we render a fragment in a large lit scene we&rsquo;d calculate the contribution of <strong>each</strong> light source in a scene, regardless of their distance to the fragment. A large portion of these light sources will never reach the fragment, so why waste all these lighting computations?</p>
<p>The idea behind light volumes is to calculate the radius, or volume, of a light source i.e. the area where its light is able to reach fragments. As most light sources use some form of attenuation, we can use that to calculate the maximum distance or radius their light is able to reach. We then only do the expensive lighting calculations if a fragment is inside one or more of these light volumes. This can save us a considerable amount of computation as we now only calculate lighting where it&rsquo;s necessary.</p>
<p>The trick to this approach is mostly figuring out the size or radius of the light volume of a light source.</p>
<h5 id="calculating-a-lights-volume-or-radius">Calculating a light&rsquo;s volume or radius</h5>
<p>To obtain a light&rsquo;s volume radius we have to solve the attenuation equation for when its light contribution becomes <code>0.0</code>. For the attenuation function we&rsquo;ll use the function introduced in the <a href="https://learnopengl.com/Lighting/Light-casters" target="_blank">light casters</a> chapter:</p>

<span class="math align-center">$$
F_{light} = \frac{I}{K_c + K_l * d + K_q * d^2}
$$</span><p>What we want to do is solve this equation for when 
<span class="math align-center">$F_{light}$</span> is <code>0.0</code>. However, this equation will never exactly reach the value <code>0.0</code>, so there won&rsquo;t be a solution. What we can do however, is not solve the equation for <code>0.0</code>, but solve it for a brightness value that is close to <code>0.0</code> but still perceived as dark. The brightness value of 
<span class="math align-center">$5/256$</span> would be acceptable for this chapter&rsquo;s demo scene; divided by 256 as the default 8-bit framebuffer can only display that many intensities per component.</p>
<p><note>The attenuation function used is mostly dark in its visible range. If we were to limit it to an even darker brightness than <strong>5/256</strong>, the light volume would become too large and thus less effective. As long as a user cannot see a sudden cut-off of a light source at its volume borders we&rsquo;ll be fine. Of course this always depends on the type of scene; a higher brightness threshold results in smaller light volumes and thus a better efficiency, but can produce noticeable artifacts where lighting seems to break at a volume&rsquo;s borders.</note></p>
<p>The attenuation equation we have to solve becomes:</p>

<span class="math align-center">$$
\frac{5}{256} = \frac{I_{max}}{Attenuation}
$$</span><p>Here 
<span class="math align-center">$I_{max}$</span> is the light source&rsquo;s brightest color component. We use a light source&rsquo;s brightest color component as solving the equation for a light&rsquo;s brightest intensity value best reflects the ideal light volume radius.</p>
<p>From here on we continue solving the equation:</p>

<span class="math align-center">$$
\frac{5}{256} * Attenuation = I_{max}
$$</span>
<span class="math align-center">$$
5 * Attenuation = I_{max} * 256
$$</span>
<span class="math align-center">$$
Attenuation = I_{max} * \frac{256}{5}
$$</span>
<span class="math align-center">$$
K_c + K_l * d + K_q * d^2 = I_{max} * \frac{256}{5}
$$</span>
<span class="math align-center">$$
K_q * d^2 + K_l * d + K_c - I_{max} * \frac{256}{5} = 0
$$</span><p>The last equation is an equation of the form 
<span class="math align-center">$ax^2 + bx + c = 0$</span>, which we can solve using the quadratic equation:</p>

<span class="math align-center">$$
x = \frac{-K_l + \sqrt{K_l^2 - 4 * K_q * (K_c - I_{max} * \frac{256}{5})}}{2 * K_q}
$$</span><p>This gives us a general equation that allows us to calculate x� i.e. the light volume&rsquo;s radius for the light source given a constant, linear, and quadratic parameter:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">float</span> <span class="n">constant</span>  <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="kt">float</span> <span class="n">linear</span>    <span class="o">=</span> <span class="mf">0.7</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="kt">float</span> <span class="n">quadratic</span> <span class="o">=</span> <span class="mf">1.8</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="kt">float</span> <span class="n">lightMax</span>  <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">fmaxf</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">fmaxf</span><span class="p">(</span><span class="n">lightColor</span><span class="p">.</span><span class="n">r</span><span class="p">,</span> <span class="n">lightColor</span><span class="p">.</span><span class="n">g</span><span class="p">),</span> <span class="n">lightColor</span><span class="p">.</span><span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="kt">float</span> <span class="n">radius</span>    <span class="o">=</span> 
</span></span><span class="line"><span class="ln">6</span><span class="cl">  <span class="p">(</span><span class="o">-</span><span class="n">linear</span> <span class="o">+</span>  <span class="n">std</span><span class="o">::</span><span class="n">sqrtf</span><span class="p">(</span><span class="n">linear</span> <span class="o">*</span> <span class="n">linear</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">quadratic</span> <span class="o">*</span> <span class="p">(</span><span class="n">constant</span> <span class="o">-</span> <span class="p">(</span><span class="mf">256.0</span> <span class="o">/</span> <span class="mf">5.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">lightMax</span><span class="p">)))</span> 
</span></span><span class="line"><span class="ln">7</span><span class="cl">  <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">quadratic</span><span class="p">);</span>  
</span></span></code></pre></div><p>We calculate this radius for each light source of the scene and use it to only calculate lighting for that light source if a fragment is inside the light source&rsquo;s volume. Below is the updated lighting pass fragment shader that takes the calculated light volumes into account. Note that this approach is merely done for teaching purposes and not viable in a practical setting as we&rsquo;ll soon discuss:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">struct</span> <span class="nc">Light</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    <span class="p">[...]</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="kt">float</span> <span class="n">Radius</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="p">};</span> 
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="p">[...]</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NR_LIGHTS</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">        <span class="c1">// calculate distance between light source and current fragment
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="c1"></span>        <span class="kt">float</span> <span class="n">distance</span> <span class="o">=</span> <span class="n">length</span><span class="p">(</span><span class="n">lights</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Position</span> <span class="o">-</span> <span class="n">FragPos</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">distance</span> <span class="o">&lt;</span> <span class="n">lights</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Radius</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">            <span class="c1">// do expensive lighting
</span></span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="c1"></span>            <span class="p">[...]</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">    <span class="p">}</span>   
</span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>The results are exactly the same as before, but this time each light only calculates lighting for the light sources in which volume it resides.</p>
<p>You can find the final source code of the demo <a href="https://learnopengl.com/code_viewer_gh.php?code=src/5.advanced_lighting/8.2.deferred_shading_volumes/deferred_shading_volumes.cpp" target="_blank">here</a>.</p>
<h5 id="how-we-really-use-light-volumes">How we really use light volumes</h5>
<p>The fragment shader shown above doesn&rsquo;t really work in practice and only illustrates how we can <em>sort of</em> use a light&rsquo;s volume to reduce lighting calculations. The reality is that your GPU and GLSL are pretty bad at optimizing loops and branches. The reason for this is that shader execution on the GPU is highly parallel and most architectures have a requirement that for large collection of threads they need to run the exact same shader code for it to be efficient. This often means that a shader is run that executes <strong>all</strong> branches of an <code>if</code> statement to ensure the shader runs are the same for that group of threads, making our previous <em>radius check</em> optimization completely useless; we&rsquo;d still calculate lighting for all light sources!</p>
<p>The appropriate approach to using light volumes is to render actual spheres, scaled by the light volume radius. The centers of these spheres are positioned at the light source&rsquo;s position, and as it is scaled by the light volume radius the sphere exactly encompasses the light&rsquo;s visible volume. This is where the trick comes in: we use the deferred lighting shader for rendering the spheres. As a rendered sphere produces fragment shader invocations that exactly match the pixels the light source affects, we only render the relevant pixels and skip all other pixels. The image below illustrates this:</p>
<p><a href="#R-image-82af1724a1b0b1c244801b96eb04340f" class="lightbox-link"><img src="./assets/deferred_light_volume_rendered.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-82af1724a1b0b1c244801b96eb04340f"><img src="./assets/deferred_light_volume_rendered.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>This is done for each light source in the scene, and the resulting fragments are additively blended together. The result is then the exact same scene as before, but this time rendering only the relevant fragments per light source. This effectively reduces the computations from <code>nr_objects * nr_lights</code> to <code>nr_objects + nr_lights</code>, which makes it incredibly efficient in scenes with a large number of lights. This approach is what makes deferred rendering so suitable for rendering a large number of lights.</p>
<p>There is still an issue with this approach: face culling should be enabled (otherwise we&rsquo;d render a light&rsquo;s effect twice) and when it is enabled the user may enter a light source&rsquo;s volume after which the volume isn&rsquo;t rendered anymore (due to back-face culling), removing the light source&rsquo;s influence; we can solve that by only rendering the spheres&rsquo; back faces.</p>
<p>Rendering light volumes does take its toll on performance, and while it is generally much faster than normal deferred shading for rendering a large number of lights, there&rsquo;s still more we can optimize. Two other popular (and more efficient) extensions on top of deferred shading exist called deferred lighting and tile-based deferred shading. These are even more efficient at rendering large amounts of light and also allow for relatively efficient MSAA.</p>
<h4 id="deferred-rendering-vs-forward-rendering">Deferred rendering vs forward rendering</h4>
<p>By itself (without light volumes), deferred shading is a nice optimization as each pixel only runs a single fragment shader, compared to forward rendering where we&rsquo;d often run the fragment shader multiple times per pixel. Deferred rendering does come with a few disadvantages though: a large memory overhead, no MSAA, and blending still has to be done with forward rendering.</p>
<p>When you have a small scene and not too many lights, deferred rendering is not necessarily faster and sometimes even slower as the overhead then outweighs the benefits of deferred rendering. In more complex scenes, deferred rendering quickly becomes a significant optimization; especially with the more advanced optimization extensions. In addition, some render effects (especially post-processing effects) become cheaper on a deferred render pipeline as a lot of scene inputs are already available from the g-buffer.</p>
<p>As a final note I&rsquo;d like to mention that basically all effects that can be accomplished with forward rendering can also be implemented in a deferred rendering context; this often only requires a small translation step. For instance, if we want to use normal mapping in a deferred renderer, we&rsquo;d change the geometry pass shaders to output a world-space normal extracted from a normal map (using a TBN matrix) instead of the surface normal; the lighting calculations in the lighting pass don&rsquo;t need to change at all. And if you want parallax mapping to work, you&rsquo;d want to first displace the texture coordinates in the geometry pass before sampling an object&rsquo;s diffuse, specular, and normal textures. Once you understand the idea behind deferred rendering, it&rsquo;s not too difficult to get creative.</p>
<h4 id="additional-resources-10">Additional resources</h4>
<ul>
<li><a href="http://ogldev.atspace.co.uk/www/tutorial35/tutorial35.html" target="_blank">Tutorial 35: Deferred Shading - Part 1</a>: a three-part deferred shading tutorial by OGLDev.</li>
<li><a href="https://software.intel.com/sites/default/files/m/d/4/1/d/8/lauritzen_deferred_shading_siggraph_2010.pdf" target="_blank">Deferred Rendering for Current and Future Rendering Pipelines</a>: slides by Andrew Lauritzen discussing high-level tile-based deferred shading and deferred lighting.</li>
</ul>
<h3 id="ssao">SSAO</h3>
<p>We&rsquo;ve briefly touched the topic in the basic lighting chapter: ambient lighting. Ambient lighting is a fixed light constant we add to the overall lighting of a scene to simulate the scattering of light. In reality, light scatters in all kinds of directions with varying intensities so the indirectly lit parts of a scene should also have varying intensities. One type of indirect lighting approximation is called ambient occlusion that tries to approximate indirect lighting by darkening creases, holes, and surfaces that are close to each other. These areas are largely occluded by surrounding geometry and thus light rays have fewer places to escape to, hence the areas appear darker. Take a look at the corners and creases of your room to see that the light there seems just a little darker.</p>
<p>Below is an example image of a scene with and without ambient occlusion. Notice how especially between the creases, the (ambient) light is more occluded:</p>
<p><a href="#R-image-f1a1446205f34495a4cb36ab58f58dc0" class="lightbox-link"><img src="./assets/ssao_example.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f1a1446205f34495a4cb36ab58f58dc0"><img src="./assets/ssao_example.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>While not an incredibly obvious effect, the image with ambient occlusion enabled does feel a lot more realistic due to these small occlusion-like details, giving the entire scene a greater feel of depth.</p>
<p>Ambient occlusion techniques are expensive as they have to take surrounding geometry into account. One could shoot a large number of rays for each point in space to determine its amount of occlusion, but that quickly becomes computationally infeasible for real-time solutions. In 2007, Crytek published a technique called screen-space ambient occlusion (SSAO) for use in their title <em>Crysis</em>. The technique uses a scene&rsquo;s depth buffer in screen-space to determine the amount of occlusion instead of real geometrical data. This approach is incredibly fast compared to real ambient occlusion and gives plausible results, making it the de-facto standard for approximating real-time ambient occlusion.</p>
<p>The basics behind screen-space ambient occlusion are simple: for each fragment on a screen-filled quad we calculate an occlusion factor based on the fragment&rsquo;s surrounding depth values. The occlusion factor is then used to reduce or nullify the fragment&rsquo;s ambient lighting component. The occlusion factor is obtained by taking multiple depth samples in a sphere sample kernel surrounding the fragment position and compare each of the samples with the current fragment&rsquo;s depth value. The number of samples that have a higher depth value than the fragment&rsquo;s depth represents the occlusion factor.</p>
<p><a href="#R-image-00e0f798cf59f6ca14628845ce32d132" class="lightbox-link"><img src="./assets/ssao_crysis_circle.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-00e0f798cf59f6ca14628845ce32d132"><img src="./assets/ssao_crysis_circle.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Each of the gray depth samples that are inside geometry contribute to the total occlusion factor; the more samples we find inside geometry, the less ambient lighting the fragment should eventually receive.</p>
<p>It is clear the quality and precision of the effect directly relates to the number of surrounding samples we take. If the sample count is too low, the precision drastically reduces and we get an artifact called banding; if it is too high, we lose performance. We can reduce the amount of samples we have to test by introducing some randomness into the sample kernel. By randomly rotating the sample kernel each fragment we can get high quality results with a much smaller amount of samples. This does come at a price as the randomness introduces a noticeable noise pattern that we&rsquo;ll have to fix by blurring the results. Below is an image (courtesy of <a href="http://john-chapman-graphics.blogspot.com/" target="_blank">John Chapman</a>) showcasing the banding effect and the effect randomness has on the results:</p>
<p><a href="#R-image-042c47ba516e94c6b8e1353b15680616" class="lightbox-link"><img src="./assets/ssao_banding_noise.jpg" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-042c47ba516e94c6b8e1353b15680616"><img src="./assets/ssao_banding_noise.jpg" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>As you can see, even though we get noticeable banding on the SSAO results due to a low sample count, by introducing some randomness the banding effects are completely gone.</p>
<p>The SSAO method developed by Crytek had a certain visual style. Because the sample kernel used was a sphere, it caused flat walls to look gray as half of the kernel samples end up being in the surrounding geometry. Below is an image of Crysis&rsquo;s screen-space ambient occlusion that clearly portrays this gray feel:</p>
<p><a href="#R-image-54f2a792ecc80c11ae322990e7b4e268" class="lightbox-link"><img src="./assets/ssao_crysis.jpg" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-54f2a792ecc80c11ae322990e7b4e268"><img src="./assets/ssao_crysis.jpg" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>For that reason we won&rsquo;t be using a sphere sample kernel, but rather a hemisphere sample kernel oriented along a surface&rsquo;s normal vector.</p>
<p><a href="#R-image-f7cb161b374bb514c7e7ab8d4b0ee5e9" class="lightbox-link"><img src="./assets/ssao_hemisphere.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f7cb161b374bb514c7e7ab8d4b0ee5e9"><img src="./assets/ssao_hemisphere.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>By sampling around this normal-oriented hemisphere we do not consider the fragment&rsquo;s underlying geometry to be a contribution to the occlusion factor. This removes the gray-feel of ambient occlusion and generally produces more realistic results. This chapter&rsquo;s technique is based on this normal-oriented hemisphere method and a slightly modified version of John Chapman&rsquo;s brilliant <a href="http://john-chapman-graphics.blogspot.nl/2013/01/ssao-tutorial.html" target="_blank">SSAO tutorial</a>.</p>
<h4 id="sample-buffers">Sample buffers</h4>
<p>SSAO requires geometrical info as we need some way to determine the occlusion factor of a fragment. For each fragment, we&rsquo;re going to need the following data:</p>
<ul>
<li>A per-fragment <strong>position</strong> vector.</li>
<li>A per-fragment <strong>normal</strong> vector.</li>
<li>A per-fragment <strong>albedo</strong> color.</li>
<li>A <strong>sample kernel</strong>.</li>
<li>A per-fragment <strong>random rotation</strong> vector used to rotate the sample kernel.</li>
</ul>
<p>Using a per-fragment view-space position we can orient a sample hemisphere kernel around the fragment&rsquo;s view-space surface normal and use this kernel to sample the position buffer texture at varying offsets. For each per-fragment kernel sample we compare its depth with its depth in the position buffer to determine the amount of occlusion. The resulting occlusion factor is then used to limit the final ambient lighting component. By also including a per-fragment rotation vector we can significantly reduce the number of samples we&rsquo;ll need to take as we&rsquo;ll soon see.</p>
<p><a href="#R-image-96a31efbaffdeaf1dda2daa997ce9a1d" class="lightbox-link"><img src="./assets/ssao_overview.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-96a31efbaffdeaf1dda2daa997ce9a1d"><img src="./assets/ssao_overview.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>As SSAO is a screen-space technique we calculate its effect on each fragment on a screen-filled 2D quad. This does mean we have no geometrical information of the scene. What we could do, is render the geometrical per-fragment data into screen-space textures that we then later send to the SSAO shader so we have access to the per-fragment geometrical data. If you&rsquo;ve followed along with the previous chapter you&rsquo;ll realize this looks quite like a deferred renderer&rsquo;s G-buffer setup. For that reason SSAO is perfectly suited in combination with deferred rendering as we already have the position and normal vectors in the G-buffer.</p>
<p><note>In this chapter we&rsquo;re going to implement SSAO on top of a slightly simplified version of the deferred renderer from the <a href="https://learnopengl.com/Advanced-Lighting/Deferred-Shading" target="_blank">deferred shading</a> chapter. If you&rsquo;re not sure what deferred shading is, be sure to first read up on that.</note></p>
<p>As we should have per-fragment position and normal data available from the scene objects, the fragment shader of the geometry stage is fairly simple:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">out</span> <span class="n">vec4</span> <span class="n">gPosition</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="n">out</span> <span class="n">vec3</span> <span class="n">gNormal</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="n">out</span> <span class="n">vec4</span> <span class="n">gAlbedoSpec</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">in</span> <span class="n">vec2</span> <span class="n">TexCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="n">in</span> <span class="n">vec3</span> <span class="n">FragPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="n">in</span> <span class="n">vec3</span> <span class="n">Normal</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="p">{</span>    
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="c1">// store the fragment position vector in the first gbuffer texture
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="c1"></span>    <span class="n">gPosition</span> <span class="o">=</span> <span class="n">FragPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="c1">// also store the per-fragment normals into the gbuffer
</span></span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="c1"></span>    <span class="n">gNormal</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">Normal</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="c1">// and the diffuse per-fragment color, ignore specular
</span></span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="c1"></span>    <span class="n">gAlbedoSpec</span><span class="p">.</span><span class="n">rgb</span> <span class="o">=</span> <span class="n">vec3</span><span class="p">(</span><span class="mf">0.95</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>Since SSAO is a screen-space technique where occlusion is calculated from the visible view, it makes sense to implement the algorithm in view-space. Therefore, FragPos and Normal as supplied by the geometry stage&rsquo;s vertex shader are transformed to view space (multiplied by the view matrix as well).</p>
<p><note>It is possible to reconstruct the position vectors from depth values alone, using some clever tricks as Matt Pettineo described in his <a href="https://mynameismjp.wordpress.com/2010/09/05/position-from-depth-3/" target="_blank">blog</a>. This requires a few extra calculations in the shaders, but saves us from having to store position data in the G-buffer (which costs a lot of memory). For the sake of a more simple example, we&rsquo;ll leave these optimizations out of the chapter.</note></p>
<p>The gPosition color buffer texture is configured as follows:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glGenTextures</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gPosition</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">gPosition</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">glTexImage2D</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGBA16F</span><span class="p">,</span> <span class="n">SCR_WIDTH</span><span class="p">,</span> <span class="n">SCR_HEIGHT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGBA</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MIN_FILTER</span><span class="p">,</span> <span class="n">GL_NEAREST</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MAG_FILTER</span><span class="p">,</span> <span class="n">GL_NEAREST</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_S</span><span class="p">,</span> <span class="n">GL_CLAMP_TO_EDGE</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_T</span><span class="p">,</span> <span class="n">GL_CLAMP_TO_EDGE</span><span class="p">);</span>  
</span></span></code></pre></div><p>This gives us a position texture that we can use to obtain depth values for each of the kernel samples. Note that we store the positions in a floating point data format; this way position values aren&rsquo;t clamped to [<code>0.0</code>,<code>1.0</code>] and we need the higher precision. Also note the texture wrapping method of GL_CLAMP_TO_EDGE. This ensures we don&rsquo;t accidentally oversample position/depth values in screen-space outside the texture&rsquo;s default coordinate region.</p>
<p>Next, we need the actual hemisphere sample kernel and some method to randomly rotate it.</p>
<h4 id="normal-oriented-hemisphere">Normal-oriented hemisphere</h4>
<p>We need to generate a number of samples oriented along the normal of a surface. As we briefly discussed at the start of this chapter, we want to generate samples that form a hemisphere. As it is difficult nor plausible to generate a sample kernel for each surface normal direction, we&rsquo;re going to generate a sample kernel in <a href="https://learnopengl.com/Advanced-Lighting/Normal-Mapping" target="_blank">tangent space</a>, with the normal vector pointing in the positive z direction.</p>
<p><a href="#R-image-b47af7d8a02fba80c91ed41e920b5c75" class="lightbox-link"><img src="./assets/ssao_hemisphere.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b47af7d8a02fba80c91ed41e920b5c75"><img src="./assets/ssao_hemisphere.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Assuming we have a unit hemisphere, we can obtain a sample kernel with a maximum of <code>64</code> sample values as follows:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">uniform_real_distribution</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">randomFloats</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span> <span class="c1">// random floats between [0.0, 1.0]
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">default_random_engine</span> <span class="n">generator</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="o">&gt;</span> <span class="n">ssaoKernel</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">64</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">sample</span><span class="p">(</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">        <span class="n">randomFloats</span><span class="p">(</span><span class="n">generator</span><span class="p">)</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">,</span> 
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        <span class="n">randomFloats</span><span class="p">(</span><span class="n">generator</span><span class="p">)</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">,</span> 
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">        <span class="n">randomFloats</span><span class="p">(</span><span class="n">generator</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="p">);</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="n">sample</span>  <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">normalize</span><span class="p">(</span><span class="n">sample</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="n">sample</span> <span class="o">*=</span> <span class="n">randomFloats</span><span class="p">(</span><span class="n">generator</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="n">ssaoKernel</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">sample</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>We vary the <code>x</code> and <code>y</code> direction in tangent space between <code>-1.0</code> and <code>1.0</code>, and vary the z direction of the samples between <code>0.0</code> and <code>1.0</code> (if we varied the z direction between <code>-1.0</code> and <code>1.0</code> as well we&rsquo;d have a sphere sample kernel). As the sample kernel will be oriented along the surface normal, the resulting sample vectors will all end up in the hemisphere.</p>
<p>Currently, all samples are randomly distributed in the sample kernel, but we&rsquo;d rather place a larger weight on occlusions close to the actual fragment. We want to distribute more kernel samples closer to the origin. We can do this with an accelerating interpolation function:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl">   <span class="kt">float</span> <span class="n">scale</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">i</span> <span class="o">/</span> <span class="mf">64.0</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">2</span><span class="cl">   <span class="n">scale</span>   <span class="o">=</span> <span class="n">lerp</span><span class="p">(</span><span class="mf">0.1f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="n">scale</span> <span class="o">*</span> <span class="n">scale</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">   <span class="n">sample</span> <span class="o">*=</span> <span class="n">scale</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">   <span class="n">ssaoKernel</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">sample</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>Where lerp is defined as:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">float</span> <span class="nf">lerp</span><span class="p">(</span><span class="kt">float</span> <span class="n">a</span><span class="p">,</span> <span class="kt">float</span> <span class="n">b</span><span class="p">,</span> <span class="kt">float</span> <span class="n">f</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">f</span> <span class="o">*</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>This gives us a kernel distribution that places most samples closer to its origin.</p>
<p><a href="#R-image-b63aa5b014277f9e0e2c1870da512ddb" class="lightbox-link"><img src="./assets/ssao_kernel_weight.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b63aa5b014277f9e0e2c1870da512ddb"><img src="./assets/ssao_kernel_weight.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Each of the kernel samples will be used to offset the view-space fragment position to sample surrounding geometry. We do need quite a lot of samples in view-space in order to get realistic results, which may be too heavy on performance. However, if we can introduce some semi-random rotation/noise on a per-fragment basis, we can significantly reduce the number of samples required.</p>
<h4 id="random-kernel-rotations">Random kernel rotations</h4>
<p>By introducing some randomness onto the sample kernels we largely reduce the number of samples necessary to get good results. We could create a random rotation vector for each fragment of a scene, but that quickly eats up memory. It makes more sense to create a small texture of random rotation vectors that we tile over the screen.</p>
<p>We create a 4x4 array of random rotation vectors oriented around the tangent-space surface normal:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="o">&gt;</span> <span class="n">ssaoNoise</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">noise</span><span class="p">(</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">        <span class="n">randomFloats</span><span class="p">(</span><span class="n">generator</span><span class="p">)</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">,</span> 
</span></span><span class="line"><span class="ln">6</span><span class="cl">        <span class="n">randomFloats</span><span class="p">(</span><span class="n">generator</span><span class="p">)</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">,</span> 
</span></span><span class="line"><span class="ln">7</span><span class="cl">        <span class="mf">0.0f</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">8</span><span class="cl">    <span class="n">ssaoNoise</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">noise</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">9</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>As the sample kernel is oriented along the positive z direction in tangent space, we leave the <code>z</code> component at <code>0.0</code> so we rotate around the <code>z</code> axis.</p>
<p>We then create a 4x4 texture that holds the random rotation vectors; make sure to set its wrapping method to GL_REPEAT so it properly tiles over the screen.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">noiseTexture</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glGenTextures</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">noiseTexture</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">noiseTexture</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="n">glTexImage2D</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGBA16F</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGB</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ssaoNoise</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MIN_FILTER</span><span class="p">,</span> <span class="n">GL_NEAREST</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MAG_FILTER</span><span class="p">,</span> <span class="n">GL_NEAREST</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_S</span><span class="p">,</span> <span class="n">GL_REPEAT</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">8</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_T</span><span class="p">,</span> <span class="n">GL_REPEAT</span><span class="p">);</span>  
</span></span></code></pre></div><p>We now have all the relevant input data we need to implement SSAO.</p>
<h4 id="the-ssao-shader">The SSAO shader</h4>
<p>The SSAO shader runs on a 2D screen-filled quad that calculates the occlusion value for each of its fragments. As we need to store the result of the SSAO stage (for use in the final lighting shader), we create yet another framebuffer object:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ssaoFBO</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="n">glGenFramebuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ssaoFBO</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">ssaoFBO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ssaoColorBuffer</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">glGenTextures</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ssaoColorBuffer</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">ssaoColorBuffer</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="n">glTexImage2D</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RED</span><span class="p">,</span> <span class="n">SCR_WIDTH</span><span class="p">,</span> <span class="n">SCR_HEIGHT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RED</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MIN_FILTER</span><span class="p">,</span> <span class="n">GL_NEAREST</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MAG_FILTER</span><span class="p">,</span> <span class="n">GL_NEAREST</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">  
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="n">glFramebufferTexture2D</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">GL_COLOR_ATTACHMENT0</span><span class="p">,</span> <span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">ssaoColorBuffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  
</span></span></code></pre></div><p>As the ambient occlusion result is a single grayscale value we&rsquo;ll only need a texture&rsquo;s red component, so we set the color buffer&rsquo;s internal format to GL_RED.</p>
<p>The complete process for rendering SSAO then looks a bit like this:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="c1">// geometry pass: render stuff into G-buffer
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1"></span><span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">gBuffer</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="p">[...]</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="c1">// use G-buffer to render SSAO texture
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1"></span><span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">ssaoFBO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="n">glClear</span><span class="p">(</span><span class="n">GL_COLOR_BUFFER_BIT</span><span class="p">);</span>    
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="n">glActiveTexture</span><span class="p">(</span><span class="n">GL_TEXTURE0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">gPosition</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="n">glActiveTexture</span><span class="p">(</span><span class="n">GL_TEXTURE1</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">gNormal</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="n">glActiveTexture</span><span class="p">(</span><span class="n">GL_TEXTURE2</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">noiseTexture</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="n">shaderSSAO</span><span class="p">.</span><span class="n">use</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="n">SendKernelSamplesToShader</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">    <span class="n">shaderSSAO</span><span class="p">.</span><span class="n">setMat4</span><span class="p">(</span><span class="s">&#34;projection&#34;</span><span class="p">,</span> <span class="n">projection</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">    <span class="n">RenderQuad</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">  
</span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="c1">// lighting pass: render scene lighting
</span></span></span><span class="line"><span class="ln">22</span><span class="cl"><span class="c1"></span><span class="n">glClear</span><span class="p">(</span><span class="n">GL_COLOR_BUFFER_BIT</span> <span class="o">|</span> <span class="n">GL_DEPTH_BUFFER_BIT</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl"><span class="n">shaderLightingPass</span><span class="p">.</span><span class="n">use</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl"><span class="p">[...]</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl"><span class="n">glActiveTexture</span><span class="p">(</span><span class="n">GL_TEXTURE3</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl"><span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">ssaoColorBuffer</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl"><span class="p">[...]</span>
</span></span><span class="line"><span class="ln">28</span><span class="cl"><span class="n">RenderQuad</span><span class="p">();</span>  
</span></span></code></pre></div><p>The shaderSSAO shader takes as input the relevant G-buffer textures, the noise texture, and the normal-oriented hemisphere kernel samples:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">out</span> <span class="kt">float</span> <span class="n">FragColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">in</span> <span class="n">vec2</span> <span class="n">TexCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">gPosition</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">gNormal</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">texNoise</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="n">uniform</span> <span class="n">vec3</span> <span class="n">samples</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="n">uniform</span> <span class="n">mat4</span> <span class="n">projection</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="c1">// tile noise texture over screen, based on screen dimensions divided by noise size
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="n">vec2</span> <span class="n">noiseScale</span> <span class="o">=</span> <span class="n">vec2</span><span class="p">(</span><span class="mf">800.0</span><span class="o">/</span><span class="mf">4.0</span><span class="p">,</span> <span class="mf">600.0</span><span class="o">/</span><span class="mf">4.0</span><span class="p">);</span> <span class="c1">// screen = 800x600
</span></span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">    <span class="p">[...]</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>Interesting to note here is the noiseScale variable. We want to tile the noise texture all over the screen, but as the TexCoords vary between <code>0.0</code> and <code>1.0</code>, the texNoise texture won&rsquo;t tile at all. So we&rsquo;ll calculate the required amount to scale TexCoords by dividing the screen&rsquo;s dimensions by the noise texture size.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">vec3</span> <span class="n">fragPos</span>   <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">gPosition</span><span class="p">,</span> <span class="n">TexCoords</span><span class="p">).</span><span class="n">xyz</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">vec3</span> <span class="n">normal</span>    <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">gNormal</span><span class="p">,</span> <span class="n">TexCoords</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">vec3</span> <span class="n">randomVec</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">texNoise</span><span class="p">,</span> <span class="n">TexCoords</span> <span class="o">*</span> <span class="n">noiseScale</span><span class="p">).</span><span class="n">xyz</span><span class="p">;</span>  
</span></span></code></pre></div><p>As we set the tiling parameters of texNoise to GL_REPEAT, the random values will be repeated all over the screen. Together with the fragPos and normal vector, we then have enough data to create a TBN matrix that transforms any vector from tangent-space to view-space:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">vec3</span> <span class="n">tangent</span>   <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">randomVec</span> <span class="o">-</span> <span class="n">normal</span> <span class="o">*</span> <span class="n">dot</span><span class="p">(</span><span class="n">randomVec</span><span class="p">,</span> <span class="n">normal</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">vec3</span> <span class="n">bitangent</span> <span class="o">=</span> <span class="n">cross</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="n">tangent</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">mat3</span> <span class="n">TBN</span>       <span class="o">=</span> <span class="n">mat3</span><span class="p">(</span><span class="n">tangent</span><span class="p">,</span> <span class="n">bitangent</span><span class="p">,</span> <span class="n">normal</span><span class="p">);</span>  
</span></span></code></pre></div><p>Using a process called the Gramm-Schmidt process we create an orthogonal basis, each time slightly tilted based on the value of randomVec. Note that because we use a random vector for constructing the tangent vector, there is no need to have the TBN matrix exactly aligned to the geometry&rsquo;s surface, thus no need for per-vertex tangent (and bitangent) vectors.</p>
<p>Next we iterate over each of the kernel samples, transform the samples from tangent to view-space, add them to the current fragment position, and compare the fragment position&rsquo;s depth with the sample depth stored in the view-space position buffer. Let&rsquo;s discuss this in a step-by-step fashion:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">float</span> <span class="n">occlusion</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">kernelSize</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="c1">// get sample position
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="c1"></span>    <span class="n">vec3</span> <span class="n">samplePos</span> <span class="o">=</span> <span class="n">TBN</span> <span class="o">*</span> <span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="c1">// from tangent to view-space
</span></span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="c1"></span>    <span class="n">samplePos</span> <span class="o">=</span> <span class="n">fragPos</span> <span class="o">+</span> <span class="n">samplePos</span> <span class="o">*</span> <span class="n">radius</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">7</span><span class="cl">    
</span></span><span class="line"><span class="ln">8</span><span class="cl">    <span class="p">[...]</span>
</span></span><span class="line"><span class="ln">9</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>Here kernelSize and radius are variables that we can use to tweak the effect; in this case a value of 64 and 0.5 respectively. For each iteration we first transform the respective sample to view-space. We then add the view-space kernel offset sample to the view-space fragment position. Then we multiply the offset sample by radius to increase (or decrease) the effective sample radius of SSAO.</p>
<p>Next we want to transform sample to screen-space so we can sample the position/depth value of sample as if we were rendering its position directly to the screen. As the vector is currently in view-space, we&rsquo;ll transform it to clip-space first using the projection matrix uniform:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">vec4</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">samplePos</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">offset</span>      <span class="o">=</span> <span class="n">projection</span> <span class="o">*</span> <span class="n">offset</span><span class="p">;</span>    <span class="c1">// from view to clip-space
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="c1"></span><span class="n">offset</span><span class="p">.</span><span class="n">xyz</span> <span class="o">/=</span> <span class="n">offset</span><span class="p">.</span><span class="n">w</span><span class="p">;</span>               <span class="c1">// perspective divide
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="c1"></span><span class="n">offset</span><span class="p">.</span><span class="n">xyz</span>  <span class="o">=</span> <span class="n">offset</span><span class="p">.</span><span class="n">xyz</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">;</span> <span class="c1">// transform to range 0.0 - 1.0  
</span></span></span></code></pre></div><p>After the variable is transformed to clip-space, we perform the perspective divide step by dividing its <code>xyz</code> components with its <code>w</code> component. The resulting normalized device coordinates are then transformed to the [<code>0.0</code>, <code>1.0</code>] range so we can use them to sample the position texture:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">float</span> <span class="n">sampleDepth</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">gPosition</span><span class="p">,</span> <span class="n">offset</span><span class="p">.</span><span class="n">xy</span><span class="p">).</span><span class="n">z</span><span class="p">;</span> 
</span></span></code></pre></div><p>We use the offset vector&rsquo;s <code>x</code> and <code>y</code> component to sample the position texture to retrieve the depth (or <code>z</code> value) of the sample position as seen from the viewer&rsquo;s perspective (the first non-occluded visible fragment). We then check if the sample&rsquo;s current depth value is larger than the stored depth value and if so, we add to the final contribution factor:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">occlusion</span> <span class="o">+=</span> <span class="p">(</span><span class="n">sampleDepth</span> <span class="o">&gt;=</span> <span class="n">samplePos</span><span class="p">.</span><span class="n">z</span> <span class="o">+</span> <span class="n">bias</span> <span class="o">?</span> <span class="mf">1.0</span> <span class="o">:</span> <span class="mf">0.0</span><span class="p">);</span>  
</span></span></code></pre></div><p>Note that we add a small <code>bias</code> here to the original fragment&rsquo;s depth value (set to <code>0.025</code> in this example). A bias isn&rsquo;t always necessary, but it helps visually tweak the SSAO effect and solves acne effects that may occur based on the scene&rsquo;s complexity.</p>
<p>We&rsquo;re not completely finished yet as there is still a small issue we have to take into account. Whenever a fragment is tested for ambient occlusion that is aligned close to the edge of a surface, it will also consider depth values of surfaces far behind the test surface; these values will (incorrectly) contribute to the occlusion factor. We can solve this by introducing a range check as the following image (courtesy of <a href="http://john-chapman-graphics.blogspot.com/" target="_blank">John Chapman</a>) illustrates:</p>
<p><a href="#R-image-73c8b941d69baadf0b6fb77fb8b9b998" class="lightbox-link"><img src="./assets/ssao_range_check.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-73c8b941d69baadf0b6fb77fb8b9b998"><img src="./assets/ssao_range_check.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>We introduce a range check that makes sure a fragment contributes to the occlusion factor if its depth values is within the sample&rsquo;s radius. We change the last line to:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">float</span> <span class="n">rangeCheck</span> <span class="o">=</span> <span class="n">smoothstep</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">radius</span> <span class="o">/</span> <span class="n">abs</span><span class="p">(</span><span class="n">fragPos</span><span class="p">.</span><span class="n">z</span> <span class="o">-</span> <span class="n">sampleDepth</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">occlusion</span>       <span class="o">+=</span> <span class="p">(</span><span class="n">sampleDepth</span> <span class="o">&gt;=</span> <span class="n">samplePos</span><span class="p">.</span><span class="n">z</span> <span class="o">+</span> <span class="n">bias</span> <span class="o">?</span> <span class="mf">1.0</span> <span class="o">:</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">rangeCheck</span><span class="p">;</span>         
</span></span></code></pre></div><p>Here we used GLSL&rsquo;s smoothstep function that smoothly interpolates its third parameter between the first and second parameter&rsquo;s range, returning <code>0.0</code> if less than or equal to its first parameter and <code>1.0</code> if equal or higher to its second parameter. If the depth difference ends up between radius, its value gets smoothly interpolated between <code>0.0</code> and <code>1.0</code> by the following curve:</p>
<p><a href="#R-image-a925a6ba143c146edc2a391b75914f29" class="lightbox-link"><img src="./assets/ssao_smoothstep.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a925a6ba143c146edc2a391b75914f29"><img src="./assets/ssao_smoothstep.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>If we were to use a hard cut-off range check that would abruptly remove occlusion contributions if the depth values are outside radius, we&rsquo;d see obvious (unattractive) borders at where the range check is applied.</p>
<p>As a final step we normalize the occlusion contribution by the size of the kernel and output the results. Note that we subtract the occlusion factor from <code>1.0</code> so we can directly use the occlusion factor to scale the ambient lighting component.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">occlusion</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span><span class="n">occlusion</span> <span class="o">/</span> <span class="n">kernelSize</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">FragColor</span> <span class="o">=</span> <span class="n">occlusion</span><span class="p">;</span>  
</span></span></code></pre></div><p>If we&rsquo;d imagine a scene where our favorite backpack model is taking a little nap, the ambient occlusion shader produces the following texture:</p>
<p><a href="#R-image-0b07b22e4efaf31e3710fc0248f7ec0a" class="lightbox-link"><img src="./assets/ssao_without_blur.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-0b07b22e4efaf31e3710fc0248f7ec0a"><img src="./assets/ssao_without_blur.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>As we can see, ambient occlusion gives a great sense of depth. With just the ambient occlusion texture we can already clearly see the model is indeed laying on the floor, instead of hovering slightly above it.</p>
<p>It still doesn&rsquo;t look perfect, as the repeating pattern of the noise texture is clearly visible. To create a smooth ambient occlusion result we need to blur the ambient occlusion texture.</p>
<h4 id="ambient-occlusion-blur">Ambient occlusion blur</h4>
<p>Between the SSAO pass and the lighting pass, we first want to blur the SSAO texture. So let&rsquo;s create yet another framebuffer object for storing the blur result:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ssaoBlurFBO</span><span class="p">,</span> <span class="n">ssaoColorBufferBlur</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glGenFramebuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ssaoBlurFBO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">ssaoBlurFBO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="n">glGenTextures</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ssaoColorBufferBlur</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">ssaoColorBufferBlur</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="n">glTexImage2D</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RED</span><span class="p">,</span> <span class="n">SCR_WIDTH</span><span class="p">,</span> <span class="n">SCR_HEIGHT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RED</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MIN_FILTER</span><span class="p">,</span> <span class="n">GL_NEAREST</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">8</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MAG_FILTER</span><span class="p">,</span> <span class="n">GL_NEAREST</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">9</span><span class="cl"><span class="n">glFramebufferTexture2D</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">GL_COLOR_ATTACHMENT0</span><span class="p">,</span> <span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">ssaoColorBufferBlur</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span></span></span></code></pre></div><p>Because the tiled random vector texture gives us a consistent randomness, we can use this property to our advantage to create a simple blur shader:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">out</span> <span class="kt">float</span> <span class="n">FragColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">in</span> <span class="n">vec2</span> <span class="n">TexCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">ssaoInput</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="n">vec2</span> <span class="n">texelSize</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">vec2</span><span class="p">(</span><span class="n">textureSize</span><span class="p">(</span><span class="n">ssaoInput</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="kt">float</span> <span class="n">result</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="o">++</span><span class="n">x</span><span class="p">)</span> 
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="o">++</span><span class="n">y</span><span class="p">)</span> 
</span></span><span class="line"><span class="ln">14</span><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">            <span class="n">vec2</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">vec2</span><span class="p">(</span><span class="kt">float</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="kt">float</span><span class="p">(</span><span class="n">y</span><span class="p">))</span> <span class="o">*</span> <span class="n">texelSize</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">            <span class="n">result</span> <span class="o">+=</span> <span class="n">texture</span><span class="p">(</span><span class="n">ssaoInput</span><span class="p">,</span> <span class="n">TexCoords</span> <span class="o">+</span> <span class="n">offset</span><span class="p">).</span><span class="n">r</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">    <span class="n">FragColor</span> <span class="o">=</span> <span class="n">result</span> <span class="o">/</span> <span class="p">(</span><span class="mf">4.0</span> <span class="o">*</span> <span class="mf">4.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>Here we traverse the surrounding SSAO texels between <code>-2.0</code> and <code>2.0</code>, sampling the SSAO texture an amount identical to the noise texture&rsquo;s dimensions. We offset each texture coordinate by the exact size of a single texel using textureSize that returns a <code>vec2</code> of the given texture&rsquo;s dimensions. We average the obtained results to get a simple, but effective blur:</p>
<p><a href="#R-image-9dcd03cbd91fc184dd565a281bef1a2c" class="lightbox-link"><img src="./assets/ssao.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-9dcd03cbd91fc184dd565a281bef1a2c"><img src="./assets/ssao.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>And there we go, a texture with per-fragment ambient occlusion data; ready for use in the lighting pass.</p>
<h4 id="applying-ambient-occlusion">Applying ambient occlusion</h4>
<p>Applying the occlusion factors to the lighting equation is incredibly easy: all we have to do is multiply the per-fragment ambient occlusion factor to the lighting&rsquo;s ambient component and we&rsquo;re done. If we take the Blinn-Phong deferred lighting shader of the previous chapter and adjust it a bit, we get the following fragment shader:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">out</span> <span class="n">vec4</span> <span class="n">FragColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">in</span> <span class="n">vec2</span> <span class="n">TexCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">gPosition</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">gNormal</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">gAlbedo</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">ssao</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="k">struct</span> <span class="nc">Light</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="n">vec3</span> <span class="n">Position</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="n">vec3</span> <span class="n">Color</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">    
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="kt">float</span> <span class="n">Linear</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="kt">float</span> <span class="n">Quadratic</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">    <span class="kt">float</span> <span class="n">Radius</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="n">uniform</span> <span class="n">Light</span> <span class="n">light</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">
</span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl"><span class="p">{</span>             
</span></span><span class="line"><span class="ln">23</span><span class="cl">    <span class="c1">// retrieve data from gbuffer
</span></span></span><span class="line"><span class="ln">24</span><span class="cl"><span class="c1"></span>    <span class="n">vec3</span> <span class="n">FragPos</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">gPosition</span><span class="p">,</span> <span class="n">TexCoords</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl">    <span class="n">vec3</span> <span class="n">Normal</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">gNormal</span><span class="p">,</span> <span class="n">TexCoords</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl">    <span class="n">vec3</span> <span class="n">Diffuse</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">gAlbedo</span><span class="p">,</span> <span class="n">TexCoords</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl">    <span class="kt">float</span> <span class="n">AmbientOcclusion</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">ssao</span><span class="p">,</span> <span class="n">TexCoords</span><span class="p">).</span><span class="n">r</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">28</span><span class="cl">    
</span></span><span class="line"><span class="ln">29</span><span class="cl">    <span class="c1">// blinn-phong (in view-space)
</span></span></span><span class="line"><span class="ln">30</span><span class="cl"><span class="c1"></span>    <span class="n">vec3</span> <span class="n">ambient</span> <span class="o">=</span> <span class="n">vec3</span><span class="p">(</span><span class="mf">0.3</span> <span class="o">*</span> <span class="n">Diffuse</span> <span class="o">*</span> <span class="n">AmbientOcclusion</span><span class="p">);</span> <span class="c1">// here we add occlusion factor
</span></span></span><span class="line"><span class="ln">31</span><span class="cl"><span class="c1"></span>    <span class="n">vec3</span> <span class="n">lighting</span>  <span class="o">=</span> <span class="n">ambient</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">32</span><span class="cl">    <span class="n">vec3</span> <span class="n">viewDir</span>  <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="o">-</span><span class="n">FragPos</span><span class="p">);</span> <span class="c1">// viewpos is (0.0.0) in view-space
</span></span></span><span class="line"><span class="ln">33</span><span class="cl"><span class="c1"></span>    <span class="c1">// diffuse
</span></span></span><span class="line"><span class="ln">34</span><span class="cl"><span class="c1"></span>    <span class="n">vec3</span> <span class="n">lightDir</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">light</span><span class="p">.</span><span class="n">Position</span> <span class="o">-</span> <span class="n">FragPos</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">35</span><span class="cl">    <span class="n">vec3</span> <span class="n">diffuse</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">Normal</span><span class="p">,</span> <span class="n">lightDir</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">Diffuse</span> <span class="o">*</span> <span class="n">light</span><span class="p">.</span><span class="n">Color</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">36</span><span class="cl">    <span class="c1">// specular
</span></span></span><span class="line"><span class="ln">37</span><span class="cl"><span class="c1"></span>    <span class="n">vec3</span> <span class="n">halfwayDir</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">lightDir</span> <span class="o">+</span> <span class="n">viewDir</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">38</span><span class="cl">    <span class="kt">float</span> <span class="n">spec</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">Normal</span><span class="p">,</span> <span class="n">halfwayDir</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">),</span> <span class="mf">8.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">39</span><span class="cl">    <span class="n">vec3</span> <span class="n">specular</span> <span class="o">=</span> <span class="n">light</span><span class="p">.</span><span class="n">Color</span> <span class="o">*</span> <span class="n">spec</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">40</span><span class="cl">    <span class="c1">// attenuation
</span></span></span><span class="line"><span class="ln">41</span><span class="cl"><span class="c1"></span>    <span class="kt">float</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">length</span><span class="p">(</span><span class="n">light</span><span class="p">.</span><span class="n">Position</span> <span class="o">-</span> <span class="n">FragPos</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">42</span><span class="cl">    <span class="kt">float</span> <span class="n">attenuation</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">light</span><span class="p">.</span><span class="n">Linear</span> <span class="o">*</span> <span class="n">dist</span> <span class="o">+</span> <span class="n">light</span><span class="p">.</span><span class="n">Quadratic</span> <span class="o">*</span> <span class="n">dist</span> <span class="o">*</span> <span class="n">dist</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">43</span><span class="cl">    <span class="n">diffuse</span>  <span class="o">*=</span> <span class="n">attenuation</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">44</span><span class="cl">    <span class="n">specular</span> <span class="o">*=</span> <span class="n">attenuation</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">45</span><span class="cl">    <span class="n">lighting</span> <span class="o">+=</span> <span class="n">diffuse</span> <span class="o">+</span> <span class="n">specular</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">46</span><span class="cl">
</span></span><span class="line"><span class="ln">47</span><span class="cl">    <span class="n">FragColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">lighting</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">48</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>The only thing (aside from the change to view-space) we really changed is the multiplication of the scene&rsquo;s ambient component by AmbientOcclusion. With a single blue-ish point light in the scene we&rsquo;d get the following result:</p>
<p><a href="#R-image-ded7603c831c006fb8c2b7d8f53bcd38" class="lightbox-link"><img src="./assets/ssao_final.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-ded7603c831c006fb8c2b7d8f53bcd38"><img src="./assets/ssao_final.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>You can find the full source code of the demo scene <a href="https://learnopengl.com/code_viewer_gh.php?code=src/5.advanced_lighting/9.ssao/ssao.cpp" target="_blank">here</a>.</p>
<p>Screen-space ambient occlusion is a highly customizable effect that relies heavily on tweaking its parameters based on the type of scene. There is no perfect combination of parameters for every type of scene. Some scenes only work with a small radius, while other scenes require a larger radius and a larger sample count for them to look realistic. The current demo uses <code>64</code> samples, which is a bit much; play around with a smaller kernel size and try to get good results.</p>
<p>Some parameters you can tweak (by using uniforms for example): kernel size, radius, bias, and/or the size of the noise kernel. You can also raise the final occlusion value to a user-defined power to increase its strength:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">occlusion</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span><span class="n">occlusion</span> <span class="o">/</span> <span class="n">kernelSize</span><span class="p">);</span>       
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">FragColor</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">occlusion</span><span class="p">,</span> <span class="n">power</span><span class="p">);</span></span></span></code></pre></div><p>Play around with different scenes and different parameters to appreciate the customizability of SSAO.</p>
<p>Even though SSAO is a subtle effect that isn&rsquo;t too clearly noticeable, it adds a great deal of realism to properly lit scenes and is definitely a technique you&rsquo;d want to have in your toolkit.</p>
<h4 id="additional-resources-11">Additional resources</h4>
<ul>
<li><a href="http://john-chapman-graphics.blogspot.nl/2013/01/ssao-tutorial.html" target="_blank">SSAO Tutorial</a>: excellent SSAO tutorial by John Chapman; a large portion of this chapter&rsquo;s code and techniques are based of his article.</li>
<li><a href="https://mtnphil.wordpress.com/2013/06/26/know-your-ssao-artifacts/" target="_blank">Know your SSAO artifacts</a>: great article about improving SSAO specific artifacts.</li>
<li><a href="http://ogldev.atspace.co.uk/www/tutorial46/tutorial46.html" target="_blank">SSAO With Depth Reconstruction</a>: extension tutorial on top of SSAO from OGLDev about reconstructing position vectors from depth alone, saving us from storing the expensive position vectors in the G-buffer.</li>
</ul>
<h2 id="pbr">PBR</h2>
<h3 id="theory">Theory</h3>
<p>PBR, or more commonly known as physically based rendering, is a collection of render techniques that are more or less based on the same underlying theory that more closely matches that of the physical world. As physically based rendering aims to mimic light in a physically plausible way, it generally looks more realistic compared to our original lighting algorithms like Phong and Blinn-Phong. Not only does it look better, as it closely approximates actual physics, we (and especially the artists) can author surface materials based on physical parameters without having to resort to cheap hacks and tweaks to make the lighting look right. One of the bigger advantages of authoring materials based on physical parameters is that these materials will look correct regardless of lighting conditions; something that is not true in non-PBR pipelines.</p>
<p>Physically based rendering is still nonetheless an approximation of reality (based on the principles of physics) which is why it&rsquo;s not called physical shading, but physically <em>based</em> shading. For a PBR lighting model to be considered physically based, it has to satisfy the following 3 conditions (don&rsquo;t worry, we&rsquo;ll get to them soon enough):</p>
<ol>
<li>Be based on the microfacet surface model.</li>
<li>Be energy conserving.</li>
<li>Use a physically based BRDF.</li>
</ol>
<p>In the next PBR chapters we&rsquo;ll be focusing on the PBR approach as originally explored by Disney and adopted for real-time display by Epic Games. Their approach, based on the metallic workflow, is decently documented, widely adopted on most popular engines, and looks visually amazing. By the end of these chapters we&rsquo;ll have something that looks like this:</p>
<p><a href="#R-image-149ff03371e84a3b5a18bd62078fe6c1" class="lightbox-link"><img src="./assets/ibl_specular_result_textured.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-149ff03371e84a3b5a18bd62078fe6c1"><img src="./assets/ibl_specular_result_textured.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Keep in mind, the topics in these chapters are rather advanced so it is advised to have a good understanding of OpenGL and shader lighting. Some of the more advanced knowledge you&rsquo;ll need for this series are: <a href="https://learnopengl.com/Advanced-OpenGL/Framebuffers" target="_blank">framebuffers</a>, <a href="https://learnopengl.com/Advanced-OpenGL/Cubemaps" target="_blank">cubemaps</a>, <a href="https://learnopengl.com/Advanced-Lighting/Gamma-Correction" target="_blank">gamma correction</a>, <a href="https://learnopengl.com/Advanced-Lighting/HDR" target="_blank">HDR</a>, and <a href="https://learnopengl.com/Advanced-Lighting/Normal-Mapping" target="_blank">normal mapping</a>. We&rsquo;ll also delve into some advanced mathematics, but I&rsquo;ll do my best to explain the concepts as clear as possible.</p>
<h4 id="the-microfacet-model">The microfacet model</h4>
<p>All the PBR techniques are based on the theory of microfacets. The theory describes that any surface at a microscopic scale can be described by tiny little perfectly reflective mirrors called microfacets. Depending on the roughness of a surface, the alignment of these tiny little mirrors can differ quite a lot:</p>
<p><a href="#R-image-a3b1de8a28582d2d9038e7e177f05bfc" class="lightbox-link"><img src="./assets/microfacets.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a3b1de8a28582d2d9038e7e177f05bfc"><img src="./assets/microfacets.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>The rougher a surface is, the more chaotically aligned each microfacet will be along the surface. The effect of these tiny-like mirror alignments is, that when specifically talking about specular lighting/reflection, the incoming light rays are more likely to scatter along completely different directions on rougher surfaces, resulting in a more widespread specular reflection. In contrast, on a smooth surface the light rays are more likely to reflect in roughly the same direction, giving us smaller and sharper reflections:</p>
<p><a href="#R-image-f56106904cff4b75b41643559b629398" class="lightbox-link"><img src="./assets/microfacets_light_rays.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f56106904cff4b75b41643559b629398"><img src="./assets/microfacets_light_rays.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>No surface is completely smooth on a microscopic level, but seeing as these microfacets are small enough that we can&rsquo;t make a distinction between them on a per-pixel basis, we statistically approximate the surface&rsquo;s microfacet roughness given a roughness parameter. Based on the roughness of a surface, we can calculate the ratio of microfacets roughly aligned to some vector hℎ. This vector hℎ is the halfway vector that sits halfway between the light 
<span class="math align-center">$l$</span> and view 
<span class="math align-center">$v$</span> vector. We&rsquo;ve discussed the halfway vector before in the <a href="https://learnopengl.com/Advanced-Lighting/Advanced-Lighting" target="_blank">advanced lighting</a> chapter which is calculated as the sum of 
<span class="math align-center">$l$</span> and 
<span class="math align-center">$v$</span> divided by its length:</p>

<span class="math align-center">$$
h = \frac{l + v}{\|l + v\|}
$$</span><p>The more the microfacets are aligned to the halfway vector, the sharper and stronger the specular reflection. Together with a roughness parameter that varies between 0 and 1, we can statistically approximate the alignment of the microfacets:</p>
<p><a href="#R-image-d1d79340e207fa08f0d8dd9bbabc7cc0" class="lightbox-link"><img src="./assets/ndf.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d1d79340e207fa08f0d8dd9bbabc7cc0"><img src="./assets/ndf.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>We can see that higher roughness values display a much larger specular reflection shape, in contrast with the smaller and sharper specular reflection shape of smooth surfaces.</p>
<h4 id="energy-conservation">Energy conservation</h4>
<p>The microfacet approximation employs a form of energy conservation: outgoing light energy should never exceed the incoming light energy (excluding emissive surfaces). Looking at the above image we see the specular reflection area increase, but also its brightness decrease at increasing roughness levels. If the specular intensity were to be the same at each pixel (regardless of the size of the specular shape) the rougher surfaces would emit much more energy, violating the energy conservation principle. This is why we see specular reflections more intensely on smooth surfaces and more dimly on rough surfaces.</p>
<p>For energy conservation to hold, we need to make a clear distinction between diffuse and specular light. The moment a light ray hits a surface, it gets split in both a refraction part and a reflection part. The reflection part is light that directly gets reflected and doesn&rsquo;t enter the surface; this is what we know as specular lighting. The refraction part is the remaining light that enters the surface and gets absorbed; this is what we know as diffuse lighting.</p>
<p>There are some nuances here as refracted light doesn&rsquo;t immediately get absorbed by touching the surface. From physics, we know that light can be modeled as a beam of energy that keeps moving forward until it loses all of its energy; the way a light beam loses energy is by collision. Each material consists of tiny little particles that can collide with the light ray as illustrated in the following image. The particles absorb some, or all, of the light&rsquo;s energy at each collision which is converted into heat.</p>
<p><a href="#R-image-28e60fff1476ea604d8e3fe7afa3520d" class="lightbox-link"><img src="./assets/surface_reaction.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-28e60fff1476ea604d8e3fe7afa3520d"><img src="./assets/surface_reaction.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Generally, not all energy is absorbed and the light will continue to scatter in a (mostly) random direction at which point it collides with other particles until its energy is depleted or it leaves the surface again. Light rays re-emerging out of the surface contribute to the surface&rsquo;s observed (diffuse) color. In physically based rendering however, we make the simplifying assumption that all refracted light gets absorbed and scattered at a very small area of impact, ignoring the effect of scattered light rays that would&rsquo;ve exited the surface at a distance. Specific shader techniques that do take this into account are known as subsurface scattering techniques that significantly improve the visual quality on materials like skin, marble, or wax, but come at the price of performance.</p>
<p>An additional subtlety when it comes to reflection and refraction are surfaces that are metallic. Metallic surfaces react different to light compared to non-metallic surfaces (also known as dielectrics). Metallic surfaces follow the same principles of reflection and refraction, but <strong>all</strong> refracted light gets directly absorbed without scattering. This means metallic surfaces only leave reflected or specular light; metallic surfaces show no diffuse colors. Because of this apparent distinction between metals and dielectrics, they&rsquo;re both treated differently in the PBR pipeline which we&rsquo;ll delve into further down the chapter.</p>
<p>This distinction between reflected and refracted light brings us to another observation regarding energy preservation: they&rsquo;re <strong>mutually exclusive</strong>. Whatever light energy gets reflected will no longer be absorbed by the material itself. Thus, the energy left to enter the surface as refracted light is directly the resulting energy after we&rsquo;ve taken reflection into account.</p>
<p>We preserve this energy conserving relation by first calculating the specular fraction that amounts the percentage the incoming light&rsquo;s energy is reflected. The fraction of refracted light is then directly calculated from the specular fraction as:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">float</span> <span class="n">kS</span> <span class="o">=</span> <span class="n">calculateSpecularComponent</span><span class="p">(...);</span> <span class="c1">// reflection/specular fraction
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="c1"></span><span class="kt">float</span> <span class="n">kD</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">kS</span><span class="p">;</span>  
</span></span></code></pre></div><p>This way we know both the amount the incoming light reflects and the amount the incoming light refracts, while adhering to the energy conservation principle. Given this approach, it is impossible for both the refracted/diffuse and reflected/specular contribution to exceed <code>1.0</code>, thus ensuring the sum of their energy never exceeds the incoming light energy. Something we did not take into account in the previous lighting chapters.</p>
<h4 id="the-reflectance-equation">The reflectance equation</h4>
<p>This brings us to something called the <a href="https://en.wikipedia.org/wiki/Rendering_equation" target="_blank">render equation</a>, an elaborate equation some very smart folks out there came up with that is currently the best model we have for simulating the visuals of light. Physically based rendering strongly follows a more specialized version of the render equation known as the reflectance equation. To properly understand PBR, it&rsquo;s important to first build a solid understanding of the reflectance equation:</p>

<span class="math align-center">$$
L_o(p,\omega_o) = \int\limits_{\Omega} f_r(p,\omega_i,\omega_o) L_i(p,\omega_i) n \cdot \omega_i  d\omega_i
$$</span><p>The reflectance equation appears daunting at first, but as we&rsquo;ll dissect it you&rsquo;ll see it slowly starts to makes sense. To understand the equation, we have to delve into a bit of radiometry. Radiometry is the measurement of electromagnetic radiation, including visible light. There are several radiometric quantities we can use to measure light over surfaces and directions, but we will only discuss a single one that&rsquo;s relevant to the reflectance equation known as radiance, denoted here as 
<span class="math align-center">$L$</span>. Radiance is used to quantify the magnitude or strength of light coming from a single direction. It&rsquo;s a bit tricky to understand at first as radiance is a combination of multiple physical quantities so we&rsquo;ll focus on those first:</p>
<p><strong>Radiant flux</strong>: radiant flux 
<span class="math align-center">$\Phi$</span> is the transmitted energy of a light source measured in Watts. Light is a collective sum of energy over multiple different wavelengths, each wavelength associated with a particular (visible) color. The emitted energy of a light source can therefore be thought of as a function of all its different wavelengths. Wavelengths between 390nm to 700nm (nanometers) are considered part of the visible light spectrum i.e. wavelengths the human eye is able to perceive. Below you&rsquo;ll find an image of the different energies per wavelength of daylight:</p>
<p><a href="#R-image-0047e1cba4443632ae05094cdfda7dea" class="lightbox-link"><img src="./assets/daylight_spectral_distribution.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-0047e1cba4443632ae05094cdfda7dea"><img src="./assets/daylight_spectral_distribution.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>The radiant flux measures the total area of this function of different wavelengths. Directly taking this measure of wavelengths as input is slightly impractical so we often make the simplification of representing radiant flux, not as a function of varying wavelength strengths, but as a light color triplet encoded as <code>RGB</code> (or as we&rsquo;d commonly call it: light color). This encoding does come at quite a loss of information, but this is generally negligible for visual aspects.</p>
<p><strong>Solid angle</strong>: the solid angle, denoted as 
<span class="math align-center">$\omega$</span>, tells us the size or area of a shape projected onto a unit sphere. The area of the projected shape onto this unit sphere is known as the solid angle; you can visualize the solid angle as a direction with volume:</p>
<p><a href="#R-image-c224e57e3f2c0e242467dca7586262df" class="lightbox-link"><img src="./assets/solid_angle.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c224e57e3f2c0e242467dca7586262df"><img src="./assets/solid_angle.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Think of being an observer at the center of this unit sphere and looking in the direction of the shape; the size of the silhouette you make out of it is the solid angle.</p>
<p><strong>Radiant intensity</strong>: radiant intensity measures the amount of radiant flux per solid angle, or the strength of a light source over a projected area onto the unit sphere. For instance, given an omnidirectional light that radiates equally in all directions, the radiant intensity can give us its energy over a specific area (solid angle):</p>
<p><a href="#R-image-131a98ee3fbae7c6c54e192f428b9093" class="lightbox-link"><img src="./assets/radiant_intensity.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-131a98ee3fbae7c6c54e192f428b9093"><img src="./assets/radiant_intensity.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>The equation to describe the radiant intensity is defined as follows:</p>

<span class="math align-center">$$
I = \frac{d\Phi}{d\omega}
$$</span><p>Where 
<span class="math align-center">$I$</span> is the radiant flux 
<span class="math align-center">$\Phi$</span> over the solid angle 
<span class="math align-center">$\omega$</span>.</p>
<p>With knowledge of radiant flux, radiant intensity, and the solid angle, we can finally describe the equation for <strong>radiance</strong>. Radiance is described as the total observed energy in an area 
<span class="math align-center">$A$</span> over the solid angle 
<span class="math align-center">$\omega$</span> of a light of radiant intensity 
<span class="math align-center">$\Phi$</span>:</p>

<span class="math align-center">$$
L=\frac{d^2\Phi}{ dA d\omega \cos\theta}
$$</span><p><a href="#R-image-7add718418e305c06aa983e1e6cee530" class="lightbox-link"><img src="./assets/radiance.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7add718418e305c06aa983e1e6cee530"><img src="./assets/radiance.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Radiance is a radiometric measure of the amount of light in an area, scaled by the incident (or incoming) angle 
<span class="math align-center">$\theta$</span> of the light to the surface&rsquo;s normal as 
<span class="math align-center">$\cos \theta$</span>: light is weaker the less it directly radiates onto the surface, and strongest when it is directly perpendicular to the surface. This is similar to our perception of diffuse lighting from the <a href="https://learnopengl.com/Lighting/Basic-lighting" target="_blank">basic lighting</a> chapter as 
<span class="math align-center">$\cos \theta$</span> directly corresponds to the dot product between the light&rsquo;s direction vector and the surface normal:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">float</span> <span class="n">cosTheta</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">lightDir</span><span class="p">,</span> <span class="n">N</span><span class="p">);</span>  
</span></span></code></pre></div><p>The radiance equation is quite useful as it contains most physical quantities we&rsquo;re interested in. If we consider the solid angle 
<span class="math align-center">$\omega$</span> and the area 
<span class="math align-center">$A$</span> to be infinitely small, we can use radiance to measure the flux of a single ray of light hitting a single point in space. This relation allows us to calculate the radiance of a single light ray influencing a single (fragment) point; we effectively translate the solid angle 
<span class="math align-center">$\omega$</span> into a direction vector 
<span class="math align-center">$\omega$</span>, and 
<span class="math align-center">$A$</span> into a point 
<span class="math align-center">$p$</span>. This way, we can directly use radiance in our shaders to calculate a single light ray&rsquo;s per-fragment contribution.</p>
<p>In fact, when it comes to radiance we generally care about <strong>all</strong> incoming light onto a point 
<span class="math align-center">$p$</span>, which is the sum of all radiance known as irradiance. With knowledge of both radiance and irradiance we can get back to the reflectance equation:</p>

<span class="math align-center">$$
L_o(p,\omega_o) = \int\limits_{\Omega} f_r(p,\omega_i,\omega_o) L_i(p,\omega_i) n \cdot \omega_i  d\omega_i
$$</span><p>We now know that 
<span class="math align-center">$L$</span> in the render equation represents the radiance of some point 
<span class="math align-center">$p$</span> and some incoming infinitely small solid angle 
<span class="math align-center">$\omega_i$</span> which can be thought of as an incoming direction vector 
<span class="math align-center">$\omega_i$</span>. Remember that 
<span class="math align-center">$\cos \theta$</span> scales the energy based on the light&rsquo;s incident angle to the surface, which we find in the reflectance equation as 
<span class="math align-center">$n \cdot \omega_i$</span>. The reflectance equation calculates the sum of reflected radiance 
<span class="math align-center">$L_o(p, \omega_o)$</span> of a point 
<span class="math align-center">$p$</span> in direction 
<span class="math align-center">$\omega_o$</span> which is the outgoing direction to the viewer. Or to put it differently: 
<span class="math align-center">$L_o$</span> measures the reflected sum of the lights&rsquo; irradiance onto point 
<span class="math align-center">$p$</span> as viewed from 
<span class="math align-center">$\omega_o$</span>.</p>
<p>The reflectance equation is based around irradiance, which is the sum of all incoming radiance we measure light of. Not just of a single incoming light direction, but of all incoming light directions within a hemisphere ΩΩ centered around point 
<span class="math align-center">$p$</span>. A hemisphere can be described as half a sphere aligned around a surface&rsquo;s normal 
<span class="math align-center">$n$</span>:</p>
<p><a href="#R-image-9944656915ae903b11f1c79fb5ab59f8" class="lightbox-link"><img src="./assets/hemisphere.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-9944656915ae903b11f1c79fb5ab59f8"><img src="./assets/hemisphere.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>To calculate the total of values inside an area or (in the case of a hemisphere) a volume, we use a mathematical construct called an integral denoted in the reflectance equation as 
<span class="math align-center">$\int$</span> over all incoming directions 
<span class="math align-center">$d\omega_i$</span> within the hemisphere 
<span class="math align-center">$\Omega$</span> . An integral measures the area of a function, which can either be calculated analytically or numerically. As there is no analytical solution to both the render and reflectance equation, we&rsquo;ll want to numerically solve the integral discretely. This translates to taking the result of small discrete steps of the reflectance equation over the hemisphere 
<span class="math align-center">$\Omega$</span> and averaging their results over the step size. This is known as the Riemann sum that we can roughly visualize in code as follows:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">int</span> <span class="n">steps</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="kt">float</span> <span class="n">sum</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">vec3</span> <span class="n">P</span>    <span class="o">=</span> <span class="p">...;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">vec3</span> <span class="n">Wo</span>   <span class="o">=</span> <span class="p">...;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">vec3</span> <span class="n">N</span>    <span class="o">=</span> <span class="p">...;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="kt">float</span> <span class="n">dW</span>  <span class="o">=</span> <span class="mf">1.0f</span> <span class="o">/</span> <span class="n">steps</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">steps</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> 
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="n">vec3</span> <span class="n">Wi</span> <span class="o">=</span> <span class="n">getNextIncomingLightDir</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="n">sum</span> <span class="o">+=</span> <span class="n">Fr</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">Wi</span><span class="p">,</span> <span class="n">Wo</span><span class="p">)</span> <span class="o">*</span> <span class="n">L</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">Wi</span><span class="p">)</span> <span class="o">*</span> <span class="n">dot</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">Wi</span><span class="p">)</span> <span class="o">*</span> <span class="n">dW</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>By scaling the steps by <code>dW</code>, the sum will equal the total area or volume of the integral function. The <code>dW</code> to scale each discrete step can be thought of as 
<span class="math align-center">$d\omega_i$</span> in the reflectance equation. Mathematically 
<span class="math align-center">$d\omega_i$</span> is the continuous symbol over which we calculate the integral, and while it does not directly relate to <code>dW</code> in code (as this is a discrete step of the Riemann sum), it helps to think of it this way. Keep in mind that taking discrete steps will always give us an approximation of the total area of the function. A careful reader will notice we can increase the <em>accuracy</em> of the Riemann Sum by increasing the number of steps.</p>
<p>The reflectance equation sums up the radiance of all incoming light directions 
<span class="math align-center">$\omega_i$</span> over the hemisphere 
<span class="math align-center">$\Omega$</span> scaled by 
<span class="math align-center">$f_r$</span> that hit point 
<span class="math align-center">$p$</span> and returns the sum of reflected light 
<span class="math align-center">$L_o$</span> in the viewer&rsquo;s direction. The incoming radiance can come from <a href="https://learnopengl.com/PBR/Lighting" target="_blank">light sources</a> as we&rsquo;re familiar with, or from an environment map measuring the radiance of every incoming direction as we&rsquo;ll discuss in the <a href="https://learnopengl.com/PBR/IBL/Diffuse-irradiance" target="_blank">IBL</a> chapters.</p>
<p>Now the only unknown left is the 
<span class="math align-center">$f_r$</span> symbol known as the BRDF or bidirectional reflective distribution function that scales or weighs the incoming radiance based on the surface&rsquo;s material properties.</p>
<h4 id="brdf">BRDF</h4>
<p>The BRDF, or bidirectional reflective distribution function, is a function that takes as input the incoming (light) direction 
<span class="math align-center">$\omega_i$</span>, the outgoing (view) direction 
<span class="math align-center">$\omega_o$</span>, the surface normal 
<span class="math align-center">$n$</span>, and a surface parameter 
<span class="math align-center">$a$</span> that represents the microsurface&rsquo;s roughness. The BRDF approximates how much each individual light ray 
<span class="math align-center">$\omega_i$</span> contributes to the final reflected light of an opaque surface given its material properties. For instance, if the surface has a perfectly smooth surface (~like a mirror) the BRDF function would return 0.0 for all incoming light rays 
<span class="math align-center">$\omega_i$</span> except the one ray that has the same (reflected) angle as the outgoing ray 
<span class="math align-center">$\omega_o$</span> at which the function returns 1.0.</p>
<p>A BRDF approximates the material&rsquo;s reflective and refractive properties based on the previously discussed microfacet theory. For a BRDF to be physically plausible it has to respect the law of energy conservation i.e. the sum of reflected light should never exceed the amount of incoming light. Technically, Blinn-Phong is considered a BRDF taking the same 
<span class="math align-center">$\omega_i$</span> and 
<span class="math align-center">$\omega_o$</span> as inputs. However, Blinn-Phong is not considered physically based as it doesn&rsquo;t adhere to the energy conservation principle. There are several physically based BRDFs out there to approximate the surface&rsquo;s reaction to light. However, almost all real-time PBR render pipelines use a BRDF known as the Cook-Torrance BRDF.</p>
<p>The Cook-Torrance BRDF contains both a diffuse and specular part:</p>

<span class="math align-center">$$
f_r = k_d f_{lambert} +  k_s f_{cook-torrance}
$$</span><p>Here 
<span class="math align-center">$k_d$</span> is the earlier mentioned ratio of incoming light energy that gets <em>refracted</em> with 
<span class="math align-center">$k_s$</span> being the ratio that gets <em>reflected</em>. The left side of the BRDF states the diffuse part of the equation denoted here as 
<span class="math align-center">$f_{lambert}$</span>. This is known as Lambertian diffuse similar to what we used for diffuse shading, which is a constant factor denoted as:</p>

<span class="math align-center">$$
f_{lambert} = \frac{c}{\pi}
$$</span><p>With 
<span class="math align-center">$c$</span> being the albedo or surface color (think of the diffuse surface texture). The divide by pi is there to normalize the diffuse light as the earlier denoted integral that contains the BRDF is scaled by 
<span class="math align-center">$\pi$</span> (we&rsquo;ll get to that in the <a href="https://learnopengl.com/PBR/IBL/Diffuse-irradiance" target="_blank">IBL</a> chapters).</p>
<p><note>You may wonder how this Lambertian diffuse relates to the diffuse lighting we&rsquo;ve been using before: the surface color multiplied by the dot product between the surface&rsquo;s normal and the light direction. The dot product is still there, but moved out of the BRDF as we find 
<span class="math align-center">$n \cdot \omega_i$</span> at the end of the 
<span class="math align-center">$L_o$</span> integral.</note></p>
<p>There exist different equations for the diffuse part of the BRDF which tend to look more realistic, but are also more computationally expensive. As concluded by Epic Games however, the Lambertian diffuse is sufficient enough for most real-time rendering purposes.</p>
<p>The specular part of the BRDF is a bit more advanced and is described as:</p>

<span class="math align-center">$$
f_{CookTorrance} = \frac{DFG}{4(\omega_o \cdot n)(\omega_i \cdot n)}
$$</span><p>The Cook-Torrance specular BRDF is composed three functions and a normalization factor in the denominator. Each of the D, F and G symbols represent a type of function that approximates a specific part of the surface&rsquo;s reflective properties. These are defined as the normal <strong>D</strong>istribution function, the <strong>F</strong>resnel equation and the <strong>G</strong>eometry function:</p>
<ul>
<li><strong>Normal distribution function</strong>: approximates the amount the surface&rsquo;s microfacets are aligned to the halfway vector, influenced by the roughness of the surface; this is the primary function approximating the microfacets.</li>
<li><strong>Geometry function</strong>: describes the self-shadowing property of the microfacets. When a surface is relatively rough, the surface&rsquo;s microfacets can overshadow other microfacets reducing the light the surface reflects.</li>
<li><strong>Fresnel equation</strong>: The Fresnel equation describes the ratio of surface reflection at different surface angles.</li>
</ul>
<p>Each of these functions are an approximation of their physics equivalents and you&rsquo;ll find more than one version of each that aims to approximate the underlying physics in different ways; some more realistic, others more efficient. It is perfectly fine to pick whatever approximated version of these functions you want to use. Brian Karis from Epic Games did a great deal of research on the multiple types of approximations <a href="http://graphicrants.blogspot.nl/2013/08/specular-brdf-reference.html" target="_blank">here</a>. We&rsquo;re going to pick the same functions used by Epic Game&rsquo;s Unreal Engine 4 which are the Trowbridge-Reitz GGX for D, the Fresnel-Schlick approximation for F, and the Smith&rsquo;s Schlick-GGX for G.</p>
<h5 id="normal-distribution-function">Normal distribution function</h5>
<p>The normal distribution function <em><strong>D</strong></em> statistically approximates the relative surface area of microfacets exactly aligned to the (halfway) vector <em><strong>h</strong></em>. There are a multitude of NDFs that statistically approximate the general alignment of the microfacets given some roughness parameter and the one we&rsquo;ll be using is known as the Trowbridge-Reitz GGX:</p>

<span class="math align-center">$$
NDF_{GGX TR}(n, h, \alpha) = \frac{\alpha^2}{\pi((n \cdot h)^2 (\alpha^2 - 1) + 1)^2}
$$</span><p>Here <em><strong>h</strong></em> is the halfway vector to measure against the surface&rsquo;s microfacets, with <em><strong>a</strong></em> being a measure of the surface&rsquo;s roughness. If we take <em><strong>h</strong></em> as the halfway vector between the surface normal and light direction over varying roughness parameters we get the following visual result:</p>
<p><a href="#R-image-61b4ac46b526fb69869e2100605e15b7" class="lightbox-link"><img src="./assets/ndf.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-61b4ac46b526fb69869e2100605e15b7"><img src="./assets/ndf.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>When the roughness is low (thus the surface is smooth), a highly concentrated number of microfacets are aligned to halfway vectors over a small radius. Due to this high concentration, the NDF displays a very bright spot. On a rough surface however, where the microfacets are aligned in much more random directions, you&rsquo;ll find a much larger number of halfway vectors <em><strong>h</strong></em> somewhat aligned to the microfacets (but less concentrated), giving us the more grayish results.</p>
<p>In GLSL the Trowbridge-Reitz GGX normal distribution function translates to the following code:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">float</span> <span class="nf">DistributionGGX</span><span class="p">(</span><span class="n">vec3</span> <span class="n">N</span><span class="p">,</span> <span class="n">vec3</span> <span class="n">H</span><span class="p">,</span> <span class="kt">float</span> <span class="n">a</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="kt">float</span> <span class="n">a2</span>     <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="kt">float</span> <span class="n">NdotH</span>  <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">H</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="kt">float</span> <span class="n">NdotH2</span> <span class="o">=</span> <span class="n">NdotH</span><span class="o">*</span><span class="n">NdotH</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">	
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="kt">float</span> <span class="n">nom</span>    <span class="o">=</span> <span class="n">a2</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="kt">float</span> <span class="n">denom</span>  <span class="o">=</span> <span class="p">(</span><span class="n">NdotH2</span> <span class="o">*</span> <span class="p">(</span><span class="n">a2</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="n">denom</span>        <span class="o">=</span> <span class="n">PI</span> <span class="o">*</span> <span class="n">denom</span> <span class="o">*</span> <span class="n">denom</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">	
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="k">return</span> <span class="n">nom</span> <span class="o">/</span> <span class="n">denom</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><h5 id="geometry-function">Geometry function</h5>
<p>The geometry function statistically approximates the relative surface area where its micro surface-details overshadow each other, causing light rays to be occluded.</p>
<p><a href="#R-image-ae4f42d9f29cdaf5ca45296e5346e3ef" class="lightbox-link"><img src="./assets/geometry_shadowing.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-ae4f42d9f29cdaf5ca45296e5346e3ef"><img src="./assets/geometry_shadowing.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Similar to the NDF, the Geometry function takes a material&rsquo;s roughness parameter as input with rougher surfaces having a higher probability of overshadowing microfacets. The geometry function we will use is a combination of the GGX and Schlick-Beckmann approximation known as Schlick-GGX:</p>

<span class="math align-center">$$
G_{SchlickGGX}(n, v, k) 
       		 = 
   		\frac{n \cdot v}
    	{(n \cdot v)(1 - k) + k }
$$</span><p>Here 
<span class="math align-center">$k$</span> is a remapping of 
<span class="math align-center">$α$</span> based on whether we&rsquo;re using the geometry function for either direct lighting or IBL lighting:</p>

<span class="math align-center">$$
k_{direct} = \frac{(\alpha + 1)^2}{8}
$$</span>
<span class="math align-center">$$
k_{IBL} = \frac{\alpha^2}{2}
$$</span><p>Note that the value of 
<span class="math align-center">$α$</span> may differ based on how your engine translates roughness to 
<span class="math align-center">$α$</span>. In the following chapters we&rsquo;ll extensively discuss how and where this remapping becomes relevant.</p>
<p>To effectively approximate the geometry we need to take account of both the view direction (geometry obstruction) and the light direction vector (geometry shadowing). We can take both into account using Smith&rsquo;s method:</p>

<span class="math align-center">$$
G(n, v, l, k) = G_{sub}(n, v, k) G_{sub}(n, l, k)
$$</span><p>Using Smith&rsquo;s method with Schlick-GGX as 
<span class="math align-center">$G_{sub}$</span> gives the following visual appearance over varying roughness <code>R</code>:</p>
<p>The geometry function is a multiplier between [0.0, 1.0] with 1.0 (or white) measuring no microfacet shadowing, and 0.0 (or black) complete microfacet shadowing.</p>
<p>In GLSL the geometry function translates to the following code:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">float</span> <span class="nf">GeometrySchlickGGX</span><span class="p">(</span><span class="kt">float</span> <span class="n">NdotV</span><span class="p">,</span> <span class="kt">float</span> <span class="n">k</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="kt">float</span> <span class="n">nom</span>   <span class="o">=</span> <span class="n">NdotV</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="kt">float</span> <span class="n">denom</span> <span class="o">=</span> <span class="n">NdotV</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="n">k</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">	
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="k">return</span> <span class="n">nom</span> <span class="o">/</span> <span class="n">denom</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="kt">float</span> <span class="nf">GeometrySmith</span><span class="p">(</span><span class="n">vec3</span> <span class="n">N</span><span class="p">,</span> <span class="n">vec3</span> <span class="n">V</span><span class="p">,</span> <span class="n">vec3</span> <span class="n">L</span><span class="p">,</span> <span class="kt">float</span> <span class="n">k</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="kt">float</span> <span class="n">NdotV</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">V</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="kt">float</span> <span class="n">NdotL</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">L</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="kt">float</span> <span class="n">ggx1</span> <span class="o">=</span> <span class="n">GeometrySchlickGGX</span><span class="p">(</span><span class="n">NdotV</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="kt">float</span> <span class="n">ggx2</span> <span class="o">=</span> <span class="n">GeometrySchlickGGX</span><span class="p">(</span><span class="n">NdotL</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">	
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="k">return</span> <span class="n">ggx1</span> <span class="o">*</span> <span class="n">ggx2</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><h5 id="fresnel-equation">Fresnel equation</h5>
<p>The Fresnel equation (pronounced as Freh-nel) describes the ratio of light that gets reflected over the light that gets refracted, which varies over the angle we&rsquo;re looking at a surface. The moment light hits a surface, based on the surface-to-view angle, the Fresnel equation tells us the percentage of light that gets reflected. From this ratio of reflection and the energy conservation principle we can directly obtain the refracted portion of light.</p>
<p>Every surface or material has a level of base reflectivity when looking straight at its surface, but when looking at the surface from an angle <a href="http://filmicworlds.com/blog/everything-has-fresnel/" target="_blank">all</a> reflections become more apparent compared to the surface&rsquo;s base reflectivity. You can check this for yourself by looking at your (presumably) wooden/metallic desk which has a certain level of base reflectivity from a perpendicular view angle, but by looking at your desk from an almost 90 degree angle you&rsquo;ll see the reflections become much more apparent. All surfaces theoretically fully reflect light if seen from perfect 90-degree angles. This phenomenon is known as Fresnel and is described by the Fresnel equation.</p>
<p>The Fresnel equation is a rather complex equation, but luckily the Fresnel equation can be approximated using the Fresnel-Schlick approximation:</p>

<span class="math align-center">$$
F_{Schlick}(h, v, F_0) = 
    F_0 + (1 - F_0) ( 1 - (h \cdot v))^5
$$</span><p>
<span class="math align-center">$F_0$</span> represents the base reflectivity of the surface, which we calculate using something called the <em>indices of refraction</em> or IOR. As you can see on a sphere surface, the more we look towards the surface&rsquo;s grazing angles (with the halfway-view angle reaching 90 degrees), the stronger the Fresnel and thus the reflections:</p>
<p><a href="#R-image-d91c87473ad03a8f9ca131b8aa9e14d1" class="lightbox-link"><img src="./assets/fresnel.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d91c87473ad03a8f9ca131b8aa9e14d1"><img src="./assets/fresnel.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>There are a few subtleties involved with the Fresnel equation. One is that the Fresnel-Schlick approximation is only really defined for dielectric or non-metal surfaces. For conductor surfaces (metals), calculating the base reflectivity with indices of refraction doesn&rsquo;t properly hold and we need to use a different Fresnel equation for conductors altogether. As this is inconvenient, we further approximate by pre-computing the surface&rsquo;s response at normal incidence (
<span class="math align-center">$F_0$</span>) at a 0 degree angle as if looking directly onto a surface. We interpolate this value based on the view angle, as per the Fresnel-Schlick approximation, such that we can use the same equation for both metals and non-metals.</p>
<p>The surface&rsquo;s response at normal incidence, or the base reflectivity, can be found in large databases like <a href="http://refractiveindex.info/" target="_blank">these</a> with some of the more common values listed below as taken from Naty Hoffman&rsquo;s course notes:</p>
<p><a href="#R-image-8ec91e571f3fe083998096868e061cfb" class="lightbox-link"><img src="./assets/20240214152427.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-8ec91e571f3fe083998096868e061cfb"><img src="./assets/20240214152427.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>What is interesting to observe here is that for all dielectric surfaces the base reflectivity never gets above 0.17 which is the exception rather than the rule, while for conductors the base reflectivity starts much higher and (mostly) varies between 0.5 and 1.0. Furthermore, for conductors (or metallic surfaces) the base reflectivity is tinted. This is why 
<span class="math align-center">$F_0$</span> is presented as an RGB triplet (reflectivity at normal incidence can vary per wavelength); this is something we <strong>only</strong> see at metallic surfaces.</p>
<p>These specific attributes of metallic surfaces compared to dielectric surfaces gave rise to something called the metallic workflow. In the metallic workflow we author surface materials with an extra parameter known as metalness that describes whether a surface is either a metallic or a non-metallic surface.</p>
<p><note>Theoretically, the metalness of a material is binary: it&rsquo;s either a metal or it isn&rsquo;t; it can&rsquo;t be both. However, most render pipelines allow configuring the metalness of a surface linearly between 0.0 and 1.0. This is mostly because of the lack of material texture precision. For instance, a surface having small (non-metal) dust/sand-like particles/scratches over a metallic surface is difficult to render with binary metalness values.</note></p>
<p>By pre-computing 
<span class="math align-center">$F_0$</span> for both dielectrics and conductors we can use the same Fresnel-Schlick approximation for both types of surfaces, but we do have to tint the base reflectivity if we have a metallic surface. We generally accomplish this as follows:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">vec3</span> <span class="n">F0</span> <span class="o">=</span> <span class="n">vec3</span><span class="p">(</span><span class="mf">0.04</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">F0</span>      <span class="o">=</span> <span class="n">mix</span><span class="p">(</span><span class="n">F0</span><span class="p">,</span> <span class="n">surfaceColor</span><span class="p">.</span><span class="n">rgb</span><span class="p">,</span> <span class="n">metalness</span><span class="p">);</span></span></span></code></pre></div><p>We define a base reflectivity that is approximated for most dielectric surfaces. This is yet another approximation as 
<span class="math align-center">$F_0$</span> is averaged around most common dielectrics. A base reflectivity of 0.04 holds for most dielectrics and produces physically plausible results without having to author an additional surface parameter. Then, based on how metallic a surface is, we either take the dielectric base reflectivity or take 
<span class="math align-center">$F_0$</span> authored as the surface color. Because metallic surfaces absorb all refracted light they have no diffuse reflections and we can directly use the surface color texture as their base reflectivity.</p>
<p>In code, the Fresnel Schlick approximation translates to:</p>
<div class="wrap-code highlight"><pre tabindex="0"><code>vec3 fresnelSchlick(float cosTheta, vec3 F0)
{
    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}</code></pre></div><p>With <code>cosTheta</code> being the dot product result between the surface&rsquo;s normal 
<span class="math align-center">$n$</span> and the halfway hℎ (or view 
<span class="math align-center">$v$</span>) direction.</p>
<h5 id="cook-torrance-reflectance-equation">Cook-Torrance reflectance equation</h5>
<p>With every component of the Cook-Torrance BRDF described, we can include the physically based BRDF into the now final reflectance equation:</p>

<span class="math align-center">$$
L_o(p,\omega_o) = \int\limits_{\Omega} 
    	(k_d\frac{c}{\pi} + k_s\frac{DFG}{4(\omega_o \cdot n)(\omega_i \cdot n)})
    	L_i(p,\omega_i) n \cdot \omega_i  d\omega_i
$$</span><p>This equation is not fully mathematically correct however. You may remember that the Fresnel term 
<span class="math align-center">$F$</span> represents the ratio of light that gets <em>reflected</em> on a surface. This is effectively our ratio 
<span class="math align-center">$k_s$</span>, meaning the specular (BRDF) part of the reflectance equation implicitly contains the reflectance ratio 
<span class="math align-center">$k_s$</span>. Given this, our final final reflectance equation becomes:</p>

<span class="math align-center">$$
L_o(p,\omega_o) = \int\limits_{\Omega} 
    	(k_d\frac{c}{\pi} + \frac{DFG}{4(\omega_o \cdot n)(\omega_i \cdot n)})
    	L_i(p,\omega_i) n \cdot \omega_i  d\omega_i
$$</span><p>This equation now completely describes a physically based render model that is generally recognized as what we commonly understand as physically based rendering, or PBR. Don&rsquo;t worry if you didn&rsquo;t yet completely understand how we&rsquo;ll need to fit all the discussed mathematics together in code. In the next chapters, we&rsquo;ll explore how to utilize the reflectance equation to get much more physically plausible results in our rendered lighting and all the bits and pieces should slowly start to fit together.</p>
<h4 id="authoring-pbr-materials">Authoring PBR materials</h4>
<p>With knowledge of the underlying mathematical model of PBR we&rsquo;ll finalize the discussion by describing how artists generally author the physical properties of a surface that we can directly feed into the PBR equations. Each of the surface parameters we need for a PBR pipeline can be defined or modeled by textures. Using textures gives us per-fragment control over how each specific surface point should react to light: whether that point is metallic, rough or smooth, or how the surface responds to different wavelengths of light.</p>
<p>Below you&rsquo;ll see a list of textures you&rsquo;ll frequently find in a PBR pipeline together with its visual output if supplied to a PBR renderer:</p>
<p><a href="#R-image-13400d8e232909372973b5faa2b7b44f" class="lightbox-link"><img src="./assets/textures-1.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-13400d8e232909372973b5faa2b7b44f"><img src="./assets/textures-1.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Albedo</strong>: the albedo texture specifies for each texel the color of the surface, or the base reflectivity if that texel is metallic. This is largely similar to what we&rsquo;ve been using before as a diffuse texture, but all lighting information is extracted from the texture. Diffuse textures often have slight shadows or darkened crevices inside the image which is something you don&rsquo;t want in an albedo texture; it should only contain the color (or refracted absorption coefficients) of the surface.</p>
<p><strong>Normal</strong>: the normal map texture is exactly as we&rsquo;ve been using before in the <a href="https://learnopengl.com/Advanced-Lighting/Normal-Mapping" target="_blank">normal mapping</a> chapter. The normal map allows us to specify, per fragment, a unique normal to give the illusion that a surface is <em>bumpier</em> than its flat counterpart.</p>
<p><strong>Metallic</strong>: the metallic map specifies per texel whether a texel is either metallic or it isn&rsquo;t. Based on how the PBR engine is set up, artists can author metalness as either grayscale values or as binary black or white.</p>
<p><strong>Roughness</strong>: the roughness map specifies how rough a surface is on a per texel basis. The sampled roughness value of the roughness influences the statistical microfacet orientations of the surface. A rougher surface gets wider and blurrier reflections, while a smooth surface gets focused and clear reflections. Some PBR engines expect a smoothness map instead of a roughness map which some artists find more intuitive. These values are then translated (<code>1.0 - smoothness</code>) to roughness the moment they&rsquo;re sampled.</p>
<p><strong>AO</strong>: the ambient occlusion or AO map specifies an extra shadowing factor of the surface and potentially surrounding geometry. If we have a brick surface for instance, the albedo texture should have no shadowing information inside the brick&rsquo;s crevices. The AO map however does specify these darkened edges as it&rsquo;s more difficult for light to escape. Taking ambient occlusion in account at the end of the lighting stage can significantly boost the visual quality of your scene. The ambient occlusion map of a mesh/surface is either manually generated, or pre-calculated in 3D modeling programs.</p>
<p>Artists set and tweak these physically based input values on a per-texel basis and can base their texture values on the physical surface properties of real-world materials. This is one of the biggest advantages of a PBR render pipeline as these physical properties of a surface remain the same, regardless of environment or lighting setup, making life easier for artists to get physically plausible results. Surfaces authored in a PBR pipeline can easily be shared among different PBR render engines, will look correct regardless of the environment they&rsquo;re in, and as a result look much more natural.</p>
<h4 id="further-reading-2">Further reading</h4>
<ul>
<li><a href="http://blog.selfshadow.com/publications/s2013-shading-course/hoffman/s2013_pbs_physics_math_notes.pdf" target="_blank">Background: Physics and Math of Shading by Naty Hoffmann</a>: there is too much theory to fully discuss in a single article so the theory here barely scratches the surface; if you want to know more about the physics of light and how it relates to the theory of PBR <strong>this</strong> is the resource you want to read.</li>
<li><a href="http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf" target="_blank">Real shading in Unreal Engine 4</a>: discusses the PBR model adopted by Epic Games in their 4th Unreal Engine installment. The PBR system we&rsquo;ll focus on in these chapters is based on this model of PBR.</li>
<li>[<a href="https://www.shadertoy.com/view/4sSfzK" target="_blank">SH17C] Physically Based Shading, by knarkowicz</a>: great showcase of all individual PBR elements in an interactive ShaderToy demo.</li>
<li><a href="https://www.marmoset.co/toolbag/learn/pbr-theory" target="_blank">Marmoset: PBR Theory</a>: an introduction to PBR mostly meant for artists, but nevertheless a good read.</li>
<li><a href="http://www.codinglabs.net/article_physically_based_rendering.aspx" target="_blank">Coding Labs: Physically based rendering</a>: an introduction to the render equation and how it relates to PBR.</li>
<li><a href="http://www.codinglabs.net/article_physically_based_rendering_cook_torrance.aspx" target="_blank">Coding Labs: Physically Based Rendering - Cook–Torrance</a>: an introduction to the Cook-Torrance BRDF.</li>
<li><a href="http://blog.wolfire.com/2015/10/Physically-based-rendering" target="_blank">Wolfire Games - Physically based rendering</a>: an introduction to PBR by Lukas Orsvärn.</li>
<li>[<a href="https://www.shadertoy.com/view/4sSfzK" target="_blank">SH17C] Physically Based Shading</a>: a great interactive shadertoy example (warning: may take a while to load) by Krzysztof Narkowi showcasing light-material interaction in a PBR fashion.</li>
</ul>
<h3 id="lighting-1">Lighting</h3>
<p>In the <a href="https://learnopengl.com/PBR/Theory" target="_blank">previous</a> chapter we laid the foundation for getting a realistic physically based renderer off the ground. In this chapter we&rsquo;ll focus on translating the previously discussed theory into an actual renderer that uses direct (or analytic) light sources: think of point lights, directional lights, and/or spotlights.</p>
<p>Let&rsquo;s start by re-visiting the final reflectance equation from the previous chapter:</p>

<span class="math align-center">$$
L_o(p,\omega_o) = \int\limits_{\Omega} 
    	(k_d\frac{c}{\pi} + \frac{DFG}{4(\omega_o \cdot n)(\omega_i \cdot n)})
    	L_i(p,\omega_i) n \cdot \omega_i  d\omega_i
$$</span><p>We now know mostly what&rsquo;s going on, but what still remained a big unknown is how exactly we&rsquo;re going to represent irradiance, the total radiance 
<span class="math align-center">$L$</span>, of the scene. We know that radiance 
<span class="math align-center">$L$</span> (as interpreted in computer graphics land) measures the radiant flux 
<span class="math align-center">$\phi$</span> or light energy of a light source over a given solid angle 
<span class="math align-center">$\omega$</span>. In our case we assumed the solid angle 
<span class="math align-center">$\omega$</span> to be infinitely small in which case radiance measures the flux of a light source over a single light ray or direction vector.</p>
<p>Given this knowledge, how do we translate this into some of the lighting knowledge we&rsquo;ve accumulated from previous chapters? Well, imagine we have a single point light (a light source that shines equally bright in all directions) with a radiant flux of <code>(23.47, 21.31, 20.79)</code> as translated to an RGB triplet. The radiant intensity of this light source equals its radiant flux at all outgoing direction rays. However, when shading a specific point 
<span class="math align-center">$p$</span> on a surface, of all possible incoming light directions over its hemisphere 
<span class="math align-center">$\Omega$</span>, only one incoming direction vector 
<span class="math align-center">$w_i$</span> directly comes from the point light source. As we only have a single light source in our scene, assumed to be a single point in space, all other possible incoming light directions have zero radiance observed over the surface point 
<span class="math align-center">$p$</span>:</p>
<p><a href="#R-image-3ce8508ceb819647207f56e41fdfb686" class="lightbox-link"><img src="./assets/lighting_radiance_direct.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-3ce8508ceb819647207f56e41fdfb686"><img src="./assets/lighting_radiance_direct.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>If at first, we assume that light attenuation (dimming of light over distance) does not affect the point light source, the radiance of the incoming light ray is the same regardless of where we position the light (excluding scaling the radiance by the incident angle 
<span class="math align-center">$\cos  \theta$</span>). This, because the point light has the same radiant intensity regardless of the angle we look at it, effectively modeling its radiant intensity as its radiant flux: a constant vector <code>(23.47, 21.31, 20.79)</code>.</p>
<p>However, radiance also takes a position 
<span class="math align-center">$p$</span> as input and as any realistic point light source takes light attenuation into account, the radiant intensity of the point light source is scaled by some measure of the distance between point 
<span class="math align-center">$p$</span> and the light source. Then, as extracted from the original radiance equation, the result is scaled by the dot product between the surface normal 
<span class="math align-center">$n$</span> and the incoming light direction 
<span class="math align-center">$w_i$</span>.</p>
<p>To put this in more practical terms: in the case of a direct point light the radiance function 
<span class="math align-center">$L$</span> measures the light color, attenuated over its distance to 
<span class="math align-center">$p$</span> and scaled by 
<span class="math align-center">$n \cdot w_i$</span>, but only over the single light ray 
<span class="math align-center">$w_i$</span> that hits 
<span class="math align-center">$p$</span> which equals the light&rsquo;s direction vector from 
<span class="math align-center">$p$</span>. In code this translates to:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">vec3</span>  <span class="n">lightColor</span>  <span class="o">=</span> <span class="n">vec3</span><span class="p">(</span><span class="mf">23.47</span><span class="p">,</span> <span class="mf">21.31</span><span class="p">,</span> <span class="mf">20.79</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">vec3</span>  <span class="n">wi</span>          <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">lightPos</span> <span class="o">-</span> <span class="n">fragPos</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="kt">float</span> <span class="n">cosTheta</span>    <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">Wi</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="kt">float</span> <span class="n">attenuation</span> <span class="o">=</span> <span class="n">calculateAttenuation</span><span class="p">(</span><span class="n">fragPos</span><span class="p">,</span> <span class="n">lightPos</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="n">vec3</span>  <span class="n">radiance</span>    <span class="o">=</span> <span class="n">lightColor</span> <span class="o">*</span> <span class="n">attenuation</span> <span class="o">*</span> <span class="n">cosTheta</span><span class="p">;</span></span></span></code></pre></div><p>Aside from the different terminology, this piece of code should be awfully familiar to you: this is exactly how we&rsquo;ve been doing diffuse lighting so far. When it comes to direct lighting, radiance is calculated similarly to how we&rsquo;ve calculated lighting before as only a single light direction vector contributes to the surface&rsquo;s radiance.</p>
<p><note>Note that this assumption holds as point lights are infinitely small and only a single point in space. If we were to model a light that has area or volume, its radiance would be non-zero in more than one incoming light direction.</note></p>
<p>For other types of light sources originating from a single point we calculate radiance similarly. For instance, a directional light source has a constant 
<span class="math align-center">$w_i$</span> without an attenuation factor. And a spotlight would not have a constant radiant intensity, but one that is scaled by the forward direction vector of the spotlight.</p>
<p>This also brings us back to the integral 
<span class="math align-center">$\int$</span> over the surface&rsquo;s hemisphere 
<span class="math align-center">$\Omega$</span> . As we know beforehand the single locations of all the contributing light sources while shading a single surface point, it is not required to try and solve the integral. We can directly take the (known) number of light sources and calculate their total irradiance, given that each light source has only a single light direction that influences the surface&rsquo;s radiance. This makes PBR on direct light sources relatively simple as we effectively only have to loop over the contributing light sources. When we later take environment lighting into account in the <a href="https://learnopengl.com/PBR/IBL/Diffuse-irradiance" target="_blank">IBL</a> chapters we do have to take the integral into account as light can come from any direction.</p>
<h4 id="a-pbr-surface-model">A PBR surface model</h4>
<p>Let&rsquo;s start by writing a fragment shader that implements the previously described PBR models. First, we need to take the relevant PBR inputs required for shading the surface:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">out</span> <span class="n">vec4</span> <span class="n">FragColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">in</span> <span class="n">vec2</span> <span class="n">TexCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">in</span> <span class="n">vec3</span> <span class="n">WorldPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">in</span> <span class="n">vec3</span> <span class="n">Normal</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="n">uniform</span> <span class="n">vec3</span> <span class="n">camPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="n">uniform</span> <span class="n">vec3</span>  <span class="n">albedo</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="n">uniform</span> <span class="kt">float</span> <span class="n">metallic</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="n">uniform</span> <span class="kt">float</span> <span class="n">roughness</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="n">uniform</span> <span class="kt">float</span> <span class="n">ao</span><span class="p">;</span></span></span></code></pre></div><p>We take the standard inputs as calculated from a generic vertex shader and a set of constant material properties over the surface of the object.</p>
<p>Then at the start of the fragment shader we do the usual calculations required for any lighting algorithm:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="n">vec3</span> <span class="n">N</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">Normal</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="n">vec3</span> <span class="n">V</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">camPos</span> <span class="o">-</span> <span class="n">WorldPos</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">    <span class="p">[...]</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><h5 id="direct-lighting">Direct lighting</h5>
<p>In this chapter&rsquo;s example demo we have a total of 4 point lights that together represent the scene&rsquo;s irradiance. To satisfy the reflectance equation we loop over each light source, calculate its individual radiance and sum its contribution scaled by the BRDF and the light&rsquo;s incident angle. We can think of the loop as solving the integral 
<span class="math align-center">$\int$</span> over 
<span class="math align-center">$\Omega$</span> for direct light sources. First, we calculate the relevant per-light variables:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">vec3</span> <span class="n">Lo</span> <span class="o">=</span> <span class="n">vec3</span><span class="p">(</span><span class="mf">0.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> 
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="n">vec3</span> <span class="n">L</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">lightPositions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">WorldPos</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="n">vec3</span> <span class="n">H</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">V</span> <span class="o">+</span> <span class="n">L</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="kt">float</span> <span class="n">distance</span>    <span class="o">=</span> <span class="n">length</span><span class="p">(</span><span class="n">lightPositions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">WorldPos</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="kt">float</span> <span class="n">attenuation</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">distance</span> <span class="o">*</span> <span class="n">distance</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="n">vec3</span> <span class="n">radiance</span>     <span class="o">=</span> <span class="n">lightColors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">attenuation</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="p">[...]</span>  
</span></span></code></pre></div><p>As we calculate lighting in linear space (we&rsquo;ll <a href="https://learnopengl.com/Advanced-Lighting/Gamma-Correction" target="_blank">gamma correct</a> at the end of the shader) we attenuate the light sources by the more physically correct inverse-square law.</p>
<p><note>While physically correct, you may still want to use the constant-linear-quadratic attenuation equation that (while not physically correct) can offer you significantly more control over the light&rsquo;s energy falloff.</note></p>
<p>Then, for each light we want to calculate the full Cook-Torrance specular BRDF term:</p>

<span class="math align-center">$$
\frac{DFG}{4(\omega_o \cdot n)(\omega_i \cdot n)}
$$</span><p>The first thing we want to do is calculate the ratio between specular and diffuse reflection, or how much the surface reflects light versus how much it refracts light. We know from the <a href="https://learnopengl.com/PBR/Theory" target="_blank">previous</a> chapter that the Fresnel equation calculates just that (note the <code>clamp</code> here to prevent black spots):</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">vec3</span> <span class="nf">fresnelSchlick</span><span class="p">(</span><span class="kt">float</span> <span class="n">cosTheta</span><span class="p">,</span> <span class="n">vec3</span> <span class="n">F0</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="k">return</span> <span class="n">F0</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">F0</span><span class="p">)</span> <span class="o">*</span> <span class="n">pow</span><span class="p">(</span><span class="n">clamp</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">cosTheta</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span> <span class="mf">5.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>The Fresnel-Schlick approximation expects a F0 parameter which is known as the <em>surface reflection at zero incidence</em> or how much the surface reflects if looking directly at the surface. The F0 varies per material and is tinted on metals as we find in large material databases. In the PBR metallic workflow we make the simplifying assumption that most dielectric surfaces look visually correct with a constant F0 of <code>0.04</code>, while we do specify F0 for metallic surfaces as then given by the albedo value. This translates to code as follows:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">vec3</span> <span class="n">F0</span> <span class="o">=</span> <span class="n">vec3</span><span class="p">(</span><span class="mf">0.04</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">F0</span>      <span class="o">=</span> <span class="n">mix</span><span class="p">(</span><span class="n">F0</span><span class="p">,</span> <span class="n">albedo</span><span class="p">,</span> <span class="n">metallic</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">vec3</span> <span class="n">F</span>  <span class="o">=</span> <span class="n">fresnelSchlick</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">V</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">),</span> <span class="n">F0</span><span class="p">);</span></span></span></code></pre></div><p>As you can see, for non-metallic surfaces F0 is always <code>0.04</code>. For metallic surfaces, we vary F0 by linearly interpolating between the original F0 and the albedo value given the metallic property.</p>
<p>Given 
<span class="math align-center">$F$</span>, the remaining terms to calculate are the normal distribution function 
<span class="math align-center">$D$</span> and the geometry function 
<span class="math align-center">$G$</span>.</p>
<p>In a direct PBR lighting shader their code equivalents are:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">float</span> <span class="nf">DistributionGGX</span><span class="p">(</span><span class="n">vec3</span> <span class="n">N</span><span class="p">,</span> <span class="n">vec3</span> <span class="n">H</span><span class="p">,</span> <span class="kt">float</span> <span class="n">roughness</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="kt">float</span> <span class="n">a</span>      <span class="o">=</span> <span class="n">roughness</span><span class="o">*</span><span class="n">roughness</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="kt">float</span> <span class="n">a2</span>     <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="kt">float</span> <span class="n">NdotH</span>  <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">H</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="kt">float</span> <span class="n">NdotH2</span> <span class="o">=</span> <span class="n">NdotH</span><span class="o">*</span><span class="n">NdotH</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">	
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="kt">float</span> <span class="n">num</span>   <span class="o">=</span> <span class="n">a2</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="kt">float</span> <span class="n">denom</span> <span class="o">=</span> <span class="p">(</span><span class="n">NdotH2</span> <span class="o">*</span> <span class="p">(</span><span class="n">a2</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="n">denom</span> <span class="o">=</span> <span class="n">PI</span> <span class="o">*</span> <span class="n">denom</span> <span class="o">*</span> <span class="n">denom</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">	
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="k">return</span> <span class="n">num</span> <span class="o">/</span> <span class="n">denom</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="kt">float</span> <span class="nf">GeometrySchlickGGX</span><span class="p">(</span><span class="kt">float</span> <span class="n">NdotV</span><span class="p">,</span> <span class="kt">float</span> <span class="n">roughness</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">    <span class="kt">float</span> <span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="n">roughness</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">    <span class="kt">float</span> <span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">r</span><span class="p">)</span> <span class="o">/</span> <span class="mf">8.0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">
</span></span><span class="line"><span class="ln">20</span><span class="cl">    <span class="kt">float</span> <span class="n">num</span>   <span class="o">=</span> <span class="n">NdotV</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">    <span class="kt">float</span> <span class="n">denom</span> <span class="o">=</span> <span class="n">NdotV</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="n">k</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">	
</span></span><span class="line"><span class="ln">23</span><span class="cl">    <span class="k">return</span> <span class="n">num</span> <span class="o">/</span> <span class="n">denom</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl"><span class="kt">float</span> <span class="nf">GeometrySmith</span><span class="p">(</span><span class="n">vec3</span> <span class="n">N</span><span class="p">,</span> <span class="n">vec3</span> <span class="n">V</span><span class="p">,</span> <span class="n">vec3</span> <span class="n">L</span><span class="p">,</span> <span class="kt">float</span> <span class="n">roughness</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl">    <span class="kt">float</span> <span class="n">NdotV</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">V</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">28</span><span class="cl">    <span class="kt">float</span> <span class="n">NdotL</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">L</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">29</span><span class="cl">    <span class="kt">float</span> <span class="n">ggx2</span>  <span class="o">=</span> <span class="n">GeometrySchlickGGX</span><span class="p">(</span><span class="n">NdotV</span><span class="p">,</span> <span class="n">roughness</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">30</span><span class="cl">    <span class="kt">float</span> <span class="n">ggx1</span>  <span class="o">=</span> <span class="n">GeometrySchlickGGX</span><span class="p">(</span><span class="n">NdotL</span><span class="p">,</span> <span class="n">roughness</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">31</span><span class="cl">	
</span></span><span class="line"><span class="ln">32</span><span class="cl">    <span class="k">return</span> <span class="n">ggx1</span> <span class="o">*</span> <span class="n">ggx2</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">33</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>What&rsquo;s important to note here is that in contrast to the <a href="https://learnopengl.com/PBR/Theory" target="_blank">theory</a> chapter, we pass the roughness parameter directly to these functions; this way we can make some term-specific modifications to the original roughness value. Based on observations by Disney and adopted by Epic Games, the lighting looks more correct squaring the roughness in both the geometry and normal distribution function.</p>
<p>With both functions defined, calculating the NDF and the G term in the reflectance loop is straightforward:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">float</span> <span class="n">NDF</span> <span class="o">=</span> <span class="n">DistributionGGX</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">roughness</span><span class="p">);</span>       
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="kt">float</span> <span class="n">G</span>   <span class="o">=</span> <span class="n">GeometrySmith</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">roughness</span><span class="p">);</span>       
</span></span></code></pre></div><p>This gives us enough to calculate the Cook-Torrance BRDF:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">vec3</span> <span class="n">numerator</span>    <span class="o">=</span> <span class="n">NDF</span> <span class="o">*</span> <span class="n">G</span> <span class="o">*</span> <span class="n">F</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="kt">float</span> <span class="n">denominator</span> <span class="o">=</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">V</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">L</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">)</span>  <span class="o">+</span> <span class="mf">0.0001</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">vec3</span> <span class="n">specular</span>     <span class="o">=</span> <span class="n">numerator</span> <span class="o">/</span> <span class="n">denominator</span><span class="p">;</span>  
</span></span></code></pre></div><p>Note that we add <code>0.0001</code> to the denominator to prevent a divide by zero in case any dot product ends up <code>0.0</code>.</p>
<p>Now we can finally calculate each light&rsquo;s contribution to the reflectance equation. As the Fresnel value directly corresponds to 
<span class="math align-center">$k_S$</span> we can use F to denote the specular contribution of any light that hits the surface. From 
<span class="math align-center">$k_S$</span> we can then calculate the ratio of refraction 
<span class="math align-center">$k_D$</span>:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">vec3</span> <span class="n">kS</span> <span class="o">=</span> <span class="n">F</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">vec3</span> <span class="n">kD</span> <span class="o">=</span> <span class="n">vec3</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span> <span class="o">-</span> <span class="n">kS</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">  
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="n">kD</span> <span class="o">*=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">metallic</span><span class="p">;</span>	
</span></span></code></pre></div><p>Seeing as kS represents the energy of light that gets reflected, the remaining ratio of light energy is the light that gets refracted which we store as kD. Furthermore, because metallic surfaces don&rsquo;t refract light and thus have no diffuse reflections we enforce this property by nullifying kD if the surface is metallic. This gives us the final data we need to calculate each light&rsquo;s outgoing reflectance value:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl">    <span class="k">const</span> <span class="kt">float</span> <span class="n">PI</span> <span class="o">=</span> <span class="mf">3.14159265359</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">  
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="kt">float</span> <span class="n">NdotL</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">L</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">);</span>        
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="n">Lo</span> <span class="o">+=</span> <span class="p">(</span><span class="n">kD</span> <span class="o">*</span> <span class="n">albedo</span> <span class="o">/</span> <span class="n">PI</span> <span class="o">+</span> <span class="n">specular</span><span class="p">)</span> <span class="o">*</span> <span class="n">radiance</span> <span class="o">*</span> <span class="n">NdotL</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>The resulting Lo value, or the outgoing radiance, is effectively the result of the reflectance equation&rsquo;s integral 
<span class="math align-center">$\int$</span> over 
<span class="math align-center">$\Omega$</span>. We don&rsquo;t really have to try and solve the integral for all possible incoming light directions as we know exactly the 4 incoming light directions that can influence the fragment. Because of this, we can directly loop over these incoming light directions e.g. the number of lights in the scene.</p>
<p>What&rsquo;s left is to add an (improvised) ambient term to the direct lighting result Lo and we have the final lit color of the fragment:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">vec3</span> <span class="n">ambient</span> <span class="o">=</span> <span class="n">vec3</span><span class="p">(</span><span class="mf">0.03</span><span class="p">)</span> <span class="o">*</span> <span class="n">albedo</span> <span class="o">*</span> <span class="n">ao</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">vec3</span> <span class="n">color</span>   <span class="o">=</span> <span class="n">ambient</span> <span class="o">+</span> <span class="n">Lo</span><span class="p">;</span>  
</span></span></code></pre></div><h5 id="linear-and-hdr-rendering">Linear and HDR rendering</h5>
<p>So far we&rsquo;ve assumed all our calculations to be in linear color space and to account for this we need to <a href="https://learnopengl.com/Advanced-Lighting/Gamma-Correction" target="_blank">gamma correct</a> at the end of the shader. Calculating lighting in linear space is incredibly important as PBR requires all inputs to be linear. Not taking this into account will result in incorrect lighting. Additionally, we want light inputs to be close to their physical equivalents such that their radiance or color values can vary wildly over a high spectrum of values. As a result, Lo can rapidly grow really high which then gets clamped between <code>0.0</code> and <code>1.0</code> due to the default low dynamic range (LDR) output. We fix this by taking Lo and tone or exposure map the <a href="https://learnopengl.com/Advanced-Lighting/HDR" target="_blank">high dynamic range</a> (HDR) value correctly to LDR before gamma correction:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">color</span> <span class="o">=</span> <span class="n">color</span> <span class="o">/</span> <span class="p">(</span><span class="n">color</span> <span class="o">+</span> <span class="n">vec3</span><span class="p">(</span><span class="mf">1.0</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">color</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">color</span><span class="p">,</span> <span class="n">vec3</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="mf">2.2</span><span class="p">));</span> 
</span></span></code></pre></div><p>Here we tone map the HDR color using the Reinhard operator, preserving the high dynamic range of a possibly highly varying irradiance, after which we gamma correct the color. We don&rsquo;t have a separate framebuffer or post-processing stage so we can directly apply both the tone mapping and gamma correction step at the end of the forward fragment shader.</p>
<p><a href="#R-image-e045628b95baf75579e70952ef4350e6" class="lightbox-link"><img src="./assets/lighting_linear_vs_non_linear_and_hdr.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-e045628b95baf75579e70952ef4350e6"><img src="./assets/lighting_linear_vs_non_linear_and_hdr.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Taking both linear color space and high dynamic range into account is incredibly important in a PBR pipeline. Without these it&rsquo;s impossible to properly capture the high and low details of varying light intensities and your calculations end up incorrect and thus visually unpleasing.</p>
<h5 id="full-direct-lighting-pbr-shader">Full direct lighting PBR shader</h5>
<p>All that&rsquo;s left now is to pass the final tone mapped and gamma corrected color to the fragment shader&rsquo;s output channel and we have ourselves a direct PBR lighting shader. For completeness&rsquo; sake, the complete main function is listed below:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">out</span> <span class="n">vec4</span> <span class="n">FragColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">in</span> <span class="n">vec2</span> <span class="n">TexCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">in</span> <span class="n">vec3</span> <span class="n">WorldPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">in</span> <span class="n">vec3</span> <span class="n">Normal</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1">// material parameters
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="c1"></span><span class="n">uniform</span> <span class="n">vec3</span>  <span class="n">albedo</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="n">uniform</span> <span class="kt">float</span> <span class="n">metallic</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="n">uniform</span> <span class="kt">float</span> <span class="n">roughness</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="n">uniform</span> <span class="kt">float</span> <span class="n">ao</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="c1">// lights
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="c1"></span><span class="n">uniform</span> <span class="n">vec3</span> <span class="n">lightPositions</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="n">uniform</span> <span class="n">vec3</span> <span class="n">lightColors</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">
</span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="n">uniform</span> <span class="n">vec3</span> <span class="n">camPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">
</span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="k">const</span> <span class="kt">float</span> <span class="n">PI</span> <span class="o">=</span> <span class="mf">3.14159265359</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">  
</span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="kt">float</span> <span class="nf">DistributionGGX</span><span class="p">(</span><span class="n">vec3</span> <span class="n">N</span><span class="p">,</span> <span class="n">vec3</span> <span class="n">H</span><span class="p">,</span> <span class="kt">float</span> <span class="n">roughness</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl"><span class="kt">float</span> <span class="nf">GeometrySchlickGGX</span><span class="p">(</span><span class="kt">float</span> <span class="n">NdotV</span><span class="p">,</span> <span class="kt">float</span> <span class="n">roughness</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl"><span class="kt">float</span> <span class="nf">GeometrySmith</span><span class="p">(</span><span class="n">vec3</span> <span class="n">N</span><span class="p">,</span> <span class="n">vec3</span> <span class="n">V</span><span class="p">,</span> <span class="n">vec3</span> <span class="n">L</span><span class="p">,</span> <span class="kt">float</span> <span class="n">roughness</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl"><span class="n">vec3</span> <span class="nf">fresnelSchlick</span><span class="p">(</span><span class="kt">float</span> <span class="n">cosTheta</span><span class="p">,</span> <span class="n">vec3</span> <span class="n">F0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl">
</span></span><span class="line"><span class="ln">26</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl"><span class="p">{</span>		
</span></span><span class="line"><span class="ln">28</span><span class="cl">    <span class="n">vec3</span> <span class="n">N</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">Normal</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">29</span><span class="cl">    <span class="n">vec3</span> <span class="n">V</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">camPos</span> <span class="o">-</span> <span class="n">WorldPos</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">30</span><span class="cl">
</span></span><span class="line"><span class="ln">31</span><span class="cl">    <span class="n">vec3</span> <span class="n">F0</span> <span class="o">=</span> <span class="n">vec3</span><span class="p">(</span><span class="mf">0.04</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">32</span><span class="cl">    <span class="n">F0</span> <span class="o">=</span> <span class="n">mix</span><span class="p">(</span><span class="n">F0</span><span class="p">,</span> <span class="n">albedo</span><span class="p">,</span> <span class="n">metallic</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">33</span><span class="cl">	           
</span></span><span class="line"><span class="ln">34</span><span class="cl">    <span class="c1">// reflectance equation
</span></span></span><span class="line"><span class="ln">35</span><span class="cl"><span class="c1"></span>    <span class="n">vec3</span> <span class="n">Lo</span> <span class="o">=</span> <span class="n">vec3</span><span class="p">(</span><span class="mf">0.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">36</span><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> 
</span></span><span class="line"><span class="ln">37</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln">38</span><span class="cl">        <span class="c1">// calculate per-light radiance
</span></span></span><span class="line"><span class="ln">39</span><span class="cl"><span class="c1"></span>        <span class="n">vec3</span> <span class="n">L</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">lightPositions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">WorldPos</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">40</span><span class="cl">        <span class="n">vec3</span> <span class="n">H</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">V</span> <span class="o">+</span> <span class="n">L</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">41</span><span class="cl">        <span class="kt">float</span> <span class="n">distance</span>    <span class="o">=</span> <span class="n">length</span><span class="p">(</span><span class="n">lightPositions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">WorldPos</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">42</span><span class="cl">        <span class="kt">float</span> <span class="n">attenuation</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">distance</span> <span class="o">*</span> <span class="n">distance</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">43</span><span class="cl">        <span class="n">vec3</span> <span class="n">radiance</span>     <span class="o">=</span> <span class="n">lightColors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">attenuation</span><span class="p">;</span>        
</span></span><span class="line"><span class="ln">44</span><span class="cl">        
</span></span><span class="line"><span class="ln">45</span><span class="cl">        <span class="c1">// cook-torrance brdf
</span></span></span><span class="line"><span class="ln">46</span><span class="cl"><span class="c1"></span>        <span class="kt">float</span> <span class="n">NDF</span> <span class="o">=</span> <span class="n">DistributionGGX</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">roughness</span><span class="p">);</span>        
</span></span><span class="line"><span class="ln">47</span><span class="cl">        <span class="kt">float</span> <span class="n">G</span>   <span class="o">=</span> <span class="n">GeometrySmith</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">roughness</span><span class="p">);</span>      
</span></span><span class="line"><span class="ln">48</span><span class="cl">        <span class="n">vec3</span> <span class="n">F</span>    <span class="o">=</span> <span class="n">fresnelSchlick</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">V</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">),</span> <span class="n">F0</span><span class="p">);</span>       
</span></span><span class="line"><span class="ln">49</span><span class="cl">        
</span></span><span class="line"><span class="ln">50</span><span class="cl">        <span class="n">vec3</span> <span class="n">kS</span> <span class="o">=</span> <span class="n">F</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">51</span><span class="cl">        <span class="n">vec3</span> <span class="n">kD</span> <span class="o">=</span> <span class="n">vec3</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span> <span class="o">-</span> <span class="n">kS</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">52</span><span class="cl">        <span class="n">kD</span> <span class="o">*=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">metallic</span><span class="p">;</span>	  
</span></span><span class="line"><span class="ln">53</span><span class="cl">        
</span></span><span class="line"><span class="ln">54</span><span class="cl">        <span class="n">vec3</span> <span class="n">numerator</span>    <span class="o">=</span> <span class="n">NDF</span> <span class="o">*</span> <span class="n">G</span> <span class="o">*</span> <span class="n">F</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">55</span><span class="cl">        <span class="kt">float</span> <span class="n">denominator</span> <span class="o">=</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">V</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">L</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.0001</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">56</span><span class="cl">        <span class="n">vec3</span> <span class="n">specular</span>     <span class="o">=</span> <span class="n">numerator</span> <span class="o">/</span> <span class="n">denominator</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">57</span><span class="cl">            
</span></span><span class="line"><span class="ln">58</span><span class="cl">        <span class="c1">// add to outgoing radiance Lo
</span></span></span><span class="line"><span class="ln">59</span><span class="cl"><span class="c1"></span>        <span class="kt">float</span> <span class="n">NdotL</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">L</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">);</span>                
</span></span><span class="line"><span class="ln">60</span><span class="cl">        <span class="n">Lo</span> <span class="o">+=</span> <span class="p">(</span><span class="n">kD</span> <span class="o">*</span> <span class="n">albedo</span> <span class="o">/</span> <span class="n">PI</span> <span class="o">+</span> <span class="n">specular</span><span class="p">)</span> <span class="o">*</span> <span class="n">radiance</span> <span class="o">*</span> <span class="n">NdotL</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">61</span><span class="cl">    <span class="p">}</span>   
</span></span><span class="line"><span class="ln">62</span><span class="cl">  
</span></span><span class="line"><span class="ln">63</span><span class="cl">    <span class="n">vec3</span> <span class="n">ambient</span> <span class="o">=</span> <span class="n">vec3</span><span class="p">(</span><span class="mf">0.03</span><span class="p">)</span> <span class="o">*</span> <span class="n">albedo</span> <span class="o">*</span> <span class="n">ao</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">64</span><span class="cl">    <span class="n">vec3</span> <span class="n">color</span> <span class="o">=</span> <span class="n">ambient</span> <span class="o">+</span> <span class="n">Lo</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">65</span><span class="cl">	
</span></span><span class="line"><span class="ln">66</span><span class="cl">    <span class="n">color</span> <span class="o">=</span> <span class="n">color</span> <span class="o">/</span> <span class="p">(</span><span class="n">color</span> <span class="o">+</span> <span class="n">vec3</span><span class="p">(</span><span class="mf">1.0</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">67</span><span class="cl">    <span class="n">color</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">color</span><span class="p">,</span> <span class="n">vec3</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="mf">2.2</span><span class="p">));</span>  
</span></span><span class="line"><span class="ln">68</span><span class="cl">   
</span></span><span class="line"><span class="ln">69</span><span class="cl">    <span class="n">FragColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">color</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">70</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>Hopefully, with the <a href="https://learnopengl.com/PBR/Theory" target="_blank">theory</a> from the previous chapter and the knowledge of the reflectance equation this shader shouldn&rsquo;t be as daunting anymore. If we take this shader, 4 point lights, and quite a few spheres where we vary both their metallic and roughness values on their vertical and horizontal axis respectively, we&rsquo;d get something like this:</p>
<p><a href="#R-image-e913f5caddc1bd2b01e5edfd583c0517" class="lightbox-link"><img src="./assets/lighting_result.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-e913f5caddc1bd2b01e5edfd583c0517"><img src="./assets/lighting_result.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>From bottom to top the metallic value ranges from <code>0.0</code> to <code>1.0</code>, with roughness increasing left to right from <code>0.0</code> to <code>1.0</code>. You can see that by only changing these two simple to understand parameters we can already display a wide array of different materials.</p>
<iframe src="https://oneshader.net/embed/6b8a7c6363" style="width:80%; height:440px; border:0;margin-left:10.0%; margin-right:12.5%;" frameborder="0" allowfullscreen=""></iframe>
<p>You can find the full source code of the demo <a href="https://learnopengl.com/code_viewer_gh.php?code=src/6.pbr/1.1.lighting/lighting.cpp" target="_blank">here</a>.</p>
<h4 id="textured-pbr">Textured PBR</h4>
<p>Extending the system to now accept its surface parameters as textures instead of uniform values gives us per-fragment control over the surface material&rsquo;s properties:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="p">[...]</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">albedoMap</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">normalMap</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">metallicMap</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">roughnessMap</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">aoMap</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="n">vec3</span> <span class="n">albedo</span>     <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">texture</span><span class="p">(</span><span class="n">albedoMap</span><span class="p">,</span> <span class="n">TexCoords</span><span class="p">).</span><span class="n">rgb</span><span class="p">,</span> <span class="mf">2.2</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="n">vec3</span> <span class="n">normal</span>     <span class="o">=</span> <span class="n">getNormalFromNormalMap</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="kt">float</span> <span class="n">metallic</span>  <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">metallicMap</span><span class="p">,</span> <span class="n">TexCoords</span><span class="p">).</span><span class="n">r</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="kt">float</span> <span class="n">roughness</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">roughnessMap</span><span class="p">,</span> <span class="n">TexCoords</span><span class="p">).</span><span class="n">r</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="kt">float</span> <span class="n">ao</span>        <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">aoMap</span><span class="p">,</span> <span class="n">TexCoords</span><span class="p">).</span><span class="n">r</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="p">[...]</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>Note that the albedo textures that come from artists are generally authored in sRGB space which is why we first convert them to linear space before using albedo in our lighting calculations. Based on the system artists use to generate ambient occlusion maps you may also have to convert these from sRGB to linear space as well. Metallic and roughness maps are almost always authored in linear space.</p>
<p>Replacing the material properties of the previous set of spheres with textures, already shows a major visual improvement over the previous lighting algorithms we&rsquo;ve used:</p>
<p><a href="#R-image-c4ebbd8b6a7a7da452ab75ce9151aa91" class="lightbox-link"><img src="./assets/lighting_textured.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c4ebbd8b6a7a7da452ab75ce9151aa91"><img src="./assets/lighting_textured.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>You can find the full source code of the textured demo <a href="https://learnopengl.com/code_viewer_gh.php?code=src/6.pbr/1.2.lighting_textured/lighting_textured.cpp" target="_blank">here</a> and the texture set used <a href="http://freepbr.com/materials/rusted-iron-pbr-metal-material-alt/" target="_blank">here</a> (with a white ao map). Keep in mind that metallic surfaces tend to look too dark in direct lighting environments as they don&rsquo;t have diffuse reflectance. They do look more correct when taking the environment&rsquo;s specular ambient lighting into account, which is what we&rsquo;ll focus on in the next chapters.</p>
<p>While not as visually impressive as some of the PBR render demos you find out there, given that we don&rsquo;t yet have <a href="https://learnopengl.com/PBR/IBL/Diffuse-irradiance" target="_blank">image based lighting</a> built in, the system we have now is still a physically based renderer, and even without IBL you&rsquo;ll see your lighting look a lot more realistic.</p>
<h3 id="ibl">IBL</h3>
<h4 id="diffuse-irradiance">Diffuse irradiance</h4>
<p>IBL, or image based lighting, is a collection of techniques to light objects, not by direct analytical lights as in the <a href="https://learnopengl.com/PBR/Lighting" target="_blank">previous</a> chapter, but by treating the surrounding environment as one big light source. This is generally accomplished by manipulating a cubemap environment map (taken from the real world or generated from a 3D scene) such that we can directly use it in our lighting equations: treating each cubemap texel as a light emitter. This way we can effectively capture an environment&rsquo;s global lighting and general feel, giving objects a better sense of <em>belonging</em> in their environment.</p>
<p>As image based lighting algorithms capture the lighting of some (global) environment, its input is considered a more precise form of ambient lighting, even a crude approximation of global illumination. This makes IBL interesting for PBR as objects look significantly more physically accurate when we take the environment&rsquo;s lighting into account.</p>
<p>To start introducing IBL into our PBR system let&rsquo;s again take a quick look at the reflectance equation:</p>

<span class="math align-center">$$
L_o(p,\omega_o) = \int\limits_{\Omega} 
    	(k_d\frac{c}{\pi} + k_s\frac{DFG}{4(\omega_o \cdot n)(\omega_i \cdot n)})
    	L_i(p,\omega_i) n \cdot \omega_i  d\omega_i
$$</span><p>As described before, our main goal is to solve the integral of all incoming light directions 
<span class="math align-center">$w_i$</span> over the hemisphere 
<span class="math align-center">$\Omega$</span> . Solving the integral in the previous chapter was easy as we knew beforehand the exact few light directions 
<span class="math align-center">$w_i$</span> that contributed to the integral. This time however, <strong>every</strong> incoming light direction 
<span class="math align-center">$w_i$</span> from the surrounding environment could potentially have some radiance making it less trivial to solve the integral. This gives us two main requirements for solving the integral:</p>
<ul>
<li>We need some way to retrieve the scene&rsquo;s radiance given any direction vector 
<span class="math align-center">$w_i$</span>.</li>
<li>Solving the integral needs to be fast and real-time.</li>
</ul>
<p>Now, the first requirement is relatively easy. We&rsquo;ve already hinted it, but one way of representing an environment or scene&rsquo;s irradiance is in the form of a (processed) environment cubemap. Given such a cubemap, we can visualize every texel of the cubemap as one single emitting light source. By sampling this cubemap with any direction vector 
<span class="math align-center">$w_i$</span>, we retrieve the scene&rsquo;s radiance from that direction.</p>
<p>Getting the scene&rsquo;s radiance given any direction vector 
<span class="math align-center">$w_i$</span> is then as simple as:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">vec3</span> <span class="n">radiance</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">_cubemapEnvironment</span><span class="p">,</span> <span class="n">w_i</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>  
</span></span></code></pre></div><p>Still, solving the integral requires us to sample the environment map from not just one direction, but all possible directions 
<span class="math align-center">$w_i$</span> over the hemisphere 
<span class="math align-center">$\Omega$</span> which is far too expensive for each fragment shader invocation. To solve the integral in a more efficient fashion we&rsquo;ll want to <em>pre-process</em> or pre-compute most of the computations. For this we&rsquo;ll have to delve a bit deeper into the reflectance equation:</p>

<span class="math align-center">$$
L_o(p,\omega_o) = \int\limits_{\Omega} 
    	(k_d\frac{c}{\pi} + k_s\frac{DFG}{4(\omega_o \cdot n)(\omega_i \cdot n)})
    	L_i(p,\omega_i) n \cdot \omega_i  d\omega_i
$$</span><p>Taking a good look at the reflectance equation we find that the diffuse 
<span class="math align-center">$k_d$</span> and specular 
<span class="math align-center">$k_s$</span> term of the BRDF are independent from each other and we can split the integral in two:</p>

<span class="math align-center">$$
L_o(p,\omega_o) = 
		\int\limits_{\Omega} (k_d\frac{c}{\pi}) L_i(p,\omega_i) n \cdot \omega_i  d\omega_i
		+ 
		\int\limits_{\Omega} (k_s\frac{DFG}{4(\omega_o \cdot n)(\omega_i \cdot n)})
			L_i(p,\omega_i) n \cdot \omega_i  d\omega_i
$$</span><p>By splitting the integral in two parts we can focus on both the diffuse and specular term individually; the focus of this chapter being on the diffuse integral.</p>
<p>Taking a closer look at the diffuse integral we find that the diffuse lambert term is a constant term (the color 
<span class="math align-center">$c$</span>, the refraction ratio 
<span class="math align-center">$k_d$</span>, and 
<span class="math align-center">$\pi$</span> are constant over the integral) and not dependent on any of the integral variables. Given this, we can move the constant term out of the diffuse integral:</p>

<span class="math align-center">$$
L_o(p,\omega_o) = 
		k_d\frac{c}{\pi} \int\limits_{\Omega} L_i(p,\omega_i) n \cdot \omega_i  d\omega_i
$$</span><p>This gives us an integral that only depends on 
<span class="math align-center">$w_i$</span> (assuming 
<span class="math align-center">$p$</span> is at the center of the environment map). With this knowledge, we can calculate or <em>pre-compute</em> a new cubemap that stores in each sample direction (or texel) 
<span class="math align-center">$w_o$</span> the diffuse integral&rsquo;s result by convolution.</p>
<p>Convolution is applying some computation to each entry in a data set considering all other entries in the data set; the data set being the scene&rsquo;s radiance or environment map. Thus for every sample direction in the cubemap, we take all other sample directions over the hemisphere 
<span class="math align-center">$\Omega$</span> into account.</p>
<p>To convolute an environment map we solve the integral for each output 
<span class="math align-center">$w_o$</span> sample direction by discretely sampling a large number of directions 
<span class="math align-center">$w_i$</span> over the hemisphere 
<span class="math align-center">$\Omega$</span> and averaging their radiance. The hemisphere we build the sample directions 
<span class="math align-center">$w_i$</span> from is oriented towards the output 
<span class="math align-center">$w_o$</span> sample direction we&rsquo;re convoluting.</p>
<p><a href="#R-image-d45af19a6e89fba1a7c7fd1c3bbdb5f8" class="lightbox-link"><img src="./assets/ibl_hemisphere_sample.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d45af19a6e89fba1a7c7fd1c3bbdb5f8"><img src="./assets/ibl_hemisphere_sample.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>This pre-computed cubemap, that for each sample direction 
<span class="math align-center">$w_o$</span> stores the integral result, can be thought of as the pre-computed sum of all indirect diffuse light of the scene hitting some surface aligned along direction 
<span class="math align-center">$w_o$</span>. Such a cubemap is known as an irradiance map seeing as the convoluted cubemap effectively allows us to directly sample the scene&rsquo;s (pre-computed) irradiance from any direction 
<span class="math align-center">$w_o$</span>.</p>
<p><note>The radiance equation also depends on a position 
<span class="math align-center">$p$</span>, which we&rsquo;ve assumed to be at the center of the irradiance map. This does mean all diffuse indirect light must come from a single environment map which may break the illusion of reality (especially indoors). Render engines solve this by placing reflection probes all over the scene where each reflection probes calculates its own irradiance map of its surroundings. This way, the irradiance (and radiance) at position 
<span class="math align-center">$p$</span> is the interpolated irradiance between its closest reflection probes. For now, we assume we always sample the environment map from its center.</note></p>
<p>Below is an example of a cubemap environment map and its resulting irradiance map (courtesy of <a href="http://www.indiedb.com/features/using-image-based-lighting-ibl" target="_blank">wave engine</a>), averaging the scene&rsquo;s radiance for every direction 
<span class="math align-center">$w_o$</span>.</p>
<p><a href="#R-image-983d48a9277600c95c186b74111036a0" class="lightbox-link"><img src="./assets/ibl_irradiance.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-983d48a9277600c95c186b74111036a0"><img src="./assets/ibl_irradiance.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>By storing the convoluted result in each cubemap texel (in the direction of wo��), the irradiance map displays somewhat like an average color or lighting display of the environment. Sampling any direction from this environment map will give us the scene&rsquo;s irradiance in that particular direction.</p>
<h4 id="pbr-and-hdr">PBR and HDR</h4>
<p>We&rsquo;ve briefly touched upon it in the <a href="https://learnopengl.com/PBR/Lighting" target="_blank">previous</a> chapter: taking the high dynamic range of your scene&rsquo;s lighting into account in a PBR pipeline is incredibly important. As PBR bases most of its inputs on real physical properties and measurements it makes sense to closely match the incoming light values to their physical equivalents. Whether we make educated guesses on each light&rsquo;s radiant flux or use their <a href="https://en.wikipedia.org/wiki/Lumen_%28unit%29" target="_blank">direct physical equivalent</a>, the difference between a simple light bulb or the sun is significant either way. Without working in an <a href="https://learnopengl.com/Advanced-Lighting/HDR" target="_blank">HDR</a> render environment it&rsquo;s impossible to correctly specify each light&rsquo;s relative intensity.</p>
<p>So, PBR and HDR go hand in hand, but how does it all relate to image based lighting? We&rsquo;ve seen in the previous chapter that it&rsquo;s relatively easy to get PBR working in HDR. However, seeing as for image based lighting we base the environment&rsquo;s indirect light intensity on the color values of an environment cubemap we need some way to store the lighting&rsquo;s high dynamic range into an environment map.</p>
<p>The environment maps we&rsquo;ve been using so far as cubemaps (used as <a href="https://learnopengl.com/Advanced-OpenGL/Cubemaps" target="_blank">skyboxes</a> for instance) are in low dynamic range (LDR). We directly used their color values from the individual face images, ranged between <code>0.0</code> and <code>1.0</code>, and processed them as is. While this may work fine for visual output, when taking them as physical input parameters it&rsquo;s not going to work.</p>
<h5 id="the-radiance-hdr-file-format">The radiance HDR file format</h5>
<p>Enter the radiance file format. The radiance file format (with the <code>.hdr</code> extension) stores a full cubemap with all 6 faces as floating point data. This allows us to specify color values outside the <code>0.0</code> to <code>1.0</code> range to give lights their correct color intensities. The file format also uses a clever trick to store each floating point value, not as a 32 bit value per channel, but 8 bits per channel using the color&rsquo;s alpha channel as an exponent (this does come with a loss of precision). This works quite well, but requires the parsing program to re-convert each color to their floating point equivalent.</p>
<p>There are quite a few radiance HDR environment maps freely available from sources like <a href="http://www.hdrlabs.com/sibl/archive.html" target="_blank">sIBL archive</a> of which you can see an example below:</p>
<p><a href="#R-image-0c2b8bdf128ec5aaa2de57e208c51dbe" class="lightbox-link"><img src="./assets/ibl_hdr_radiance.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-0c2b8bdf128ec5aaa2de57e208c51dbe"><img src="./assets/ibl_hdr_radiance.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>This may not be exactly what you were expecting, as the image appears distorted and doesn&rsquo;t show any of the 6 individual cubemap faces of environment maps we&rsquo;ve seen before. This environment map is projected from a sphere onto a flat plane such that we can more easily store the environment into a single image known as an equirectangular map. This does come with a small caveat as most of the visual resolution is stored in the horizontal view direction, while less is preserved in the bottom and top directions. In most cases this is a decent compromise as with almost any renderer you&rsquo;ll find most of the interesting lighting and surroundings in the horizontal viewing directions.</p>
<h5 id="hdr-and-stb_imageh">HDR and stb_image.h</h5>
<p>Loading radiance HDR images directly requires some knowledge of the <a href="http://radsite.lbl.gov/radiance/refer/Notes/picture_format.html" target="_blank">file format</a> which isn&rsquo;t too difficult, but cumbersome nonetheless. Lucky for us, the popular one header library <a href="https://github.com/nothings/stb/blob/master/stb_image.h" target="_blank">stb_image.h</a> supports loading radiance HDR images directly as an array of floating point values which perfectly fits our needs. With <code>stb_image</code> added to your project, loading an HDR image is now as simple as follows:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;stb_image.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="p">[...]</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">stbi_set_flip_vertically_on_load</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">nrComponents</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="kt">float</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">stbi_loadf</span><span class="p">(</span><span class="s">&#34;newport_loft.hdr&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">width</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">height</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nrComponents</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hdrTexture</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="n">glGenTextures</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hdrTexture</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">hdrTexture</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="n">glTexImage2D</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGB16F</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGB</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">13</span><span class="cl">
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_S</span><span class="p">,</span> <span class="n">GL_CLAMP_TO_EDGE</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_T</span><span class="p">,</span> <span class="n">GL_CLAMP_TO_EDGE</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MIN_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">    <span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MAG_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">
</span></span><span class="line"><span class="ln">19</span><span class="cl">    <span class="n">stbi_image_free</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="k">else</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Failed to load HDR image.&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p><code>stb_image.h</code> automatically maps the HDR values to a list of floating point values: 32 bits per channel and 3 channels per color by default. This is all we need to store the equirectangular HDR environment map into a 2D floating point texture.</p>
<h5 id="from-equirectangular-to-cubemap">From Equirectangular to Cubemap</h5>
<p>It is possible to use the equirectangular map directly for environment lookups, but these operations can be relatively expensive in which case a direct cubemap sample is more performant. Therefore, in this chapter we&rsquo;ll first convert the equirectangular image to a cubemap for further processing. Note that in the process we also show how to sample an equirectangular map as if it was a 3D environment map in which case you&rsquo;re free to pick whichever solution you prefer.</p>
<p>To convert an equirectangular image into a cubemap we need to render a (unit) cube and project the equirectangular map on all of the cube&rsquo;s faces from the inside and take 6 images of each of the cube&rsquo;s sides as a cubemap face. The vertex shader of this cube simply renders the cube as is and passes its local position to the fragment shader as a 3D sample vector:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">aPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">out</span> <span class="n">vec3</span> <span class="n">localPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">uniform</span> <span class="n">mat4</span> <span class="n">projection</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="n">uniform</span> <span class="n">mat4</span> <span class="n">view</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="n">localPos</span> <span class="o">=</span> <span class="n">aPos</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="n">gl_Position</span> <span class="o">=</span>  <span class="n">projection</span> <span class="o">*</span> <span class="n">view</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">localPos</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>For the fragment shader, we color each part of the cube as if we neatly folded the equirectangular map onto each side of the cube. To accomplish this, we take the fragment&rsquo;s sample direction as interpolated from the cube&rsquo;s local position and then use this direction vector and some trigonometry magic (spherical to cartesian) to sample the equirectangular map as if it&rsquo;s a cubemap itself. We directly store the result onto the cube-face&rsquo;s fragment which should be all we need to do:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">out</span> <span class="n">vec4</span> <span class="n">FragColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">in</span> <span class="n">vec3</span> <span class="n">localPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">equirectangularMap</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="k">const</span> <span class="n">vec2</span> <span class="n">invAtan</span> <span class="o">=</span> <span class="n">vec2</span><span class="p">(</span><span class="mf">0.1591</span><span class="p">,</span> <span class="mf">0.3183</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="n">vec2</span> <span class="nf">SampleSphericalMap</span><span class="p">(</span><span class="n">vec3</span> <span class="n">v</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="n">vec2</span> <span class="n">uv</span> <span class="o">=</span> <span class="n">vec2</span><span class="p">(</span><span class="n">atan</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">x</span><span class="p">),</span> <span class="n">asin</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">y</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="n">uv</span> <span class="o">*=</span> <span class="n">invAtan</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="n">uv</span> <span class="o">+=</span> <span class="mf">0.5</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="k">return</span> <span class="n">uv</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">
</span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="p">{</span>		
</span></span><span class="line"><span class="ln">18</span><span class="cl">    <span class="n">vec2</span> <span class="n">uv</span> <span class="o">=</span> <span class="n">SampleSphericalMap</span><span class="p">(</span><span class="n">normalize</span><span class="p">(</span><span class="n">localPos</span><span class="p">));</span> <span class="c1">// make sure to normalize localPos
</span></span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="c1"></span>    <span class="n">vec3</span> <span class="n">color</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">equirectangularMap</span><span class="p">,</span> <span class="n">uv</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">    
</span></span><span class="line"><span class="ln">21</span><span class="cl">    <span class="n">FragColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">color</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>If you render a cube at the center of the scene given an HDR equirectangular map you&rsquo;ll get something that looks like this:</p>
<p><a href="#R-image-2289e939a31a81bbeb34e3c444644bed" class="lightbox-link"><img src="./assets/ibl_equirectangular_projection.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-2289e939a31a81bbeb34e3c444644bed"><img src="./assets/ibl_equirectangular_projection.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>This demonstrates that we effectively mapped an equirectangular image onto a cubic shape, but doesn&rsquo;t yet help us in converting the source HDR image to a cubemap texture. To accomplish this we have to render the same cube 6 times, looking at each individual face of the cube, while recording its visual result with a <a href="https://learnopengl.com/Advanced-OpenGL/Framebuffers" target="_blank">framebuffer</a> object:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">captureFBO</span><span class="p">,</span> <span class="n">captureRBO</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glGenFramebuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">captureFBO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">glGenRenderbuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">captureRBO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">captureFBO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="n">glBindRenderbuffer</span><span class="p">(</span><span class="n">GL_RENDERBUFFER</span><span class="p">,</span> <span class="n">captureRBO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="n">glRenderbufferStorage</span><span class="p">(</span><span class="n">GL_RENDERBUFFER</span><span class="p">,</span> <span class="n">GL_DEPTH_COMPONENT24</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="mi">512</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">8</span><span class="cl"><span class="n">glFramebufferRenderbuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">GL_DEPTH_ATTACHMENT</span><span class="p">,</span> <span class="n">GL_RENDERBUFFER</span><span class="p">,</span> <span class="n">captureRBO</span><span class="p">);</span>  
</span></span></code></pre></div><p>Of course, we then also generate the corresponding cubemap color textures, pre-allocating memory for each of its 6 faces:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">envCubemap</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="n">glGenTextures</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">envCubemap</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_CUBE_MAP</span><span class="p">,</span> <span class="n">envCubemap</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="c1">// note that we store each face with 16 bit floating point values
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1"></span>    <span class="n">glTexImage2D</span><span class="p">(</span><span class="n">GL_TEXTURE_CUBE_MAP_POSITIVE_X</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGB16F</span><span class="p">,</span> 
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">                 <span class="mi">512</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGB</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_CUBE_MAP</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_S</span><span class="p">,</span> <span class="n">GL_CLAMP_TO_EDGE</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_CUBE_MAP</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_T</span><span class="p">,</span> <span class="n">GL_CLAMP_TO_EDGE</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_CUBE_MAP</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_R</span><span class="p">,</span> <span class="n">GL_CLAMP_TO_EDGE</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_CUBE_MAP</span><span class="p">,</span> <span class="n">GL_TEXTURE_MIN_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_CUBE_MAP</span><span class="p">,</span> <span class="n">GL_TEXTURE_MAG_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR</span><span class="p">);</span></span></span></code></pre></div><p>Then what&rsquo;s left to do is capture the equirectangular 2D texture onto the cubemap faces.</p>
<p>I won&rsquo;t go over the details as the code details topics previously discussed in the <a href="https://learnopengl.com/Advanced-OpenGL/Framebuffers" target="_blank">framebuffer</a> and <a href="https://learnopengl.com/Advanced-Lighting/Shadows/Point-Shadows" target="_blank">point shadows</a> chapters, but it effectively boils down to setting up 6 different view matrices (facing each side of the cube), set up a projection matrix with a fov of <code>90</code> degrees to capture the entire face, and render a cube 6 times storing the results in a floating point framebuffer:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span> <span class="n">captureProjection</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">perspective</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">radians</span><span class="p">(</span><span class="mf">90.0f</span><span class="p">),</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.1f</span><span class="p">,</span> <span class="mf">10.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span> <span class="n">captureViews</span><span class="p">[]</span> <span class="o">=</span> 
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">   <span class="n">glm</span><span class="o">::</span><span class="n">lookAt</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">),</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span> <span class="mf">1.0f</span><span class="p">,</span>  <span class="mf">0.0f</span><span class="p">,</span>  <span class="mf">0.0f</span><span class="p">),</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0f</span><span class="p">,</span>  <span class="mf">0.0f</span><span class="p">)),</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">   <span class="n">glm</span><span class="o">::</span><span class="n">lookAt</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">),</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0f</span><span class="p">,</span>  <span class="mf">0.0f</span><span class="p">,</span>  <span class="mf">0.0f</span><span class="p">),</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0f</span><span class="p">,</span>  <span class="mf">0.0f</span><span class="p">)),</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">   <span class="n">glm</span><span class="o">::</span><span class="n">lookAt</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">),</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span> <span class="mf">0.0f</span><span class="p">,</span>  <span class="mf">1.0f</span><span class="p">,</span>  <span class="mf">0.0f</span><span class="p">),</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span>  <span class="mf">0.0f</span><span class="p">,</span>  <span class="mf">1.0f</span><span class="p">)),</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">   <span class="n">glm</span><span class="o">::</span><span class="n">lookAt</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">),</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0f</span><span class="p">,</span>  <span class="mf">0.0f</span><span class="p">),</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span>  <span class="mf">0.0f</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0f</span><span class="p">)),</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">   <span class="n">glm</span><span class="o">::</span><span class="n">lookAt</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">),</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span> <span class="mf">0.0f</span><span class="p">,</span>  <span class="mf">0.0f</span><span class="p">,</span>  <span class="mf">1.0f</span><span class="p">),</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0f</span><span class="p">,</span>  <span class="mf">0.0f</span><span class="p">)),</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">   <span class="n">glm</span><span class="o">::</span><span class="n">lookAt</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">),</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span> <span class="mf">0.0f</span><span class="p">,</span>  <span class="mf">0.0f</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0f</span><span class="p">),</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0f</span><span class="p">,</span>  <span class="mf">0.0f</span><span class="p">))</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="c1">// convert HDR equirectangular environment map to cubemap equivalent
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="c1"></span><span class="n">equirectangularToCubemapShader</span><span class="p">.</span><span class="n">use</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="n">equirectangularToCubemapShader</span><span class="p">.</span><span class="n">setInt</span><span class="p">(</span><span class="s">&#34;equirectangularMap&#34;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="n">equirectangularToCubemapShader</span><span class="p">.</span><span class="n">setMat4</span><span class="p">(</span><span class="s">&#34;projection&#34;</span><span class="p">,</span> <span class="n">captureProjection</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="n">glActiveTexture</span><span class="p">(</span><span class="n">GL_TEXTURE0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">hdrTexture</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">
</span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="n">glViewport</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="mi">512</span><span class="p">);</span> <span class="c1">// don&#39;t forget to configure the viewport to the capture dimensions.
</span></span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="c1"></span><span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">captureFBO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">    <span class="n">equirectangularToCubemapShader</span><span class="p">.</span><span class="n">setMat4</span><span class="p">(</span><span class="s">&#34;view&#34;</span><span class="p">,</span> <span class="n">captureViews</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">    <span class="n">glFramebufferTexture2D</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">GL_COLOR_ATTACHMENT0</span><span class="p">,</span> 
</span></span><span class="line"><span class="ln">25</span><span class="cl">                           <span class="n">GL_TEXTURE_CUBE_MAP_POSITIVE_X</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">envCubemap</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl">    <span class="n">glClear</span><span class="p">(</span><span class="n">GL_COLOR_BUFFER_BIT</span> <span class="o">|</span> <span class="n">GL_DEPTH_BUFFER_BIT</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl">
</span></span><span class="line"><span class="ln">28</span><span class="cl">    <span class="n">renderCube</span><span class="p">();</span> <span class="c1">// renders a 1x1 cube
</span></span></span><span class="line"><span class="ln">29</span><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="ln">30</span><span class="cl"><span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  
</span></span></code></pre></div><p>We take the color attachment of the framebuffer and switch its texture target around for every face of the cubemap, directly rendering the scene into one of the cubemap&rsquo;s faces. Once this routine has finished (which we only have to do once), the cubemap envCubemap should be the cubemapped environment version of our original HDR image.</p>
<p>Let&rsquo;s test the cubemap by writing a very simple skybox shader to display the cubemap around us:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">aPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">uniform</span> <span class="n">mat4</span> <span class="n">projection</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">uniform</span> <span class="n">mat4</span> <span class="n">view</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="n">out</span> <span class="n">vec3</span> <span class="n">localPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="n">localPos</span> <span class="o">=</span> <span class="n">aPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="n">mat4</span> <span class="n">rotView</span> <span class="o">=</span> <span class="n">mat4</span><span class="p">(</span><span class="n">mat3</span><span class="p">(</span><span class="n">view</span><span class="p">));</span> <span class="c1">// remove translation from the view matrix
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="c1"></span>    <span class="n">vec4</span> <span class="n">clipPos</span> <span class="o">=</span> <span class="n">projection</span> <span class="o">*</span> <span class="n">rotView</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">localPos</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">clipPos</span><span class="p">.</span><span class="n">xyww</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>Note the <code>xyww</code> trick here that ensures the depth value of the rendered cube fragments always end up at <code>1.0</code>, the maximum depth value, as described in the <a href="https://learnopengl.com/Advanced-OpenGL/Cubemaps" target="_blank">cubemap</a> chapter. Do note that we need to change the depth comparison function to GL_LEQUAL:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glDepthFunc</span><span class="p">(</span><span class="n">GL_LEQUAL</span><span class="p">);</span>  
</span></span></code></pre></div><p>The fragment shader then directly samples the cubemap environment map using the cube&rsquo;s local fragment position:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">out</span> <span class="n">vec4</span> <span class="n">FragColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">in</span> <span class="n">vec3</span> <span class="n">localPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">uniform</span> <span class="n">samplerCube</span> <span class="n">environmentMap</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="n">vec3</span> <span class="n">envColor</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">environmentMap</span><span class="p">,</span> <span class="n">localPos</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="n">envColor</span> <span class="o">=</span> <span class="n">envColor</span> <span class="o">/</span> <span class="p">(</span><span class="n">envColor</span> <span class="o">+</span> <span class="n">vec3</span><span class="p">(</span><span class="mf">1.0</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="n">envColor</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">envColor</span><span class="p">,</span> <span class="n">vec3</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="mf">2.2</span><span class="p">));</span> 
</span></span><span class="line"><span class="ln">14</span><span class="cl">  
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="n">FragColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">envColor</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>We sample the environment map using its interpolated vertex cube positions that directly correspond to the correct direction vector to sample. Seeing as the camera&rsquo;s translation components are ignored, rendering this shader over a cube should give you the environment map as a non-moving background. Also, as we directly output the environment map&rsquo;s HDR values to the default LDR framebuffer, we want to properly tone map the color values. Furthermore, almost all HDR maps are in linear color space by default so we need to apply <a href="https://learnopengl.com/Advanced-Lighting/Gamma-Correction" target="_blank">gamma correction</a> before writing to the default framebuffer.</p>
<p>Now rendering the sampled environment map over the previously rendered spheres should look something like this:</p>
<p><a href="#R-image-921865e54f3a21c42bf3af505fea71a1" class="lightbox-link"><img src="./assets/ibl_hdr_environment_mapped.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-921865e54f3a21c42bf3af505fea71a1"><img src="./assets/ibl_hdr_environment_mapped.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Well&hellip; it took us quite a bit of setup to get here, but we successfully managed to read an HDR environment map, convert it from its equirectangular mapping to a cubemap, and render the HDR cubemap into the scene as a skybox. Furthermore, we set up a small system to render onto all 6 faces of a cubemap, which we&rsquo;ll need again when convoluting the environment map. You can find the source code of the entire conversion process <a href="https://learnopengl.com/code_viewer_gh.php?code=src/6.pbr/2.1.1.ibl_irradiance_conversion/ibl_irradiance_conversion.cpp" target="_blank">here</a>.</p>
<h4 id="cubemap-convolution">Cubemap convolution</h4>
<p>As described at the start of the chapter, our main goal is to solve the integral for all diffuse indirect lighting given the scene&rsquo;s irradiance in the form of a cubemap environment map. We know that we can get the radiance of the scene 
<span class="math align-center">$L(p, w_i)$</span> in a particular direction by sampling an HDR environment map in direction 
<span class="math align-center">$w_i$</span>. To solve the integral, we have to sample the scene&rsquo;s radiance from all possible directions within the hemisphere 
<span class="math align-center">$\Omega$</span> for each fragment.</p>
<p>It is however computationally impossible to sample the environment&rsquo;s lighting from every possible direction in 
<span class="math align-center">$\Omega$</span>, the number of possible directions is theoretically infinite. We can however, approximate the number of directions by taking a finite number of directions or samples, spaced uniformly or taken randomly from within the hemisphere, to get a fairly accurate approximation of the irradiance; effectively solving the integral 
<span class="math align-center">$\int$</span> discretely</p>
<p>It is however still too expensive to do this for every fragment in real-time as the number of samples needs to be significantly large for decent results, so we want to pre-compute this. Since the orientation of the hemisphere decides where we capture the irradiance, we can pre-calculate the irradiance for every possible hemisphere orientation oriented around all outgoing directions 
<span class="math align-center">$w_o$</span>:</p>

<span class="math align-center">$$
L_o(p,\omega_o) = 
		k_d\frac{c}{\pi} \int\limits_{\Omega} L_i(p,\omega_i) n \cdot \omega_i  d\omega_i
$$</span><p>Given any direction vector 
<span class="math align-center">$w_i$</span> in the lighting pass, we can then sample the pre-computed irradiance map to retrieve the total diffuse irradiance from direction 
<span class="math align-center">$w_i$</span>. To determine the amount of indirect diffuse (irradiant) light at a fragment surface, we retrieve the total irradiance from the hemisphere oriented around its surface normal. Obtaining the scene&rsquo;s irradiance is then as simple as:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">vec3</span> <span class="n">irradiance</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">irradianceMap</span><span class="p">,</span> <span class="n">N</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span></span></span></code></pre></div><p>Now, to generate the irradiance map, we need to convolute the environment&rsquo;s lighting as converted to a cubemap. Given that for each fragment the surface&rsquo;s hemisphere is oriented along the normal vector 
<span class="math align-center">$N$</span>, convoluting a cubemap equals calculating the total averaged radiance of each direction 
<span class="math align-center">$w_i$</span> in the hemisphere 
<span class="math align-center">$\Omega$</span> oriented along 
<span class="math align-center">$N$</span>.</p>
<p><a href="#R-image-b6f6aff56f56a3747e382936aea6615d" class="lightbox-link"><img src="./assets/ibl_hemisphere_sample_normal.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b6f6aff56f56a3747e382936aea6615d"><img src="./assets/ibl_hemisphere_sample_normal.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Thankfully, all of the cumbersome setup of this chapter isn&rsquo;t all for nothing as we can now directly take the converted cubemap, convolute it in a fragment shader, and capture its result in a new cubemap using a framebuffer that renders to all 6 face directions. As we&rsquo;ve already set this up for converting the equirectangular environment map to a cubemap, we can take the exact same approach but use a different fragment shader:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">out</span> <span class="n">vec4</span> <span class="n">FragColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">in</span> <span class="n">vec3</span> <span class="n">localPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">uniform</span> <span class="n">samplerCube</span> <span class="n">environmentMap</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="k">const</span> <span class="kt">float</span> <span class="n">PI</span> <span class="o">=</span> <span class="mf">3.14159265359</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="p">{</span>		
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="c1">// the sample direction equals the hemisphere&#39;s orientation 
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="c1"></span>    <span class="n">vec3</span> <span class="n">normal</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">localPos</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">  
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="n">vec3</span> <span class="n">irradiance</span> <span class="o">=</span> <span class="n">vec3</span><span class="p">(</span><span class="mf">0.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">  
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="p">[...]</span> <span class="c1">// convolution code
</span></span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="c1"></span>  
</span></span><span class="line"><span class="ln">18</span><span class="cl">    <span class="n">FragColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">irradiance</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>With environmentMap being the HDR cubemap as converted from the equirectangular HDR environment map.</p>
<p>There are many ways to convolute the environment map, but for this chapter we&rsquo;re going to generate a fixed amount of sample vectors for each cubemap texel along a hemisphere 
<span class="math align-center">$\Omega$</span> oriented around the sample direction and average the results. The fixed amount of sample vectors will be uniformly spread inside the hemisphere. Note that an integral is a continuous function and discretely sampling its function given a fixed amount of sample vectors will be an approximation. The more sample vectors we use, the better we approximate the integral.</p>
<p>The integral 
<span class="math align-center">$\int$</span> of the reflectance equation revolves around the solid angle 
<span class="math align-center">$dw$</span> which is rather difficult to work with. Instead of integrating over the solid angle 
<span class="math align-center">$dw$</span> we&rsquo;ll integrate over its equivalent spherical coordinates 
<span class="math align-center">$\theta$</span> and 
<span class="math align-center">$\phi$</span>.</p>
<p><a href="#R-image-cad70a5569f4c214f884c1ae45709218" class="lightbox-link"><img src="./assets/ibl_spherical_integrate.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-cad70a5569f4c214f884c1ae45709218"><img src="./assets/ibl_spherical_integrate.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>We use the polar azimuth 
<span class="math align-center">$\phi$</span> angle to sample around the ring of the hemisphere between 
<span class="math align-center">$0$</span> and 
<span class="math align-center">$2\pi$</span>, and use the inclination zenith 
<span class="math align-center">$\theta$</span> angle between 
<span class="math align-center">$0$</span> and 
<span class="math align-center">$\frac{1}{2}\pi$</span> to sample the increasing rings of the hemisphere. This will give us the updated reflectance integral:</p>

<span class="math align-center">$$
L_o(p,\phi_o, \theta_o) = 
        k_d\frac{c}{\pi} \int_{\phi = 0}^{2\pi} \int_{\theta = 0}^{\frac{1}{2}\pi} L_i(p,\phi_i, \theta_i) \cos(\theta) \sin(\theta)  d\phi d\theta
$$</span><p>Solving the integral requires us to take a fixed number of discrete samples within the hemisphere 
<span class="math align-center">$\Omega$</span> and averaging their results. This translates the integral to the following discrete version as based on the <a href="https://en.wikipedia.org/wiki/Riemann_sum" target="_blank">Riemann sum</a> given 
<span class="math align-center">$n1$</span> and 
<span class="math align-center">$n2$</span> discrete samples on each spherical coordinate respectively:</p>

<span class="math align-center">$$
L_o(p,\phi_o, \theta_o) = 
        k_d \frac{c\pi}{n1 n2} \sum_{\phi = 0}^{n1} \sum_{\theta = 0}^{n2} L_i(p,\phi_i, \theta_i) \cos(\theta) \sin(\theta)  d\phi d\theta
$$</span><p>As we sample both spherical values discretely, each sample will approximate or average an area on the hemisphere as the image before shows. Note that (due to the general properties of a spherical shape) the hemisphere&rsquo;s discrete sample area gets smaller the higher the zenith angle 
<span class="math align-center">$\theta$</span> as the sample regions converge towards the center top. To compensate for the smaller areas, we weigh its contribution by scaling the area by 
<span class="math align-center">$\sin \theta$</span>.</p>
<p>Discretely sampling the hemisphere given the integral&rsquo;s spherical coordinates translates to the following fragment code:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">vec3</span> <span class="n">irradiance</span> <span class="o">=</span> <span class="n">vec3</span><span class="p">(</span><span class="mf">0.0</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">vec3</span> <span class="n">up</span>    <span class="o">=</span> <span class="n">vec3</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">vec3</span> <span class="n">right</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">cross</span><span class="p">(</span><span class="n">up</span><span class="p">,</span> <span class="n">normal</span><span class="p">));</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">up</span>         <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">cross</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="n">right</span><span class="p">));</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="kt">float</span> <span class="n">sampleDelta</span> <span class="o">=</span> <span class="mf">0.025</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="kt">float</span> <span class="n">nrSamples</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="k">for</span><span class="p">(</span><span class="kt">float</span> <span class="n">phi</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="n">phi</span> <span class="o">&lt;</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">PI</span><span class="p">;</span> <span class="n">phi</span> <span class="o">+=</span> <span class="n">sampleDelta</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">float</span> <span class="n">theta</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="n">theta</span> <span class="o">&lt;</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">PI</span><span class="p">;</span> <span class="n">theta</span> <span class="o">+=</span> <span class="n">sampleDelta</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">        <span class="c1">// spherical to cartesian (in tangent space)
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="c1"></span>        <span class="n">vec3</span> <span class="n">tangentSample</span> <span class="o">=</span> <span class="n">vec3</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">),</span>  <span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">),</span> <span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">        <span class="c1">// tangent space to world
</span></span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="c1"></span>        <span class="n">vec3</span> <span class="n">sampleVec</span> <span class="o">=</span> <span class="n">tangentSample</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">right</span> <span class="o">+</span> <span class="n">tangentSample</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">up</span> <span class="o">+</span> <span class="n">tangentSample</span><span class="p">.</span><span class="n">z</span> <span class="o">*</span> <span class="n">N</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">17</span><span class="cl">
</span></span><span class="line"><span class="ln">18</span><span class="cl">        <span class="n">irradiance</span> <span class="o">+=</span> <span class="n">texture</span><span class="p">(</span><span class="n">environmentMap</span><span class="p">,</span> <span class="n">sampleVec</span><span class="p">).</span><span class="n">rgb</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">        <span class="n">nrSamples</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl"><span class="n">irradiance</span> <span class="o">=</span> <span class="n">PI</span> <span class="o">*</span> <span class="n">irradiance</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="kt">float</span><span class="p">(</span><span class="n">nrSamples</span><span class="p">));</span></span></span></code></pre></div><p>We specify a fixed sampleDelta delta value to traverse the hemisphere; decreasing or increasing the sample delta will increase or decrease the accuracy respectively.</p>
<p>From within both loops, we take both spherical coordinates to convert them to a 3D Cartesian sample vector, convert the sample from tangent to world space oriented around the normal, and use this sample vector to directly sample the HDR environment map. We add each sample result to irradiance which at the end we divide by the total number of samples taken, giving us the average sampled irradiance. Note that we scale the sampled color value by <code>cos(theta)</code> due to the light being weaker at larger angles and by <code>sin(theta)</code> to account for the smaller sample areas in the higher hemisphere areas.</p>
<p>Now what&rsquo;s left to do is to set up the OpenGL rendering code such that we can convolute the earlier captured envCubemap. First we create the irradiance cubemap (again, we only have to do this once before the render loop):</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irradianceMap</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="n">glGenTextures</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">irradianceMap</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_CUBE_MAP</span><span class="p">,</span> <span class="n">irradianceMap</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="n">glTexImage2D</span><span class="p">(</span><span class="n">GL_TEXTURE_CUBE_MAP_POSITIVE_X</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGB16F</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> 
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">                 <span class="n">GL_RGB</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_CUBE_MAP</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_S</span><span class="p">,</span> <span class="n">GL_CLAMP_TO_EDGE</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_CUBE_MAP</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_T</span><span class="p">,</span> <span class="n">GL_CLAMP_TO_EDGE</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_CUBE_MAP</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_R</span><span class="p">,</span> <span class="n">GL_CLAMP_TO_EDGE</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_CUBE_MAP</span><span class="p">,</span> <span class="n">GL_TEXTURE_MIN_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_CUBE_MAP</span><span class="p">,</span> <span class="n">GL_TEXTURE_MAG_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR</span><span class="p">);</span></span></span></code></pre></div><p>As the irradiance map averages all surrounding radiance uniformly it doesn&rsquo;t have a lot of high frequency details, so we can store the map at a low resolution (32x32) and let OpenGL&rsquo;s linear filtering do most of the work. Next, we re-scale the capture framebuffer to the new resolution:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">captureFBO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glBindRenderbuffer</span><span class="p">(</span><span class="n">GL_RENDERBUFFER</span><span class="p">,</span> <span class="n">captureRBO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">glRenderbufferStorage</span><span class="p">(</span><span class="n">GL_RENDERBUFFER</span><span class="p">,</span> <span class="n">GL_DEPTH_COMPONENT24</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>  
</span></span></code></pre></div><p>Using the convolution shader, we render the environment map in a similar way to how we captured the environment cubemap:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">irradianceShader</span><span class="p">.</span><span class="n">use</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="n">irradianceShader</span><span class="p">.</span><span class="n">setInt</span><span class="p">(</span><span class="s">&#34;environmentMap&#34;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">irradianceShader</span><span class="p">.</span><span class="n">setMat4</span><span class="p">(</span><span class="s">&#34;projection&#34;</span><span class="p">,</span> <span class="n">captureProjection</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">glActiveTexture</span><span class="p">(</span><span class="n">GL_TEXTURE0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_CUBE_MAP</span><span class="p">,</span> <span class="n">envCubemap</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="n">glViewport</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span> <span class="c1">// don&#39;t forget to configure the viewport to the capture dimensions.
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="c1"></span><span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">captureFBO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="n">irradianceShader</span><span class="p">.</span><span class="n">setMat4</span><span class="p">(</span><span class="s">&#34;view&#34;</span><span class="p">,</span> <span class="n">captureViews</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="n">glFramebufferTexture2D</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">GL_COLOR_ATTACHMENT0</span><span class="p">,</span> 
</span></span><span class="line"><span class="ln">13</span><span class="cl">                           <span class="n">GL_TEXTURE_CUBE_MAP_POSITIVE_X</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">irradianceMap</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="n">glClear</span><span class="p">(</span><span class="n">GL_COLOR_BUFFER_BIT</span> <span class="o">|</span> <span class="n">GL_DEPTH_BUFFER_BIT</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="n">renderCube</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  
</span></span></code></pre></div><p>Now after this routine we should have a pre-computed irradiance map that we can directly use for our diffuse image based lighting. To see if we successfully convoluted the environment map we&rsquo;ll substitute the environment map for the irradiance map as the skybox&rsquo;s environment sampler:</p>
<p><a href="#R-image-f87b3880554c05ded36bac9b63e9476f" class="lightbox-link"><img src="./assets/ibl_irradiance_map_background.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f87b3880554c05ded36bac9b63e9476f"><img src="./assets/ibl_irradiance_map_background.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<h4 id="pbr-and-indirect-irradiance-lighting">PBR and indirect irradiance lighting</h4>
<p>The irradiance map represents the diffuse part of the reflectance integral as accumulated from all surrounding indirect light. Seeing as the light doesn&rsquo;t come from direct light sources, but from the surrounding environment, we treat both the diffuse and specular indirect lighting as the ambient lighting, replacing our previously set constant term.</p>
<p>First, be sure to add the pre-calculated irradiance map as a cube sampler:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">uniform</span> <span class="n">samplerCube</span> <span class="n">irradianceMap</span><span class="p">;</span></span></span></code></pre></div><p>Given the irradiance map that holds all of the scene&rsquo;s indirect diffuse light, retrieving the irradiance influencing the fragment is as simple as a single texture sample given the surface normal:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="c1">// vec3 ambient = vec3(0.03);
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="c1"></span><span class="n">vec3</span> <span class="n">ambient</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">irradianceMap</span><span class="p">,</span> <span class="n">N</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span></span></span></code></pre></div><p>However, as the indirect lighting contains both a diffuse and specular part (as we&rsquo;ve seen from the split version of the reflectance equation) we need to weigh the diffuse part accordingly. Similar to what we did in the previous chapter, we use the Fresnel equation to determine the surface&rsquo;s indirect reflectance ratio from which we derive the refractive (or diffuse) ratio:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">vec3</span> <span class="n">kS</span> <span class="o">=</span> <span class="n">fresnelSchlick</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">V</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">),</span> <span class="n">F0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">vec3</span> <span class="n">kD</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">kS</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">vec3</span> <span class="n">irradiance</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">irradianceMap</span><span class="p">,</span> <span class="n">N</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="n">vec3</span> <span class="n">diffuse</span>    <span class="o">=</span> <span class="n">irradiance</span> <span class="o">*</span> <span class="n">albedo</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="n">vec3</span> <span class="n">ambient</span>    <span class="o">=</span> <span class="p">(</span><span class="n">kD</span> <span class="o">*</span> <span class="n">diffuse</span><span class="p">)</span> <span class="o">*</span> <span class="n">ao</span><span class="p">;</span> 
</span></span></code></pre></div><p>As the ambient light comes from all directions within the hemisphere oriented around the normal N, there&rsquo;s no single halfway vector to determine the Fresnel response. To still simulate Fresnel, we calculate the Fresnel from the angle between the normal and view vector. However, earlier we used the micro-surface halfway vector, influenced by the roughness of the surface, as input to the Fresnel equation. As we currently don&rsquo;t take roughness into account, the surface&rsquo;s reflective ratio will always end up relatively high. Indirect light follows the same properties of direct light so we expect rougher surfaces to reflect less strongly on the surface edges. Because of this, the indirect Fresnel reflection strength looks off on rough non-metal surfaces (slightly exaggerated for demonstration purposes):</p>
<p><a href="#R-image-b27a1a7fd94383bd7d8410e36cedd5b8" class="lightbox-link"><img src="./assets/lighting_fresnel_no_roughness.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b27a1a7fd94383bd7d8410e36cedd5b8"><img src="./assets/lighting_fresnel_no_roughness.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>We can alleviate the issue by injecting a roughness term in the Fresnel-Schlick equation as described by <a href="https://seblagarde.wordpress.com/2011/08/17/hello-world/" target="_blank">Sébastien Lagarde</a>:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">vec3</span> <span class="nf">fresnelSchlickRoughness</span><span class="p">(</span><span class="kt">float</span> <span class="n">cosTheta</span><span class="p">,</span> <span class="n">vec3</span> <span class="n">F0</span><span class="p">,</span> <span class="kt">float</span> <span class="n">roughness</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="k">return</span> <span class="n">F0</span> <span class="o">+</span> <span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">vec3</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">roughness</span><span class="p">),</span> <span class="n">F0</span><span class="p">)</span> <span class="o">-</span> <span class="n">F0</span><span class="p">)</span> <span class="o">*</span> <span class="n">pow</span><span class="p">(</span><span class="n">clamp</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">cosTheta</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span> <span class="mf">5.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="p">}</span>   
</span></span></code></pre></div><p>By taking account of the surface&rsquo;s roughness when calculating the Fresnel response, the ambient code ends up as:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">vec3</span> <span class="n">kS</span> <span class="o">=</span> <span class="n">fresnelSchlickRoughness</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">V</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">),</span> <span class="n">F0</span><span class="p">,</span> <span class="n">roughness</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">vec3</span> <span class="n">kD</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">kS</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">vec3</span> <span class="n">irradiance</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">irradianceMap</span><span class="p">,</span> <span class="n">N</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="n">vec3</span> <span class="n">diffuse</span>    <span class="o">=</span> <span class="n">irradiance</span> <span class="o">*</span> <span class="n">albedo</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="n">vec3</span> <span class="n">ambient</span>    <span class="o">=</span> <span class="p">(</span><span class="n">kD</span> <span class="o">*</span> <span class="n">diffuse</span><span class="p">)</span> <span class="o">*</span> <span class="n">ao</span><span class="p">;</span> 
</span></span></code></pre></div><p>As you can see, the actual image based lighting computation is quite simple and only requires a single cubemap texture lookup; most of the work is in pre-computing or convoluting the irradiance map.</p>
<p>If we take the initial scene from the PBR <a href="https://learnopengl.com/PBR/Lighting" target="_blank">lighting</a> chapter, where each sphere has a vertically increasing metallic and a horizontally increasing roughness value, and add the diffuse image based lighting it&rsquo;ll look a bit like this:</p>
<p><a href="#R-image-59344e94aac26cd62be23fba43258b00" class="lightbox-link"><img src="./assets/ibl_irradiance_result.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-59344e94aac26cd62be23fba43258b00"><img src="./assets/ibl_irradiance_result.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>It still looks a bit weird as the more metallic spheres <strong>require</strong> some form of reflection to properly start looking like metallic surfaces (as metallic surfaces don&rsquo;t reflect diffuse light) which at the moment are only (barely) coming from the point light sources. Nevertheless, you can already tell the spheres do feel more <em>in place</em> within the environment (especially if you switch between environment maps) as the surface response reacts accordingly to the environment&rsquo;s ambient lighting.</p>
<p>You can find the complete source code of the discussed topics <a href="https://learnopengl.com/code_viewer_gh.php?code=src/6.pbr/2.1.2.ibl_irradiance/ibl_irradiance.cpp" target="_blank">here</a>. In the <a href="https://learnopengl.com/PBR/IBL/Specular-IBL" target="_blank">next</a> chapter we&rsquo;ll add the indirect specular part of the reflectance integral at which point we&rsquo;re really going to see the power of PBR.</p>
<h4 id="further-reading-3">Further reading</h4>
<ul>
<li><a href="http://www.codinglabs.net/article_physically_based_rendering.aspx" target="_blank">Coding Labs: Physically based rendering</a>: an introduction to PBR and how and why to generate an irradiance map.</li>
<li><a href="http://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/mathematics-of-shading" target="_blank">The Mathematics of Shading</a>: a brief introduction by ScratchAPixel on several of the mathematics described in this tutorial, specifically on polar coordinates and integrals.</li>
</ul>
<h4 id="specular-ibl">Specular IBL</h4>
<p>In the <a href="https://learnopengl.com/PBR/IBL/Diffuse-irradiance" target="_blank">previous</a> chapter we&rsquo;ve set up PBR in combination with image based lighting by pre-computing an irradiance map as the lighting&rsquo;s indirect diffuse portion. In this chapter we&rsquo;ll focus on the specular part of the reflectance equation:</p>

<span class="math align-center">$$
L_o(p,\omega_o) = \int\limits_{\Omega} 
    	(k_d\frac{c}{\pi} + k_s\frac{DFG}{4(\omega_o \cdot n)(\omega_i \cdot n)})
    	L_i(p,\omega_i) n \cdot \omega_i  d\omega_i
$$</span><p>You&rsquo;ll notice that the Cook-Torrance specular portion (multiplied by 
<span class="math align-center">$k_S$</span>) isn&rsquo;t constant over the integral and is dependent on the incoming light direction, but <strong>also</strong> the incoming view direction. Trying to solve the integral for all incoming light directions including all possible view directions is a combinatorial overload and way too expensive to calculate on a real-time basis. Epic Games proposed a solution where they were able to pre-convolute the specular part for real time purposes, given a few compromises, known as the split sum approximation.</p>
<p>The split sum approximation splits the specular part of the reflectance equation into two separate parts that we can individually convolute and later combine in the PBR shader for specular indirect image based lighting. Similar to how we pre-convoluted the irradiance map, the split sum approximation requires an HDR environment map as its convolution input. To understand the split sum approximation we&rsquo;ll again look at the reflectance equation, but this time focus on the specular part:</p>

<span class="math align-center">$$
L_o(p,\omega_o) = 
		\int\limits_{\Omega} (k_s\frac{DFG}{4(\omega_o \cdot n)(\omega_i \cdot n)}
			L_i(p,\omega_i) n \cdot \omega_i  d\omega_i
			=
		\int\limits_{\Omega} f_r(p, \omega_i, \omega_o) L_i(p,\omega_i) n \cdot \omega_i  d\omega_i
$$</span><p>For the same (performance) reasons as the irradiance convolution, we can&rsquo;t solve the specular part of the integral in real time and expect a reasonable performance. So preferably we&rsquo;d pre-compute this integral to get something like a specular IBL map, sample this map with the fragment&rsquo;s normal, and be done with it. However, this is where it gets a bit tricky. We were able to pre-compute the irradiance map as the integral only depended on 
<span class="math align-center">$w_i$</span> and we could move the constant diffuse albedo terms out of the integral. This time, the integral depends on more than just 
<span class="math align-center">$w_i$</span> as evident from the BRDF:</p>

<span class="math align-center">$$
f_r(p, w_i, w_o) = \frac{DFG}{4(\omega_o \cdot n)(\omega_i \cdot n)}
$$</span><p>The integral also depends on 
<span class="math align-center">$w_o$</span>, and we can&rsquo;t really sample a pre-computed cubemap with two direction vectors. The position 
<span class="math align-center">$p$</span> is irrelevant here as described in the previous chapter. Pre-computing this integral for every possible combination of 
<span class="math align-center">$w_i$</span> and 
<span class="math align-center">$w_o$</span> isn&rsquo;t practical in a real-time setting.</p>
<p>Epic Games&rsquo; split sum approximation solves the issue by splitting the pre-computation into 2 individual parts that we can later combine to get the resulting pre-computed result we&rsquo;re after. The split sum approximation splits the specular integral into two separate integrals:</p>

<span class="math align-center">$$
L_o(p,\omega_o) = 
		\int\limits_{\Omega} L_i(p,\omega_i) d\omega_i
		*
		\int\limits_{\Omega} f_r(p, \omega_i, \omega_o) n \cdot \omega_i d\omega_i
$$</span><p>The first part (when convoluted) is known as the pre-filtered environment map which is (similar to the irradiance map) a pre-computed environment convolution map, but this time taking roughness into account. For increasing roughness levels, the environment map is convoluted with more scattered sample vectors, creating blurrier reflections. For each roughness level we convolute, we store the sequentially blurrier results in the pre-filtered map&rsquo;s mipmap levels. For instance, a pre-filtered environment map storing the pre-convoluted result of 5 different roughness values in its 5 mipmap levels looks as follows:</p>
<p><a href="#R-image-c555007a5fe9b68219a960ef31b50eb0" class="lightbox-link"><img src="./assets/ibl_prefilter_map.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c555007a5fe9b68219a960ef31b50eb0"><img src="./assets/ibl_prefilter_map.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>We generate the sample vectors and their scattering amount using the normal distribution function (NDF) of the Cook-Torrance BRDF that takes as input both a normal and view direction. As we don&rsquo;t know beforehand the view direction when convoluting the environment map, Epic Games makes a further approximation by assuming the view direction (and thus the specular reflection direction) to be equal to the output sample direction 
<span class="math align-center">$w_o$</span>. This translates itself to the following code:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">vec3</span> <span class="n">N</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">w_o</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">vec3</span> <span class="n">R</span> <span class="o">=</span> <span class="n">N</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">vec3</span> <span class="n">V</span> <span class="o">=</span> <span class="n">R</span><span class="p">;</span></span></span></code></pre></div><p>This way, the pre-filtered environment convolution doesn&rsquo;t need to be aware of the view direction. This does mean we don&rsquo;t get nice grazing specular reflections when looking at specular surface reflections from an angle as seen in the image below (courtesy of the <em>Moving Frostbite to PBR</em> article); this is however generally considered an acceptable compromise:</p>
<p><a href="#R-image-5bd96467dc49658ef5b37f271ca74bbb" class="lightbox-link"><img src="./assets/ibl_grazing_angles.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-5bd96467dc49658ef5b37f271ca74bbb"><img src="./assets/ibl_grazing_angles.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>The second part of the split sum equation equals the BRDF part of the specular integral. If we pretend the incoming radiance is completely white for every direction (thus 
<span class="math align-center">$L(p, x) = 1.0$</span>) we can pre-calculate the BRDF&rsquo;s response given an input roughness and an input angle between the normal 
<span class="math align-center">$n$</span> and light direction 
<span class="math align-center">$w_i$</span>, or 
<span class="math align-center">$n \cdot w_i$</span>. Epic Games stores the pre-computed BRDF&rsquo;s response to each normal and light direction combination on varying roughness values in a 2D lookup texture (LUT) known as the BRDF integration map. The 2D lookup texture outputs a scale (red) and a bias value (green) to the surface&rsquo;s Fresnel response giving us the second part of the split specular integral:</p>
<p><a href="#R-image-9abb88e5724cc7b96d9b3474df301ade" class="lightbox-link"><img src="./assets/ibl_brdf_lut.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-9abb88e5724cc7b96d9b3474df301ade"><img src="./assets/ibl_brdf_lut.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>We generate the lookup texture by treating the horizontal texture coordinate (ranged between <code>0.0</code> and <code>1.0</code>) of a plane as the BRDF&rsquo;s input 
<span class="math align-center">$n \cdot w_i$</span>, and its vertical texture coordinate as the input roughness value. With this BRDF integration map and the pre-filtered environment map we can combine both to get the result of the specular integral:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">float</span> <span class="n">lod</span>             <span class="o">=</span> <span class="n">getMipLevelFromRoughness</span><span class="p">(</span><span class="n">roughness</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">vec3</span> <span class="n">prefilteredColor</span> <span class="o">=</span> <span class="n">textureCubeLod</span><span class="p">(</span><span class="n">PrefilteredEnvMap</span><span class="p">,</span> <span class="n">refVec</span><span class="p">,</span> <span class="n">lod</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">vec2</span> <span class="n">envBRDF</span>          <span class="o">=</span> <span class="n">texture2D</span><span class="p">(</span><span class="n">BRDFIntegrationMap</span><span class="p">,</span> <span class="n">vec2</span><span class="p">(</span><span class="n">NdotV</span><span class="p">,</span> <span class="n">roughness</span><span class="p">)).</span><span class="n">xy</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="n">vec3</span> <span class="n">indirectSpecular</span> <span class="o">=</span> <span class="n">prefilteredColor</span> <span class="o">*</span> <span class="p">(</span><span class="n">F</span> <span class="o">*</span> <span class="n">envBRDF</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">envBRDF</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> 
</span></span></code></pre></div><p>This should give you a bit of an overview on how Epic Games&rsquo; split sum approximation roughly approaches the indirect specular part of the reflectance equation. Let&rsquo;s now try and build the pre-convoluted parts ourselves.</p>
<h4 id="pre-filtering-an-hdr-environment-map">Pre-filtering an HDR environment map</h4>
<p>Pre-filtering an environment map is quite similar to how we convoluted an irradiance map. The difference being that we now account for roughness and store sequentially rougher reflections in the pre-filtered map&rsquo;s mip levels.</p>
<p>First, we need to generate a new cubemap to hold the pre-filtered environment map data. To make sure we allocate enough memory for its mip levels we call glGenerateMipmap as an easy way to allocate the required amount of memory:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">prefilterMap</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="n">glGenTextures</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prefilterMap</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_CUBE_MAP</span><span class="p">,</span> <span class="n">prefilterMap</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="n">glTexImage2D</span><span class="p">(</span><span class="n">GL_TEXTURE_CUBE_MAP_POSITIVE_X</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGB16F</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGB</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_CUBE_MAP</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_S</span><span class="p">,</span> <span class="n">GL_CLAMP_TO_EDGE</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_CUBE_MAP</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_T</span><span class="p">,</span> <span class="n">GL_CLAMP_TO_EDGE</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_CUBE_MAP</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_R</span><span class="p">,</span> <span class="n">GL_CLAMP_TO_EDGE</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_CUBE_MAP</span><span class="p">,</span> <span class="n">GL_TEXTURE_MIN_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR_MIPMAP_LINEAR</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_CUBE_MAP</span><span class="p">,</span> <span class="n">GL_TEXTURE_MAG_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="n">glGenerateMipmap</span><span class="p">(</span><span class="n">GL_TEXTURE_CUBE_MAP</span><span class="p">);</span></span></span></code></pre></div><p>Note that because we plan to sample prefilterMap&rsquo;s mipmaps you&rsquo;ll need to make sure its minification filter is set to GL_LINEAR_MIPMAP_LINEAR to enable trilinear filtering. We store the pre-filtered specular reflections in a per-face resolution of 128 by 128 at its base mip level. This is likely to be enough for most reflections, but if you have a large number of smooth materials (think of car reflections) you may want to increase the resolution.</p>
<p>In the previous chapter we convoluted the environment map by generating sample vectors uniformly spread over the hemisphere 
<span class="math align-center">$\Omega$</span> using spherical coordinates. While this works just fine for irradiance, for specular reflections it&rsquo;s less efficient. When it comes to specular reflections, based on the roughness of a surface, the light reflects closely or roughly around a reflection vector 
<span class="math align-center">$r$</span> over a normal 
<span class="math align-center">$n$</span>, but (unless the surface is extremely rough) around the reflection vector nonetheless:</p>
<p><a href="#R-image-c13e7861f0dc5e8148284b6430a28f42" class="lightbox-link"><img src="./assets/ibl_specular_lobe.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c13e7861f0dc5e8148284b6430a28f42"><img src="./assets/ibl_specular_lobe.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>The general shape of possible outgoing light reflections is known as the specular lobe. As roughness increases, the specular lobe&rsquo;s size increases; and the shape of the specular lobe changes on varying incoming light directions. The shape of the specular lobe is thus highly dependent on the material.</p>
<p>When it comes to the microsurface model, we can imagine the specular lobe as the reflection orientation about the microfacet halfway vectors given some incoming light direction. Seeing as most light rays end up in a specular lobe reflected around the microfacet halfway vectors, it makes sense to generate the sample vectors in a similar fashion as most would otherwise be wasted. This process is known as importance sampling.</p>
<h4 id="monte-carlo-integration-and-importance-sampling">Monte Carlo integration and importance sampling</h4>
<p>To fully get a grasp of importance sampling it&rsquo;s relevant we first delve into the mathematical construct known as Monte Carlo integration. Monte Carlo integration revolves mostly around a combination of statistics and probability theory. Monte Carlo helps us in discretely solving the problem of figuring out some statistic or value of a population without having to take <strong>all</strong> of the population into consideration.</p>
<p>For instance, let&rsquo;s say you want to count the average height of all citizens of a country. To get your result, you could measure <strong>every</strong> citizen and average their height which will give you the <strong>exact</strong> answer you&rsquo;re looking for. However, since most countries have a considerable population this isn&rsquo;t a realistic approach: it would take too much effort and time.</p>
<p>A different approach is to pick a much smaller <strong>completely random</strong> (unbiased) subset of this population, measure their height, and average the result. This population could be as small as a 100 people. While not as accurate as the exact answer, you&rsquo;ll get an answer that is relatively close to the ground truth. This is known as the law of large numbers. The idea is that if you measure a smaller set of size 
<span class="math align-center">$N$</span> of truly random samples from the total population, the result will be relatively close to the true answer and gets closer as the number of samples 
<span class="math align-center">$N$</span> increases.</p>
<p>Monte Carlo integration builds on this law of large numbers and takes the same approach in solving an integral. Rather than solving an integral for all possible (theoretically infinite) sample values 
<span class="math align-center">$x$</span>, simply generate 
<span class="math align-center">$N$</span> sample values randomly picked from the total population and average. As 
<span class="math align-center">$N$</span> increases, we&rsquo;re guaranteed to get a result closer to the exact answer of the integral:</p>

<span class="math align-center">$$
O =  \int\limits_{a}^{b} f(x) dx 
      = 
      \frac{1}{N} \sum_{i=0}^{N-1} \frac{f(x)}{pdf(x)}
$$</span><p>To solve the integral, we take 
<span class="math align-center">$N$</span> random samples over the population 
<span class="math align-center">$a$</span> to 
<span class="math align-center">$b$</span>, add them together, and divide by the total number of samples to average them. The 
<span class="math align-center">$pdf$</span> stands for the probability density function that tells us the probability a specific sample occurs over the total sample set. For instance, the pdf of the height of a population would look a bit like this:</p>
<p><a href="#R-image-9470a4bf90e1752964bb09e2b601b4ad" class="lightbox-link"><img src="./assets/ibl_pdf.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-9470a4bf90e1752964bb09e2b601b4ad"><img src="./assets/ibl_pdf.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>From this graph we can see that if we take any random sample of the population, there is a higher chance of picking a sample of someone of height 1.70, compared to the lower probability of the sample being of height 1.50.</p>
<p>When it comes to Monte Carlo integration, some samples may have a higher probability of being generated than others. This is why for any general Monte Carlo estimation we divide or multiply the sampled value by the sample probability according to a pdf. So far, in each of our cases of estimating an integral, the samples we&rsquo;ve generated were uniform, having the exact same chance of being generated. Our estimations so far were unbiased, meaning that given an ever-increasing amount of samples we will eventually converge to the <strong>exact</strong> solution of the integral.</p>
<p>However, some Monte Carlo estimators are biased, meaning that the generated samples aren&rsquo;t completely random, but focused towards a specific value or direction. These biased Monte Carlo estimators have a faster rate of convergence, meaning they can converge to the exact solution at a much faster rate, but due to their biased nature it&rsquo;s likely they won&rsquo;t ever converge to the exact solution. This is generally an acceptable tradeoff, especially in computer graphics, as the exact solution isn&rsquo;t too important as long as the results are visually acceptable. As we&rsquo;ll soon see with importance sampling (which uses a biased estimator), the generated samples are biased towards specific directions in which case we account for this by multiplying or dividing each sample by its corresponding pdf.</p>
<p>Monte Carlo integration is quite prevalent in computer graphics as it&rsquo;s a fairly intuitive way to approximate continuous integrals in a discrete and efficient fashion: take any area/volume to sample over (like the hemisphere 
<span class="math align-center">$\Omega$</span>), generate 
<span class="math align-center">$N$</span> amount of random samples within the area/volume, and sum and weigh every sample contribution to the final result.</p>
<p>Monte Carlo integration is an extensive mathematical topic and I won&rsquo;t delve much further into the specifics, but we&rsquo;ll mention that there are multiple ways of generating the <em>random samples</em>. By default, each sample is completely (pseudo)random as we&rsquo;re used to, but by utilizing certain properties of semi-random sequences we can generate sample vectors that are still random, but have interesting properties. For instance, we can do Monte Carlo integration on something called low-discrepancy sequences which still generate random samples, but each sample is more evenly distributed (image courtesy of James Heald):</p>
<p><a href="#R-image-ebd3ffc9a7cdd468f6d26f09912af2f5" class="lightbox-link"><img src="./assets/ibl_low_discrepancy_sequence.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-ebd3ffc9a7cdd468f6d26f09912af2f5"><img src="./assets/ibl_low_discrepancy_sequence.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>When using a low-discrepancy sequence for generating the Monte Carlo sample vectors, the process is known as Quasi-Monte Carlo integration. Quasi-Monte Carlo methods have a faster rate of convergence which makes them interesting for performance heavy applications.</p>
<p>Given our newly obtained knowledge of Monte Carlo and Quasi-Monte Carlo integration, there is an interesting property we can use for an even faster rate of convergence known as importance sampling. We&rsquo;ve mentioned it before in this chapter, but when it comes to specular reflections of light, the reflected light vectors are constrained in a specular lobe with its size determined by the roughness of the surface. Seeing as any (quasi-)randomly generated sample outside the specular lobe isn&rsquo;t relevant to the specular integral it makes sense to focus the sample generation to within the specular lobe, at the cost of making the Monte Carlo estimator biased.</p>
<p>This is in essence what importance sampling is about: generate sample vectors in some region constrained by the roughness oriented around the microfacet&rsquo;s halfway vector. By combining Quasi-Monte Carlo sampling with a low-discrepancy sequence and biasing the sample vectors using importance sampling, we get a high rate of convergence. Because we reach the solution at a faster rate, we&rsquo;ll need significantly fewer samples to reach an approximation that is sufficient enough.</p>
<h5 id="a-low-discrepancy-sequence">A low-discrepancy sequence</h5>
<p>In this chapter we&rsquo;ll pre-compute the specular portion of the indirect reflectance equation using importance sampling given a random low-discrepancy sequence based on the Quasi-Monte Carlo method. The sequence we&rsquo;ll be using is known as the Hammersley Sequence as carefully described by <a href="http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html" target="_blank">Holger Dammertz</a>. The Hammersley sequence is based on the Van Der Corput sequence which mirrors a decimal binary representation around its decimal point.</p>
<p>Given some neat bit tricks, we can quite efficiently generate the Van Der Corput sequence in a shader program which we&rsquo;ll use to get a Hammersley sequence sample i over <code>N</code> total samples:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">float</span> <span class="nf">RadicalInverse_VdC</span><span class="p">(</span><span class="n">uint</span> <span class="n">bits</span><span class="p">)</span> 
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="n">bits</span> <span class="o">=</span> <span class="p">(</span><span class="n">bits</span> <span class="o">&lt;&lt;</span> <span class="mi">16u</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">bits</span> <span class="o">&gt;&gt;</span> <span class="mi">16u</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="n">bits</span> <span class="o">=</span> <span class="p">((</span><span class="n">bits</span> <span class="o">&amp;</span> <span class="mh">0x55555555u</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1u</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">bits</span> <span class="o">&amp;</span> <span class="mh">0xAAAAAAAAu</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1u</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="n">bits</span> <span class="o">=</span> <span class="p">((</span><span class="n">bits</span> <span class="o">&amp;</span> <span class="mh">0x33333333u</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">2u</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">bits</span> <span class="o">&amp;</span> <span class="mh">0xCCCCCCCCu</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">2u</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="n">bits</span> <span class="o">=</span> <span class="p">((</span><span class="n">bits</span> <span class="o">&amp;</span> <span class="mh">0x0F0F0F0Fu</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">4u</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">bits</span> <span class="o">&amp;</span> <span class="mh">0xF0F0F0F0u</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4u</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="n">bits</span> <span class="o">=</span> <span class="p">((</span><span class="n">bits</span> <span class="o">&amp;</span> <span class="mh">0x00FF00FFu</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8u</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">bits</span> <span class="o">&amp;</span> <span class="mh">0xFF00FF00u</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8u</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="k">return</span> <span class="kt">float</span><span class="p">(</span><span class="n">bits</span><span class="p">)</span> <span class="o">*</span> <span class="mf">2.3283064365386963e-10</span><span class="p">;</span> <span class="c1">// / 0x100000000
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1">// ----------------------------------------------------------------------------
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="c1"></span><span class="n">vec2</span> <span class="nf">Hammersley</span><span class="p">(</span><span class="n">uint</span> <span class="n">i</span><span class="p">,</span> <span class="n">uint</span> <span class="n">N</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="k">return</span> <span class="n">vec2</span><span class="p">(</span><span class="kt">float</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">/</span><span class="kt">float</span><span class="p">(</span><span class="n">N</span><span class="p">),</span> <span class="n">RadicalInverse_VdC</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>The GLSL Hammersley function gives us the low-discrepancy sample i of the total sample set of size N.</p>
<p><note><strong>Hammersley sequence without bit operator support</strong><br><br>Not all OpenGL related drivers support bit operators (WebGL and OpenGL ES 2.0 for instance) in which case you may want to use an alternative version of the Van Der Corput Sequence that doesn&rsquo;t rely on bit operators:<br><a href="#R-image-e6cc352c902f577efe6b104c380b0b27" class="lightbox-link"><img src="./assets/20240214192942.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-e6cc352c902f577efe6b104c380b0b27"><img src="./assets/20240214192942.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a><br>Note that due to GLSL loop restrictions in older hardware, the sequence loops over all possible <code>32</code> bits. This version is less performant, but does work on all hardware if you ever find yourself without bit operators.</note></p>
<h5 id="ggx-importance-sampling">GGX Importance sampling</h5>
<p>Instead of uniformly or randomly (Monte Carlo) generating sample vectors over the integral&rsquo;s hemisphere ΩΩ, we&rsquo;ll generate sample vectors biased towards the general reflection orientation of the microsurface halfway vector based on the surface&rsquo;s roughness. The sampling process will be similar to what we&rsquo;ve seen before: begin a large loop, generate a random (low-discrepancy) sequence value, take the sequence value to generate a sample vector in tangent space, transform to world space, and sample the scene&rsquo;s radiance. What&rsquo;s different is that we now use a low-discrepancy sequence value as input to generate a sample vector:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">const</span> <span class="n">uint</span> <span class="n">SAMPLE_COUNT</span> <span class="o">=</span> <span class="mi">4096u</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="k">for</span><span class="p">(</span><span class="n">uint</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SAMPLE_COUNT</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="n">vec2</span> <span class="n">Xi</span> <span class="o">=</span> <span class="n">Hammersley</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">SAMPLE_COUNT</span><span class="p">);</span>   
</span></span></code></pre></div><p>Additionally, to build a sample vector, we need some way of orienting and biasing the sample vector towards the specular lobe of some surface roughness. We can take the NDF as described in the <a href="https://learnopengl.com/PBR/Theory" target="_blank">theory</a> chapter and combine the GGX NDF in the spherical sample vector process as described by Epic Games:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">vec3</span> <span class="nf">ImportanceSampleGGX</span><span class="p">(</span><span class="n">vec2</span> <span class="n">Xi</span><span class="p">,</span> <span class="n">vec3</span> <span class="n">N</span><span class="p">,</span> <span class="kt">float</span> <span class="n">roughness</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="kt">float</span> <span class="n">a</span> <span class="o">=</span> <span class="n">roughness</span><span class="o">*</span><span class="n">roughness</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">	
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="kt">float</span> <span class="n">phi</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">PI</span> <span class="o">*</span> <span class="n">Xi</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="kt">float</span> <span class="n">cosTheta</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">((</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">Xi</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">a</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">Xi</span><span class="p">.</span><span class="n">y</span><span class="p">));</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="kt">float</span> <span class="n">sinTheta</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">cosTheta</span><span class="o">*</span><span class="n">cosTheta</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">	
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="c1">// from spherical coordinates to cartesian coordinates
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1"></span>    <span class="n">vec3</span> <span class="n">H</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="n">H</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">sinTheta</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="n">H</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">sinTheta</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="n">H</span><span class="p">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">cosTheta</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">	
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="c1">// from tangent-space vector to world-space sample vector
</span></span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="c1"></span>    <span class="n">vec3</span> <span class="n">up</span>        <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">N</span><span class="p">.</span><span class="n">z</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.999</span> <span class="o">?</span> <span class="n">vec3</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">:</span> <span class="n">vec3</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">    <span class="n">vec3</span> <span class="n">tangent</span>   <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">cross</span><span class="p">(</span><span class="n">up</span><span class="p">,</span> <span class="n">N</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">    <span class="n">vec3</span> <span class="n">bitangent</span> <span class="o">=</span> <span class="n">cross</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">tangent</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">	
</span></span><span class="line"><span class="ln">20</span><span class="cl">    <span class="n">vec3</span> <span class="n">sampleVec</span> <span class="o">=</span> <span class="n">tangent</span> <span class="o">*</span> <span class="n">H</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">bitangent</span> <span class="o">*</span> <span class="n">H</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">N</span> <span class="o">*</span> <span class="n">H</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">    <span class="k">return</span> <span class="n">normalize</span><span class="p">(</span><span class="n">sampleVec</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>This gives us a sample vector somewhat oriented around the expected microsurface&rsquo;s halfway vector based on some input roughness and the low-discrepancy sequence value Xi. Note that Epic Games uses the squared roughness for better visual results as based on Disney&rsquo;s original PBR research.</p>
<p>With the low-discrepancy Hammersley sequence and sample generation defined, we can finalize the pre-filter convolution shader:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">out</span> <span class="n">vec4</span> <span class="n">FragColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">in</span> <span class="n">vec3</span> <span class="n">localPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">uniform</span> <span class="n">samplerCube</span> <span class="n">environmentMap</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">uniform</span> <span class="kt">float</span> <span class="n">roughness</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="k">const</span> <span class="kt">float</span> <span class="n">PI</span> <span class="o">=</span> <span class="mf">3.14159265359</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="kt">float</span> <span class="nf">RadicalInverse_VdC</span><span class="p">(</span><span class="n">uint</span> <span class="n">bits</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="n">vec2</span> <span class="nf">Hammersley</span><span class="p">(</span><span class="n">uint</span> <span class="n">i</span><span class="p">,</span> <span class="n">uint</span> <span class="n">N</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="n">vec3</span> <span class="nf">ImportanceSampleGGX</span><span class="p">(</span><span class="n">vec2</span> <span class="n">Xi</span><span class="p">,</span> <span class="n">vec3</span> <span class="n">N</span><span class="p">,</span> <span class="kt">float</span> <span class="n">roughness</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">  
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="p">{</span>		
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="n">vec3</span> <span class="n">N</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">localPos</span><span class="p">);</span>    
</span></span><span class="line"><span class="ln">17</span><span class="cl">    <span class="n">vec3</span> <span class="n">R</span> <span class="o">=</span> <span class="n">N</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">    <span class="n">vec3</span> <span class="n">V</span> <span class="o">=</span> <span class="n">R</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">
</span></span><span class="line"><span class="ln">20</span><span class="cl">    <span class="k">const</span> <span class="n">uint</span> <span class="n">SAMPLE_COUNT</span> <span class="o">=</span> <span class="mi">1024u</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">    <span class="kt">float</span> <span class="n">totalWeight</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>   
</span></span><span class="line"><span class="ln">22</span><span class="cl">    <span class="n">vec3</span> <span class="n">prefilteredColor</span> <span class="o">=</span> <span class="n">vec3</span><span class="p">(</span><span class="mf">0.0</span><span class="p">);</span>     
</span></span><span class="line"><span class="ln">23</span><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="n">uint</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SAMPLE_COUNT</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl">        <span class="n">vec2</span> <span class="n">Xi</span> <span class="o">=</span> <span class="n">Hammersley</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">SAMPLE_COUNT</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl">        <span class="n">vec3</span> <span class="n">H</span>  <span class="o">=</span> <span class="n">ImportanceSampleGGX</span><span class="p">(</span><span class="n">Xi</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">roughness</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl">        <span class="n">vec3</span> <span class="n">L</span>  <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">dot</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">H</span><span class="p">)</span> <span class="o">*</span> <span class="n">H</span> <span class="o">-</span> <span class="n">V</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">28</span><span class="cl">
</span></span><span class="line"><span class="ln">29</span><span class="cl">        <span class="kt">float</span> <span class="n">NdotL</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">L</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">30</span><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">NdotL</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">31</span><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="ln">32</span><span class="cl">            <span class="n">prefilteredColor</span> <span class="o">+=</span> <span class="n">texture</span><span class="p">(</span><span class="n">environmentMap</span><span class="p">,</span> <span class="n">L</span><span class="p">).</span><span class="n">rgb</span> <span class="o">*</span> <span class="n">NdotL</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">33</span><span class="cl">            <span class="n">totalWeight</span>      <span class="o">+=</span> <span class="n">NdotL</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">34</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln">35</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">36</span><span class="cl">    <span class="n">prefilteredColor</span> <span class="o">=</span> <span class="n">prefilteredColor</span> <span class="o">/</span> <span class="n">totalWeight</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">37</span><span class="cl">
</span></span><span class="line"><span class="ln">38</span><span class="cl">    <span class="n">FragColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">prefilteredColor</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">39</span><span class="cl"><span class="p">}</span>  
</span></span><span class="line"><span class="ln">40</span><span class="cl">  
</span></span></code></pre></div><p>We pre-filter the environment, based on some input roughness that varies over each mipmap level of the pre-filter cubemap (from <code>0.0</code> to <code>1.0</code>), and store the result in prefilteredColor. The resulting prefilteredColor is divided by the total sample weight, where samples with less influence on the final result (for small NdotL) contribute less to the final weight.</p>
<h5 id="capturing-pre-filter-mipmap-levels">Capturing pre-filter mipmap levels</h5>
<p>What&rsquo;s left to do is let OpenGL pre-filter the environment map with different roughness values over multiple mipmap levels. This is actually fairly easy to do with the original setup of the <a href="https://learnopengl.com/PBR/IBL/Diffuse-irradiance" target="_blank">irradiance</a> chapter:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">prefilterShader</span><span class="p">.</span><span class="n">use</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="n">prefilterShader</span><span class="p">.</span><span class="n">setInt</span><span class="p">(</span><span class="s">&#34;environmentMap&#34;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">prefilterShader</span><span class="p">.</span><span class="n">setMat4</span><span class="p">(</span><span class="s">&#34;projection&#34;</span><span class="p">,</span> <span class="n">captureProjection</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">glActiveTexture</span><span class="p">(</span><span class="n">GL_TEXTURE0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_CUBE_MAP</span><span class="p">,</span> <span class="n">envCubemap</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">captureFBO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">maxMipLevels</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mip</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">mip</span> <span class="o">&lt;</span> <span class="n">maxMipLevels</span><span class="p">;</span> <span class="o">++</span><span class="n">mip</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="c1">// reisze framebuffer according to mip-level size.
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mipWidth</span>  <span class="o">=</span> <span class="mi">128</span> <span class="o">*</span> <span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">mip</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mipHeight</span> <span class="o">=</span> <span class="mi">128</span> <span class="o">*</span> <span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">mip</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="n">glBindRenderbuffer</span><span class="p">(</span><span class="n">GL_RENDERBUFFER</span><span class="p">,</span> <span class="n">captureRBO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="n">glRenderbufferStorage</span><span class="p">(</span><span class="n">GL_RENDERBUFFER</span><span class="p">,</span> <span class="n">GL_DEPTH_COMPONENT24</span><span class="p">,</span> <span class="n">mipWidth</span><span class="p">,</span> <span class="n">mipHeight</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="n">glViewport</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mipWidth</span><span class="p">,</span> <span class="n">mipHeight</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">
</span></span><span class="line"><span class="ln">18</span><span class="cl">    <span class="kt">float</span> <span class="n">roughness</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">mip</span> <span class="o">/</span> <span class="p">(</span><span class="kt">float</span><span class="p">)(</span><span class="n">maxMipLevels</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">    <span class="n">prefilterShader</span><span class="p">.</span><span class="n">setFloat</span><span class="p">(</span><span class="s">&#34;roughness&#34;</span><span class="p">,</span> <span class="n">roughness</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">        <span class="n">prefilterShader</span><span class="p">.</span><span class="n">setMat4</span><span class="p">(</span><span class="s">&#34;view&#34;</span><span class="p">,</span> <span class="n">captureViews</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">        <span class="n">glFramebufferTexture2D</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">GL_COLOR_ATTACHMENT0</span><span class="p">,</span> 
</span></span><span class="line"><span class="ln">24</span><span class="cl">                               <span class="n">GL_TEXTURE_CUBE_MAP_POSITIVE_X</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">prefilterMap</span><span class="p">,</span> <span class="n">mip</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl">
</span></span><span class="line"><span class="ln">26</span><span class="cl">        <span class="n">glClear</span><span class="p">(</span><span class="n">GL_COLOR_BUFFER_BIT</span> <span class="o">|</span> <span class="n">GL_DEPTH_BUFFER_BIT</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl">        <span class="n">renderCube</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">28</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">29</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">30</span><span class="cl"><span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>   
</span></span></code></pre></div><p>The process is similar to the irradiance map convolution, but this time we scale the framebuffer&rsquo;s dimensions to the appropriate mipmap scale, each mip level reducing the dimensions by a scale of 2. Additionally, we specify the mip level we&rsquo;re rendering into in glFramebufferTexture2D&rsquo;s last parameter and pass the roughness we&rsquo;re pre-filtering for to the pre-filter shader.</p>
<p>This should give us a properly pre-filtered environment map that returns blurrier reflections the higher mip level we access it from. If we use the pre-filtered environment cubemap in the skybox shader and forcefully sample somewhat above its first mip level like so:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">vec3</span> <span class="n">envColor</span> <span class="o">=</span> <span class="n">textureLod</span><span class="p">(</span><span class="n">environmentMap</span><span class="p">,</span> <span class="n">WorldPos</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span> 
</span></span></code></pre></div><p>We get a result that indeed looks like a blurrier version of the original environment:</p>
<p><a href="#R-image-fdaa700882ada95c977ff74c389777e6" class="lightbox-link"><img src="./assets/ibl_prefilter_map_sample.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-fdaa700882ada95c977ff74c389777e6"><img src="./assets/ibl_prefilter_map_sample.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>If it looks somewhat similar you&rsquo;ve successfully pre-filtered the HDR environment map. Play around with different mipmap levels to see the pre-filter map gradually change from sharp to blurry reflections on increasing mip levels.</p>
<h4 id="pre-filter-convolution-artifacts">Pre-filter convolution artifacts</h4>
<p>While the current pre-filter map works fine for most purposes, sooner or later you&rsquo;ll come across several render artifacts that are directly related to the pre-filter convolution. I&rsquo;ll list the most common here including how to fix them.</p>
<h5 id="cubemap-seams-at-high-roughness">Cubemap seams at high roughness</h5>
<p>Sampling the pre-filter map on surfaces with a rough surface means sampling the pre-filter map on some of its lower mip levels. When sampling cubemaps, OpenGL by default doesn&rsquo;t linearly interpolate <strong>across</strong> cubemap faces. Because the lower mip levels are both of a lower resolution and the pre-filter map is convoluted with a much larger sample lobe, the lack of <em>between-cube-face filtering</em> becomes quite apparent:</p>
<p><a href="#R-image-997b64b1fdcebc1053334a66ec9e0161" class="lightbox-link"><img src="./assets/ibl_prefilter_seams.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-997b64b1fdcebc1053334a66ec9e0161"><img src="./assets/ibl_prefilter_seams.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Luckily for us, OpenGL gives us the option to properly filter across cubemap faces by enabling GL_TEXTURE_CUBE_MAP_SEAMLESS:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glEnable</span><span class="p">(</span><span class="n">GL_TEXTURE_CUBE_MAP_SEAMLESS</span><span class="p">);</span>  
</span></span></code></pre></div><p>Simply enable this property somewhere at the start of your application and the seams will be gone.</p>
<h5 id="bright-dots-in-the-pre-filter-convolution">Bright dots in the pre-filter convolution</h5>
<p>Due to high frequency details and wildly varying light intensities in specular reflections, convoluting the specular reflections requires a large number of samples to properly account for the wildly varying nature of HDR environmental reflections. We already take a very large number of samples, but on some environments it may still not be enough at some of the rougher mip levels in which case you&rsquo;ll start seeing dotted patterns emerge around bright areas:</p>
<p><a href="#R-image-703a8b4ebddf30c58ad7b56559791aac" class="lightbox-link"><img src="./assets/ibl_prefilter_dots.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-703a8b4ebddf30c58ad7b56559791aac"><img src="./assets/ibl_prefilter_dots.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>One option is to further increase the sample count, but this won&rsquo;t be enough for all environments. As described by <a href="https://chetanjags.wordpress.com/2015/08/26/image-based-lighting/" target="_blank">Chetan Jags</a> we can reduce this artifact by (during the pre-filter convolution) not directly sampling the environment map, but sampling a mip level of the environment map based on the integral&rsquo;s PDF and the roughness:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">float</span> <span class="n">D</span>   <span class="o">=</span> <span class="n">DistributionGGX</span><span class="p">(</span><span class="n">NdotH</span><span class="p">,</span> <span class="n">roughness</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="kt">float</span> <span class="n">pdf</span> <span class="o">=</span> <span class="p">(</span><span class="n">D</span> <span class="o">*</span> <span class="n">NdotH</span> <span class="o">/</span> <span class="p">(</span><span class="mf">4.0</span> <span class="o">*</span> <span class="n">HdotV</span><span class="p">))</span> <span class="o">+</span> <span class="mf">0.0001</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">3</span><span class="cl">
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="kt">float</span> <span class="n">resolution</span> <span class="o">=</span> <span class="mf">512.0</span><span class="p">;</span> <span class="c1">// resolution of source cubemap (per face)
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="c1"></span><span class="kt">float</span> <span class="n">saTexel</span>  <span class="o">=</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="n">PI</span> <span class="o">/</span> <span class="p">(</span><span class="mf">6.0</span> <span class="o">*</span> <span class="n">resolution</span> <span class="o">*</span> <span class="n">resolution</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="kt">float</span> <span class="n">saSample</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="kt">float</span><span class="p">(</span><span class="n">SAMPLE_COUNT</span><span class="p">)</span> <span class="o">*</span> <span class="n">pdf</span> <span class="o">+</span> <span class="mf">0.0001</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl">
</span></span><span class="line"><span class="ln">8</span><span class="cl"><span class="kt">float</span> <span class="n">mipLevel</span> <span class="o">=</span> <span class="n">roughness</span> <span class="o">==</span> <span class="mf">0.0</span> <span class="o">?</span> <span class="mf">0.0</span> <span class="o">:</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">log2</span><span class="p">(</span><span class="n">saSample</span> <span class="o">/</span> <span class="n">saTexel</span><span class="p">);</span> 
</span></span></code></pre></div><p>Don&rsquo;t forget to enable trilinear filtering on the environment map you want to sample its mip levels from:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_CUBE_MAP</span><span class="p">,</span> <span class="n">envCubemap</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_CUBE_MAP</span><span class="p">,</span> <span class="n">GL_TEXTURE_MIN_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR_MIPMAP_LINEAR</span><span class="p">);</span> 
</span></span></code></pre></div><p>And let OpenGL generate the mipmaps <strong>after</strong> the cubemap&rsquo;s base texture is set:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="c1">// convert HDR equirectangular environment map to cubemap equivalent
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="c1"></span><span class="p">[...]</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="c1">// then generate mipmaps
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="c1"></span><span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_CUBE_MAP</span><span class="p">,</span> <span class="n">envCubemap</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="n">glGenerateMipmap</span><span class="p">(</span><span class="n">GL_TEXTURE_CUBE_MAP</span><span class="p">);</span></span></span></code></pre></div><p>This works surprisingly well and should remove most, if not all, dots in your pre-filter map on rougher surfaces.</p>
<h4 id="pre-computing-the-brdf">Pre-computing the BRDF</h4>
<p>With the pre-filtered environment up and running, we can focus on the second part of the split-sum approximation: the BRDF. Let&rsquo;s briefly review the specular split sum approximation again:</p>

<span class="math align-center">$$
L_o(p,\omega_o) = 
		\int\limits_{\Omega} L_i(p,\omega_i) d\omega_i
		*
		\int\limits_{\Omega} f_r(p, \omega_i, \omega_o) n \cdot \omega_i d\omega_i
$$</span><p>We&rsquo;ve pre-computed the left part of the split sum approximation in the pre-filter map over different roughness levels. The right side requires us to convolute the BRDF equation over the angle 
<span class="math align-center">$n \cdot \omega_o$</span>, the surface roughness, and Fresnel&rsquo;s 
<span class="math align-center">$F_0$</span>. This is similar to integrating the specular BRDF with a solid-white environment or a constant radiance 
<span class="math align-center">$L_i$</span> of <code>1.0</code>. Convoluting the BRDF over 3 variables is a bit much, but we can try to move 
<span class="math align-center">$F_0$</span> out of the specular BRDF equation:</p>

<span class="math align-center">$$
\int\limits_{\Omega} f_r(p, \omega_i, \omega_o) n \cdot \omega_i d\omega_i = \int\limits_{\Omega} f_r(p, \omega_i, \omega_o) \frac{F(\omega_o, h)}{F(\omega_o, h)} n \cdot \omega_i d\omega_i
$$</span><p>With 
<span class="math align-center">$F$</span> being the Fresnel equation. Moving the Fresnel denominator to the BRDF gives us the following equivalent equation:</p>

<span class="math align-center">$$
\int\limits_{\Omega} \frac{f_r(p, \omega_i, \omega_o)}{F(\omega_o, h)} F(\omega_o, h)  n \cdot \omega_i d\omega_i
$$</span><p>Substituting the right-most 
<span class="math align-center">$F$</span> with the Fresnel-Schlick approximation gives us:</p>

<span class="math align-center">$$
\int\limits_{\Omega} \frac{f_r(p, \omega_i, \omega_o)}{F(\omega_o, h)} (F_0 + (1 - F_0){(1 - \omega_o \cdot h)}^5)  n \cdot \omega_i d\omega_i
$$</span><p>Let&rsquo;s replace 
<span class="math align-center">${(1 - \omega_o \cdot h)}^5$</span> by 
<span class="math align-center">$\alpha$</span> to make it easier to solve for 
<span class="math align-center">$F_0$</span>:</p>

<span class="math align-center">$$
\int\limits_{\Omega} \frac{f_r(p, \omega_i, \omega_o)}{F(\omega_o, h)} (F_0 + (1 - F_0)\alpha)  n \cdot \omega_i d\omega_i
$$</span>
<span class="math align-center">$$
\int\limits_{\Omega} \frac{f_r(p, \omega_i, \omega_o)}{F(\omega_o, h)} (F_0 + 1*\alpha - F_0*\alpha)  n \cdot \omega_i d\omega_i
$$</span>
<span class="math align-center">$$
\int\limits_{\Omega} \frac{f_r(p, \omega_i, \omega_o)}{F(\omega_o, h)} (F_0 * (1 - \alpha) + \alpha)  n \cdot \omega_i d\omega_i
$$</span><p>Then we split the Fresnel function 
<span class="math align-center">$F$</span> over two integrals:</p>

<span class="math align-center">$$
\int\limits_{\Omega} \frac{f_r(p, \omega_i, \omega_o)}{F(\omega_o, h)} (F_0 * (1 - \alpha))  n \cdot \omega_i d\omega_i
              +
	\int\limits_{\Omega} \frac{f_r(p, \omega_i, \omega_o)}{F(\omega_o, h)} (\alpha)  n \cdot \omega_i d\omega_i
$$</span><p>This way, 
<span class="math align-center">$F_0$</span> is constant over the integral and we can take 
<span class="math align-center">$F_0$</span> out of the integral. Next, we substitute 
<span class="math align-center">$\alpha$</span> back to its original form giving us the final split sum BRDF equation:</p>

<span class="math align-center">$$
F_0 \int\limits_{\Omega} f_r(p, \omega_i, \omega_o)(1 - {(1 - \omega_o \cdot h)}^5)  n \cdot \omega_i d\omega_i
              +
	\int\limits_{\Omega} f_r(p, \omega_i, \omega_o) {(1 - \omega_o \cdot h)}^5  n \cdot \omega_i d\omega_i
$$</span><p>The two resulting integrals represent a scale and a bias to 
<span class="math align-center">$F_0$</span> respectively. Note that as 
<span class="math align-center">$f_r(p, \omega_i, \omega_o)$</span> already contains a term for 
<span class="math align-center">$F$</span> they both cancel out, removing 
<span class="math align-center">$F$</span> from 
<span class="math align-center">$f_r$</span>.</p>
<p>In a similar fashion to the earlier convoluted environment maps, we can convolute the BRDF equations on their inputs: the angle between 
<span class="math align-center">$n$</span> and 
<span class="math align-center">$\omega_o$</span>, and the roughness. We store the convoluted results in a 2D lookup texture (LUT) known as a BRDF integration map that we later use in our PBR lighting shader to get the final convoluted indirect specular result.</p>
<p>The BRDF convolution shader operates on a 2D plane, using its 2D texture coordinates directly as inputs to the BRDF convolution (NdotV and roughness). The convolution code is largely similar to the pre-filter convolution, except that it now processes the sample vector according to our BRDF&rsquo;s geometry function and Fresnel-Schlick&rsquo;s approximation:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">vec2</span> <span class="nf">IntegrateBRDF</span><span class="p">(</span><span class="kt">float</span> <span class="n">NdotV</span><span class="p">,</span> <span class="kt">float</span> <span class="n">roughness</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="n">vec3</span> <span class="n">V</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="n">V</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">NdotV</span><span class="o">*</span><span class="n">NdotV</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="n">V</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="n">V</span><span class="p">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">NdotV</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="kt">float</span> <span class="n">A</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="kt">float</span> <span class="n">B</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="n">vec3</span> <span class="n">N</span> <span class="o">=</span> <span class="n">vec3</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="k">const</span> <span class="n">uint</span> <span class="n">SAMPLE_COUNT</span> <span class="o">=</span> <span class="mi">1024u</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="n">uint</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SAMPLE_COUNT</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">        <span class="n">vec2</span> <span class="n">Xi</span> <span class="o">=</span> <span class="n">Hammersley</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">SAMPLE_COUNT</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">        <span class="n">vec3</span> <span class="n">H</span>  <span class="o">=</span> <span class="n">ImportanceSampleGGX</span><span class="p">(</span><span class="n">Xi</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">roughness</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">        <span class="n">vec3</span> <span class="n">L</span>  <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">dot</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">H</span><span class="p">)</span> <span class="o">*</span> <span class="n">H</span> <span class="o">-</span> <span class="n">V</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">
</span></span><span class="line"><span class="ln">20</span><span class="cl">        <span class="kt">float</span> <span class="n">NdotL</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">L</span><span class="p">.</span><span class="n">z</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">        <span class="kt">float</span> <span class="n">NdotH</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">H</span><span class="p">.</span><span class="n">z</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">        <span class="kt">float</span> <span class="n">VdotH</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">H</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">
</span></span><span class="line"><span class="ln">24</span><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">NdotL</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl">            <span class="kt">float</span> <span class="n">G</span> <span class="o">=</span> <span class="n">GeometrySmith</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">roughness</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl">            <span class="kt">float</span> <span class="n">G_Vis</span> <span class="o">=</span> <span class="p">(</span><span class="n">G</span> <span class="o">*</span> <span class="n">VdotH</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">NdotH</span> <span class="o">*</span> <span class="n">NdotV</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">28</span><span class="cl">            <span class="kt">float</span> <span class="n">Fc</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">VdotH</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">29</span><span class="cl">
</span></span><span class="line"><span class="ln">30</span><span class="cl">            <span class="n">A</span> <span class="o">+=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">Fc</span><span class="p">)</span> <span class="o">*</span> <span class="n">G_Vis</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">31</span><span class="cl">            <span class="n">B</span> <span class="o">+=</span> <span class="n">Fc</span> <span class="o">*</span> <span class="n">G_Vis</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">32</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln">33</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">34</span><span class="cl">    <span class="n">A</span> <span class="o">/=</span> <span class="kt">float</span><span class="p">(</span><span class="n">SAMPLE_COUNT</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">35</span><span class="cl">    <span class="n">B</span> <span class="o">/=</span> <span class="kt">float</span><span class="p">(</span><span class="n">SAMPLE_COUNT</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">36</span><span class="cl">    <span class="k">return</span> <span class="n">vec2</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">37</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">38</span><span class="cl"><span class="c1">// ----------------------------------------------------------------------------
</span></span></span><span class="line"><span class="ln">39</span><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> 
</span></span><span class="line"><span class="ln">40</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">41</span><span class="cl">    <span class="n">vec2</span> <span class="n">integratedBRDF</span> <span class="o">=</span> <span class="n">IntegrateBRDF</span><span class="p">(</span><span class="n">TexCoords</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">TexCoords</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">42</span><span class="cl">    <span class="n">FragColor</span> <span class="o">=</span> <span class="n">integratedBRDF</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">43</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>As you can see, the BRDF convolution is a direct translation from the mathematics to code. We take both the angle 
<span class="math align-center">$\theta$</span> and the roughness as input, generate a sample vector with importance sampling, process it over the geometry and the derived Fresnel term of the BRDF, and output both a scale and a bias to 
<span class="math align-center">$F_0$</span> for each sample, averaging them in the end.</p>
<p>You may recall from the <a href="https://learnopengl.com/PBR/Theory" target="_blank">theory</a> chapter that the geometry term of the BRDF is slightly different when used alongside IBL as its 
<span class="math align-center">$k$</span> variable has a slightly different interpretation:</p>

<span class="math align-center">$$
k_{direct} = \frac{(\alpha + 1)^2}{8}
$$</span>
<span class="math align-center">$$
k_{IBL} = \frac{\alpha^2}{2}
$$</span><p>Since the BRDF convolution is part of the specular IBL integral we&rsquo;ll use 
<span class="math align-center">$k_{IBL}$</span> for the Schlick-GGX geometry function:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">float</span> <span class="nf">GeometrySchlickGGX</span><span class="p">(</span><span class="kt">float</span> <span class="n">NdotV</span><span class="p">,</span> <span class="kt">float</span> <span class="n">roughness</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="kt">float</span> <span class="n">a</span> <span class="o">=</span> <span class="n">roughness</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="kt">float</span> <span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">a</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="kt">float</span> <span class="n">nom</span>   <span class="o">=</span> <span class="n">NdotV</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="kt">float</span> <span class="n">denom</span> <span class="o">=</span> <span class="n">NdotV</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="n">k</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="k">return</span> <span class="n">nom</span> <span class="o">/</span> <span class="n">denom</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="c1">// ----------------------------------------------------------------------------
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="c1"></span><span class="kt">float</span> <span class="nf">GeometrySmith</span><span class="p">(</span><span class="n">vec3</span> <span class="n">N</span><span class="p">,</span> <span class="n">vec3</span> <span class="n">V</span><span class="p">,</span> <span class="n">vec3</span> <span class="n">L</span><span class="p">,</span> <span class="kt">float</span> <span class="n">roughness</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="kt">float</span> <span class="n">NdotV</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">V</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="kt">float</span> <span class="n">NdotL</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">L</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="kt">float</span> <span class="n">ggx2</span> <span class="o">=</span> <span class="n">GeometrySchlickGGX</span><span class="p">(</span><span class="n">NdotV</span><span class="p">,</span> <span class="n">roughness</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">    <span class="kt">float</span> <span class="n">ggx1</span> <span class="o">=</span> <span class="n">GeometrySchlickGGX</span><span class="p">(</span><span class="n">NdotL</span><span class="p">,</span> <span class="n">roughness</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">
</span></span><span class="line"><span class="ln">19</span><span class="cl">    <span class="k">return</span> <span class="n">ggx1</span> <span class="o">*</span> <span class="n">ggx2</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>Note that while 
<span class="math align-center">$k$</span>  takes a as its parameter we didn&rsquo;t square roughness as a as we originally did for other interpretations of a; likely as a is squared here already. I&rsquo;m not sure whether this is an inconsistency on Epic Games&rsquo; part or the original Disney paper, but directly translating roughness to a gives the BRDF integration map that is identical to Epic Games&rsquo; version.</p>
<p>Finally, to store the BRDF convolution result we&rsquo;ll generate a 2D texture of a 512 by 512 resolution:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">brdfLUTTexture</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="n">glGenTextures</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">brdfLUTTexture</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1">// pre-allocate enough memory for the LUT texture.
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="c1"></span><span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">brdfLUTTexture</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">glTexImage2D</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RG16F</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RG</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_S</span><span class="p">,</span> <span class="n">GL_CLAMP_TO_EDGE</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_T</span><span class="p">,</span> <span class="n">GL_CLAMP_TO_EDGE</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MIN_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MAG_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR</span><span class="p">);</span> 
</span></span></code></pre></div><p>Note that we use a 16-bit precision floating format as recommended by Epic Games. Be sure to set the wrapping mode to GL_CLAMP_TO_EDGE to prevent edge sampling artifacts.</p>
<p>Then, we re-use the same framebuffer object and run this shader over an NDC screen-space quad:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">captureFBO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="n">glBindRenderbuffer</span><span class="p">(</span><span class="n">GL_RENDERBUFFER</span><span class="p">,</span> <span class="n">captureRBO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">glRenderbufferStorage</span><span class="p">(</span><span class="n">GL_RENDERBUFFER</span><span class="p">,</span> <span class="n">GL_DEPTH_COMPONENT24</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="mi">512</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">glFramebufferTexture2D</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">GL_COLOR_ATTACHMENT0</span><span class="p">,</span> <span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">brdfLUTTexture</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">glViewport</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="mi">512</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="n">brdfShader</span><span class="p">.</span><span class="n">use</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="n">glClear</span><span class="p">(</span><span class="n">GL_COLOR_BUFFER_BIT</span> <span class="o">|</span> <span class="n">GL_DEPTH_BUFFER_BIT</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="n">RenderQuad</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  
</span></span></code></pre></div><p>The convoluted BRDF part of the split sum integral should give you the following result:</p>
<p><a href="#R-image-f527cec73f890f538debb584eb8a2668" class="lightbox-link"><img src="./assets/ibl_brdf_lut.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f527cec73f890f538debb584eb8a2668"><img src="./assets/ibl_brdf_lut.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<h4 id="completing-the-ibl-reflectance">Completing the IBL reflectance</h4>
<p>To get the indirect specular part of the reflectance equation up and running we need to stitch both parts of the split sum approximation together. Let&rsquo;s start by adding the pre-computed lighting data to the top of our PBR shader:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">uniform</span> <span class="n">samplerCube</span> <span class="n">prefilterMap</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">uniform</span> <span class="n">sampler2D</span>   <span class="n">brdfLUT</span><span class="p">;</span>  
</span></span></code></pre></div><p>First, we get the indirect specular reflections of the surface by sampling the pre-filtered environment map using the reflection vector. Note that we sample the appropriate mip level based on the surface roughness, giving rougher surfaces <em>blurrier</em> specular reflections:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="p">[...]</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="n">vec3</span> <span class="n">R</span> <span class="o">=</span> <span class="n">reflect</span><span class="p">(</span><span class="o">-</span><span class="n">V</span><span class="p">,</span> <span class="n">N</span><span class="p">);</span>   
</span></span><span class="line"><span class="ln">5</span><span class="cl">
</span></span><span class="line"><span class="ln">6</span><span class="cl">    <span class="k">const</span> <span class="kt">float</span> <span class="n">MAX_REFLECTION_LOD</span> <span class="o">=</span> <span class="mf">4.0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl">    <span class="n">vec3</span> <span class="n">prefilteredColor</span> <span class="o">=</span> <span class="n">textureLod</span><span class="p">(</span><span class="n">prefilterMap</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span>  <span class="n">roughness</span> <span class="o">*</span> <span class="n">MAX_REFLECTION_LOD</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>    
</span></span><span class="line"><span class="ln">8</span><span class="cl">    <span class="p">[...]</span>
</span></span><span class="line"><span class="ln">9</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>In the pre-filter step we only convoluted the environment map up to a maximum of 5 mip levels (0 to 4), which we denote here as MAX_REFLECTION_LOD to ensure we don&rsquo;t sample a mip level where there&rsquo;s no (relevant) data.</p>
<p>Then we sample from the BRDF lookup texture given the material&rsquo;s roughness and the angle between the normal and view vector:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">vec3</span> <span class="n">F</span>        <span class="o">=</span> <span class="n">FresnelSchlickRoughness</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">V</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">),</span> <span class="n">F0</span><span class="p">,</span> <span class="n">roughness</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">vec2</span> <span class="n">envBRDF</span>  <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">brdfLUT</span><span class="p">,</span> <span class="n">vec2</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">V</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">),</span> <span class="n">roughness</span><span class="p">)).</span><span class="n">rg</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">vec3</span> <span class="n">specular</span> <span class="o">=</span> <span class="n">prefilteredColor</span> <span class="o">*</span> <span class="p">(</span><span class="n">F</span> <span class="o">*</span> <span class="n">envBRDF</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">envBRDF</span><span class="p">.</span><span class="n">y</span><span class="p">);</span></span></span></code></pre></div><p>Given the scale and bias to 
<span class="math align-center">$F_0$</span> (here we&rsquo;re directly using the indirect Fresnel result F) from the BRDF lookup texture, we combine this with the left pre-filter portion of the IBL reflectance equation and re-construct the approximated integral result as specular.</p>
<p>This gives us the indirect specular part of the reflectance equation. Now, combine this with the diffuse IBL part of the reflectance equation from the <a href="https://learnopengl.com/PBR/IBL/Diffuse-irradiance" target="_blank">last</a> chapter and we get the full PBR IBL result:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">vec3</span> <span class="n">F</span> <span class="o">=</span> <span class="n">FresnelSchlickRoughness</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">V</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">),</span> <span class="n">F0</span><span class="p">,</span> <span class="n">roughness</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">vec3</span> <span class="n">kS</span> <span class="o">=</span> <span class="n">F</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">vec3</span> <span class="n">kD</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">kS</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">kD</span> <span class="o">*=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">metallic</span><span class="p">;</span>	  
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="n">vec3</span> <span class="n">irradiance</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">irradianceMap</span><span class="p">,</span> <span class="n">N</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="n">vec3</span> <span class="n">diffuse</span>    <span class="o">=</span> <span class="n">irradiance</span> <span class="o">*</span> <span class="n">albedo</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="k">const</span> <span class="kt">float</span> <span class="n">MAX_REFLECTION_LOD</span> <span class="o">=</span> <span class="mf">4.0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="n">vec3</span> <span class="n">prefilteredColor</span> <span class="o">=</span> <span class="n">textureLod</span><span class="p">(</span><span class="n">prefilterMap</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span>  <span class="n">roughness</span> <span class="o">*</span> <span class="n">MAX_REFLECTION_LOD</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>   
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="n">vec2</span> <span class="n">envBRDF</span>  <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">brdfLUT</span><span class="p">,</span> <span class="n">vec2</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">V</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">),</span> <span class="n">roughness</span><span class="p">)).</span><span class="n">rg</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="n">vec3</span> <span class="n">specular</span> <span class="o">=</span> <span class="n">prefilteredColor</span> <span class="o">*</span> <span class="p">(</span><span class="n">F</span> <span class="o">*</span> <span class="n">envBRDF</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">envBRDF</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">  
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="n">vec3</span> <span class="n">ambient</span> <span class="o">=</span> <span class="p">(</span><span class="n">kD</span> <span class="o">*</span> <span class="n">diffuse</span> <span class="o">+</span> <span class="n">specular</span><span class="p">)</span> <span class="o">*</span> <span class="n">ao</span><span class="p">;</span> 
</span></span></code></pre></div><p>Note that we don&rsquo;t multiply specular by kS as we already have a Fresnel multiplication in there.</p>
<p>Now, running this exact code on the series of spheres that differ by their roughness and metallic properties, we finally get to see their true colors in the final PBR renderer:</p>
<p><a href="#R-image-22399e79c13a856393a0f0f99ebb404e" class="lightbox-link"><img src="./assets/ibl_specular_result.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-22399e79c13a856393a0f0f99ebb404e"><img src="./assets/ibl_specular_result.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>We could even go wild, and use some cool textured <a href="http://freepbr.com/" target="_blank">PBR materials</a>:</p>
<p><a href="#R-image-ddeadffc83b47cdd4c4cd0800999697d" class="lightbox-link"><img src="./assets/ibl_specular_result_textured.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-ddeadffc83b47cdd4c4cd0800999697d"><img src="./assets/ibl_specular_result_textured.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Or load <a href="http://artisaverb.info/PBT.html" target="_blank">this awesome free 3D PBR model</a> by Andrew Maximov:</p>
<p><a href="#R-image-6cb075d11cc3aa30789517d0b5c747cc" class="lightbox-link"><img src="./assets/ibl_specular_result_model.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-6cb075d11cc3aa30789517d0b5c747cc"><img src="./assets/ibl_specular_result_model.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>I&rsquo;m sure we can all agree that our lighting now looks a lot more convincing. What&rsquo;s even better, is that our lighting looks physically correct regardless of which environment map we use. Below you&rsquo;ll see several different pre-computed HDR maps, completely changing the lighting dynamics, but still looking physically correct without changing a single lighting variable!</p>
<p><a href="#R-image-0a0ee0e881866ea17f937962cd633582" class="lightbox-link"><img src="./assets/ibl_specular_result_different_environments.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-0a0ee0e881866ea17f937962cd633582"><img src="./assets/ibl_specular_result_different_environments.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Well, this PBR adventure turned out to be quite a long journey. There are a lot of steps and thus a lot that could go wrong so carefully work your way through the <a href="https://learnopengl.com/code_viewer_gh.php?code=src/6.pbr/2.2.1.ibl_specular/ibl_specular.cpp" target="_blank">sphere scene</a> or <a href="https://learnopengl.com/code_viewer_gh.php?code=src/6.pbr/2.2.2.ibl_specular_textured/ibl_specular_textured.cpp" target="_blank">textured scene</a> code samples (including all shaders) if you&rsquo;re stuck, or check and ask around in the comments.</p>
<h4 id="whats-next">What&rsquo;s next?</h4>
<p>Hopefully, by the end of this tutorial you should have a pretty clear understanding of what PBR is about, and even have an actual PBR renderer up and running. In these tutorials, we&rsquo;ve pre-computed all the relevant PBR image-based lighting data at the start of our application, before the render loop. This was fine for educational purposes, but not too great for any practical use of PBR. First, the pre-computation only really has to be done once, not at every startup. And second, the moment you use multiple environment maps you&rsquo;ll have to pre-compute each and every one of them at every startup which tends to build up.</p>
<p>For this reason you&rsquo;d generally pre-compute an environment map into an irradiance and pre-filter map just once, and then store it on disk (note that the BRDF integration map isn&rsquo;t dependent on an environment map so you only need to calculate or load it once). This does mean you&rsquo;ll need to come up with a custom image format to store HDR cubemaps, including their mip levels. Or, you&rsquo;ll store (and load) it as one of the available formats (like .dds that supports storing mip levels).</p>
<p>Furthermore, we&rsquo;ve described the <strong>total</strong> process in these tutorials, including generating the pre-computed IBL images to help further our understanding of the PBR pipeline. But, you&rsquo;ll be just as fine by using several great tools like <a href="https://github.com/dariomanesku/cmftStudio" target="_blank">cmftStudio</a> or <a href="https://github.com/derkreature/IBLBaker" target="_blank">IBLBaker</a> to generate these pre-computed maps for you.</p>
<p>One point we&rsquo;ve skipped over is pre-computed cubemaps as reflection probes: cubemap interpolation and parallax correction. This is the process of placing several reflection probes in your scene that take a cubemap snapshot of the scene at that specific location, which we can then convolute as IBL data for that part of the scene. By interpolating between several of these probes based on the camera&rsquo;s vicinity we can achieve local high-detail image-based lighting that is simply limited by the amount of reflection probes we&rsquo;re willing to place. This way, the image-based lighting could correctly update when moving from a bright outdoor section of a scene to a darker indoor section for instance. I&rsquo;ll write a tutorial about reflection probes somewhere in the future, but for now I recommend the article by Chetan Jags below to give you a head start.</p>
<h4 id="further-reading-4">Further reading</h4>
<ul>
<li><a href="http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf" target="_blank">Real Shading in Unreal Engine 4</a>: explains Epic Games&rsquo; split sum approximation. This is the article the IBL PBR code is based of.</li>
<li><a href="http://www.trentreed.net/blog/physically-based-shading-and-image-based-lighting/" target="_blank">Physically Based Shading and Image Based Lighting</a>: great blog post by Trent Reed about integrating specular IBL into a PBR pipeline in real time.</li>
<li><a href="https://chetanjags.wordpress.com/2015/08/26/image-based-lighting/" target="_blank">Image Based Lighting</a>: very extensive write-up by Chetan Jags about specular-based image-based lighting and several of its caveats, including light probe interpolation.</li>
<li><a href="https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf" target="_blank">Moving Frostbite to PBR</a>: well written and in-depth overview of integrating PBR into a AAA game engine by Sébastien Lagarde and Charles de Rousiers.</li>
<li><a href="https://jmonkeyengine.github.io/wiki/jme3/advanced/pbr_part3.html" target="_blank">Physically Based Rendering – Part Three</a>: high level overview of IBL lighting and PBR by the JMonkeyEngine team.</li>
<li><a href="https://placeholderart.wordpress.com/2015/07/28/implementation-notes-runtime-environment-map-filtering-for-image-based-lighting/" target="_blank">Implementation Notes: Runtime Environment Map Filtering for Image Based Lighting</a>: extensive write-up by Padraic Hennessy about pre-filtering HDR environment maps and significantly optimizing the sample process.</li>
</ul>
<h2 id="in-practice-1">In Practice</h2>
<h3 id="debugging">Debugging</h3>
<p>Graphics programming can be a lot of fun, but it can also be a large source of frustration whenever something isn&rsquo;t rendering just right, or perhaps not even rendering at all! Seeing as most of what we do involves manipulating pixels, it can be difficult to figure out the cause of error whenever something doesn&rsquo;t work the way it&rsquo;s supposed to. Debugging these kinds of <em>visual</em> errors is different than what you&rsquo;re used to when debugging errors on the CPU. We have no console to output text to, no breakpoints to set on GLSL code, and no way of easily checking the state of GPU execution.</p>
<p>In this chapter we&rsquo;ll look into several techniques and tricks of debugging your OpenGL program. Debugging in OpenGL is not too difficult to do and getting a grasp of its techniques definitely pays out in the long run.</p>
<h4 id="glgeterror">glGetError()</h4>
<p>The moment you incorrectly use OpenGL (like configuring a buffer without first binding any) it will take notice and generate one or more user error flags behind the scenes. We can query these error flags using a function named glGetError that checks the error flag(s) set and returns an error value if OpenGL got misused:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">GLenum</span> <span class="nf">glGetError</span><span class="p">();</span>  
</span></span></code></pre></div><p>The moment glGetError is called, it returns either an error flag or no error at all. The error codes that glGetError can return are listed below:</p>
<p><a href="#R-image-ceb49bd13d5e67f03f4d0aac313265af" class="lightbox-link"><img src="./assets/20240214222302.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-ceb49bd13d5e67f03f4d0aac313265af"><img src="./assets/20240214222302.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Within OpenGL&rsquo;s function documentation you can always find the error codes a function generates the moment it is incorrectly used. For instance, if you take a look at the documentation of <a href="http://docs.gl/gl3/glBindTexture" target="_blank">glBindTexture</a> function, you can find all the user error codes it could generate under the <em>Errors</em> section.</p>
<p>The moment an error flag is set, no other error flags will be reported. Furthermore, the moment glGetError is called it clears all error flags (or only one if on a distributed system, see note below). This means that if you call glGetError once at the end of each frame and it returns an error, you can&rsquo;t conclude this was the only error, and the source of the error could&rsquo;ve been anywhere in the frame.</p>
<p><note>Note that when OpenGL runs distributedly like frequently found on X11 systems, other user error codes can still be generated as long as they have different error codes. Calling glGetError then only resets one of the error code flags instead of all of them. Because of this, it is recommended to call glGetError inside a loop.</note></p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">tex</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">glGetError</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// returns 0 (no error)
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="c1"></span>  
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">glTexImage2D</span><span class="p">(</span><span class="n">GL_TEXTURE_3D</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGB</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGB</span><span class="p">,</span> <span class="n">GL_UNSIGNED_BYTE</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">glGetError</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// returns 1280 (invalid enum)
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="c1"></span>  
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="n">glGenTextures</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="n">textures</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">glGetError</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// returns 1281 (invalid value)
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1"></span>  
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">glGetError</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// returns 0 (no error)
</span></span></span></code></pre></div><p>The great thing about glGetError is that it makes it relatively easy to pinpoint where any error may be and to validate the proper use of OpenGL. Let&rsquo;s say you get a black screen and you have no idea what&rsquo;s causing it: is the framebuffer not properly set? Did I forget to bind a texture? By calling glGetError all over your codebase, you can quickly catch the first place an OpenGL error starts showing up.</p>
<p>By default glGetError only prints error numbers, which isn&rsquo;t easy to understand unless you&rsquo;ve memorized the error codes. It often makes sense to write a small helper function to easily print out the error strings together with where the error check function was called:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">GLenum</span> <span class="nf">glCheckError_</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">int</span> <span class="n">line</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="n">GLenum</span> <span class="n">errorCode</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="k">while</span> <span class="p">((</span><span class="n">errorCode</span> <span class="o">=</span> <span class="n">glGetError</span><span class="p">())</span> <span class="o">!=</span> <span class="n">GL_NO_ERROR</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">error</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">        <span class="k">switch</span> <span class="p">(</span><span class="n">errorCode</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">            <span class="k">case</span> <span class="nl">GL_INVALID_ENUM</span><span class="p">:</span>                  <span class="n">error</span> <span class="o">=</span> <span class="s">&#34;INVALID_ENUM&#34;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">            <span class="k">case</span> <span class="nl">GL_INVALID_VALUE</span><span class="p">:</span>                 <span class="n">error</span> <span class="o">=</span> <span class="s">&#34;INVALID_VALUE&#34;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">            <span class="k">case</span> <span class="nl">GL_INVALID_OPERATION</span><span class="p">:</span>             <span class="n">error</span> <span class="o">=</span> <span class="s">&#34;INVALID_OPERATION&#34;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">            <span class="k">case</span> <span class="nl">GL_STACK_OVERFLOW</span><span class="p">:</span>                <span class="n">error</span> <span class="o">=</span> <span class="s">&#34;STACK_OVERFLOW&#34;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">            <span class="k">case</span> <span class="nl">GL_STACK_UNDERFLOW</span><span class="p">:</span>               <span class="n">error</span> <span class="o">=</span> <span class="s">&#34;STACK_UNDERFLOW&#34;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">            <span class="k">case</span> <span class="nl">GL_OUT_OF_MEMORY</span><span class="p">:</span>                 <span class="n">error</span> <span class="o">=</span> <span class="s">&#34;OUT_OF_MEMORY&#34;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">            <span class="k">case</span> <span class="nl">GL_INVALID_FRAMEBUFFER_OPERATION</span><span class="p">:</span> <span class="n">error</span> <span class="o">=</span> <span class="s">&#34;INVALID_FRAMEBUFFER_OPERATION&#34;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">error</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; | &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">file</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; (&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">line</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;)&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">    <span class="k">return</span> <span class="n">errorCode</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="cp">#define glCheckError() glCheckError_(__FILE__, __LINE__) </span></span></span></code></pre></div><p>In case you&rsquo;re unaware of what the preprocessor directives <code>__FILE__</code> and <code>__LINE__</code> are: these variables get replaced during compile time with the respective file and line they were compiled in. If we decide to stick a large number of these glCheckError calls in our codebase it&rsquo;s helpful to more precisely know which glCheckError call returned the error.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_VERTEX_ARRAY</span><span class="p">,</span> <span class="n">vbo</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glCheckError</span><span class="p">();</span> 
</span></span></code></pre></div><p>This will give us the following output:</p>
<p><a href="#R-image-df29d4e5e84fa1df7f60b94b232a2aa5" class="lightbox-link"><img src="./assets/debugging_glgeterror.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-df29d4e5e84fa1df7f60b94b232a2aa5"><img src="./assets/debugging_glgeterror.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>glGetError doesn&rsquo;t help you too much as the information it returns is rather simple, but it does often help you catch typos or quickly pinpoint where in your code things went wrong; a simple but effective tool in your debugging toolkit.</p>
<h4 id="debug-output">Debug output</h4>
<p>A less common, but more useful tool than glCheckError is an OpenGL extension called debug output that became part of core OpenGL since version 4.3. With the debug output extension, OpenGL itself will directly send an error or warning message to the user with a lot more details compared to glCheckError. Not only does it provide more information, it can also help you catch errors exactly where they occur by intelligently using a debugger.</p>
<p><note>Debug output is core since OpenGL version 4.3, which means you&rsquo;ll find this functionality on any machine that runs OpenGL 4.3 or higher. If they&rsquo;re not available, its functionality can be queried from the <code>ARB_debug_output</code> or <code>AMD_debug_output</code> extension. Note that OS X does not seem to support debug output functionality (as gathered online).</note></p>
<p>In order to start using debug output we have to request a debug output context from OpenGL at our initialization process. This process varies based on whatever windowing system you use; here we will discuss setting it up on GLFW, but you can find info on other systems in the additional resources at the end of the chapter.</p>
<h5 id="debug-output-in-glfw">Debug output in GLFW</h5>
<p>Requesting a debug context in GLFW is surprisingly easy as all we have to do is pass a hint to GLFW that we&rsquo;d like to have a debug output context. We have to do this before we call glfwCreateWindow:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glfwWindowHint</span><span class="p">(</span><span class="n">GLFW_OPENGL_DEBUG_CONTEXT</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>  
</span></span></code></pre></div><p>Once we&rsquo;ve then initialized GLFW, we should have a debug context if we&rsquo;re using OpenGL version 4.3 or higher. If not, we have to take our chances and hope the system is still able to request a debug context. Otherwise we have to request debug output using its OpenGL extension(s).</p>
<p><note>Using OpenGL in debug context can be significantly slower compared to a non-debug context, so when working on optimizations or releasing your application you want to remove GLFW&rsquo;s debug request hint.</note></p>
<p>o check if we successfully initialized a debug context we can query OpenGL:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">int</span> <span class="n">flags</span><span class="p">;</span> <span class="n">glGetIntegerv</span><span class="p">(</span><span class="n">GL_CONTEXT_FLAGS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">GL_CONTEXT_FLAG_DEBUG_BIT</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="c1">// initialize debug output 
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></div><p>The way debug output works is that we pass OpenGL an error logging function callback (similar to GLFW&rsquo;s input callbacks) and in the callback function we are free to process the OpenGL error data as we see fit; in our case we&rsquo;ll be displaying useful error data to the console. Below is the callback function prototype that OpenGL expects for debug output:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">void</span> <span class="n">APIENTRY</span> <span class="nf">glDebugOutput</span><span class="p">(</span><span class="n">GLenum</span> <span class="n">source</span><span class="p">,</span> <span class="n">GLenum</span> <span class="n">type</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="n">GLenum</span> <span class="n">severity</span><span class="p">,</span> 
</span></span><span class="line"><span class="ln">2</span><span class="cl">                            <span class="n">GLsizei</span> <span class="n">length</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">message</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">userParam</span><span class="p">);</span></span></span></code></pre></div><p>Given the large set of data we have at our exposal, we can create a useful error printing tool like below:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="n">APIENTRY</span> <span class="nf">glDebugOutput</span><span class="p">(</span><span class="n">GLenum</span> <span class="n">source</span><span class="p">,</span> 
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">                            <span class="n">GLenum</span> <span class="n">type</span><span class="p">,</span> 
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">                            <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">id</span><span class="p">,</span> 
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">                            <span class="n">GLenum</span> <span class="n">severity</span><span class="p">,</span> 
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">                            <span class="n">GLsizei</span> <span class="n">length</span><span class="p">,</span> 
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">                            <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">message</span><span class="p">,</span> 
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">                            <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">userParam</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="c1">// ignore non-significant error/warning codes
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="mi">131169</span> <span class="o">||</span> <span class="n">id</span> <span class="o">==</span> <span class="mi">131185</span> <span class="o">||</span> <span class="n">id</span> <span class="o">==</span> <span class="mi">131218</span> <span class="o">||</span> <span class="n">id</span> <span class="o">==</span> <span class="mi">131204</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">11</span><span class="cl">
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;---------------&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Debug message (&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">id</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;): &#34;</span> <span class="o">&lt;&lt;</span>  <span class="n">message</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="k">switch</span> <span class="p">(</span><span class="n">source</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">        <span class="k">case</span> <span class="nl">GL_DEBUG_SOURCE_API</span><span class="p">:</span>             <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Source: API&#34;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">        <span class="k">case</span> <span class="nl">GL_DEBUG_SOURCE_WINDOW_SYSTEM</span><span class="p">:</span>   <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Source: Window System&#34;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">        <span class="k">case</span> <span class="nl">GL_DEBUG_SOURCE_SHADER_COMPILER</span><span class="p">:</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Source: Shader Compiler&#34;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">        <span class="k">case</span> <span class="nl">GL_DEBUG_SOURCE_THIRD_PARTY</span><span class="p">:</span>     <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Source: Third Party&#34;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">        <span class="k">case</span> <span class="nl">GL_DEBUG_SOURCE_APPLICATION</span><span class="p">:</span>     <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Source: Application&#34;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">        <span class="k">case</span> <span class="nl">GL_DEBUG_SOURCE_OTHER</span><span class="p">:</span>           <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Source: Other&#34;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">    <span class="p">}</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">
</span></span><span class="line"><span class="ln">25</span><span class="cl">    <span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl">        <span class="k">case</span> <span class="nl">GL_DEBUG_TYPE_ERROR</span><span class="p">:</span>               <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Type: Error&#34;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">28</span><span class="cl">        <span class="k">case</span> <span class="nl">GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR</span><span class="p">:</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Type: Deprecated Behaviour&#34;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">29</span><span class="cl">        <span class="k">case</span> <span class="nl">GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR</span><span class="p">:</span>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Type: Undefined Behaviour&#34;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">30</span><span class="cl">        <span class="k">case</span> <span class="nl">GL_DEBUG_TYPE_PORTABILITY</span><span class="p">:</span>         <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Type: Portability&#34;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">31</span><span class="cl">        <span class="k">case</span> <span class="nl">GL_DEBUG_TYPE_PERFORMANCE</span><span class="p">:</span>         <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Type: Performance&#34;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">32</span><span class="cl">        <span class="k">case</span> <span class="nl">GL_DEBUG_TYPE_MARKER</span><span class="p">:</span>              <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Type: Marker&#34;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">33</span><span class="cl">        <span class="k">case</span> <span class="nl">GL_DEBUG_TYPE_PUSH_GROUP</span><span class="p">:</span>          <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Type: Push Group&#34;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">34</span><span class="cl">        <span class="k">case</span> <span class="nl">GL_DEBUG_TYPE_POP_GROUP</span><span class="p">:</span>           <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Type: Pop Group&#34;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">35</span><span class="cl">        <span class="k">case</span> <span class="nl">GL_DEBUG_TYPE_OTHER</span><span class="p">:</span>               <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Type: Other&#34;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">36</span><span class="cl">    <span class="p">}</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">37</span><span class="cl">    
</span></span><span class="line"><span class="ln">38</span><span class="cl">    <span class="k">switch</span> <span class="p">(</span><span class="n">severity</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">39</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln">40</span><span class="cl">        <span class="k">case</span> <span class="nl">GL_DEBUG_SEVERITY_HIGH</span><span class="p">:</span>         <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Severity: high&#34;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">41</span><span class="cl">        <span class="k">case</span> <span class="nl">GL_DEBUG_SEVERITY_MEDIUM</span><span class="p">:</span>       <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Severity: medium&#34;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">42</span><span class="cl">        <span class="k">case</span> <span class="nl">GL_DEBUG_SEVERITY_LOW</span><span class="p">:</span>          <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Severity: low&#34;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">43</span><span class="cl">        <span class="k">case</span> <span class="nl">GL_DEBUG_SEVERITY_NOTIFICATION</span><span class="p">:</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Severity: notification&#34;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">44</span><span class="cl">    <span class="p">}</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">45</span><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">46</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>Whenever debug output detects an OpenGL error, it will call this callback function and we&rsquo;ll be able to print out a large deal of information regarding the OpenGL error. Note that we ignore a few error codes that tend to not really display anything useful (like <code>131185</code> in NVidia drivers that tells us a buffer was successfully created).</p>
<p>Now that we have the callback function it&rsquo;s time to initialize debug output:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">GL_CONTEXT_FLAG_DEBUG_BIT</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="n">glEnable</span><span class="p">(</span><span class="n">GL_DEBUG_OUTPUT</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="n">glEnable</span><span class="p">(</span><span class="n">GL_DEBUG_OUTPUT_SYNCHRONOUS</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">5</span><span class="cl">    <span class="n">glDebugMessageCallback</span><span class="p">(</span><span class="n">glDebugOutput</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">    <span class="n">glDebugMessageControl</span><span class="p">(</span><span class="n">GL_DONT_CARE</span><span class="p">,</span> <span class="n">GL_DONT_CARE</span><span class="p">,</span> <span class="n">GL_DONT_CARE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">,</span> <span class="n">GL_TRUE</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="p">}</span> 
</span></span></code></pre></div><p>Here we tell OpenGL to enable debug output. The <code>glEnable(GL_DEBUG_SYNCRHONOUS)</code> call tells OpenGL to directly call the callback function the moment an error occurred.</p>
<h5 id="filter-debug-output">Filter debug output</h5>
<p>With glDebugMessageControl you can potentially filter the type(s) of errors you&rsquo;d like to receive a message from. In our case we decided to not filter on any of the sources, types, or severity rates. If we wanted to only show messages from the OpenGL API, that are errors, and have a high severity, we&rsquo;d configure it as follows:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glDebugMessageControl</span><span class="p">(</span><span class="n">GL_DEBUG_SOURCE_API</span><span class="p">,</span> 
</span></span><span class="line"><span class="ln">2</span><span class="cl">                      <span class="n">GL_DEBUG_TYPE_ERROR</span><span class="p">,</span> 
</span></span><span class="line"><span class="ln">3</span><span class="cl">                      <span class="n">GL_DEBUG_SEVERITY_HIGH</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">                      <span class="mi">0</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">,</span> <span class="n">GL_TRUE</span><span class="p">);</span> 
</span></span></code></pre></div><p>Given our configuration, and assuming you have a context that supports debug output, every incorrect OpenGL command will now print a large bundle of useful data:</p>
<p><a href="#R-image-0010db09c3977a954113a955f162d8fa" class="lightbox-link"><img src="./assets/debugging_debug_output.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-0010db09c3977a954113a955f162d8fa"><img src="./assets/debugging_debug_output.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<h5 id="backtracking-the-debug-error-source">Backtracking the debug error source</h5>
<p>Another great trick with debug output is that you can relatively easy figure out the exact line or call an error occurred. By setting a breakpoint in DebugOutput at a specific error type (or at the top of the function if you don&rsquo;t care), the debugger will catch the error thrown and you can move up the call stack to whatever function caused the message dispatch:</p>
<p><a href="#R-image-404b90044523adac33d3529186e7af38" class="lightbox-link"><img src="./assets/debugging_debug_output_breakpoint.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-404b90044523adac33d3529186e7af38"><img src="./assets/debugging_debug_output_breakpoint.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>It requires some manual intervention, but if you roughly know what you&rsquo;re looking for it&rsquo;s incredibly useful to quickly determine which call causes an error.</p>
<h5 id="custom-error-output">Custom error output</h5>
<p>Aside from reading messages, we can also push messages to the debug output system with glDebugMessageInsert:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glDebugMessageInsert</span><span class="p">(</span><span class="n">GL_DEBUG_SOURCE_APPLICATION</span><span class="p">,</span> <span class="n">GL_DEBUG_TYPE_ERROR</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>                       
</span></span><span class="line"><span class="ln">2</span><span class="cl">                     <span class="n">GL_DEBUG_SEVERITY_MEDIUM</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="s">&#34;error message here&#34;</span><span class="p">);</span> 
</span></span></code></pre></div><p>This is especially useful if you&rsquo;re hooking into other application or OpenGL code that makes use of a debug output context. Other developers can quickly figure out any <em>reported</em> bug that occurs in your custom OpenGL code.</p>
<p>In summary, debug output (if you can use it) is incredibly useful for quickly catching errors and is well worth the effort in setting up as it saves considerable development time. You can find a source code example <a href="https://learnopengl.com/code_viewer_gh.php?code=src/7.in_practice/1.debugging/debugging.cpp" target="_blank">here</a> with both glGetError and debug output context configured; see if you can fix all the errors.</p>
<h4 id="debugging-shader-output">Debugging shader output</h4>
<p>When it comes to GLSL, we unfortunately don&rsquo;t have access to a function like glGetError nor the ability to step through the shader code. When you end up with a black screen or the completely wrong visuals, it&rsquo;s often difficult to figure out if something&rsquo;s wrong with the shader code. Yes, we have the compilation error reports that report syntax errors, but catching the semantic errors is another beast.</p>
<p>One frequently used trick to figure out what is wrong with a shader is to evaluate all the relevant variables in a shader program by sending them directly to the fragment shader&rsquo;s output channel. By outputting shader variables directly to the output color channels, we can convey interesting information by inspecting the visual results. For instance, let&rsquo;s say we want to check if a model has correct normal vectors. We can pass them (either transformed or untransformed) from the vertex shader to the fragment shader where we&rsquo;d then output the normals as follows:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">out</span> <span class="n">vec4</span> <span class="n">FragColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">in</span> <span class="n">vec3</span> <span class="n">Normal</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="p">[...]</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="kt">void</span> <span class="n">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="p">[...]</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="n">FragColor</span><span class="p">.</span><span class="n">rgb</span> <span class="o">=</span> <span class="n">Normal</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="n">FragColor</span><span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="mf">1.0f</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>By outputting a (non-color) variable to the output color channel like this we can quickly inspect if the variable is, as far as you can tell, displaying correct values. If, for instance, the visual result is completely black it is clear the normal vectors aren&rsquo;t correctly passed to the shaders; and when they are displayed it&rsquo;s relatively easy to check if they&rsquo;re (sort of) correct or not:</p>
<p><a href="#R-image-04eaa44a9093ba2c6afbe4c985a62752" class="lightbox-link"><img src="./assets/debugging_glsl_output.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-04eaa44a9093ba2c6afbe4c985a62752"><img src="./assets/debugging_glsl_output.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>From the visual results we can see the world-space normal vectors appear to be correct as the right sides of the backpack model is mostly colored red (which would mean the normals roughly point (correctly) towards the positive x axis). Similarly, the front side of the backpack is mostly colored towards the positive z axis (blue).</p>
<p>This approach can easily extend to any type of variable you&rsquo;d like to test. Whenever you get stuck and suspect there&rsquo;s something wrong with your shaders, try displaying multiple variables and/or intermediate results to see at which part of the algorithm something&rsquo;s missing or seemingly incorrect.</p>
<h4 id="opengl-glsl-reference-compiler">OpenGL GLSL reference compiler</h4>
<p>Each driver has its own quirks and tidbits; for instance, NVIDIA drivers are more flexible and tend to overlook some restrictions on the specification, while ATI/AMD drivers tend to better enforce the OpenGL specification (which is the better approach in my opinion). The result of this is that shaders on one machine may not work on the other due to driver differences.</p>
<p>With years of experience you&rsquo;ll eventually get to learn the minor differences between GPU vendors, but if you want to be sure your shader code runs on all kinds of machines you can directly check your shader code against the official specification using OpenGL&rsquo;s GLSL <a href="https://www.khronos.org/opengles/sdk/tools/Reference-Compiler/" target="_blank">reference compiler</a>. You can download the so called GLSL lang validator binaries from <a href="https://www.khronos.org/opengles/sdk/tools/Reference-Compiler/" target="_blank">here</a> or its complete source code from <a href="https://github.com/KhronosGroup/glslang" target="_blank">here</a>.</p>
<p>Given the binary GLSL lang validator you can easily check your shader code by passing it as the binary&rsquo;s first argument. Keep in mind that the GLSL lang validator determines the type of shader by a list of fixed extensions:</p>
<ul>
<li><code>.vert</code>: vertex shader.</li>
<li><code>.frag</code>: fragment shader.</li>
<li><code>.geom</code>: geometry shader.</li>
<li><code>.tesc</code>: tessellation control shader.</li>
<li><code>.tese</code>: tessellation evaluation shader.</li>
<li><code>.comp</code>: compute shader.</li>
</ul>
<p>Running the GLSL reference compiler is as simple as:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glsllangvalidator</span> <span class="n">shaderFile</span><span class="p">.</span><span class="n">vert</span>  
</span></span></code></pre></div><p>Note that if it detects no error, it returns no output. Testing the GLSL reference compiler on a broken vertex shader gives the following output:</p>
<p><a href="#R-image-96ff7f4b4e00b076e260fd0a5d6cb8c7" class="lightbox-link"><img src="./assets/debugging_glsl_reference_compiler.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-96ff7f4b4e00b076e260fd0a5d6cb8c7"><img src="./assets/debugging_glsl_reference_compiler.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>It won&rsquo;t show you the subtle differences between AMD, NVidia, or Intel GLSL compilers, nor will it help you completely bug proof your shaders, but it does at least help you to check your shaders against the direct GLSL specification.</p>
<h4 id="framebuffer-output">Framebuffer output</h4>
<p>Another useful trick for your debugging toolkit is displaying a framebuffer&rsquo;s content(s) in some pre-defined region of your screen. You&rsquo;re likely to use <a href="https://learnopengl.com/Advanced-OpenGL/Framebuffers" target="_blank">framebuffers</a> quite often and, as most of their magic happens behind the scenes, it&rsquo;s sometimes difficult to figure out what&rsquo;s going on. Displaying the content(s) of a framebuffer on your screen is a useful trick to quickly see if things look correct.</p>
<p><note>Note that displaying the contents (attachments) of a framebuffer as explained here only works on texture attachments, not render buffer objects.</note></p>
<p>Using a simple shader that only displays a texture, we can easily write a small helper function to quickly display any texture at the top-right of the screen:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="c1">// vertex shader
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1"></span><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="cp"></span><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec2</span> <span class="n">position</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec2</span> <span class="n">texCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">out</span> <span class="n">vec2</span> <span class="n">TexCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="n">TexCoords</span> <span class="o">=</span> <span class="n">texCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">  
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="c1">// fragment shader
</span></span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="c1"></span><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="cp"></span><span class="n">out</span> <span class="n">vec4</span> <span class="n">FragColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="n">in</span>  <span class="n">vec2</span> <span class="n">TexCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">  
</span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">fboAttachment</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">  
</span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">    <span class="n">FragColor</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">fboAttachment</span><span class="p">,</span> <span class="n">TexCoords</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl"><span class="p">}</span> 
</span></span></code></pre></div><div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="nf">DisplayFramebufferTexture</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">textureID</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">notInitialized</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">        <span class="c1">// initialize shader and vao w/ NDC vertex coordinates at top-right of the screen
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="c1"></span>        <span class="p">[...]</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="n">glActiveTexture</span><span class="p">(</span><span class="n">GL_TEXTURE0</span><span class="p">);</span>  	
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="n">glUseProgram</span><span class="p">(</span><span class="n">shaderDisplayFBOOutput</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">        <span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">textureID</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">        <span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">vaoDebugTexturedRect</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">            <span class="n">glDrawArrays</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">        <span class="n">glBindVertexArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="n">glUseProgram</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">  
</span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">    <span class="p">[...]</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">glfwWindowShouldClose</span><span class="p">(</span><span class="n">window</span><span class="p">))</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">        <span class="p">[...]</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">        <span class="n">DisplayFramebufferTexture</span><span class="p">(</span><span class="n">fboAttachment0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl">        
</span></span><span class="line"><span class="ln">26</span><span class="cl">        <span class="n">glfwSwapBuffers</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">28</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>This will give you a nice little window at the corner of your screen for debugging framebuffer output. Useful, for example, for determining if the normal vectors of the geometry pass in a deferred renderer look correct:</p>
<p><a href="#R-image-17171d7c9d8dde053095044d8d1a8d88" class="lightbox-link"><img src="./assets/debugging_fbo_output.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-17171d7c9d8dde053095044d8d1a8d88"><img src="./assets/debugging_fbo_output.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>You can of course extend such a utility function to support rendering more than one texture. This is a quick and dirty way to get continuous feedback from whatever is in your framebuffer(s).</p>
<h4 id="external-debugging-software">External debugging software</h4>
<p>When all else fails there is still the option to use a 3rd party tool to help us in our debugging efforts. Third party applications often inject themselves in the OpenGL drivers and are able to intercept all kinds of OpenGL calls to give you a large array of interesting data. These tools can help you in all kinds of ways like: profiling OpenGL function usage, finding bottlenecks, inspecting buffer memory, and displaying textures and framebuffer attachments. When you&rsquo;re working on (large) production code, these kinds of tools can become invaluable in your development process.</p>
<p>I&rsquo;ve listed some of the more popular debugging tools here; try out several of them to see which fits your needs the best.</p>
<h5 id="renderdoc">RenderDoc</h5>
<p>RenderDoc is a great (completely <a href="https://github.com/baldurk/renderdoc" target="_blank">open source</a>) standalone debugging tool. To start a capture, you specify the executable you&rsquo;d like to capture and a working directory. The application then runs as usual, and whenever you want to inspect a particular frame, you let RenderDoc capture one or more frames at the executable&rsquo;s current state. Within the captured frame(s) you can view the pipeline state, all OpenGL commands, buffer storage, and textures in use.</p>
<p><a href="#R-image-42e8bafdfc056e272eb69e64ab7dcdee" class="lightbox-link"><img src="./assets/debugging_external_renderdoc.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-42e8bafdfc056e272eb69e64ab7dcdee"><img src="./assets/debugging_external_renderdoc.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<h5 id="codexl">CodeXL</h5>
<p><a href="https://gpuopen.com/compute-product/codexl/" target="_blank">CodeXL</a> is GPU debugging tool released as both a standalone tool and a Visual Studio plugin. CodeXL gives a good set of information and is great for profiling graphics applications. CodeXL also works on NVidia or Intel cards, but without support for OpenCL debugging.</p>
<p><a href="#R-image-191dc12d4ad9a140ba0950e2904e1f88" class="lightbox-link"><img src="./assets/debugging_external_codexl.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-191dc12d4ad9a140ba0950e2904e1f88"><img src="./assets/debugging_external_codexl.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>I personally don&rsquo;t have much experience with CodeXL since I found RenderDoc easier to use, but I&rsquo;ve included it anyways as it looks to be a pretty solid tool and developed by one of the larger GPU manufacturers.</p>
<h5 id="nvidia-nsight">NVIDIA Nsight</h5>
<p>NVIDIA&rsquo;s popular <a href="https://developer.nvidia.com/nvidia-nsight-visual-studio-edition" target="_blank">Nsight</a> GPU debugging tool is not a standalone tool, but a plugin to either the Visual Studio IDE or the Eclipse IDE (NVIDIA now has a <a href="https://developer.nvidia.com/nsight-graphics" target="_blank">standalone version</a> as well). The Nsight plugin is an incredibly useful tool for graphics developers as it gives a large host of run-time statistics regarding GPU usage and the frame-by-frame GPU state.</p>
<p>The moment you start your application from within Visual Studio (or Eclipse), using Nsight&rsquo;s debugging or profiling commands, Nsight will run within the application itself. The great thing about Nsight is that it renders an overlay GUI system from within your application that you can use to gather all kinds of interesting information about your application, both at run-time and during frame-by-frame analysis.</p>
<p><a href="#R-image-f3834e6cc7ea98bfd78eec0db85c52d1" class="lightbox-link"><img src="./assets/debugging_external_nsight.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f3834e6cc7ea98bfd78eec0db85c52d1"><img src="./assets/debugging_external_nsight.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Nsight is an incredibly useful tool, but it does come with one major drawback in that it only works on NVIDIA cards. If you are working on NVIDIA cards (and use Visual Studio) it&rsquo;s definitely worth a shot.</p>
<p>I&rsquo;m sure there&rsquo;s plenty of other debugging tools I&rsquo;ve missed (some that come to mind are Valve&rsquo;s <a href="https://github.com/ValveSoftware/vogl" target="_blank">VOGL</a> and <a href="https://apitrace.github.io/" target="_blank">APItrace</a>), but I feel this list should already get you plenty of tools to experiment with.</p>
<h4 id="additional-resources-12">Additional resources</h4>
<ul>
<li><a href="http://retokoradi.com/2014/04/21/opengl-why-is-your-code-producing-a-black-window/" target="_blank">Why is your code producing a black window</a>: list of general causes by Reto Koradi of why your screen may not be producing any output.</li>
<li><a href="https://vallentin.dev/2015/02/23/debugging-opengl" target="_blank">Debug Output in OpenGL</a>: an extensive debug output write-up by Vallentin with detailed information on setting up a debug context on multiple windowing systems.</li>
</ul>
<h3 id="text-rendering">Text Rendering</h3>
<div class="include hide-first-heading">
<h1 id="text-rendering-1">Text Rendering</h1>
<p>At some stage of your graphics adventures you will want to draw text in OpenGL. Contrary to what you may expect, getting a simple string to render on screen is all but easy with a low-level API like OpenGL. If you don&rsquo;t care about rendering more than 128 different same-sized characters, then it&rsquo;s probably not too difficult. Things are getting difficult as soon as each character has a different width, height, and margin. Based on where you live, you may also need more than 128 characters, and what if you want to express special symbols for like mathematical expressions or sheet music symbols, and what about rendering text from top to bottom? Once you think about all these complicated matters of text, it wouldn&rsquo;t surprise you that this probably doesn&rsquo;t belong in a low-level API like OpenGL.</p>
<p>Since there is no support for text capabilities within OpenGL, it is up to us to define a system for rendering text to the screen. There are no graphical primitives for text characters, we have to get creative. Some example techniques are: drawing letter shapes via GL_LINES, create 3D meshes of letters, or render character textures to 2D quads in a 3D environment.</p>
<p>Most developers choose to render character textures onto quads. Rendering textured quads by itself shouldn&rsquo;t be too difficult, but getting the relevant character(s) onto a texture could prove challenging. In this chapter we&rsquo;ll explore several methods and implement a more advanced, but flexible technique for rendering text using the FreeType library.</p>
<h4 id="classical-text-rendering-bitmap-fonts">Classical text rendering: bitmap fonts</h4>
<p>In the early days, rendering text involved selecting a font (or create one yourself) you&rsquo;d like for your application and extracting all relevant characters out of this font to place them within a single large texture. Such a texture, that we call a bitmap font, contains all character symbols we want to use in predefined regions of the texture. These character symbols of the font are known as glyphs. Each glyph has a specific region of texture coordinates associated with them. Whenever you want to render a character, you select the corresponding glyph by rendering this section of the bitmap font to a 2D quad.</p>
<p><a href="#R-image-8ba2b7949ecde8da5c693c1d838ab3c8" class="lightbox-link"><img src="./assets/bitmapfont.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-8ba2b7949ecde8da5c693c1d838ab3c8"><img src="./assets/bitmapfont.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Here you can see how we would render the text &lsquo;OpenGL&rsquo; by taking a bitmap font and sampling the corresponding glyphs from the texture (carefully choosing the texture coordinates) that we render on top of several quads. By enabling <a href="https://learnopengl.com/Advanced-OpenGL/Blending" target="_blank">blending</a> and keeping the background transparent, we will end up with just a string of characters rendered to the screen. This particular bitmap font was generated using Codehead&rsquo;s Bitmap <a href="http://www.codehead.co.uk/cbfg/" target="_blank">Font Generator</a>.</p>
<p>This approach has several advantages and disadvantages. It is relatively easy to implement and because bitmap fonts are pre-rasterized, they&rsquo;re quite efficient. However, it is not particularly flexible. When you want to use a different font, you need to recompile a complete new bitmap font and the system is limited to a single resolution; zooming will quickly show pixelated edges. Furthermore, it is limited to a small character set, so Extended or Unicode characters are often out of the question.</p>
<p>This approach was quite popular back in the day (and still is) since it is fast and works on any platform, but as of today more flexible approaches exist. One of these approaches is loading TrueType fonts using the FreeType library.</p>
<h4 id="modern-text-rendering-freetype">Modern text rendering: FreeType</h4>
<p>FreeType is a software development library that is able to load fonts, render them to bitmaps, and provide support for several font-related operations. It is a popular library used by Mac OS X, Java, PlayStation, Linux, and Android to name a few. What makes FreeType particularly attractive is that it is able to load TrueType fonts.</p>
<p>A TrueType font is a collection of character glyphs not defined by pixels or any other non-scalable solution, but by mathematical equations (combinations of splines). Similar to vector images, the rasterized font images can be procedurally generated based on the preferred font height you&rsquo;d like to obtain them in. By using TrueType fonts you can easily render character glyphs of various sizes without any loss of quality.</p>
<p>FreeType can be downloaded from their <a href="http://www.freetype.org/" target="_blank">website</a>. You can choose to compile the library yourself or use one of their precompiled libraries if your target platform is listed. Be sure to link to <code>freetype.lib</code> and make sure your compiler knows where to find the header files.</p>
<p>Then include the appropriate headers:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;ft2build.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="cp">#include FT_FREETYPE_H  </span></span></span></code></pre></div><p><warning>Due to how FreeType is developed (at least at the time of this writing), you cannot put their header files in a new directory; they should be located at the root of your include directories. Including FreeType like <code>#include &lt;FreeType/ft2build.h&gt;</code> will likely cause several header conflicts.</warning></p>
<p>FreeType loads these TrueType fonts and, for each glyph, generates a bitmap image and calculates several metrics. We can extract these bitmap images for generating textures and position each character glyph appropriately using the loaded metrics.</p>
<p>To load a font, all we have to do is initialize the FreeType library and load the font as a face as FreeType likes to call it. Here we load the <code>arial.ttf</code> TrueType font file that was copied from the <code>Windows/Fonts</code> directory:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">FT_Library</span> <span class="n">ft</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">FT_Init_FreeType</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ft</span><span class="p">))</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;ERROR::FREETYPE: Could not init FreeType Library&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="n">FT_Face</span> <span class="n">face</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">FT_New_Face</span><span class="p">(</span><span class="n">ft</span><span class="p">,</span> <span class="s">&#34;fonts/arial.ttf&#34;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">face</span><span class="p">))</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;ERROR::FREETYPE: Failed to load font&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>Each of these FreeType functions returns a non-zero integer whenever an error occurred.</p>
<p>Once we&rsquo;ve loaded the face, we should define the pixel font size we&rsquo;d like to extract from this face:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">FT_Set_Pixel_Sizes</span><span class="p">(</span><span class="n">face</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">48</span><span class="p">);</span>  
</span></span></code></pre></div><p>The function sets the font&rsquo;s width and height parameters. Setting the width to <code>0</code> lets the face dynamically calculate the width based on the given height.</p>
<p>A FreeType face hosts a collection of glyphs. We can set one of those glyphs as the active glyph by calling FT_Load_Char. Here we choose to load the character glyph &lsquo;X&rsquo;:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">FT_Load_Char</span><span class="p">(</span><span class="n">face</span><span class="p">,</span> <span class="sc">&#39;X&#39;</span><span class="p">,</span> <span class="n">FT_LOAD_RENDER</span><span class="p">))</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;ERROR::FREETYTPE: Failed to load Glyph&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>By setting FT_LOAD_RENDER as one of the loading flags, we tell FreeType to create an 8-bit grayscale bitmap image for us that we can access via <code>face-&gt;glyph-&gt;bitmap</code>.</p>
<p>Each of the glyphs we load with FreeType however, do not have the same size (as we had with bitmap fonts). The bitmap image generated by FreeType is just large enough to contain the visible part of a character. For example, the bitmap image of the dot character &lsquo;.&rsquo; is much smaller in dimensions than the bitmap image of the character &lsquo;X&rsquo;. For this reason, FreeType also loads several metrics that specify how large each character should be and how to properly position them. Next is an image from FreeType that shows all of the metrics it calculates for each character glyph:</p>
<p><a href="#R-image-f954d1cda7e180487f1aaebf96050aae" class="lightbox-link"><img src="./assets/glyph.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f954d1cda7e180487f1aaebf96050aae"><img src="./assets/glyph.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Each of the glyphs reside on a horizontal baseline (as depicted by the horizontal arrow) where some glyphs sit exactly on top of this baseline (like &lsquo;X&rsquo;) or some slightly below the baseline (like &lsquo;g&rsquo; or &lsquo;p&rsquo;). These metrics define the exact offsets to properly position each glyph on the baseline, how large each glyph should be, and how many pixels we need to advance to render the next glyph. Next is a small list of the properties we&rsquo;ll be needing:</p>
<ul>
<li><strong>width</strong>: the width (in pixels) of the bitmap accessed via <code>face-&gt;glyph-&gt;bitmap.width</code>.</li>
<li><strong>height</strong>: the height (in pixels) of the bitmap accessed via <code>face-&gt;glyph-&gt;bitmap.rows</code>.</li>
<li><strong>bearingX</strong>: the horizontal bearing e.g. the horizontal position (in pixels) of the bitmap relative to the origin accessed via <code>face-&gt;glyph-&gt;bitmap_left</code>.</li>
<li><strong>bearingY</strong>: the vertical bearing e.g. the vertical position (in pixels) of the bitmap relative to the baseline accessed via <code>face-&gt;glyph-&gt;bitmap_top</code>.</li>
<li><strong>advance</strong>: the horizontal advance e.g. the horizontal distance (in 1/64th pixels) from the origin to the origin of the next glyph. Accessed via <code>face-&gt;glyph-&gt;advance.x</code>.</li>
</ul>
<p>We could load a character glyph, retrieve its metrics, and generate a texture each time we want to render a character to the screen, but it would be inefficient to do this each frame. We&rsquo;d rather store the generated data somewhere in the application and query it whenever we want to render a character. We&rsquo;ll define a convenient <code>struct</code> that we&rsquo;ll store in a map:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">struct</span> <span class="nc">Character</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">TextureID</span><span class="p">;</span>  <span class="c1">// ID handle of the glyph texture
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="c1"></span>    <span class="n">glm</span><span class="o">::</span><span class="n">ivec2</span>   <span class="n">Size</span><span class="p">;</span>       <span class="c1">// Size of glyph
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="c1"></span>    <span class="n">glm</span><span class="o">::</span><span class="n">ivec2</span>   <span class="n">Bearing</span><span class="p">;</span>    <span class="c1">// Offset from baseline to left/top of glyph
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">Advance</span><span class="p">;</span>    <span class="c1">// Offset to advance to next glyph
</span></span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl">
</span></span><span class="line"><span class="ln">8</span><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="n">Character</span><span class="o">&gt;</span> <span class="n">Characters</span><span class="p">;</span></span></span></code></pre></div><p>For this chapter we&rsquo;ll keep things simple by restricting ourselves to the first 128 characters of the ASCII character set. For each character, we generate a texture and store its relevant data into a Character struct that we add to the Characters map. This way, all data required to render each character is stored for later use.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">glPixelStorei</span><span class="p">(</span><span class="n">GL_UNPACK_ALIGNMENT</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// disable byte-alignment restriction
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1"></span>  
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="mi">128</span><span class="p">;</span> <span class="n">c</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="c1">// load character glyph 
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">FT_Load_Char</span><span class="p">(</span><span class="n">face</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">FT_LOAD_RENDER</span><span class="p">))</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;ERROR::FREETYTPE: Failed to load Glyph&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">        <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="c1">// generate texture
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">texture</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="n">glGenTextures</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">texture</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">texture</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="n">glTexImage2D</span><span class="p">(</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">        <span class="n">GL_TEXTURE_2D</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">        <span class="mi">0</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">        <span class="n">GL_RED</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">        <span class="n">face</span><span class="o">-&gt;</span><span class="n">glyph</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">.</span><span class="n">width</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">        <span class="n">face</span><span class="o">-&gt;</span><span class="n">glyph</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">.</span><span class="n">rows</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">        <span class="mi">0</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">        <span class="n">GL_RED</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">        <span class="n">GL_UNSIGNED_BYTE</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">        <span class="n">face</span><span class="o">-&gt;</span><span class="n">glyph</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">.</span><span class="n">buffer</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl">    <span class="p">);</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl">    <span class="c1">// set texture options
</span></span></span><span class="line"><span class="ln">27</span><span class="cl"><span class="c1"></span>    <span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_S</span><span class="p">,</span> <span class="n">GL_CLAMP_TO_EDGE</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">28</span><span class="cl">    <span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_T</span><span class="p">,</span> <span class="n">GL_CLAMP_TO_EDGE</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">29</span><span class="cl">    <span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MIN_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">30</span><span class="cl">    <span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MAG_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">31</span><span class="cl">    <span class="c1">// now store character for later use
</span></span></span><span class="line"><span class="ln">32</span><span class="cl"><span class="c1"></span>    <span class="n">Character</span> <span class="n">character</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">33</span><span class="cl">        <span class="n">texture</span><span class="p">,</span> 
</span></span><span class="line"><span class="ln">34</span><span class="cl">        <span class="n">glm</span><span class="o">::</span><span class="n">ivec2</span><span class="p">(</span><span class="n">face</span><span class="o">-&gt;</span><span class="n">glyph</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">face</span><span class="o">-&gt;</span><span class="n">glyph</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">.</span><span class="n">rows</span><span class="p">),</span>
</span></span><span class="line"><span class="ln">35</span><span class="cl">        <span class="n">glm</span><span class="o">::</span><span class="n">ivec2</span><span class="p">(</span><span class="n">face</span><span class="o">-&gt;</span><span class="n">glyph</span><span class="o">-&gt;</span><span class="n">bitmap_left</span><span class="p">,</span> <span class="n">face</span><span class="o">-&gt;</span><span class="n">glyph</span><span class="o">-&gt;</span><span class="n">bitmap_top</span><span class="p">),</span>
</span></span><span class="line"><span class="ln">36</span><span class="cl">        <span class="n">face</span><span class="o">-&gt;</span><span class="n">glyph</span><span class="o">-&gt;</span><span class="n">advance</span><span class="p">.</span><span class="n">x</span>
</span></span><span class="line"><span class="ln">37</span><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="ln">38</span><span class="cl">    <span class="n">Characters</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="n">Character</span><span class="o">&gt;</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">character</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">39</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>Within the for loop we list over all the 128 characters of the ASCII set and retrieve their corresponding character glyphs. For each character: we generate a texture, set its options, and store its metrics. What is interesting to note here is that we use GL_RED as the texture&rsquo;s <code>internalFormat</code> and <code>format</code> arguments. The bitmap generated from the glyph is a grayscale 8-bit image where each color is represented by a single byte. For this reason we&rsquo;d like to store each byte of the bitmap buffer as the texture&rsquo;s single color value. We accomplish this by creating a texture where each byte corresponds to the texture color&rsquo;s red component (first byte of its color vector). If we use a single byte to represent the colors of a texture we do need to take care of a restriction of OpenGL:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glPixelStorei</span><span class="p">(</span><span class="n">GL_UNPACK_ALIGNMENT</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>   
</span></span></code></pre></div><p>OpenGL requires that textures all have a 4-byte alignment e.g. their size is always a multiple of 4 bytes. Normally this won&rsquo;t be a problem since most textures have a width that is a multiple of 4 and/or use 4 bytes per pixel, but since we now only use a single byte per pixel, the texture can have any possible width. By setting its unpack alignment to <code>1</code> we ensure there are no alignment issues (which could cause segmentation faults).</p>
<p>Be sure to clear FreeType&rsquo;s resources once you&rsquo;re finished processing the glyphs:</p>
<div class="wrap-code highlight"><pre tabindex="0"><code>FT_Done_Face(face);
FT_Done_FreeType(ft);</code></pre></div><h5 id="shaders-1">Shaders</h5>
<p>To render the glyphs we&rsquo;ll be using the following vertex shader:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec4</span> <span class="n">vertex</span><span class="p">;</span> <span class="c1">// &lt;vec2 pos, vec2 tex&gt;
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="c1"></span><span class="n">out</span> <span class="n">vec2</span> <span class="n">TexCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">uniform</span> <span class="n">mat4</span> <span class="n">projection</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">projection</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">vertex</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="n">TexCoords</span> <span class="o">=</span> <span class="n">vertex</span><span class="p">.</span><span class="n">zw</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>We combine both the position and texture coordinate data into one vec4. The vertex shader multiplies the coordinates with a projection matrix and forwards the texture coordinates to the fragment shader:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">in</span> <span class="n">vec2</span> <span class="n">TexCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">out</span> <span class="n">vec4</span> <span class="n">color</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">text</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">uniform</span> <span class="n">vec3</span> <span class="n">textColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="p">{</span>    
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="n">vec4</span> <span class="n">sampled</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">texture</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">TexCoords</span><span class="p">).</span><span class="n">r</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="n">color</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">textColor</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">sampled</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>The fragment shader takes two uniforms: one is the mono-colored bitmap image of the glyph, and the other is a color uniform for adjusting the text&rsquo;s final color. We first sample the color value of the bitmap texture. Because the texture&rsquo;s data is stored in just its red component, we sample the <code>r</code> component of the texture as the sampled alpha value. By varying the output color&rsquo;s alpha value, the resulting pixel will be transparent for all the glyph&rsquo;s background colors and non-transparent for the actual character pixels. We also multiply the RGB colors by the textColor uniform to vary the text color.</p>
<p>We do need to enable <a href="https://learnopengl.com/Advanced-OpenGL/Blending" target="_blank">blending</a> for this to work though:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glEnable</span><span class="p">(</span><span class="n">GL_BLEND</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glBlendFunc</span><span class="p">(</span><span class="n">GL_SRC_ALPHA</span><span class="p">,</span> <span class="n">GL_ONE_MINUS_SRC_ALPHA</span><span class="p">);</span>  
</span></span></code></pre></div><p>For the projection matrix we&rsquo;ll be using an orthographic projection matrix. For rendering text we (usually) do not need perspective, and using an orthographic projection matrix also allows us to specify all vertex coordinates in screen coordinates if we set it up as follows:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span> <span class="n">projection</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">ortho</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">800.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">600.0f</span><span class="p">);</span></span></span></code></pre></div><p>We set the projection matrix&rsquo;s bottom parameter to <code>0.0f</code> and its top parameter equal to the window&rsquo;s height. The result is that we specify coordinates with <code>y</code> values ranging from the bottom part of the screen (<code>0.0f</code>) to the top part of the screen (<code>600.0f</code>). This means that the point (<code>0.0</code>, <code>0.0</code>) now corresponds to the bottom-left corner.</p>
<p>Last up is creating a VBO and VAO for rendering the quads. For now we reserve enough memory when initiating the VBO so that we can later update the VBO&rsquo;s memory when rendering characters:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">VAO</span><span class="p">,</span> <span class="n">VBO</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="n">glGenVertexArrays</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">VAO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">glGenBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">VBO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">VAO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">VBO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span> <span class="o">*</span> <span class="mi">6</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">GL_DYNAMIC_DRAW</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="n">glBindVertexArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>      
</span></span></code></pre></div><p>The 2D quad requires <code>6</code> vertices of <code>4</code> floats each, so we reserve <code>6 * 4</code> floats of memory. Because we&rsquo;ll be updating the content of the VBO&rsquo;s memory quite often we&rsquo;ll allocate the memory with GL_DYNAMIC_DRAW.</p>
<h5 id="render-line-of-text">Render line of text</h5>
<p>To render a character, we extract the corresponding Character struct of the Characters map and calculate the quad&rsquo;s dimensions using the character&rsquo;s metrics. With the quad&rsquo;s calculated dimensions we dynamically generate a set of 6 vertices that we use to update the content of the memory managed by the VBO using glBufferSubData.</p>
<p>We create a function called RenderText that renders a string of characters:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="nf">RenderText</span><span class="p">(</span><span class="n">Shader</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">text</span><span class="p">,</span> <span class="kt">float</span> <span class="n">x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">y</span><span class="p">,</span> <span class="kt">float</span> <span class="n">scale</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">color</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="c1">// activate corresponding render state	
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1"></span>    <span class="n">s</span><span class="p">.</span><span class="n">Use</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="n">glUniform3f</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">Program</span><span class="p">,</span> <span class="s">&#34;textColor&#34;</span><span class="p">),</span> <span class="n">color</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">color</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">color</span><span class="p">.</span><span class="n">z</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="n">glActiveTexture</span><span class="p">(</span><span class="n">GL_TEXTURE0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">VAO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="c1">// iterate through all characters
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">const_iterator</span> <span class="n">c</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">c</span> <span class="o">=</span> <span class="n">text</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">c</span> <span class="o">!=</span> <span class="n">text</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">c</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">        <span class="n">Character</span> <span class="n">ch</span> <span class="o">=</span> <span class="n">Characters</span><span class="p">[</span><span class="o">*</span><span class="n">c</span><span class="p">];</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">
</span></span><span class="line"><span class="ln">15</span><span class="cl">        <span class="kt">float</span> <span class="n">xpos</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">ch</span><span class="p">.</span><span class="n">Bearing</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">scale</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">        <span class="kt">float</span> <span class="n">ypos</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="p">(</span><span class="n">ch</span><span class="p">.</span><span class="n">Size</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">ch</span><span class="p">.</span><span class="n">Bearing</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="n">scale</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">
</span></span><span class="line"><span class="ln">18</span><span class="cl">        <span class="kt">float</span> <span class="n">w</span> <span class="o">=</span> <span class="n">ch</span><span class="p">.</span><span class="n">Size</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">scale</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">        <span class="kt">float</span> <span class="n">h</span> <span class="o">=</span> <span class="n">ch</span><span class="p">.</span><span class="n">Size</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">scale</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">        <span class="c1">// update VBO for each character
</span></span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="c1"></span>        <span class="kt">float</span> <span class="n">vertices</span><span class="p">[</span><span class="mi">6</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">            <span class="p">{</span> <span class="n">xpos</span><span class="p">,</span>     <span class="n">ypos</span> <span class="o">+</span> <span class="n">h</span><span class="p">,</span>   <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span> <span class="p">},</span>            
</span></span><span class="line"><span class="ln">23</span><span class="cl">            <span class="p">{</span> <span class="n">xpos</span><span class="p">,</span>     <span class="n">ypos</span><span class="p">,</span>       <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">1.0f</span> <span class="p">},</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">            <span class="p">{</span> <span class="n">xpos</span> <span class="o">+</span> <span class="n">w</span><span class="p">,</span> <span class="n">ypos</span><span class="p">,</span>       <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">1.0f</span> <span class="p">},</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl">
</span></span><span class="line"><span class="ln">26</span><span class="cl">            <span class="p">{</span> <span class="n">xpos</span><span class="p">,</span>     <span class="n">ypos</span> <span class="o">+</span> <span class="n">h</span><span class="p">,</span>   <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span> <span class="p">},</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl">            <span class="p">{</span> <span class="n">xpos</span> <span class="o">+</span> <span class="n">w</span><span class="p">,</span> <span class="n">ypos</span><span class="p">,</span>       <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">1.0f</span> <span class="p">},</span>
</span></span><span class="line"><span class="ln">28</span><span class="cl">            <span class="p">{</span> <span class="n">xpos</span> <span class="o">+</span> <span class="n">w</span><span class="p">,</span> <span class="n">ypos</span> <span class="o">+</span> <span class="n">h</span><span class="p">,</span>   <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.0f</span> <span class="p">}</span>           
</span></span><span class="line"><span class="ln">29</span><span class="cl">        <span class="p">};</span>
</span></span><span class="line"><span class="ln">30</span><span class="cl">        <span class="c1">// render glyph texture over quad
</span></span></span><span class="line"><span class="ln">31</span><span class="cl"><span class="c1"></span>        <span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">ch</span><span class="p">.</span><span class="n">textureID</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">32</span><span class="cl">        <span class="c1">// update content of VBO memory
</span></span></span><span class="line"><span class="ln">33</span><span class="cl"><span class="c1"></span>        <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">VBO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">34</span><span class="cl">        <span class="n">glBufferSubData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vertices</span><span class="p">),</span> <span class="n">vertices</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">35</span><span class="cl">        <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">36</span><span class="cl">        <span class="c1">// render quad
</span></span></span><span class="line"><span class="ln">37</span><span class="cl"><span class="c1"></span>        <span class="n">glDrawArrays</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">38</span><span class="cl">        <span class="c1">// now advance cursors for next glyph (note that advance is number of 1/64 pixels)
</span></span></span><span class="line"><span class="ln">39</span><span class="cl"><span class="c1"></span>        <span class="n">x</span> <span class="o">+=</span> <span class="p">(</span><span class="n">ch</span><span class="p">.</span><span class="n">Advance</span> <span class="o">&gt;&gt;</span> <span class="mi">6</span><span class="p">)</span> <span class="o">*</span> <span class="n">scale</span><span class="p">;</span> <span class="c1">// bitshift by 6 to get value in pixels (2^6 = 64)
</span></span></span><span class="line"><span class="ln">40</span><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="ln">41</span><span class="cl">    <span class="n">glBindVertexArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">42</span><span class="cl">    <span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">43</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>Most of the content of the function should be relatively self-explanatory: we first calculate the origin position of the quad (as xpos and ypos) and the quad&rsquo;s size (as w and h) and generate a set of 6 vertices to form the 2D quad; note that we scale each metric by scale. We then update the content of the VBO and render the quad.</p>
<p>The following line of code requires some extra attention though:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">float</span> <span class="n">ypos</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="p">(</span><span class="n">ch</span><span class="p">.</span><span class="n">Size</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">ch</span><span class="p">.</span><span class="n">Bearing</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>   
</span></span></code></pre></div><p>Some characters (like &lsquo;p&rsquo; or &lsquo;g&rsquo;) are rendered slightly below the baseline, so the quad should also be positioned slightly below RenderText&rsquo;s y value. The exact amount we need to offset ypos below the baseline can be figured out from the glyph metrics:</p>
<p><a href="#R-image-2acdd3feda57fe7065611b1308aef2ec" class="lightbox-link"><img src="./assets/glyph_offset.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-2acdd3feda57fe7065611b1308aef2ec"><img src="./assets/glyph_offset.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>To calculate this distance e.g. offset we need to figure out the distance a glyph extends below the baseline; this distance is indicated by the red arrow. As you can see from the glyph metrics, we can calculate the length of this vector by subtracting <code>bearingY</code> from the glyph&rsquo;s (bitmap) height. This value is then <code>0.0</code> for characters that rest on the baseline (like &lsquo;X&rsquo;) and positive for characters that reside slightly below the baseline (like &lsquo;g&rsquo; or &lsquo;j&rsquo;).</p>
<p>If you did everything correct you should now be able to successfully render strings of text with the following statements:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">RenderText</span><span class="p">(</span><span class="n">shader</span><span class="p">,</span> <span class="s">&#34;This is sample text&#34;</span><span class="p">,</span> <span class="mf">25.0f</span><span class="p">,</span> <span class="mf">25.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.8f</span><span class="p">,</span> <span class="mf">0.2f</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">RenderText</span><span class="p">(</span><span class="n">shader</span><span class="p">,</span> <span class="s">&#34;(C) LearnOpenGL.com&#34;</span><span class="p">,</span> <span class="mf">540.0f</span><span class="p">,</span> <span class="mf">570.0f</span><span class="p">,</span> <span class="mf">0.5f</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.7f</span><span class="p">,</span> <span class="mf">0.9f</span><span class="p">));</span></span></span></code></pre></div><p>This should then look similar to the following image:</p>
<p><a href="#R-image-bff66871dad2b9b6d34df8433bb14f8a" class="lightbox-link"><img src="./assets/text_rendering.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-bff66871dad2b9b6d34df8433bb14f8a"><img src="./assets/text_rendering.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>You can find the code of this example <a href="https://learnopengl.com/code_viewer_gh.php?code=src/7.in_practice/2.text_rendering/text_rendering.cpp" target="_blank">here</a>.</p>
<p>To give you a feel for how we calculated the quad&rsquo;s vertices, we can disable blending to see what the actual rendered quads look like:</p>
<p><a href="#R-image-684bcb695ebff245035e4c398909408f" class="lightbox-link"><img src="./assets/text_rendering_quads.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-684bcb695ebff245035e4c398909408f"><img src="./assets/text_rendering_quads.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Here you can clearly see most quads resting on the (imaginary) baseline while the quads that corresponds to glyphs like &lsquo;p&rsquo; or &lsquo;(&rsquo; are shifted downwards.</p>
<h4 id="going-further">Going further</h4>
<p>This chapter demonstrated a text rendering technique with TrueType fonts using the FreeType library. The approach is flexible, scalable, and works with many character encodings. However, this approach is likely going to be overkill for your application as we generate and render textures for each glyph. Performance-wise, bitmap fonts are preferable as we only need one texture for all our glyphs. The best approach would be to combine the two approaches by dynamically generating a bitmap font texture featuring all character glyphs as loaded with FreeType. This saves the renderer from a significant amount of texture switches and, based on how tight each glyph is packed, could save quite some performance.</p>
<p>Another issue with FreeType font bitmaps is that the glyph textures are stored with a fixed font size, so a significant amount of scaling may introduce jagged edges. Furthermore, rotations applied to the glyphs will cause them to appear blurry. This can be mitigated by, instead of storing the actual rasterized pixel colors, storing the distance to the closest glyph outline per pixel. This technique is called signed distance field fonts and Valve published a <a href="https://steamcdn-a.akamaihd.net/apps/valve/2007/SIGGRAPH2007_AlphaTestedMagnification.pdf" target="_blank">paper</a> a few years ago about their implementation of this technique which works surprisingly well for 3D rendering applications.</p>
<h4 id="further-reading-5">Further reading</h4>
<ul>
<li><a href="https://www.websiteplanet.com/blog/best-free-fonts/" target="_blank">70+ Best Free Fonts for Designers</a>: summarized list of a large group of fonts to use in your project for personal or commercial use.</div></li>
</ul>
<h3 id="2d-game">2D Game</h3>
<h4 id="breakout">Breakout</h4>
<p>Over these chapters we learned a fair share about OpenGL&rsquo;s inner workings and how we can use them to create fancy graphics. However, aside from a lot of tech demos, we haven&rsquo;t really created a practical application with OpenGL. This is the introduction of a larger series about creating a relatively simple 2D game using OpenGL. The next chapters will demonstrate how we can use OpenGL in a larger, more complicated, setting. Note that the series does not necessarily introduce new OpenGL concepts but more or less show how we can apply these concepts to a larger whole.</p>
<p>Because we rather keep things simple, we&rsquo;re going to base our 2D game on an already existing 2D arcade game. Introducing Breakout, a classic 2D game released in 1976 on the Atari 2600 console. Breakout requires the player, who controls a small horizontal paddle, to destroy all the bricks by bouncing a small ball against each brick without allowing the ball to reach the bottom edge. Once the player destroys all bricks, he completes the game.</p>
<p>Below we can see how Breakout originally looked on the Atari 2600:</p>
<p><a href="#R-image-9fb06ff681ef8c487b683b1e03413d19" class="lightbox-link"><img src="./assets/breakout2600.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-9fb06ff681ef8c487b683b1e03413d19"><img src="./assets/breakout2600.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>The game has the following mechanics:</p>
<ul>
<li>A small paddle is controlled by the player and can only move horizontally within the bounds of the screen.</li>
<li>The ball travels across the screen and each collision results in the ball changing its direction based on where it hit; this applies to the screen bounds, the bricks, and the paddle.</li>
<li>If the ball reaches the bottom edge of the screen, the player is either game over or loses a life.</li>
<li>As soon as a brick touches the ball, the brick is destroyed.</li>
<li>The player wins as soon as all bricks are destroyed.</li>
<li>The direction of the ball can be manipulated by how far the ball bounces from the paddle&rsquo;s center.</li>
</ul>
<p>Because from time to time the ball may find a small gap reaching the area above the brick wall, it will continue to bounce up and forth between the top edge of the level and the top edge of the brick layer. The ball keeps this up, until it eventually finds a gap again. This is logically where the game obtained its name from, since the ball has to <em>break out</em>.</p>
<h5 id="opengl-breakout">OpenGL Breakout</h5>
<p>We&rsquo;re going to take this classic arcade game as the basis of a 2D game that we&rsquo;ll completely implement with OpenGL. This version of Breakout will render its graphics on the GPU which gives us the ability to enhance the classical Breakout game with some nice extra features.</p>
<p>Other than the classic mechanics, our version of Breakout will feature:</p>
<ul>
<li>Amazing graphics!</li>
<li>Particles</li>
<li>Text rendering</li>
<li>Power-ups</li>
<li>Postprocessing effects</li>
<li>Multiple (customizable) levels</li>
</ul>
<p>To get you excited you can see what the game will look like after you&rsquo;ve finished these chapters:</p>
<p><a href="#R-image-8513d38798ab78b3b22bf5937e5e33b9" class="lightbox-link"><img src="./assets/cover.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-8513d38798ab78b3b22bf5937e5e33b9"><img src="./assets/cover.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>These chapters will combine a large number of concepts from previous chapters and demonstrate how they can work together as a whole. Therefore, it is important to have at least finished the <a href="https://learnopengl.com/Getting-started/OpenGL" target="_blank">Getting started</a> chapters before working your way through these series.</p>
<p>Also, several chapters will require concepts from other chapters (Framebuffers for example from the <a href="https://learnopengl.com/Advanced-OpenGL/Framebuffers" target="_blank">Advanced OpenGL</a> section) so where necessary, the required chapters are listed.</p>
<p>If you believe you&rsquo;re ready to get your hands dirty then move on to the <a href="https://learnopengl.com/In-Practice/2D-Game/Setting-up" target="_blank">next</a> chapter.</p>
<h4 id="setting-up">Setting up</h4>
<p>Before we get started with the game mechanics, we first need to set up a simple framework for the game to reside in. The game will use several third party libraries of which most have been introduced in earlier chapters. Wherever a new library is required, it will be properly introduced.</p>
<p>First, we define a so called uber game class that contains all relevant render and gameplay code. The idea of such a game class is that it (sort of) organizes your game code, while also decoupling all windowing code from the game. This way, you could use the same class in a completely different windowing library (like SDL or SFML for example) without much effort.</p>
<p><note>There are thousands of ways of trying to abstract and generalize game/graphics code into classes and objects. What you will see in these chapters is just one (relatively simple) approach to solve this issue. If you feel there is a better approach, try to come up with your own improvement of the implementation.</note></p>
<p>The game class hosts an initialization function, an update function, a function to process input, and a render function:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">class</span> <span class="nc">Game</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">        <span class="c1">// game state
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="c1"></span>        <span class="n">GameState</span>    <span class="n">State</span><span class="p">;</span>	
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">        <span class="kt">bool</span>         <span class="n">Keys</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">Width</span><span class="p">,</span> <span class="n">Height</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        <span class="c1">// constructor/destructor
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1"></span>        <span class="n">Game</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">height</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">        <span class="o">~</span><span class="n">Game</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">        <span class="c1">// initialize game state (load all shaders/textures/levels)
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="c1"></span>        <span class="kt">void</span> <span class="nf">Init</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">        <span class="c1">// game loop
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="c1"></span>        <span class="kt">void</span> <span class="nf">ProcessInput</span><span class="p">(</span><span class="kt">float</span> <span class="n">dt</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">        <span class="kt">void</span> <span class="nf">Update</span><span class="p">(</span><span class="kt">float</span> <span class="n">dt</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">        <span class="kt">void</span> <span class="nf">Render</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="p">};</span></span></span></code></pre></div><p>The class hosts what you may expect from a game class. We initialize the game with a width and height (the resolution you want to play the game in) and use the Init function to load shaders, textures, and initialize all gameplay state. We can process input as stored within the Keys array by calling ProcessInput, and update all gameplay events (like player/ball movement) in the Update function. Last, we can render the game by calling Render. Note that we split the movement logic from the render logic.</p>
<p>The Game class also hosts a variable called State which is of type GameState as defined below:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="c1">// Represents the current state of the game
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="c1"></span><span class="k">enum</span> <span class="nc">GameState</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="n">GAME_ACTIVE</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="n">GAME_MENU</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">    <span class="n">GAME_WIN</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="p">};</span> 
</span></span></code></pre></div><p>This allows us to keep track of what state the game is currently in. This way, we can decide to adjust rendering and/or processing based on the current state of the game (we probably render and process different items when we&rsquo;re in the game&rsquo;s menu for example).</p>
<p>As of now, the functions of the game class are completely empty since we have yet to write the actual game code, but here are the Game class&rsquo;s <a href="https://learnopengl.com/code_viewer_gh.php?code=src/7.in_practice/3.2d_game/0.full_source/progress/2.game.h" target="_blank">header</a> and <a href="https://learnopengl.com/code_viewer_gh.php?code=src/7.in_practice/3.2d_game/0.full_source/progress/2.game.cpp" target="_blank">code</a> file.</p>
<h5 id="utility">Utility</h5>
<p>Since we&rsquo;re creating a large application we&rsquo;ll frequently have to re-use several OpenGL concepts, like textures and shaders. It thus makes sense to create a more easy-to-use interface for these two items as similarly done in one of the earlier chapters where we created a shader class.</p>
<p>We define a shader class that generates a compiled shader (or generates error messages if it fails) from two or three strings (if a geometry shader is present). The shader class also contains a lot of useful utility functions to quickly set uniform values. We also define a texture class that generates a 2D texture image (based on its properties) from a byte array and a given width and height. Again, the texture class also hosts utility functions.</p>
<p>We won&rsquo;t delve into the details of the classes since by now you should easily understand how they work. For this reason you can find the header and code files, fully commented, below:</p>
<ul>
<li><strong>Shader</strong>: <a href="https://learnopengl.com/code_viewer_gh.php?code=src/7.in_practice/3.2d_game/0.full_source/shader.h" target="_blank">header</a>, <a href="https://learnopengl.com/code_viewer_gh.php?code=src/7.in_practice/3.2d_game/0.full_source/shader.cpp" target="_blank">code</a>.</li>
<li><strong>Texture</strong>: <a href="https://learnopengl.com/code_viewer_gh.php?code=src/7.in_practice/3.2d_game/0.full_source/texture.h" target="_blank">header</a>, <a href="https://learnopengl.com/code_viewer_gh.php?code=src/7.in_practice/3.2d_game/0.full_source/texture.cpp" target="_blank">code</a>.</li>
</ul>
<p>Note that the current texture class is solely designed for 2D textures only, but could easily be extended for alternative texture types.</p>
<h5 id="resource-management">Resource management</h5>
<p>While the shader and texture classes function great by themselves, they do require either a byte array or a list of strings for initialization. We could easily embed file loading code within the classes themselves, but this slightly violates the single responsibility principle. We&rsquo;d prefer these classes to only focus on either textures or shaders respectively, and not necessarily their file-loading mechanics.</p>
<p>For this reason it is often considered a more organized approach to create a single entity designed for loading game-related resources called a resource manager. There are several approaches to creating a resource manager; for this chapter we chose to use a singleton static resource manager that is (due to its static nature) always available throughout the project, hosting all loaded resources and their relevant loading functionality.</p>
<p>Using a singleton class with static functionality has several advantages and disadvantages, with its disadvantages mostly being the loss of several OOP properties and less control over construction/destruction. However, for relatively small projects like this it is easy to work with.</p>
<p>Like the other class files, the resource manager is listed below:</p>
<ul>
<li><strong>Resource Manager</strong>: <a href="https://learnopengl.com/code_viewer_gh.php?code=src/7.in_practice/3.2d_game/0.full_source/resource_manager.h" target="_blank">header</a>, <a href="https://learnopengl.com/code_viewer_gh.php?code=src/7.in_practice/3.2d_game/0.full_source/resource_manager.cpp" target="_blank">code</a>.</li>
</ul>
<p>Using the resource manager, we can easily load shaders into the program like:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">Shader</span> <span class="n">shader</span> <span class="o">=</span> <span class="n">ResourceManager</span><span class="o">::</span><span class="n">LoadShader</span><span class="p">(</span><span class="s">&#34;vertex.vs&#34;</span><span class="p">,</span> <span class="s">&#34;fragment.vs&#34;</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">,</span> <span class="s">&#34;test&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="c1">// then use it
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="c1"></span><span class="n">shader</span><span class="p">.</span><span class="n">Use</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="c1">// or
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="c1"></span><span class="n">ResourceManager</span><span class="o">::</span><span class="n">GetShader</span><span class="p">(</span><span class="s">&#34;test&#34;</span><span class="p">).</span><span class="n">Use</span><span class="p">();</span></span></span></code></pre></div><p>The defined Game class, together with the resource manager and the easily manageable Shader and Texture2D classes, form the basis for the next chapters as we&rsquo;ll be extensively using these classes to implement the Breakout game.</p>
<h5 id="program">Program</h5>
<p>We still need a window for the game and set some initial OpenGL state as we make use of OpenGL&rsquo;s <a href="https://learnopengl.com/Advanced-OpenGL/Blending" target="_blank">blending</a> functionality. We do not enable depth testing, since the game is entirely in 2D. All vertices are defined with the same z-values so enabling depth testing would be of no use and likely cause z-fighting.</p>
<p>The startup code of the Breakout game is relatively simple: we create a window with GLFW, register a few callback functions, create the Game object, and propagate all relevant functionality to the game class. The code is given below:</p>
<ul>
<li><strong>Program</strong>: <a href="https://learnopengl.com/code_viewer_gh.php?code=src/7.in_practice/3.2d_game/0.full_source/progress/2.program.cpp" target="_blank">code</a>.</li>
</ul>
<p>Running the code should give you the following output:</p>
<p><a href="#R-image-6605b493616696f6f85080beb3b4ef87" class="lightbox-link"><img src="./assets/setting-up.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-6605b493616696f6f85080beb3b4ef87"><img src="./assets/setting-up.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>By now we have a solid framework for the upcoming chapters; we&rsquo;ll be continuously extending the game class to host new functionality. Hop over to the <a href="https://learnopengl.com/In-Practice/2D-Game/Rendering-Sprites" target="_blank">next</a> chapter once you&rsquo;re ready.</p>
<h4 id="rendering-sprites">Rendering Sprites</h4>
<p>To bring some life to the currently black abyss of our game world, we will render sprites to fill the void. A sprite has many definitions, but it&rsquo;s effectively not much more than a 2D image used together with some data to position it in a larger world (e.g. position, rotation, and size). Basically, sprites are the render-able image/texture objects we use in a 2D game.</p>
<p>We can, just like we did in previous chapters, create a 2D shape out of vertex data, pass all data to the GPU, and transform it all by hand. However, in a larger application like this we rather have some abstractions on rendering 2D shapes. If we were to manually define these shapes and transformations for each object, it&rsquo;ll quickly get messy.</p>
<p>In this chapter we&rsquo;ll define a rendering class that allows us to render a large amount of unique sprites with a minimal amount of code. This way, we&rsquo;re abstracting the gameplay code from the gritty OpenGL rendering code as is commonly done in larger projects. First, we have to set up a proper projection matrix though.</p>
<h5 id="2d-projection-matrix">2D projection matrix</h5>
<p>We know from the <a href="https://learnopengl.com/Getting-started/Coordinate-Systems" target="_blank">coordinate systems</a> chapter that a projection matrix converts all view-space coordinates to clip-space (and then to normalized device) coordinates. By generating the appropriate projection matrix we can work with different coordinates that are easier to work with, compared to directly specifying all coordinates as normalized device coordinates.</p>
<p>We don&rsquo;t need any perspective applied to the coordinates, since the game is entirely in 2D, so an orthographic projection matrix would suit the rendering quite well. Because an orthographic projection matrix directly transforms all coordinates to normalized device coordinates, we can choose to specify the world coordinates as screen coordinates by defining the projection matrix as follows:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span> <span class="n">projection</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">ortho</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">800.0f</span><span class="p">,</span> <span class="mf">600.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">);</span>  
</span></span></code></pre></div><p>The first four arguments specify in order the left, right, bottom, and top part of the projection frustum. This projection matrix transforms all <code>x</code> coordinates between <code>0</code> and <code>800</code> to <code>-1</code> and <code>1</code>, and all <code>y</code> coordinates between <code>0</code> and <code>600</code> to <code>-1</code> and <code>1</code>. Here we specified that the top of the frustum has a <code>y</code> coordinate of <code>0</code>, while the bottom has a <code>y</code> coordinate of <code>600</code>. The result is that the top-left coordinate of the scene will be at (<code>0,0</code>) and the bottom-right part of the screen is at coordinate (<code>800,600</code>), just like screen coordinates; the world-space coordinates directly correspond to the resulting pixel coordinates.</p>
<p><a href="#R-image-92e67621d3a26a3c1ce4559a62b098d5" class="lightbox-link"><img src="./assets/projection.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-92e67621d3a26a3c1ce4559a62b098d5"><img src="./assets/projection.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>This allows us to specify all vertex coordinates equal to the pixel coordinates they end up in on the screen, which is rather intuitive for 2D games.</p>
<h5 id="rendering-sprites-1">Rendering sprites</h5>
<p>Rendering an actual sprite shouldn&rsquo;t be too complicated. We create a textured quad that we can transform with a model matrix, after which we project it using the previously defined orthographic projection matrix.</p>
<p><note>Since Breakout is a single-scene game, there is no need for a view/camera matrix. Using the projection matrix we can directly transform the world-space coordinates to normalized device coordinates.</note></p>
<p>To transform a sprite, we use the following vertex shader:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec4</span> <span class="n">vertex</span><span class="p">;</span> <span class="c1">// &lt;vec2 position, vec2 texCoords&gt;
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">out</span> <span class="n">vec2</span> <span class="n">TexCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">uniform</span> <span class="n">mat4</span> <span class="n">model</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="n">uniform</span> <span class="n">mat4</span> <span class="n">projection</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="n">TexCoords</span> <span class="o">=</span> <span class="n">vertex</span><span class="p">.</span><span class="n">zw</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">projection</span> <span class="o">*</span> <span class="n">model</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">vertex</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>Note that we store both the position and texture-coordinate data in a single vec4 variable. Because both the position and texture coordinates contain two floats, we can combine them in a single vertex attribute.</p>
<p>The fragment shader is relatively straightforward as well. We take a texture and a color vector that both affect the final color of the fragment. By having a uniform color vector, we can easily change the color of sprites from the game-code:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">in</span> <span class="n">vec2</span> <span class="n">TexCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">out</span> <span class="n">vec4</span> <span class="n">color</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">image</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">uniform</span> <span class="n">vec3</span> <span class="n">spriteColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="p">{</span>    
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="n">color</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">spriteColor</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">texture</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">TexCoords</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>To make the rendering of sprites more organized, we define a SpriteRenderer class that is able to render a sprite with just a single function. Its definition is as follows:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">class</span> <span class="nc">SpriteRenderer</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">        <span class="n">SpriteRenderer</span><span class="p">(</span><span class="n">Shader</span> <span class="o">&amp;</span><span class="n">shader</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">        <span class="o">~</span><span class="n">SpriteRenderer</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">        <span class="kt">void</span> <span class="nf">DrawSprite</span><span class="p">(</span><span class="n">Texture2D</span> <span class="o">&amp;</span><span class="n">texture</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec2</span> <span class="n">position</span><span class="p">,</span> 
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">            <span class="n">glm</span><span class="o">::</span><span class="n">vec2</span> <span class="n">size</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec2</span><span class="p">(</span><span class="mf">10.0f</span><span class="p">,</span> <span class="mf">10.0f</span><span class="p">),</span> <span class="kt">float</span> <span class="n">rotate</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">,</span> 
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">            <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">color</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">        <span class="n">Shader</span>       <span class="n">shader</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">12</span><span class="cl">        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">quadVAO</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">
</span></span><span class="line"><span class="ln">14</span><span class="cl">        <span class="kt">void</span> <span class="nf">initRenderData</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="p">};</span></span></span></code></pre></div><p>The SpriteRenderer class hosts a shader object, a single vertex array object, and a render and initialization function. Its constructor takes a shader object that it uses for all future rendering.</p>
<h6 id="initialization-1">Initialization</h6>
<p>First, let&rsquo;s delve into the initRenderData function that configures the quadVAO:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="n">SpriteRenderer</span><span class="o">::</span><span class="n">initRenderData</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="c1">// configure VAO/VBO
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">VBO</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="kt">float</span> <span class="n">vertices</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">        <span class="c1">// pos      // tex
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1"></span>        <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">        <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> 
</span></span><span class="line"><span class="ln">10</span><span class="cl">    
</span></span><span class="line"><span class="ln">11</span><span class="cl">        <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">        <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">        <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.0f</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="n">glGenVertexArrays</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">quadVAO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">    <span class="n">glGenBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">VBO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">    
</span></span><span class="line"><span class="ln">19</span><span class="cl">    <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">VBO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">    <span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vertices</span><span class="p">),</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">GL_STATIC_DRAW</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">
</span></span><span class="line"><span class="ln">22</span><span class="cl">    <span class="n">glBindVertexArray</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">quadVAO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">    <span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">    <span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl">    <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">26</span><span class="cl">    <span class="n">glBindVertexArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>Here we first define a set of vertices with (<code>0,0</code>) being the top-left corner of the quad. This means that when we apply translation or scaling transformations on the quad, they&rsquo;re transformed from the top-left position of the quad. This is commonly accepted in 2D graphics and/or GUI systems where elements&rsquo; positions correspond to the top-left corner of the elements.</p>
<p>Next we simply sent the vertices to the GPU and configure the vertex attributes, which in this case is a single vertex attribute. We only have to define a single VAO for the sprite renderer since all sprites share the same vertex data.</p>
<h6 id="rendering-2">Rendering</h6>
<p>Rendering sprites is not too difficult; we use the sprite renderer&rsquo;s shader, configure a model matrix, and set the relevant uniforms. What is important here is the order of transformations:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="n">SpriteRenderer</span><span class="o">::</span><span class="n">DrawSprite</span><span class="p">(</span><span class="n">Texture2D</span> <span class="o">&amp;</span><span class="n">texture</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec2</span> <span class="n">position</span><span class="p">,</span> 
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">  <span class="n">glm</span><span class="o">::</span><span class="n">vec2</span> <span class="n">size</span><span class="p">,</span> <span class="kt">float</span> <span class="n">rotate</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">color</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="c1">// prepare transformations
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="c1"></span>    <span class="k">this</span><span class="o">-&gt;</span><span class="n">shader</span><span class="p">.</span><span class="n">Use</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="n">glm</span><span class="o">::</span><span class="n">mat4</span> <span class="n">model</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="n">model</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">translate</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">));</span>  
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="n">model</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">translate</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.5f</span> <span class="o">*</span> <span class="n">size</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="mf">0.5f</span> <span class="o">*</span> <span class="n">size</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">));</span> 
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="n">model</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">rotate</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">radians</span><span class="p">(</span><span class="n">rotate</span><span class="p">),</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">));</span> 
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="n">model</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">translate</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5f</span> <span class="o">*</span> <span class="n">size</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5f</span> <span class="o">*</span> <span class="n">size</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="n">model</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">scale</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">));</span> 
</span></span><span class="line"><span class="ln">14</span><span class="cl">  
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="k">this</span><span class="o">-&gt;</span><span class="n">shader</span><span class="p">.</span><span class="n">SetMatrix4</span><span class="p">(</span><span class="s">&#34;model&#34;</span><span class="p">,</span> <span class="n">model</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="k">this</span><span class="o">-&gt;</span><span class="n">shader</span><span class="p">.</span><span class="n">SetVector3f</span><span class="p">(</span><span class="s">&#34;spriteColor&#34;</span><span class="p">,</span> <span class="n">color</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">  
</span></span><span class="line"><span class="ln">18</span><span class="cl">    <span class="n">glActiveTexture</span><span class="p">(</span><span class="n">GL_TEXTURE0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">    <span class="n">texture</span><span class="p">.</span><span class="n">Bind</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">
</span></span><span class="line"><span class="ln">21</span><span class="cl">    <span class="n">glBindVertexArray</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">quadVAO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">    <span class="n">glDrawArrays</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">    <span class="n">glBindVertexArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>When trying to position objects somewhere in a scene with rotation and scaling transformations, it is advised to first scale, then rotate, and finally translate the object. Because multiplying matrices occurs from right to left, we transform the matrix in reverse order: translate, rotate, and then scale.</p>
<p>The rotation transformation may still seem a bit daunting. We know from the <a href="https://learnopengl.com/Getting-started/Transformations" target="_blank">transformations</a> chapter that rotations always revolve around the origin (<code>0,0</code>). Because we specified the quad&rsquo;s vertices with (<code>0,0</code>) as the top-left coordinate, all rotations will rotate around this point of (<code>0,0</code>). The origin of rotation is at the top-left of the quad, which produces undesirable results. What we want to do is move the origin of rotation to the center of the quad so the quad neatly rotates around this origin, instead of rotating around the top-left of the quad. We solve this by translating the quad by half its size first, so its center is at coordinate (<code>0,0</code>) before rotating.</p>
<p><a href="#R-image-9749ec7c5748dde1044c9d3f557ddeee" class="lightbox-link"><img src="./assets/rotation-origin.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-9749ec7c5748dde1044c9d3f557ddeee"><img src="./assets/rotation-origin.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Since we first scale the quad, we have to take the size of the sprite into account when translating to the sprite&rsquo;s center, which is why we multiply with the sprite&rsquo;s size vector. Once the rotation transformation is applied, we reverse the previous translation.</p>
<p>Combining all these transformations, we can position, scale, and rotate each sprite in any way we like. Below you can find the complete source code of the sprite renderer:</p>
<ul>
<li><strong>SpriteRenderer</strong>: <a href="https://learnopengl.com/code_viewer_gh.php?code=src/7.in_practice/3.2d_game/0.full_source/sprite_renderer.h" target="_blank">header</a>, <a href="https://learnopengl.com/code_viewer_gh.php?code=src/7.in_practice/3.2d_game/0.full_source/sprite_renderer.cpp" target="_blank">code</a></li>
</ul>
<h5 id="hello-sprite">Hello sprite</h5>
<p>With the SpriteRenderer class we finally have the ability to render actual images to the screen! Let&rsquo;s initialize one within the game code and load our favorite <a href="https://learnopengl.com/img/textures/awesomeface.png" target="_blank">texture</a> while we&rsquo;re at it:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">SpriteRenderer</span>  <span class="o">*</span><span class="n">Renderer</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="kt">void</span> <span class="n">Game</span><span class="o">::</span><span class="n">Init</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="c1">// load shaders
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="c1"></span>    <span class="n">ResourceManager</span><span class="o">::</span><span class="n">LoadShader</span><span class="p">(</span><span class="s">&#34;shaders/sprite.vs&#34;</span><span class="p">,</span> <span class="s">&#34;shaders/sprite.frag&#34;</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">,</span> <span class="s">&#34;sprite&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="c1">// configure shaders
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="c1"></span>    <span class="n">glm</span><span class="o">::</span><span class="n">mat4</span> <span class="n">projection</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">ortho</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">Width</span><span class="p">),</span> 
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">        <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">Height</span><span class="p">),</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="n">ResourceManager</span><span class="o">::</span><span class="n">GetShader</span><span class="p">(</span><span class="s">&#34;sprite&#34;</span><span class="p">).</span><span class="n">Use</span><span class="p">().</span><span class="n">SetInteger</span><span class="p">(</span><span class="s">&#34;image&#34;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="n">ResourceManager</span><span class="o">::</span><span class="n">GetShader</span><span class="p">(</span><span class="s">&#34;sprite&#34;</span><span class="p">).</span><span class="n">SetMatrix4</span><span class="p">(</span><span class="s">&#34;projection&#34;</span><span class="p">,</span> <span class="n">projection</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="c1">// set render-specific controls
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="c1"></span>    <span class="n">Renderer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SpriteRenderer</span><span class="p">(</span><span class="n">ResourceManager</span><span class="o">::</span><span class="n">GetShader</span><span class="p">(</span><span class="s">&#34;sprite&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="c1">// load textures
</span></span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="c1"></span>    <span class="n">ResourceManager</span><span class="o">::</span><span class="n">LoadTexture</span><span class="p">(</span><span class="s">&#34;textures/awesomeface.png&#34;</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="s">&#34;face&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>Then within the render function we can render our beloved mascot to see if everything works as it should:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">void</span> <span class="n">Game</span><span class="o">::</span><span class="n">Render</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="n">Renderer</span><span class="o">-&gt;</span><span class="n">DrawSprite</span><span class="p">(</span><span class="n">ResourceManager</span><span class="o">::</span><span class="n">GetTexture</span><span class="p">(</span><span class="s">&#34;face&#34;</span><span class="p">),</span> 
</span></span><span class="line"><span class="ln">4</span><span class="cl">        <span class="n">glm</span><span class="o">::</span><span class="n">vec2</span><span class="p">(</span><span class="mf">200.0f</span><span class="p">,</span> <span class="mf">200.0f</span><span class="p">),</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec2</span><span class="p">(</span><span class="mf">300.0f</span><span class="p">,</span> <span class="mf">400.0f</span><span class="p">),</span> <span class="mf">45.0f</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>Here we position the sprite somewhat close to the center of the screen with its height being slightly larger than its width. We also rotate it by 45 degrees and give it a green color. Note that the position we give the sprite equals the top-left vertex of the sprite&rsquo;s quad.</p>
<p>If you did everything right you should get the following output:</p>
<p><a href="#R-image-f154beb9b80b16108c73bdeb010c2fa2" class="lightbox-link"><img src="./assets/rendering-sprites.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f154beb9b80b16108c73bdeb010c2fa2"><img src="./assets/rendering-sprites.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>You can find the updated game class&rsquo;s source code <a href="https://learnopengl.com/code_viewer_gh.php?code=src/7.in_practice/3.2d_game/0.full_source/progress/3.game.cpp" target="_blank">here</a>.</p>
<p>Now that we got the render systems working, we can put it to good use in the <a href="https://learnopengl.com/In-Practice/2D-Game/Levels" target="_blank">next</a> chapter where we&rsquo;ll work on building the game&rsquo;s levels.</p>
<h4 id="levels">Levels</h4>
<p>Breakout is unfortunately not just about a single happy green face, but contains complete levels with a lot of playfully colored bricks. We want these levels to be configurable such that they can support any number of rows and/or columns, we want the levels to have solid bricks (that cannot be destroyed), we want the levels to support multiple brick colors, and we want them to be stored externally in (text) files.</p>
<p>In this chapter we&rsquo;ll briefly walk through the code of a game level object that is used to manage a large amount of bricks. We first have to define what an actual brick is though.</p>
<p>We create a component called a game object that acts as the base representation of an object inside the game. Such a game object holds state data like its position, size, and velocity. It holds a color, a rotation component, whether it is solid and/or destroyed, and it also stores a Texture2D variable as its sprite.</p>
<p>Each object in the game is represented as a GameObject or a derivative of this class. You can find the code of the GameObject class below:</p>
<ul>
<li><strong>GameObject</strong>: <a href="https://learnopengl.com/code_viewer_gh.php?code=src/7.in_practice/3.2d_game/0.full_source/game_object.h" target="_blank">header</a>, <a href="https://learnopengl.com/code_viewer_gh.php?code=src/7.in_practice/3.2d_game/0.full_source/game_object.cpp" target="_blank">code</a></li>
</ul>
<p>A level in Breakout consists entirely of bricks so we can represent a level by exactly that: a collection of bricks. Because a brick requires the same state as a game object, we&rsquo;re going to represent each brick of the level as a GameObject. The declaration of the GameLevel class then looks as follows:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">class</span> <span class="nc">GameLevel</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="c1">// level state
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">GameObject</span><span class="o">&gt;</span> <span class="n">Bricks</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="c1">// constructor
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1"></span>    <span class="n">GameLevel</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="c1">// loads level from file
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="nf">Load</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">levelWidth</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">levelHeight</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="c1">// render level
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="nf">Draw</span><span class="p">(</span><span class="n">SpriteRenderer</span> <span class="o">&amp;</span><span class="n">renderer</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="c1">// check if the level is completed (all non-solid tiles are destroyed)
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="c1"></span>    <span class="kt">bool</span> <span class="nf">IsCompleted</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="c1">// initialize level from tile data
</span></span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="n">init</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">tileData</span><span class="p">,</span> 
</span></span><span class="line"><span class="ln">17</span><span class="cl">              <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">levelWidth</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">levelHeight</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="p">};</span>  
</span></span></code></pre></div><p>Since a level is loaded from an external (text) file, we need to propose some kind of level structure. Here is an example of what a game level may look like in a text file:</p>
<div class="wrap-code highlight"><pre tabindex="0"><code>1 1 1 1 1 1 
2 2 0 0 2 2
3 3 4 4 3 3</code></pre></div><p>A level is stored in a matrix-like structure where each number represents a type of brick, each one separated by a space. Within the level code we can then assign what each number represents. We have chosen the following representation:</p>
<ul>
<li>A number of 0: no brick, an empty space within the level.</li>
<li>A number of 1: a solid brick, a brick that cannot be destroyed.</li>
<li>A number higher than 1: a destroyable brick; each subsequent number only differs in color.</li>
</ul>
<p>The example level listed above would, after being processed by GameLevel, look like this:</p>
<p><a href="#R-image-37223bd99496e1dd2ced85c4e250c6da" class="lightbox-link"><img src="./assets/levels-example.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-37223bd99496e1dd2ced85c4e250c6da"><img src="./assets/levels-example.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>The GameLevel class uses two functions to generate a level from file. It first loads all the numbers in a two-dimensional vector within its Load function that then processes these numbers (to create all game objects) in its init function.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="n">GameLevel</span><span class="o">::</span><span class="n">Load</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">levelWidth</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">levelHeight</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="c1">// clear old data
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1"></span>    <span class="k">this</span><span class="o">-&gt;</span><span class="n">Bricks</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="c1">// load from file
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tileCode</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="n">GameLevel</span> <span class="n">level</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">line</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">ifstream</span> <span class="n">fstream</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">tileData</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">fstream</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">getline</span><span class="p">(</span><span class="n">fstream</span><span class="p">,</span> <span class="n">line</span><span class="p">))</span> <span class="c1">// read each line from level file
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="c1"></span>        <span class="p">{</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">            <span class="n">std</span><span class="o">::</span><span class="n">istringstream</span> <span class="n">sstream</span><span class="p">(</span><span class="n">line</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">            <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">row</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">            <span class="k">while</span> <span class="p">(</span><span class="n">sstream</span> <span class="o">&gt;&gt;</span> <span class="n">tileCode</span><span class="p">)</span> <span class="c1">// read each word separated by spaces
</span></span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="c1"></span>                <span class="n">row</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tileCode</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">            <span class="n">tileData</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">row</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">tileData</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">            <span class="k">this</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">(</span><span class="n">tileData</span><span class="p">,</span> <span class="n">levelWidth</span><span class="p">,</span> <span class="n">levelHeight</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl"><span class="p">}</span> 
</span></span></code></pre></div><p>The loaded tileData is then passed to the game level&rsquo;s init function:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="n">GameLevel</span><span class="o">::</span><span class="n">init</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">tileData</span><span class="p">,</span> 
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">                     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lvlWidth</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lvlHeight</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="c1">// calculate dimensions
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">height</span> <span class="o">=</span> <span class="n">tileData</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">width</span>  <span class="o">=</span> <span class="n">tileData</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="kt">float</span> <span class="n">unit_width</span>    <span class="o">=</span> <span class="n">lvlWidth</span> <span class="o">/</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">width</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="kt">float</span> <span class="n">unit_height</span>   <span class="o">=</span> <span class="n">lvlHeight</span> <span class="o">/</span> <span class="n">height</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="c1">// initialize level tiles based on tileData		
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">height</span><span class="p">;</span> <span class="o">++</span><span class="n">y</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">;</span> <span class="o">++</span><span class="n">x</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">            <span class="c1">// check block type from level data (2D level array)
</span></span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">tileData</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// solid
</span></span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="c1"></span>            <span class="p">{</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">                <span class="n">glm</span><span class="o">::</span><span class="n">vec2</span> <span class="n">pos</span><span class="p">(</span><span class="n">unit_width</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="n">unit_height</span> <span class="o">*</span> <span class="n">y</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">                <span class="n">glm</span><span class="o">::</span><span class="n">vec2</span> <span class="n">size</span><span class="p">(</span><span class="n">unit_width</span><span class="p">,</span> <span class="n">unit_height</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">                <span class="n">GameObject</span> <span class="nf">obj</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> 
</span></span><span class="line"><span class="ln">20</span><span class="cl">                    <span class="n">ResourceManager</span><span class="o">::</span><span class="n">GetTexture</span><span class="p">(</span><span class="s">&#34;block_solid&#34;</span><span class="p">),</span> 
</span></span><span class="line"><span class="ln">21</span><span class="cl">                    <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.8f</span><span class="p">,</span> <span class="mf">0.8f</span><span class="p">,</span> <span class="mf">0.7f</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">                <span class="p">);</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">                <span class="n">obj</span><span class="p">.</span><span class="n">IsSolid</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">                <span class="k">this</span><span class="o">-&gt;</span><span class="n">Bricks</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl">            <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">tileData</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>	
</span></span><span class="line"><span class="ln">27</span><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="ln">28</span><span class="cl">                <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">color</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">);</span> <span class="c1">// original: white
</span></span></span><span class="line"><span class="ln">29</span><span class="cl"><span class="c1"></span>                <span class="k">if</span> <span class="p">(</span><span class="n">tileData</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">30</span><span class="cl">                    <span class="n">color</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.2f</span><span class="p">,</span> <span class="mf">0.6f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">31</span><span class="cl">                <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tileData</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">32</span><span class="cl">                    <span class="n">color</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.7f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">33</span><span class="cl">                <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tileData</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">34</span><span class="cl">                    <span class="n">color</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.8f</span><span class="p">,</span> <span class="mf">0.8f</span><span class="p">,</span> <span class="mf">0.4f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">35</span><span class="cl">                <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tileData</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">36</span><span class="cl">                    <span class="n">color</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">37</span><span class="cl">
</span></span><span class="line"><span class="ln">38</span><span class="cl">                <span class="n">glm</span><span class="o">::</span><span class="n">vec2</span> <span class="n">pos</span><span class="p">(</span><span class="n">unit_width</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="n">unit_height</span> <span class="o">*</span> <span class="n">y</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">39</span><span class="cl">                <span class="n">glm</span><span class="o">::</span><span class="n">vec2</span> <span class="n">size</span><span class="p">(</span><span class="n">unit_width</span><span class="p">,</span> <span class="n">unit_height</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">40</span><span class="cl">                <span class="k">this</span><span class="o">-&gt;</span><span class="n">Bricks</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span>
</span></span><span class="line"><span class="ln">41</span><span class="cl">                    <span class="n">GameObject</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">ResourceManager</span><span class="o">::</span><span class="n">GetTexture</span><span class="p">(</span><span class="s">&#34;block&#34;</span><span class="p">),</span> <span class="n">color</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">42</span><span class="cl">                <span class="p">);</span>
</span></span><span class="line"><span class="ln">43</span><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="ln">44</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln">45</span><span class="cl">    <span class="p">}</span>  
</span></span><span class="line"><span class="ln">46</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>The init function iterates through each of the loaded numbers and adds a GameObject to the level&rsquo;s Bricks vector based on the processed number. The size of each brick is automatically calculated (unit_width and unit_height) based on the total number of bricks so that each brick perfectly fits within the screen bounds.</p>
<p>Here we load the game objects with two new textures, a <a href="https://learnopengl.com/img/in-practice/breakout/textures/block.png" target="_blank">block</a> texture and a <a href="https://learnopengl.com/img/in-practice/breakout/textures/block_solid.png" target="_blank">solid block</a> texture.</p>
<p><a href="#R-image-9fd221ee40c7de340ca880617537d09f" class="lightbox-link"><img src="./assets/block-textures.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-9fd221ee40c7de340ca880617537d09f"><img src="./assets/block-textures.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>A nice little trick here is that these textures are completely in gray-scale. The effect is that we can neatly manipulate their colors within the game-code by multiplying their grayscale colors with a defined color vector; exactly as we did within the SpriteRenderer. This way, customizing the appearance of their colors doesn&rsquo;t look too weird or unbalanced.</p>
<p>The GameLevel class also houses a few other functions, like rendering all non-destroyed bricks, or validating if all non-solid bricks are destroyed. You can find the source code of the GameLevel class below:</p>
<ul>
<li><strong>GameLevel</strong>: <a href="https://learnopengl.com/code_viewer_gh.php?code=src/7.in_practice/3.2d_game/0.full_source/game_level.h" target="_blank">header</a>, <a href="https://learnopengl.com/code_viewer_gh.php?code=src/7.in_practice/3.2d_game/0.full_source/game_level.cpp" target="_blank">code</a></li>
</ul>
<p>The game level class gives us a lot of flexibility since any amount of rows and columns are supported and a user could easily create his/her own levels by modifying the level files.</p>
<h5 id="within-the-game">Within the game</h5>
<p>We would like to support multiple levels in the Breakout game so we&rsquo;ll have to extend the game class a little by adding a vector that holds variables of type GameLevel. We&rsquo;ll also store the currently active level while we&rsquo;re at it:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">class</span> <span class="nc">Game</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="p">[...]</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">GameLevel</span><span class="o">&gt;</span> <span class="n">Levels</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">    <span class="kt">unsigned</span> <span class="kt">int</span>           <span class="n">Level</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">    <span class="p">[...]</span>  
</span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="p">};</span></span></span></code></pre></div><p>This series&rsquo; version of the Breakout game features a total of 4 levels:</p>
<ul>
<li><a href="https://learnopengl.com/code_viewer_gh.php?code=src/7.in_practice/3.2d_game/0.full_source/levels/one.lvl" target="_blank">Standard</a></li>
<li><a href="https://learnopengl.com/code_viewer_gh.php?code=src/7.in_practice/3.2d_game/0.full_source/levels/two.lvl" target="_blank">A few small gaps</a></li>
<li><a href="https://learnopengl.com/code_viewer_gh.php?code=src/7.in_practice/3.2d_game/0.full_source/levels/three.lvl" target="_blank">Space invader</a></li>
<li><a href="https://learnopengl.com/code_viewer_gh.php?code=src/7.in_practice/3.2d_game/0.full_source/levels/four.lvl" target="_blank">Bounce galore</a></li>
</ul>
<p>Each of the textures and levels are then initialized within the game class&rsquo;s Init function:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="n">Game</span><span class="o">::</span><span class="n">Init</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="p">[...]</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="c1">// load textures
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="c1"></span>    <span class="n">ResourceManager</span><span class="o">::</span><span class="n">LoadTexture</span><span class="p">(</span><span class="s">&#34;textures/background.jpg&#34;</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="s">&#34;background&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="n">ResourceManager</span><span class="o">::</span><span class="n">LoadTexture</span><span class="p">(</span><span class="s">&#34;textures/awesomeface.png&#34;</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="s">&#34;face&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="n">ResourceManager</span><span class="o">::</span><span class="n">LoadTexture</span><span class="p">(</span><span class="s">&#34;textures/block.png&#34;</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="s">&#34;block&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="n">ResourceManager</span><span class="o">::</span><span class="n">LoadTexture</span><span class="p">(</span><span class="s">&#34;textures/block_solid.png&#34;</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="s">&#34;block_solid&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="c1">// load levels
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1"></span>    <span class="n">GameLevel</span> <span class="n">one</span><span class="p">;</span> <span class="n">one</span><span class="p">.</span><span class="n">Load</span><span class="p">(</span><span class="s">&#34;levels/one.lvl&#34;</span><span class="p">,</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">Width</span><span class="p">,</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">Height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="n">GameLevel</span> <span class="n">two</span><span class="p">;</span> <span class="n">two</span><span class="p">.</span><span class="n">Load</span><span class="p">(</span><span class="s">&#34;levels/two.lvl&#34;</span><span class="p">,</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">Width</span><span class="p">,</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">Height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="n">GameLevel</span> <span class="n">three</span><span class="p">;</span> <span class="n">three</span><span class="p">.</span><span class="n">Load</span><span class="p">(</span><span class="s">&#34;levels/three.lvl&#34;</span><span class="p">,</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">Width</span><span class="p">,</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">Height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="n">GameLevel</span> <span class="n">four</span><span class="p">;</span> <span class="n">four</span><span class="p">.</span><span class="n">Load</span><span class="p">(</span><span class="s">&#34;levels/four.lvl&#34;</span><span class="p">,</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">Width</span><span class="p">,</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">Height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="k">this</span><span class="o">-&gt;</span><span class="n">Levels</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">one</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="k">this</span><span class="o">-&gt;</span><span class="n">Levels</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">two</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="k">this</span><span class="o">-&gt;</span><span class="n">Levels</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">three</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">    <span class="k">this</span><span class="o">-&gt;</span><span class="n">Levels</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">four</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">    <span class="k">this</span><span class="o">-&gt;</span><span class="n">Level</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>Now all that is left to do, is actually render the level. We accomplish this by calling the currently active level&rsquo;s Draw function that in turn calls each GameObject&rsquo;s Draw function using the given sprite renderer. Next to the level, we&rsquo;ll also render the scene with a nice <a href="https://learnopengl.com/img/in-practice/breakout/textures/background.jpg" target="_blank">background image</a> (courtesy of Tenha):</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="n">Game</span><span class="o">::</span><span class="n">Render</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">State</span> <span class="o">==</span> <span class="n">GAME_ACTIVE</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">        <span class="c1">// draw background
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="c1"></span>        <span class="n">Renderer</span><span class="o">-&gt;</span><span class="n">DrawSprite</span><span class="p">(</span><span class="n">ResourceManager</span><span class="o">::</span><span class="n">GetTexture</span><span class="p">(</span><span class="s">&#34;background&#34;</span><span class="p">),</span> 
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">            <span class="n">glm</span><span class="o">::</span><span class="n">vec2</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">),</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec2</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">Width</span><span class="p">,</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">Height</span><span class="p">),</span> <span class="mf">0.0f</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        <span class="p">);</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">        <span class="c1">// draw level
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1"></span>        <span class="k">this</span><span class="o">-&gt;</span><span class="n">Levels</span><span class="p">[</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">Level</span><span class="p">].</span><span class="n">Draw</span><span class="p">(</span><span class="o">*</span><span class="n">Renderer</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>The result is then a nicely rendered level that really starts to make the game feel more alive:</p>
<p><a href="#R-image-d9b08f8340f9c3b6f5db7daa502b1e8b" class="lightbox-link"><img src="./assets/levels.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d9b08f8340f9c3b6f5db7daa502b1e8b"><img src="./assets/levels.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<h6 id="the-player-paddle">The player paddle</h6>
<p>While we&rsquo;re at it, we may just as well introduce a paddle at the bottom of the scene that is controlled by the player. The paddle only allows for horizontal movement and whenever it touches any of the scene&rsquo;s edges, its movement should halt. For the player paddle we&rsquo;re going to use the <a href="https://learnopengl.com/img/in-practice/breakout/textures/paddle.png" target="_blank">following</a> texture:</p>
<p><a href="#R-image-6a984fea0dc70791ddea487474d8a131" class="lightbox-link"><img src="./assets/paddle.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-6a984fea0dc70791ddea487474d8a131"><img src="./assets/paddle.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>A paddle object will have a position, a size, and a sprite texture, so it makes sense to define the paddle as a GameObject as well:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="c1">// Initial size of the player paddle
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec2</span> <span class="n">PLAYER_SIZE</span><span class="p">(</span><span class="mf">100.0f</span><span class="p">,</span> <span class="mf">20.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="c1">// Initial velocity of the player paddle
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">float</span> <span class="nf">PLAYER_VELOCITY</span><span class="p">(</span><span class="mf">500.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">GameObject</span>      <span class="o">*</span><span class="n">Player</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="kt">void</span> <span class="n">Game</span><span class="o">::</span><span class="n">Init</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="p">[...]</span>    
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="n">ResourceManager</span><span class="o">::</span><span class="n">LoadTexture</span><span class="p">(</span><span class="s">&#34;textures/paddle.png&#34;</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="s">&#34;paddle&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="p">[...]</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="n">glm</span><span class="o">::</span><span class="n">vec2</span> <span class="n">playerPos</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec2</span><span class="p">(</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">        <span class="k">this</span><span class="o">-&gt;</span><span class="n">Width</span> <span class="o">/</span> <span class="mf">2.0f</span> <span class="o">-</span> <span class="n">PLAYER_SIZE</span><span class="p">.</span><span class="n">x</span> <span class="o">/</span> <span class="mf">2.0f</span><span class="p">,</span> 
</span></span><span class="line"><span class="ln">15</span><span class="cl">        <span class="k">this</span><span class="o">-&gt;</span><span class="n">Height</span> <span class="o">-</span> <span class="n">PLAYER_SIZE</span><span class="p">.</span><span class="n">y</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="p">);</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">    <span class="n">Player</span> <span class="o">=</span> <span class="k">new</span> <span class="n">GameObject</span><span class="p">(</span><span class="n">playerPos</span><span class="p">,</span> <span class="n">PLAYER_SIZE</span><span class="p">,</span> <span class="n">ResourceManager</span><span class="o">::</span><span class="n">GetTexture</span><span class="p">(</span><span class="s">&#34;paddle&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>Here we defined several constant values that define the paddle&rsquo;s size and speed. Within the Game&rsquo;s Init function we calculate the starting position of the paddle within the scene. We make sure the player paddle&rsquo;s center is aligned with the horizontal center of the scene.</p>
<p>With the player paddle initialized, we also need to add a statement to the Game&rsquo;s Render function:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">Player</span><span class="o">-&gt;</span><span class="n">Draw</span><span class="p">(</span><span class="o">*</span><span class="n">Renderer</span><span class="p">);</span>  
</span></span></code></pre></div><p>If you&rsquo;d start the game now, you would not only see the level, but also a fancy player paddle aligned to the bottom edge of the scene. As of now, it doesn&rsquo;t really do anything so we&rsquo;re going to delve into the Game&rsquo;s ProcessInput function to horizontally move the paddle whenever the user presses the A or D key:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="n">Game</span><span class="o">::</span><span class="n">ProcessInput</span><span class="p">(</span><span class="kt">float</span> <span class="n">dt</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">State</span> <span class="o">==</span> <span class="n">GAME_ACTIVE</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">        <span class="kt">float</span> <span class="n">velocity</span> <span class="o">=</span> <span class="n">PLAYER_VELOCITY</span> <span class="o">*</span> <span class="n">dt</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">        <span class="c1">// move playerboard
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">[</span><span class="n">GLFW_KEY_A</span><span class="p">])</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">Player</span><span class="o">-&gt;</span><span class="n">Position</span><span class="p">.</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="mf">0.0f</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">                <span class="n">Player</span><span class="o">-&gt;</span><span class="n">Position</span><span class="p">.</span><span class="n">x</span> <span class="o">-=</span> <span class="n">velocity</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">[</span><span class="n">GLFW_KEY_D</span><span class="p">])</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">Player</span><span class="o">-&gt;</span><span class="n">Position</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">Width</span> <span class="o">-</span> <span class="n">Player</span><span class="o">-&gt;</span><span class="n">Size</span><span class="p">.</span><span class="n">x</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">                <span class="n">Player</span><span class="o">-&gt;</span><span class="n">Position</span><span class="p">.</span><span class="n">x</span> <span class="o">+=</span> <span class="n">velocity</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="p">}</span> 
</span></span></code></pre></div><p>Here we move the player paddle either in the left or right direction based on which key the user pressed (note how we multiply the velocity with the deltatime variable). If the paddle&rsquo;s <code>x</code> value would be less than <code>0</code> it would&rsquo;ve moved outside the left edge, so we only move the paddle to the left if the paddle&rsquo;s <code>x</code> value is higher than the left edge&rsquo;s <code>x</code> position (<code>0.0</code>). We do the same for when the paddle breaches the right edge, but we have to compare the right edge&rsquo;s position with the right edge of the paddle (subtract the paddle&rsquo;s width from the right edge&rsquo;s <code>x</code> position).</p>
<p>Now running the game gives us a player paddle that we can move all across the bottom edge:</p>
<p><a href="#R-image-69ea68f761a5a1e0fb8ce3b292ef4742" class="lightbox-link"><img src="./assets/levels-player.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-69ea68f761a5a1e0fb8ce3b292ef4742"><img src="./assets/levels-player.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>You can find the updated code of the Game class here:</p>
<ul>
<li><strong>Game</strong>: <a href="https://learnopengl.com/code_viewer_gh.php?code=src/7.in_practice/3.2d_game/0.full_source/progress/4.game.h" target="_blank">header</a>, <a href="https://learnopengl.com/code_viewer_gh.php?code=src/7.in_practice/3.2d_game/0.full_source/progress/4.game.cpp" target="_blank">code</a></li>
</ul>
<h4 id="collisions">Collisions</h4>
<h5 id="ball">Ball</h5>
<p>At this point we have a level full of bricks and a movable player paddle. The only thing missing from the classic Breakout recipe is the ball. The objective is to let the ball collide with all the bricks until each of the destroyable bricks are destroyed, but this all within the condition that the ball is not allowed to reach the bottom edge of the screen.</p>
<p>In addition to the general game object components, a ball has a radius, and an extra boolean value indicating whether the ball is stuck on the player paddle or it&rsquo;s allowed free movement. When the game starts, the ball is initially stuck on the player paddle until the player starts the game by pressing some arbitrary key.</p>
<p>Because the ball is effectively a GameObject with a few extra properties it makes sense to create a BallObject class as a subclass of GameObject:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">class</span> <span class="nc">BallObject</span> <span class="o">:</span> <span class="k">public</span> <span class="n">GameObject</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">        <span class="c1">// ball state	
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="c1"></span>        <span class="kt">float</span>     <span class="n">Radius</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">        <span class="kt">bool</span>      <span class="n">Stuck</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">        <span class="n">BallObject</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">        <span class="n">BallObject</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">vec2</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">float</span> <span class="n">radius</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec2</span> <span class="n">velocity</span><span class="p">,</span> <span class="n">Texture2D</span> <span class="n">sprite</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">
</span></span><span class="line"><span class="ln">12</span><span class="cl">        <span class="n">glm</span><span class="o">::</span><span class="n">vec2</span> <span class="n">Move</span><span class="p">(</span><span class="kt">float</span> <span class="n">dt</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">window_width</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">        <span class="kt">void</span>      <span class="nf">Reset</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">vec2</span> <span class="n">position</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec2</span> <span class="n">velocity</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="p">};</span> 
</span></span></code></pre></div><p>The constructor of BallObject initializes its own values, but also initializes the underlying GameObject. The BallObject class hosts a Move function that moves the ball based on its velocity. It also checks if it reaches any of the scene&rsquo;s edges and if so, reverses the ball&rsquo;s velocity:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">vec2</span> <span class="n">BallObject</span><span class="o">::</span><span class="n">Move</span><span class="p">(</span><span class="kt">float</span> <span class="n">dt</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">window_width</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="c1">// if not stuck to player board
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">Stuck</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="p">{</span> 
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">        <span class="c1">// move the ball
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1"></span>        <span class="k">this</span><span class="o">-&gt;</span><span class="n">Position</span> <span class="o">+=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">Velocity</span> <span class="o">*</span> <span class="n">dt</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        <span class="c1">// check if outside window bounds; if so, reverse velocity and restore at correct position
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">Position</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="mf">0.0f</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">            <span class="k">this</span><span class="o">-&gt;</span><span class="n">Velocity</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">Velocity</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">            <span class="k">this</span><span class="o">-&gt;</span><span class="n">Position</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">        <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">Position</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">Size</span><span class="p">.</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="n">window_width</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">            <span class="k">this</span><span class="o">-&gt;</span><span class="n">Velocity</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">Velocity</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">            <span class="k">this</span><span class="o">-&gt;</span><span class="n">Position</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">window_width</span> <span class="o">-</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">Size</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">Position</span><span class="p">.</span><span class="n">y</span> <span class="o">&lt;=</span> <span class="mf">0.0f</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">            <span class="k">this</span><span class="o">-&gt;</span><span class="n">Velocity</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="o">-</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">Velocity</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">            <span class="k">this</span><span class="o">-&gt;</span><span class="n">Position</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">      
</span></span><span class="line"><span class="ln">25</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl">    <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">Position</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>In addition to reversing the ball&rsquo;s velocity, we also want relocate the ball back along the edge; the ball is only able to move if it isn&rsquo;t stuck.</p>
<p><note>Because the player is game over (or loses a life) if the ball reaches the bottom edge, there is no code to let the ball bounce of the bottom edge. We do need to later implement this logic somewhere in the game code though.</note></p>
<p>You can find the code for the ball object below:</p>
<ul>
<li><strong>BallObject</strong>: <a href="https://learnopengl.com/code_viewer_gh.php?code=src/7.in_practice/3.2d_game/0.full_source/progress/5.1.ball_object_collisions.h" target="_blank">header</a>, <a href="https://learnopengl.com/code_viewer_gh.php?code=src/7.in_practice/3.2d_game/0.full_source/progress/5.1.ball_object_collisions.cpp" target="_blank">code</a></li>
</ul>
<p>First, let&rsquo;s add the ball to the game. Just like the player paddle, we create a BallObject and define two constants that we use to initialize the ball. As for the texture of the ball, we&rsquo;re going to use an image that makes perfect sense in a LearnOpenGL Breakout game: <a href="https://learnopengl.com/img/textures/awesomeface.png" target="_blank">ball texture</a>.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="c1">// Initial velocity of the Ball
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec2</span> <span class="n">INITIAL_BALL_VELOCITY</span><span class="p">(</span><span class="mf">100.0f</span><span class="p">,</span> <span class="o">-</span><span class="mf">350.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="c1">// Radius of the ball object
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">float</span> <span class="n">BALL_RADIUS</span> <span class="o">=</span> <span class="mf">12.5f</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">BallObject</span>     <span class="o">*</span><span class="n">Ball</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="kt">void</span> <span class="n">Game</span><span class="o">::</span><span class="n">Init</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="p">[...]</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="n">glm</span><span class="o">::</span><span class="n">vec2</span> <span class="n">ballPos</span> <span class="o">=</span> <span class="n">playerPos</span> <span class="o">+</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec2</span><span class="p">(</span><span class="n">PLAYER_SIZE</span><span class="p">.</span><span class="n">x</span> <span class="o">/</span> <span class="mf">2.0f</span> <span class="o">-</span> <span class="n">BALL_RADIUS</span><span class="p">,</span> 
</span></span><span class="line"><span class="ln">12</span><span class="cl">                                              <span class="o">-</span><span class="n">BALL_RADIUS</span> <span class="o">*</span> <span class="mf">2.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="n">Ball</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BallObject</span><span class="p">(</span><span class="n">ballPos</span><span class="p">,</span> <span class="n">BALL_RADIUS</span><span class="p">,</span> <span class="n">INITIAL_BALL_VELOCITY</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">        <span class="n">ResourceManager</span><span class="o">::</span><span class="n">GetTexture</span><span class="p">(</span><span class="s">&#34;face&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>Then we have to update the position of the ball each frame by calling its Move function within the game code&rsquo;s Update function:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">void</span> <span class="n">Game</span><span class="o">::</span><span class="n">Update</span><span class="p">(</span><span class="kt">float</span> <span class="n">dt</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="n">Ball</span><span class="o">-&gt;</span><span class="n">Move</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">Width</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>Furthermore, because the ball is initially stuck to the paddle, we have to give the player the ability to remove it from its stuck position. We select the space key for freeing the ball from the paddle. This means we have to change the processInput function a little:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="n">Game</span><span class="o">::</span><span class="n">ProcessInput</span><span class="p">(</span><span class="kt">float</span> <span class="n">dt</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">State</span> <span class="o">==</span> <span class="n">GAME_ACTIVE</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">        <span class="kt">float</span> <span class="n">velocity</span> <span class="o">=</span> <span class="n">PLAYER_VELOCITY</span> <span class="o">*</span> <span class="n">dt</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">        <span class="c1">// move playerboard
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">[</span><span class="n">GLFW_KEY_A</span><span class="p">])</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">Player</span><span class="o">-&gt;</span><span class="n">Position</span><span class="p">.</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="mf">0.0f</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">                <span class="n">Player</span><span class="o">-&gt;</span><span class="n">Position</span><span class="p">.</span><span class="n">x</span> <span class="o">-=</span> <span class="n">velocity</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">Ball</span><span class="o">-&gt;</span><span class="n">Stuck</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">                    <span class="n">Ball</span><span class="o">-&gt;</span><span class="n">Position</span><span class="p">.</span><span class="n">x</span> <span class="o">-=</span> <span class="n">velocity</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">[</span><span class="n">GLFW_KEY_D</span><span class="p">])</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">Player</span><span class="o">-&gt;</span><span class="n">Position</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">Width</span> <span class="o">-</span> <span class="n">Player</span><span class="o">-&gt;</span><span class="n">Size</span><span class="p">.</span><span class="n">x</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">                <span class="n">Player</span><span class="o">-&gt;</span><span class="n">Position</span><span class="p">.</span><span class="n">x</span> <span class="o">+=</span> <span class="n">velocity</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">Ball</span><span class="o">-&gt;</span><span class="n">Stuck</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">                    <span class="n">Ball</span><span class="o">-&gt;</span><span class="n">Position</span><span class="p">.</span><span class="n">x</span> <span class="o">+=</span> <span class="n">velocity</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">[</span><span class="n">GLFW_KEY_SPACE</span><span class="p">])</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl">            <span class="n">Ball</span><span class="o">-&gt;</span><span class="n">Stuck</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">28</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>Here, if the user presses the space bar, the ball&rsquo;s Stuck variable is set to <code>false</code>. Note that we also move the position of the ball alongside the paddle&rsquo;s position whenever the ball is stuck.</p>
<p>Last, we need to render the ball which by now should be fairly obvious:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">void</span> <span class="n">Game</span><span class="o">::</span><span class="n">Render</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">State</span> <span class="o">==</span> <span class="n">GAME_ACTIVE</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">        <span class="p">[...]</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">        <span class="n">Ball</span><span class="o">-&gt;</span><span class="n">Draw</span><span class="p">(</span><span class="o">*</span><span class="n">Renderer</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">8</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>The result is a ball that follows the paddle and roams freely whenever we press the spacebar. The ball also properly bounces of the left, right, and top edge, but it doesn&rsquo;t yet seem to collide with any of the bricks as we can see:</p>
<p><video src="assets/no_collisions.mp4" width="600" height="450" controls="" preload="auto"></video></p>
<p>What we want is to create one or several function(s) that check if the ball object is colliding with any of the bricks in the level and if so, destroy the brick. These so called collision detection functions is what we&rsquo;ll focus on in the <a href="https://learnopengl.com/In-Practice/2D-Game/Collisions/Collision-detection" target="_blank">next</a> chapter.</p>
<h5 id="collision-detection">Collision detection</h5>
<p>When trying to determine if a collision occurs between two objects, we generally do not use the vertex data of the objects themselves since these objects often have complicated shapes; this in turn makes the collision detection complicated. For this reason, it is a common practice to use more simple shapes (that usually have a nice mathematical definition) for collision detection that we <em>overlay</em> on top of the original object. We then check for collisions based on these simple shapes; this makes the code easier and saves a lot of performance. A few examples of such collision shapes are circles, spheres, rectangles, and boxes; these are a lot simpler to work with compared to arbitrary meshes with hundreds of triangles.</p>
<p>While the simple shapes do give us easier and more efficient collision detection algorithms, they share a common disadvantage in that these shapes usually do not fully surround the object. The effect is that a collision may be detected that didn&rsquo;t really collide with the actual object; one should always keep in mind that these shapes are just approximations of the real shapes.</p>
<h6 id="aabb---aabb-collisions">AABB - AABB collisions</h6>
<p>AABB stands for axis-aligned bounding box, a rectangular collision shape aligned to the base axes of the scene, which in 2D aligns to the x and y axis. Being axis-aligned means the rectangular box has no rotation and its edges are parallel to the base axes of the scene (e.g. left and right edge are parallel to the y axis). The fact that these boxes are always aligned to the axes of the scene makes calculations easier. Here we surround the ball object with an AABB:</p>
<p><a href="#R-image-677d59392270abf32a79dc0f90b61cb7" class="lightbox-link"><img src="./assets/collisions_ball_aabb.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-677d59392270abf32a79dc0f90b61cb7"><img src="./assets/collisions_ball_aabb.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Almost all the objects in Breakout are rectangular based objects, so it makes perfect sense to use axis aligned bounding boxes for detecting collisions. This is exactly what we&rsquo;re going to do.</p>
<p>Axis aligned bounding boxes can be defined in several ways. One of them is to define an AABB by a top-left and a bottom-right position. The GameObject class that we defined already contains a top-left position (its Position vector), and we can easily calculate its bottom-right position by adding its size to the top-left position vector (Position<code>+</code>Size). Effectively, each GameObject contains an AABB that we can use for collisions.</p>
<p>So how do we check for collisions? A collision occurs when two collision shapes enter each other&rsquo;s regions e.g. the shape that determines the first object is in some way inside the shape of the second object. For AABBs this is quite easy to determine due to the fact that they&rsquo;re aligned to the scene&rsquo;s axes: we check for each axis if the two object&rsquo; edges on that axis overlap. So we check if the horizontal edges overlap, and if the vertical edges overlap of both objects. If both the horizontal <strong>and</strong> vertical edges overlap we have a collision.</p>
<p><a href="#R-image-43cce899916150a35ba2c3000b1d075e" class="lightbox-link"><img src="./assets/collisions_overlap.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-43cce899916150a35ba2c3000b1d075e"><img src="./assets/collisions_overlap.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Translating this concept to code is relatively straightforward. We check for overlap on both axes and if so, return a collision:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">bool</span> <span class="nf">CheckCollision</span><span class="p">(</span><span class="n">GameObject</span> <span class="o">&amp;</span><span class="n">one</span><span class="p">,</span> <span class="n">GameObject</span> <span class="o">&amp;</span><span class="n">two</span><span class="p">)</span> <span class="c1">// AABB - AABB collision
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="c1">// collision x-axis?
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1"></span>    <span class="kt">bool</span> <span class="n">collisionX</span> <span class="o">=</span> <span class="n">one</span><span class="p">.</span><span class="n">Position</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">one</span><span class="p">.</span><span class="n">Size</span><span class="p">.</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="n">two</span><span class="p">.</span><span class="n">Position</span><span class="p">.</span><span class="n">x</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">        <span class="n">two</span><span class="p">.</span><span class="n">Position</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">two</span><span class="p">.</span><span class="n">Size</span><span class="p">.</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="n">one</span><span class="p">.</span><span class="n">Position</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="c1">// collision y-axis?
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1"></span>    <span class="kt">bool</span> <span class="n">collisionY</span> <span class="o">=</span> <span class="n">one</span><span class="p">.</span><span class="n">Position</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">one</span><span class="p">.</span><span class="n">Size</span><span class="p">.</span><span class="n">y</span> <span class="o">&gt;=</span> <span class="n">two</span><span class="p">.</span><span class="n">Position</span><span class="p">.</span><span class="n">y</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        <span class="n">two</span><span class="p">.</span><span class="n">Position</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">two</span><span class="p">.</span><span class="n">Size</span><span class="p">.</span><span class="n">y</span> <span class="o">&gt;=</span> <span class="n">one</span><span class="p">.</span><span class="n">Position</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="c1">// collision only if on both axes
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">collisionX</span> <span class="o">&amp;&amp;</span> <span class="n">collisionY</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>We check if the right side of the first object is greater than the left side of the second object <strong>and</strong> if the second object&rsquo;s right side is greater than the first object&rsquo;s left side; similarly for the vertical axis. If you have trouble visualizing this, try to draw the edges/rectangles on paper and determine this for yourself.</p>
<p>To keep the collision code a bit more organized we add an extra function to the Game class:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">class</span> <span class="nc">Game</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">        <span class="p">[...]</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">        <span class="kt">void</span> <span class="n">DoCollisions</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="p">};</span></span></span></code></pre></div><p>Within DoCollisions, we check for collisions between the ball object and each brick of the level. If we detect a collision, we set the brick&rsquo;s Destroyed property to <code>true</code>, which instantly stops the level from rendering this brick:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="n">Game</span><span class="o">::</span><span class="n">DoCollisions</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">GameObject</span> <span class="o">&amp;</span><span class="nl">box</span> <span class="p">:</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">Levels</span><span class="p">[</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">Level</span><span class="p">].</span><span class="n">Bricks</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">box</span><span class="p">.</span><span class="n">Destroyed</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">CheckCollision</span><span class="p">(</span><span class="o">*</span><span class="n">Ball</span><span class="p">,</span> <span class="n">box</span><span class="p">))</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">box</span><span class="p">.</span><span class="n">IsSolid</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">                    <span class="n">box</span><span class="p">.</span><span class="n">Destroyed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>Then we also need to update the game&rsquo;s Update function:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">void</span> <span class="n">Game</span><span class="o">::</span><span class="n">Update</span><span class="p">(</span><span class="kt">float</span> <span class="n">dt</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="c1">// update objects
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="c1"></span>    <span class="n">Ball</span><span class="o">-&gt;</span><span class="n">Move</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">Width</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">    <span class="c1">// check for collisions
</span></span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="c1"></span>    <span class="k">this</span><span class="o">-&gt;</span><span class="n">DoCollisions</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>If we run the code now, the ball should detect collisions with each of the bricks and if the brick is not solid, the brick is destroyed. If you run the game now it&rsquo;ll look something like this:</p>
<p><video src="assets/collisions.mp4" width="600" height="450" controls="" preload="auto"></video></p>
<p>While the collision detection does work, it&rsquo;s not very precise since the ball&rsquo;s rectangular collision shape collides with most of the bricks without the ball directly touching them. Let&rsquo;s see if we can figure out a more precise collision detection technique.</p>
<h6 id="aabb---circle-collision-detection">AABB - Circle collision detection</h6>
<p>Because the ball is a circle-like object, an AABB is probably not the best choice for the ball&rsquo;s collision shape. The collision code thinks the ball is a rectangular box, so the ball often collides with a brick even though the ball sprite itself isn&rsquo;t yet touching the brick.</p>
<p><a href="#R-image-667f5ea88d0d326170cb0ca4689dccde" class="lightbox-link"><img src="./assets/collisions_ball_aabb_touch.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-667f5ea88d0d326170cb0ca4689dccde"><img src="./assets/collisions_ball_aabb_touch.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>It makes much more sense to represent the ball with a circle collision shape instead of an AABB. For this reason we included a Radius variable within the ball object. To define a circle collision shape, all we need is a position vector and a radius.</p>
<p><a href="#R-image-7162b6eb92707a088360f12380b360f0" class="lightbox-link"><img src="./assets/collisions_circle.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7162b6eb92707a088360f12380b360f0"><img src="./assets/collisions_circle.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>This does mean we have to update the detection algorithm since it currently only works between two AABBs. Detecting collisions between a circle and a rectangle is a bit more complicated, but the trick is as follows: we find the point on the AABB that is closest to the circle, and if the distance from the circle to this point is less than its radius, we have a collision.</p>
<p>The difficult part is getting this closest point {{<math>}}$\color{red}{\bar{P}}${{</math>}} on the AABB. The following image shows how we can calculate this point for any arbitrary AABB and circle:</p>
<p><a href="#R-image-0fe459a4ba3cb7812d5502525445d88d" class="lightbox-link"><img src="./assets/collisions_aabb_circle.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-0fe459a4ba3cb7812d5502525445d88d"><img src="./assets/collisions_aabb_circle.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>We first need to get the difference vector between the ball&rsquo;s center {{<math>}}$\color{blue}{\bar{C}}${{</math>}} and the AABB&rsquo;s center {{<math>}}$\color{green}{\bar{B}}${{</math>}} to obtain {{<math>}}$\color{purple}{\bar{D}}${{</math>}}. What we then need to do is clamp this vector {{<math>}}$\color{purple}{\bar{D}}${{</math>}} to the AABB&rsquo;s half-extents {{<math>}}$\color{orange}{{w}}${{</math>}} and {{<math>}}$\color{teal}{\bar{h}}${{</math>}} and add it to {{<math>}}$\color{green}{\bar{B}}${{</math>}}. The half-extents of a rectangle are the distances between the rectangle&rsquo;s center and its edges: its size divided by two. This returns a position vector that is always located somewhere at the edge of the AABB (unless the circle&rsquo;s center is inside the AABB).</p>
<p><note>A clamp operation <strong>clamps</strong> a value to a value within a given range. This is often expressed as:<br><a href="#R-image-c381149169b804623fc05b8f88d23fa4" class="lightbox-link"><img src="./assets/20240215083139.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c381149169b804623fc05b8f88d23fa4"><img src="./assets/20240215083139.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a><br>For example, a value of <code>42.0f</code> is clamped to <code>6.0f</code> with a range of <code>3.0f</code> to <code>6.0f</code>, and a value of <code>4.20f</code> would be clamped to <code>4.20f</code>.
Clamping a 2D vector means we clamp both its <code>x</code> and its <code>y</code> component within the given range.</note></p>
<p>This clamped vector {{<math>}}$\color{red}{\bar{P}}${{</math>}} is then the closest point from the AABB to the circle. What we then need to do is calculate a new difference vector {{<math>}}$\color{purple}{\bar{D}}${{</math>}} that is the difference between the circle&rsquo;s center {{<math>}}$\color{blue}{\bar{C}}${{</math>}} and the vector {{<math>}}$\color{red}{\bar{P}}${{</math>}}.</p>
<p><a href="#R-image-97e10b4ff80a08a0a18b4655267fb52c" class="lightbox-link"><img src="./assets/collisions_aabb_circle_radius_compare.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-97e10b4ff80a08a0a18b4655267fb52c"><img src="./assets/collisions_aabb_circle_radius_compare.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Now that we have the vector {{<math>}}$\color{purple}{\bar{D}}${{</math>}}, we can compare its length to the radius of the circle. If the length of {{<math>}}$\color{purple}{\bar{D}}${{</math>}} is less than the circle&rsquo;s radius, we have a collision.</p>
<p>This is all expressed in code as follows:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">bool</span> <span class="nf">CheckCollision</span><span class="p">(</span><span class="n">BallObject</span> <span class="o">&amp;</span><span class="n">one</span><span class="p">,</span> <span class="n">GameObject</span> <span class="o">&amp;</span><span class="n">two</span><span class="p">)</span> <span class="c1">// AABB - Circle collision
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="c1">// get center point circle first 
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1"></span>    <span class="n">glm</span><span class="o">::</span><span class="n">vec2</span> <span class="n">center</span><span class="p">(</span><span class="n">one</span><span class="p">.</span><span class="n">Position</span> <span class="o">+</span> <span class="n">one</span><span class="p">.</span><span class="n">Radius</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="c1">// calculate AABB info (center, half-extents)
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="c1"></span>    <span class="n">glm</span><span class="o">::</span><span class="n">vec2</span> <span class="n">aabb_half_extents</span><span class="p">(</span><span class="n">two</span><span class="p">.</span><span class="n">Size</span><span class="p">.</span><span class="n">x</span> <span class="o">/</span> <span class="mf">2.0f</span><span class="p">,</span> <span class="n">two</span><span class="p">.</span><span class="n">Size</span><span class="p">.</span><span class="n">y</span> <span class="o">/</span> <span class="mf">2.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="n">glm</span><span class="o">::</span><span class="n">vec2</span> <span class="n">aabb_center</span><span class="p">(</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        <span class="n">two</span><span class="p">.</span><span class="n">Position</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">aabb_half_extents</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> 
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">        <span class="n">two</span><span class="p">.</span><span class="n">Position</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">aabb_half_extents</span><span class="p">.</span><span class="n">y</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="p">);</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="c1">// get difference vector between both centers
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="c1"></span>    <span class="n">glm</span><span class="o">::</span><span class="n">vec2</span> <span class="n">difference</span> <span class="o">=</span> <span class="n">center</span> <span class="o">-</span> <span class="n">aabb_center</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="n">glm</span><span class="o">::</span><span class="n">vec2</span> <span class="n">clamped</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">clamp</span><span class="p">(</span><span class="n">difference</span><span class="p">,</span> <span class="o">-</span><span class="n">aabb_half_extents</span><span class="p">,</span> <span class="n">aabb_half_extents</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="c1">// add clamped value to AABB_center and we get the value of box closest to circle
</span></span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="c1"></span>    <span class="n">glm</span><span class="o">::</span><span class="n">vec2</span> <span class="n">closest</span> <span class="o">=</span> <span class="n">aabb_center</span> <span class="o">+</span> <span class="n">clamped</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="c1">// retrieve vector between center circle and closest point AABB and check if length &lt;= radius
</span></span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="c1"></span>    <span class="n">difference</span> <span class="o">=</span> <span class="n">closest</span> <span class="o">-</span> <span class="n">center</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">    <span class="k">return</span> <span class="n">glm</span><span class="o">::</span><span class="n">length</span><span class="p">(</span><span class="n">difference</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">one</span><span class="p">.</span><span class="n">Radius</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="p">}</span>      
</span></span></code></pre></div><p>We create an overloaded function for CheckCollision that specifically deals with the case between a BallObject and a GameObject. Because we did not store the collision shape information in the objects themselves we have to calculate them: first the center of the ball is calculated, then the AABB&rsquo;s half-extents and its center.</p>
<p>Using these collision shape attributes we calculate vector {{<math>}}$\color{purple}{\bar{D}}${{</math>}} as difference that we clamp to clamped and add to the AABB&rsquo;s center to get point {{<math>}}$\color{red}{\bar{P}}${{</math>}} as closest. Then we calculate the difference vector {{<math>}}$\color{purple}{\bar{D}}${{</math>}} between center and closest and return whether the two shapes collided or not.</p>
<p>Since we previously called CheckCollision with the ball object as its first argument, we do not have to change any code since the overloaded version of CheckCollision now automatically applies. The result is now a much more precise collision detection algorithm:</p>
<p><video src="assets/collisions_circle.mp4" width="600" height="450" controls="" preload="auto"></video></p>
<p>It seems to work, but still, something is off. We properly do all the collision detection, but the ball does not <strong>react</strong> in any way to the collisions. We need to update the ball&rsquo;s position and/or velocity whenever a collision occurs. This is the topic of the <a href="https://learnopengl.com/In-Practice/2D-Game/Collisions/Collision-resolution" target="_blank">next</a> chapter.</p>
<h5 id="collision-resolution">Collision resolution</h5>
<p>At the end of the last chapter we had a working collision detection system. However, the ball does not react in any way to the detected collisions; it moves straight through all the bricks. We want the ball to <em>bounce</em> of the collided bricks. This chapter discusses how we can accomplish this so called collision resolution within the AABB - circle collision detection logic.</p>
<p>Whenever a collision occurs we want two things to happen: we want to reposition the ball so it is no longer inside the other object and second, we want to change the direction of the ball&rsquo;s velocity so it looks like it&rsquo;s bouncing of the object.</p>
<h6 id="collision-repositioning">Collision repositioning</h6>
<p>To position the ball object outside the collided AABB we have to figure out the distance the ball penetrated the bounding box. For this we&rsquo;ll revisit the diagram from the previous chapter:</p>
<p><a href="#R-image-f424bc2c0608f8a6fee9b5973d6d9e12" class="lightbox-link"><img src="./assets/collisions_aabb_circle_resolution.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f424bc2c0608f8a6fee9b5973d6d9e12"><img src="./assets/collisions_aabb_circle_resolution.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Here the ball moved slightly into the AABB and a collision was detected. We now want to move the ball out of the shape so that it merely touches the AABB as if no collision occurred. To figure out how much we need to move the ball out of the AABB we need to retrieve the vector {{<math>}}$\color{brown}{\bar{R}}${{</math>}}, which is the level of penetration into the AABB. To get this vector {{<math>}}$\color{brown}{\bar{R}}${{</math>}}, we subtract {{<math>}}$\color{green}{\bar{V}}${{</math>}} from the ball&rsquo;s radius. Vector {{<math>}}$\color{green}{\bar{V}}${{</math>}} is the difference between closest point {{<math>}}$\color{red}{\bar{P}}${{</math>}} and the ball&rsquo;s center {{<math>}}$\color{blue}{\bar{C}}${{</math>}}.</p>
<p>Knowing {{<math>}}$\color{brown}{\bar{R}}${{</math>}}, we offset the ball&rsquo;s position by {{<math>}}$\color{brown}{\bar{R}}${{</math>}} positioning it directly against the AABB; the ball is now properly positioned.</p>
<h6 id="collision-direction">Collision direction</h6>
<p>Next we need to figure out how to update the ball&rsquo;s velocity after a collision. For Breakout we use the following rules to change the ball&rsquo;s velocity:</p>
<ol>
<li>If the ball collides with the right or left side of an AABB, its horizontal velocity (<code>x</code>) is reversed.</li>
<li>If the ball collides with the bottom or top side of an AABB, its vertical velocity (<code>y</code>) is reversed.</li>
</ol>
<p>But how do we figure out the direction the ball hit the AABB? There are several approaches to this problem. One of them is that, instead of 1 AABB, we use 4 AABBs for each brick that we each position at one of its edges. This way we can determine which AABB and thus which edge was hit. However, a simpler approach exists with the help of the dot product.</p>
<p>ou probably still remember from the <a href="https://learnopengl.com/Getting-started/Transformations" target="_blank">transformations</a> chapter that the dot product gives us the angle between two normalized vectors. What if we were to define four vectors pointing north, south, west, and east, and calculate the dot product between them and a given vector? The resulting dot product between these four direction vectors and the given vector that is highest (dot product&rsquo;s maximum value is <code>1.0f</code> which represents a <code>0</code> degree angle) is then the direction of the vector.</p>
<p>This procedure looks as follows in code:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">Direction</span> <span class="nf">VectorDirection</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">vec2</span> <span class="n">target</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="n">glm</span><span class="o">::</span><span class="n">vec2</span> <span class="n">compass</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">        <span class="n">glm</span><span class="o">::</span><span class="n">vec2</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">),</span>	<span class="c1">// up
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="c1"></span>        <span class="n">glm</span><span class="o">::</span><span class="n">vec2</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">),</span>	<span class="c1">// right
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="c1"></span>        <span class="n">glm</span><span class="o">::</span><span class="n">vec2</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0f</span><span class="p">),</span>	<span class="c1">// down
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1"></span>        <span class="n">glm</span><span class="o">::</span><span class="n">vec2</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">)</span>	<span class="c1">// left
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="c1"></span>    <span class="p">};</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="kt">float</span> <span class="n">max</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">best_match</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">        <span class="kt">float</span> <span class="n">dot_product</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">dot</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">normalize</span><span class="p">(</span><span class="n">target</span><span class="p">),</span> <span class="n">compass</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">dot_product</span> <span class="o">&gt;</span> <span class="n">max</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">            <span class="n">max</span> <span class="o">=</span> <span class="n">dot_product</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">            <span class="n">best_match</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="n">Direction</span><span class="p">)</span><span class="n">best_match</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="p">}</span>    
</span></span></code></pre></div><p>The function compares target to each of the direction vectors in the compass array. The compass vector target is closest to in angle, is the direction returned to the function caller. Here Direction is part of an enum defined in the game class&rsquo;s header file:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">enum</span> <span class="nc">Direction</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">	<span class="n">UP</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">	<span class="n">RIGHT</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">	<span class="n">DOWN</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">	<span class="n">LEFT</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="p">};</span>    
</span></span></code></pre></div><p>Now that we know how to get vector {{<math>}}$\color{brown}{\bar{R}}${{</math>}} and how to determine the direction the ball hit the AABB, we can start writing the collision resolution code.</p>
<h6 id="aabb---circle-collision-resolution">AABB - Circle collision resolution</h6>
<p>To calculate the required values for collision resolution we need a bit more information from the collision function(s) than just a <code>true</code> or <code>false</code>. We&rsquo;re now going to return a tuple of information that tells us if a collision occurred, what direction it occurred, and the difference vector {{<math>}}$\color{brown}{\bar{R}}${{</math>}}. You can find the <code>tuple</code> container in the <code>&lt;tuple&gt;</code> header.</p>
<p>To keep the code slightly more organized we&rsquo;ll typedef the collision relevant data as Collision:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span> <span class="n">Direction</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec2</span><span class="o">&gt;</span> <span class="n">Collision</span><span class="p">;</span>    
</span></span></code></pre></div><p>Then we change the code of the CheckCollision function to not only return <code>true</code> or <code>false</code>, but also the direction and difference vector:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">Collision</span> <span class="nf">CheckCollision</span><span class="p">(</span><span class="n">BallObject</span> <span class="o">&amp;</span><span class="n">one</span><span class="p">,</span> <span class="n">GameObject</span> <span class="o">&amp;</span><span class="n">two</span><span class="p">)</span> <span class="c1">// AABB - AABB collision
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="p">[...]</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">length</span><span class="p">(</span><span class="n">difference</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">one</span><span class="p">.</span><span class="n">Radius</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="n">VectorDirection</span><span class="p">(</span><span class="n">difference</span><span class="p">),</span> <span class="n">difference</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl">        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="nb">false</span><span class="p">,</span> <span class="n">UP</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec2</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">8</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>The game&rsquo;s DoCollision function now doesn&rsquo;t just check if a collision occurred, but also acts appropriately whenever a collision did occur. The function now calculates the level of penetration (as shown in the diagram at the start of this tutorial) and adds or subtracts it from the ball&rsquo;s position based on the direction of the collision.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="n">Game</span><span class="o">::</span><span class="n">DoCollisions</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">GameObject</span> <span class="o">&amp;</span><span class="nl">box</span> <span class="p">:</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">Levels</span><span class="p">[</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">Level</span><span class="p">].</span><span class="n">Bricks</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">box</span><span class="p">.</span><span class="n">Destroyed</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">            <span class="n">Collision</span> <span class="n">collision</span> <span class="o">=</span> <span class="n">CheckCollision</span><span class="p">(</span><span class="o">*</span><span class="n">Ball</span><span class="p">,</span> <span class="n">box</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">collision</span><span class="p">))</span> <span class="c1">// if collision is true
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1"></span>            <span class="p">{</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">                <span class="c1">// destroy block if not solid
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="c1"></span>                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">box</span><span class="p">.</span><span class="n">IsSolid</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">                    <span class="n">box</span><span class="p">.</span><span class="n">Destroyed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">                <span class="c1">// collision resolution
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="c1"></span>                <span class="n">Direction</span> <span class="n">dir</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">collision</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">                <span class="n">glm</span><span class="o">::</span><span class="n">vec2</span> <span class="n">diff_vector</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">collision</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">dir</span> <span class="o">==</span> <span class="n">LEFT</span> <span class="o">||</span> <span class="n">dir</span> <span class="o">==</span> <span class="n">RIGHT</span><span class="p">)</span> <span class="c1">// horizontal collision
</span></span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="c1"></span>                <span class="p">{</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">                    <span class="n">Ball</span><span class="o">-&gt;</span><span class="n">Velocity</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="n">Ball</span><span class="o">-&gt;</span><span class="n">Velocity</span><span class="p">.</span><span class="n">x</span><span class="p">;</span> <span class="c1">// reverse horizontal velocity
</span></span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="c1"></span>                    <span class="c1">// relocate
</span></span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="c1"></span>                    <span class="kt">float</span> <span class="n">penetration</span> <span class="o">=</span> <span class="n">Ball</span><span class="o">-&gt;</span><span class="n">Radius</span> <span class="o">-</span> <span class="n">std</span><span class="o">::</span><span class="n">abs</span><span class="p">(</span><span class="n">diff_vector</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">                    <span class="k">if</span> <span class="p">(</span><span class="n">dir</span> <span class="o">==</span> <span class="n">LEFT</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">                        <span class="n">Ball</span><span class="o">-&gt;</span><span class="n">Position</span><span class="p">.</span><span class="n">x</span> <span class="o">+=</span> <span class="n">penetration</span><span class="p">;</span> <span class="c1">// move ball to right
</span></span></span><span class="line"><span class="ln">23</span><span class="cl"><span class="c1"></span>                    <span class="k">else</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">                        <span class="n">Ball</span><span class="o">-&gt;</span><span class="n">Position</span><span class="p">.</span><span class="n">x</span> <span class="o">-=</span> <span class="n">penetration</span><span class="p">;</span> <span class="c1">// move ball to left;
</span></span></span><span class="line"><span class="ln">25</span><span class="cl"><span class="c1"></span>                <span class="p">}</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl">                <span class="k">else</span> <span class="c1">// vertical collision
</span></span></span><span class="line"><span class="ln">27</span><span class="cl"><span class="c1"></span>                <span class="p">{</span>
</span></span><span class="line"><span class="ln">28</span><span class="cl">                    <span class="n">Ball</span><span class="o">-&gt;</span><span class="n">Velocity</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="o">-</span><span class="n">Ball</span><span class="o">-&gt;</span><span class="n">Velocity</span><span class="p">.</span><span class="n">y</span><span class="p">;</span> <span class="c1">// reverse vertical velocity
</span></span></span><span class="line"><span class="ln">29</span><span class="cl"><span class="c1"></span>                    <span class="c1">// relocate
</span></span></span><span class="line"><span class="ln">30</span><span class="cl"><span class="c1"></span>                    <span class="kt">float</span> <span class="n">penetration</span> <span class="o">=</span> <span class="n">Ball</span><span class="o">-&gt;</span><span class="n">Radius</span> <span class="o">-</span> <span class="n">std</span><span class="o">::</span><span class="n">abs</span><span class="p">(</span><span class="n">diff_vector</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">31</span><span class="cl">                    <span class="k">if</span> <span class="p">(</span><span class="n">dir</span> <span class="o">==</span> <span class="n">UP</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">32</span><span class="cl">                        <span class="n">Ball</span><span class="o">-&gt;</span><span class="n">Position</span><span class="p">.</span><span class="n">y</span> <span class="o">-=</span> <span class="n">penetration</span><span class="p">;</span> <span class="c1">// move ball back up
</span></span></span><span class="line"><span class="ln">33</span><span class="cl"><span class="c1"></span>                    <span class="k">else</span>
</span></span><span class="line"><span class="ln">34</span><span class="cl">                        <span class="n">Ball</span><span class="o">-&gt;</span><span class="n">Position</span><span class="p">.</span><span class="n">y</span> <span class="o">+=</span> <span class="n">penetration</span><span class="p">;</span> <span class="c1">// move ball back down
</span></span></span><span class="line"><span class="ln">35</span><span class="cl"><span class="c1"></span>                <span class="p">}</span>
</span></span><span class="line"><span class="ln">36</span><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="ln">37</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln">38</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">39</span><span class="cl"><span class="p">}</span>    
</span></span></code></pre></div><p>Don&rsquo;t get too scared by the function&rsquo;s complexity since it is basically a direct translation of the concepts introduced so far. First we check for a collision and if so, we destroy the block if it is non-solid. Then we obtain the collision direction dir and the vector {{<math>}}$\color{green}{\bar{V}}${{</math>}} as diff_vector from the tuple and finally do the collision resolution.</p>
<p>We first check if the collision direction is either horizontal or vertical and then reverse the velocity accordingly. If horizontal, we calculate the penetration value {{<math>}}$\color{brown}{\bar{R}}${{</math>}} from the diff_vector&rsquo;s x component and either add or subtract this from the ball&rsquo;s position. The same applies to the vertical collisions, but this time we operate on the <code>y</code> component of all the vectors.</p>
<p>Running your application should now give you working collision resolution, but it&rsquo;s probably difficult to really see its effect since the ball will bounce towards the bottom edge as soon as you hit a single block and be lost forever. We can fix this by also handling player paddle collisions.</p>
<h6 id="player---ball-collisions">Player - ball collisions</h6>
<p>Collisions between the ball and the player is handled slightly different from what we&rsquo;ve previously discussed, since this time the ball&rsquo;s horizontal velocity should be updated based on how far it hit the paddle from its center. The further the ball hits the paddle from its center, the stronger its horizontal velocity change should be.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="n">Game</span><span class="o">::</span><span class="n">DoCollisions</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="p">[...]</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="n">Collision</span> <span class="n">result</span> <span class="o">=</span> <span class="n">CheckCollision</span><span class="p">(</span><span class="o">*</span><span class="n">Ball</span><span class="p">,</span> <span class="o">*</span><span class="n">Player</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Ball</span><span class="o">-&gt;</span><span class="n">Stuck</span> <span class="o">&amp;&amp;</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">        <span class="c1">// check where it hit the board, and change velocity based on where it hit the board
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="c1"></span>        <span class="kt">float</span> <span class="n">centerBoard</span> <span class="o">=</span> <span class="n">Player</span><span class="o">-&gt;</span><span class="n">Position</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">Player</span><span class="o">-&gt;</span><span class="n">Size</span><span class="p">.</span><span class="n">x</span> <span class="o">/</span> <span class="mf">2.0f</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">        <span class="kt">float</span> <span class="n">distance</span> <span class="o">=</span> <span class="p">(</span><span class="n">Ball</span><span class="o">-&gt;</span><span class="n">Position</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">Ball</span><span class="o">-&gt;</span><span class="n">Radius</span><span class="p">)</span> <span class="o">-</span> <span class="n">centerBoard</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">        <span class="kt">float</span> <span class="n">percentage</span> <span class="o">=</span> <span class="n">distance</span> <span class="o">/</span> <span class="p">(</span><span class="n">Player</span><span class="o">-&gt;</span><span class="n">Size</span><span class="p">.</span><span class="n">x</span> <span class="o">/</span> <span class="mf">2.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">        <span class="c1">// then move accordingly
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="c1"></span>        <span class="kt">float</span> <span class="n">strength</span> <span class="o">=</span> <span class="mf">2.0f</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">        <span class="n">glm</span><span class="o">::</span><span class="n">vec2</span> <span class="n">oldVelocity</span> <span class="o">=</span> <span class="n">Ball</span><span class="o">-&gt;</span><span class="n">Velocity</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">        <span class="n">Ball</span><span class="o">-&gt;</span><span class="n">Velocity</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">INITIAL_BALL_VELOCITY</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">percentage</span> <span class="o">*</span> <span class="n">strength</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">15</span><span class="cl">        <span class="n">Ball</span><span class="o">-&gt;</span><span class="n">Velocity</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="o">-</span><span class="n">Ball</span><span class="o">-&gt;</span><span class="n">Velocity</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">        <span class="n">Ball</span><span class="o">-&gt;</span><span class="n">Velocity</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">normalize</span><span class="p">(</span><span class="n">Ball</span><span class="o">-&gt;</span><span class="n">Velocity</span><span class="p">)</span> <span class="o">*</span> <span class="n">glm</span><span class="o">::</span><span class="n">length</span><span class="p">(</span><span class="n">oldVelocity</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">  
</span></span></code></pre></div><p>After we checked collisions between the ball and each brick, we&rsquo;ll check if the ball collided with the player paddle. If so (and the ball is not stuck to the paddle) we calculate the percentage of how far the ball&rsquo;s center is moved from the paddle&rsquo;s center compared to the half-extent of the paddle. The horizontal velocity of the ball is then updated based on the distance it hit the paddle from its center. In addition to updating the horizontal velocity, we also have to reverse the y velocity.</p>
<p>Note that the old velocity is stored as oldVelocity. The reason for storing the old velocity is that we update the horizontal velocity of the ball&rsquo;s velocity vector while keeping its <code>y</code> velocity constant. This would mean that the length of the vector constantly changes, which has the effect that the ball&rsquo;s velocity vector is much larger (and thus stronger) if the ball hit the edge of the paddle compared to if the ball would hit the center of the paddle. For this reason, the new velocity vector is normalized and multiplied by the length of the old velocity vector. This way, the velocity of the ball is always consistent, regardless of where it hits the paddle.</p>
<h6 id="sticky-paddle">Sticky paddle</h6>
<p>You may or may not have noticed it when you ran the code, but there is still a large issue with the player and ball collision resolution. The following shows what may happen:</p>
<p><video src="assets/collisions_sticky_paddle.mp4" width="600" height="450" controls="" preload="auto"></video></p>
<p>This issue is called the sticky paddle issue. This happens, because the player paddle moves with a high velocity towards the ball with the ball&rsquo;s center ending up inside the player paddle. Since we did not account for the case where the ball&rsquo;s center is inside an AABB, the game tries to continuously react to all the collisions. Once it finally breaks free, it will have reversed its <code>y</code> velocity so much that it&rsquo;s unsure whether to go up or down after breaking free.</p>
<p>We can easily fix this behavior by introducing a small hack made possible by the fact that the we can always assume we have a collision at the top of the paddle. Instead of reversing the <code>y</code> velocity, we simply always return a positive <code>y</code> direction so whenever it does get stuck, it will immediately break free.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"> <span class="c1">//Ball-&gt;Velocity.y = -Ball-&gt;Velocity.y;
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="c1"></span><span class="n">Ball</span><span class="o">-&gt;</span><span class="n">Velocity</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0f</span> <span class="o">*</span> <span class="n">abs</span><span class="p">(</span><span class="n">Ball</span><span class="o">-&gt;</span><span class="n">Velocity</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>  
</span></span></code></pre></div><p>If you try hard enough the effect is still noticeable, but I personally find it an acceptable trade-off.</p>
<h6 id="the-bottom-edge">The bottom edge</h6>
<p>The only thing that is still missing from the classic Breakout recipe is some loss condition that resets the level and the player. Within the game class&rsquo;s Update function we want to check if the ball reached the bottom edge, and if so, reset the game.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">void</span> <span class="n">Game</span><span class="o">::</span><span class="n">Update</span><span class="p">(</span><span class="kt">float</span> <span class="n">dt</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="p">[...]</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">Ball</span><span class="o">-&gt;</span><span class="n">Position</span><span class="p">.</span><span class="n">y</span> <span class="o">&gt;=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">Height</span><span class="p">)</span> <span class="c1">// did ball reach bottom edge?
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="c1"></span>    <span class="p">{</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">        <span class="k">this</span><span class="o">-&gt;</span><span class="n">ResetLevel</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl">        <span class="k">this</span><span class="o">-&gt;</span><span class="n">ResetPlayer</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">8</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">9</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>The ResetLevel and ResetPlayer functions re-load the level and reset the objects&rsquo; values to their original starting values. The game should now look a bit like this:</p>
<p><video src="assets/collisions_complete.mp4" width="600" height="450" controls="" preload="auto"></video></p>
<p>And there you have it, we just finished creating a clone of the classical Breakout game with similar mechanics. You can find the game class&rsquo; source code here: <a href="https://learnopengl.com/code_viewer_gh.php?code=src/7.in_practice/3.2d_game/0.full_source/progress/5.game.h" target="_blank">header</a>, <a href="https://learnopengl.com/code_viewer_gh.php?code=src/7.in_practice/3.2d_game/0.full_source/progress/5.game.cpp" target="_blank">code</a>.</p>
<h6 id="a-few-notes">A few notes</h6>
<p>Collision detection is a difficult topic of video game development and possibly its most challenging. Most collision detection and resolution schemes are combined with physics engines as found in most modern-day games. The collision scheme we used for the Breakout game is a very simple scheme and one specialized specifically for this type of game.</p>
<p>It should be stressed that this type of collision detection and resolution is not perfect. It calculates possible collisions only per frame and only for the positions exactly as they are at that timestep; this means that if an object would have such a velocity that it would pass over another object within a single frame, it would look like it never collided with this object. So if there are framedrops, or you reach high enough velocities, this collision detection scheme will not hold.</p>
<p>Several of the issues that can still occur:</p>
<ul>
<li>If the ball goes too fast, it may skip over an object entirely within a single frame, not detecting any collisions.</li>
<li>If the ball hits more than one object within a single frame, it will have detected two collisions and reversed its velocity twice; not affecting its original velocity.</li>
<li>Hitting a corner of a brick could reverse the ball&rsquo;s velocity in the wrong direction since the distance it travels in a single frame could decide the difference between VectorDirection returning a vertical or horizontal direction.</li>
</ul>
<p>These chapters are however aimed to teach the readers the basics of several aspects of graphics and game-development. For this reason, this collision scheme serves its purpose; its understandable and works quite well in normal scenarios. Just keep in mind that there exist better (more complicated) collision schemes that work well in almost all scenarios (including movable objects) like the separating axis theorem.</p>
<p>Thankfully, there exist large, practical, and often quite efficient physics engines (with timestep-independent collision schemes) for use in your own games. If you wish to delve further into such systems or need more advanced physics and have trouble figuring out the mathematics, <a href="http://box2d.org/" target="_blank">Box2D</a> is a perfect 2D physics library for implementing physics and collision detection in your applications.</p>
<h4 id="particles">Particles</h4>
<p>A particle is a point moving in space based on some simulation rules. These points are often rendered as tiny 2D quads that are always facing the camera (billboarding) and (usually) contain a texture with large parts of the texture being transparent. A particle, in our OpenGL game case, is then effectively just a moving sprite as we&rsquo;ve been using so far. However, when you put hundreds or even thousands of these particles together you can create amazing effects.</p>
<p>When working with particles, there is usually an object called a particle emitter or particle generator that, from its location, continuously spawns new particles that decay over time. If such a particle emitter would for example spawn tiny particles with a smoke-like texture, color them less bright the larger the distance from the emitter, and give them a glowy appearance, you&rsquo;d get a fire-like effect:</p>
<p><a href="#R-image-0700f8fd3b5529ea61452e79efd60964" class="lightbox-link"><img src="./assets/particles_example.jpg" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-0700f8fd3b5529ea61452e79efd60964"><img src="./assets/particles_example.jpg" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>A single particle often has a life variable that slowly decays once it&rsquo;s spawned. Once its life is less than a certain threshold (usually <code>0</code>), we kill the particle so it can be replaced with a new particle when the next particle spawns. A particle emitter controls all its spawned particles and changes their behavior based on their attributes. A particle generally has the following attributes:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">struct</span> <span class="nc">Particle</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">    <span class="n">glm</span><span class="o">::</span><span class="n">vec2</span> <span class="n">Position</span><span class="p">,</span> <span class="n">Velocity</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="n">glm</span><span class="o">::</span><span class="n">vec4</span> <span class="n">Color</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="kt">float</span>     <span class="n">Life</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">  
</span></span><span class="line"><span class="ln">6</span><span class="cl">    <span class="n">Particle</span><span class="p">()</span> 
</span></span><span class="line"><span class="ln">7</span><span class="cl">      <span class="o">:</span> <span class="n">Position</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">),</span> <span class="n">Velocity</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">),</span> <span class="n">Color</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">),</span> <span class="n">Life</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</span></span><span class="line"><span class="ln">8</span><span class="cl"><span class="p">};</span>    
</span></span></code></pre></div><p>Looking at the fire example, the particle emitter probably spawns each particle with a position close to the emitter and with an upwards velocity. It seems to have 3 different regions, so it probably gives some particles a higher velocity than others. We can also see that the higher the <code>y</code> position of the particle, the less <em>yellow</em> or <em>bright</em> its color becomes. After the particles have reached a certain height, their life is depleted and the particles are killed; never reaching the stars.</p>
<p>You can imagine that with systems like these we can create interesting effects like fire, smoke, fog, magic effects, gunfire residue etc. In Breakout, we&rsquo;re going to add a simple particle generator that follows the ball to make it all look just a bit more interesting. It&rsquo;ll look something like this:</p>
<p><video src="assets/particles.mp4" width="600" height="450" controls="" preload="auto"></video></p>
<p>Here, the particle generator spawns each particle at the ball&rsquo;s position, gives it a velocity equal to a fraction of the ball&rsquo;s velocity, and changes the color of the particle based on how long it lived.</p>
<p>For rendering the particles we&rsquo;ll be using a different set of shaders:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec4</span> <span class="n">vertex</span><span class="p">;</span> <span class="c1">// &lt;vec2 position, vec2 texCoords&gt;
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">out</span> <span class="n">vec2</span> <span class="n">TexCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">out</span> <span class="n">vec4</span> <span class="n">ParticleColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="n">uniform</span> <span class="n">mat4</span> <span class="n">projection</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="n">uniform</span> <span class="n">vec2</span> <span class="n">offset</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="n">uniform</span> <span class="n">vec4</span> <span class="n">color</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="kt">float</span> <span class="n">scale</span> <span class="o">=</span> <span class="mf">10.0f</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="n">TexCoords</span> <span class="o">=</span> <span class="n">vertex</span><span class="p">.</span><span class="n">zw</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="n">ParticleColor</span> <span class="o">=</span> <span class="n">color</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">projection</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">((</span><span class="n">vertex</span><span class="p">.</span><span class="n">xy</span> <span class="o">*</span> <span class="n">scale</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>And the fragment shader:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">in</span> <span class="n">vec2</span> <span class="n">TexCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">in</span> <span class="n">vec4</span> <span class="n">ParticleColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">out</span> <span class="n">vec4</span> <span class="n">color</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">sprite</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="n">color</span> <span class="o">=</span> <span class="p">(</span><span class="n">texture</span><span class="p">(</span><span class="n">sprite</span><span class="p">,</span> <span class="n">TexCoords</span><span class="p">)</span> <span class="o">*</span> <span class="n">ParticleColor</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>We take the standard position and texture attributes per particle and also accept an offset and a color uniform for changing the outcome per particle. Note that in the vertex shader we scale the particle quad by <code>10.0f</code>; you can also set the scale as a uniform and control this individually per particle.</p>
<p>First, we need a list of particles that we instantiate with default Particle structs:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_particles</span> <span class="o">=</span> <span class="mi">500</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Particle</span><span class="o">&gt;</span> <span class="n">particles</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">  
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_particles</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">    <span class="n">particles</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Particle</span><span class="p">());</span></span></span></code></pre></div><p>Then in each frame, we spawn several new particles with starting values. For each particle that is (still) alive we also update their values:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_new_particles</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1">// add new particles
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_new_particles</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="kt">int</span> <span class="n">unusedParticle</span> <span class="o">=</span> <span class="n">FirstUnusedParticle</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="n">RespawnParticle</span><span class="p">(</span><span class="n">particles</span><span class="p">[</span><span class="n">unusedParticle</span><span class="p">],</span> <span class="n">object</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="c1">// update all particles
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_particles</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="n">Particle</span> <span class="o">&amp;</span><span class="n">p</span> <span class="o">=</span> <span class="n">particles</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="n">p</span><span class="p">.</span><span class="n">Life</span> <span class="o">-=</span> <span class="n">dt</span><span class="p">;</span> <span class="c1">// reduce life
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">Life</span> <span class="o">&gt;</span> <span class="mf">0.0f</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="p">{</span>	<span class="c1">// particle is alive, thus update
</span></span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="c1"></span>        <span class="n">p</span><span class="p">.</span><span class="n">Position</span> <span class="o">-=</span> <span class="n">p</span><span class="p">.</span><span class="n">Velocity</span> <span class="o">*</span> <span class="n">dt</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">        <span class="n">p</span><span class="p">.</span><span class="n">Color</span><span class="p">.</span><span class="n">a</span> <span class="o">-=</span> <span class="n">dt</span> <span class="o">*</span> <span class="mf">2.5f</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>The first loop may look a little daunting. As particles die over time we want to spawn nr_new_particles particles each frame, but since we don&rsquo;t want to infinitely keep spawning new particles (we&rsquo;ll quickly run out of memory this way) we only spawn up to a max of nr_particles. If were to push all new particles to the end of the list we&rsquo;ll quickly get a list filled with thousands of particles. This isn&rsquo;t really efficient considering only a small portion of that list has particles that are alive.</p>
<p>What we want is to find the first particle that is dead (life &lt; <code>0.0f</code>) and update that particle as a new respawned particle.</p>
<p>The function FirstUnusedParticle tries to find the first particle that is dead and returns its index to the caller.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lastUsedParticle</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">FirstUnusedParticle</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="c1">// search from last used particle, this will usually return almost instantly
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lastUsedParticle</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_particles</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">particles</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Life</span> <span class="o">&lt;=</span> <span class="mf">0.0f</span><span class="p">){</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">            <span class="n">lastUsedParticle</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">            <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="c1">// otherwise, do a linear search
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">lastUsedParticle</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">particles</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Life</span> <span class="o">&lt;=</span> <span class="mf">0.0f</span><span class="p">){</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">            <span class="n">lastUsedParticle</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">            <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">    <span class="c1">// override first particle if all others are alive
</span></span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="c1"></span>    <span class="n">lastUsedParticle</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>The function stores the index of the last dead particle it found. Since the next dead particle will most likely be right after the last particle index, we first search from this stored index. If we found no dead particles this way, we simply do a slower linear search. If no particles are dead, it will return index <code>0</code> which results in the first particle being overwritten. Note that if it reaches this last case, it means your particles are alive for too long; you&rsquo;d need to spawn less particles per frame and/or reserve a larger number of particles.</p>
<p>Then, once the first dead particle in the list is found, we update its values by calling RespawnParticle that takes the particle, a GameObject, and an offset vector:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">void</span> <span class="nf">RespawnParticle</span><span class="p">(</span><span class="n">Particle</span> <span class="o">&amp;</span><span class="n">particle</span><span class="p">,</span> <span class="n">GameObject</span> <span class="o">&amp;</span><span class="n">object</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec2</span> <span class="n">offset</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="kt">float</span> <span class="n">random</span> <span class="o">=</span> <span class="p">((</span><span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">100</span><span class="p">)</span> <span class="o">-</span> <span class="mi">50</span><span class="p">)</span> <span class="o">/</span> <span class="mf">10.0f</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="kt">float</span> <span class="n">rColor</span> <span class="o">=</span> <span class="mf">0.5f</span> <span class="o">+</span> <span class="p">((</span><span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">100</span><span class="p">)</span> <span class="o">/</span> <span class="mf">100.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">    <span class="n">particle</span><span class="p">.</span><span class="n">Position</span> <span class="o">=</span> <span class="n">object</span><span class="p">.</span><span class="n">Position</span> <span class="o">+</span> <span class="n">random</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">    <span class="n">particle</span><span class="p">.</span><span class="n">Color</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec4</span><span class="p">(</span><span class="n">rColor</span><span class="p">,</span> <span class="n">rColor</span><span class="p">,</span> <span class="n">rColor</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl">    <span class="n">particle</span><span class="p">.</span><span class="n">Life</span> <span class="o">=</span> <span class="mf">1.0f</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">8</span><span class="cl">    <span class="n">particle</span><span class="p">.</span><span class="n">Velocity</span> <span class="o">=</span> <span class="n">object</span><span class="p">.</span><span class="n">Velocity</span> <span class="o">*</span> <span class="mf">0.1f</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">9</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>This function simply resets the particle&rsquo;s life to <code>1.0f</code>, randomly gives it a brightness (via the color vector) starting from <code>0.5</code>, and assigns a (slightly random) position and velocity based on the game object&rsquo;s data.</p>
<p>The second particle loop within the update function loops over all particles and for each particle reduces their life by the delta time variable; this way, each particle&rsquo;s life corresponds to exactly the second(s) it&rsquo;s allowed to live multiplied by some scalar. Then we check if the particle is alive and if so, update its position and color attributes. We also slowly reduce the alpha component of each particle so it looks like they&rsquo;re slowly disappearing over time.</p>
<p>Then what&rsquo;s left to do is render the particles:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">glBlendFunc</span><span class="p">(</span><span class="n">GL_SRC_ALPHA</span><span class="p">,</span> <span class="n">GL_ONE</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="n">particleShader</span><span class="p">.</span><span class="n">Use</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="n">Particle</span> <span class="nl">particle</span> <span class="p">:</span> <span class="n">particles</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">particle</span><span class="p">.</span><span class="n">Life</span> <span class="o">&gt;</span> <span class="mf">0.0f</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">        <span class="n">particleShader</span><span class="p">.</span><span class="n">SetVector2f</span><span class="p">(</span><span class="s">&#34;offset&#34;</span><span class="p">,</span> <span class="n">particle</span><span class="p">.</span><span class="n">Position</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        <span class="n">particleShader</span><span class="p">.</span><span class="n">SetVector4f</span><span class="p">(</span><span class="s">&#34;color&#34;</span><span class="p">,</span> <span class="n">particle</span><span class="p">.</span><span class="n">Color</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">        <span class="n">particleTexture</span><span class="p">.</span><span class="n">Bind</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">        <span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">particleVAO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">        <span class="n">glDrawArrays</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">        <span class="n">glBindVertexArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="p">}</span> 
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="n">glBlendFunc</span><span class="p">(</span><span class="n">GL_SRC_ALPHA</span><span class="p">,</span> <span class="n">GL_ONE_MINUS_SRC_ALPHA</span><span class="p">);</span></span></span></code></pre></div><p>Here, for each particle, we set their offset and color uniform values, bind the texture, and render the 2D quad. What&rsquo;s interesting to note here are the two calls to glBlendFunc. When rendering the particles, instead of the default destination blend mode of <code>GL_ONE_MINUS_SRC_ALPHA</code>, we use the <code>GL_ONE</code> (additive) blend mode that gives the particles a very neat glow effect when stacked onto each other. This is also likely the blend mode used when rendering the fire at the top of the chapter, since the fire is more &lsquo;glowy&rsquo; at the center where most of the particles are.</p>
<p>Because we (like most other parts of the Breakout chapters) like to keep things organized, we create another class called ParticleGenerator that hosts all the functionality we just described. You can find the source code below:</p>
<ul>
<li><a href="https://learnopengl.com/code_viewer_gh.php?code=src/7.in_practice/3.2d_game/0.full_source/particle_generator.h" target="_blank">header</a>, <a href="https://learnopengl.com/code_viewer_gh.php?code=src/7.in_practice/3.2d_game/0.full_source/particle_generator.cpp" target="_blank">code</a></li>
</ul>
<p>Within the game code, we create a particle generator and initialize it with <a href="https://learnopengl.com/img/in-practice/breakout/textures/particle.png" target="_blank">this</a> texture.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">ParticleGenerator</span>   <span class="o">*</span><span class="n">Particles</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="kt">void</span> <span class="n">Game</span><span class="o">::</span><span class="n">Init</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="p">[...]</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="n">ResourceManager</span><span class="o">::</span><span class="n">LoadShader</span><span class="p">(</span><span class="s">&#34;shaders/particle.vs&#34;</span><span class="p">,</span> <span class="s">&#34;shaders/particle.frag&#34;</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">,</span> <span class="s">&#34;particle&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="p">[...]</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="n">ResourceManager</span><span class="o">::</span><span class="n">LoadTexture</span><span class="p">(</span><span class="s">&#34;textures/particle.png&#34;</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="s">&#34;particle&#34;</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="p">[...]</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="n">Particles</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ParticleGenerator</span><span class="p">(</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">        <span class="n">ResourceManager</span><span class="o">::</span><span class="n">GetShader</span><span class="p">(</span><span class="s">&#34;particle&#34;</span><span class="p">),</span> 
</span></span><span class="line"><span class="ln">12</span><span class="cl">        <span class="n">ResourceManager</span><span class="o">::</span><span class="n">GetTexture</span><span class="p">(</span><span class="s">&#34;particle&#34;</span><span class="p">),</span> 
</span></span><span class="line"><span class="ln">13</span><span class="cl">        <span class="mi">500</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="p">);</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>Then we change the game class&rsquo;s Update function by adding an update statement for the particle generator:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">void</span> <span class="n">Game</span><span class="o">::</span><span class="n">Update</span><span class="p">(</span><span class="kt">float</span> <span class="n">dt</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="p">[...]</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="c1">// update particles
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="c1"></span>    <span class="n">Particles</span><span class="o">-&gt;</span><span class="n">Update</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="o">*</span><span class="n">Ball</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec2</span><span class="p">(</span><span class="n">Ball</span><span class="o">-&gt;</span><span class="n">Radius</span> <span class="o">/</span> <span class="mf">2.0f</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">    <span class="p">[...]</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>Each of the particles will use the game object properties from the ball object, spawn 2 particles each frame, and their positions will be offset towards the center of the ball. Last up is rendering the particles:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="n">Game</span><span class="o">::</span><span class="n">Render</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">State</span> <span class="o">==</span> <span class="n">GAME_ACTIVE</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">        <span class="p">[...]</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">        <span class="c1">// draw player
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1"></span>        <span class="n">Player</span><span class="o">-&gt;</span><span class="n">Draw</span><span class="p">(</span><span class="o">*</span><span class="n">Renderer</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        <span class="c1">// draw particles	
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1"></span>        <span class="n">Particles</span><span class="o">-&gt;</span><span class="n">Draw</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">        <span class="c1">// draw ball
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="c1"></span>        <span class="n">Ball</span><span class="o">-&gt;</span><span class="n">Draw</span><span class="p">(</span><span class="o">*</span><span class="n">Renderer</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>Note that we render the particles before we render the ball. This way, the particles end up rendered in front of all other objects, but behind the ball. You can find the updated game class code <a href="https://learnopengl.com/code_viewer_gh.php?code=src/7.in_practice/3.2d_game/0.full_source/progress/6.game.cpp" target="_blank">here</a>.</p>
<p>If you&rsquo;d now compile and run your application you should see a trail of particles following the ball, just like at the beginning of the chapter, giving the game a more modern look. The system can also easily be extended to host more advanced effects, so feel free to experiment with the particle generation and see if you can come up with your own creative effects.</p>
<h4 id="postprocessing">Postprocessing</h4>
<p>Wouldn&rsquo;t it be fun if we could completely spice up the visuals of the Breakout game with just a few postprocessing effects? We could create a blurry shake effect, inverse all the colors of the scene, do crazy vertex movement, and/or make use of other interesting effects with relative ease thanks to OpenGL&rsquo;s framebuffers.</p>
<p><note>This chapters makes extensive use of concepts from the <a href="https://learnopengl.com/Advanced-OpenGL/Framebuffers" target="_blank">framebuffers</a> and <a href="https://learnopengl.com!advanced-opengl/Anti-Aliasing" target="_blank">anti-aliasing</a> chapters.</note></p>
<p>In the framebuffers chapter we demonstrated how we could use postprocessing to achieve interesting effects using just a single texture. In Breakout we&rsquo;re going to do something similar: we&rsquo;re going to create a framebuffer object with a multisampled renderbuffer object attached as its color attachment. All the game&rsquo;s render code should render to this multisampled framebuffer that then blits its content to a different framebuffer with a texture attachment as its color buffer. This texture contains the rendered anti-aliased image of the game that we&rsquo;ll render to a full-screen 2D quad with zero or more postprocessing effects applied.</p>
<p>So to summarize, the rendering steps are:</p>
<ol>
<li>Bind to multisampled framebuffer.</li>
<li>Render game as normal.</li>
<li>Blit multisampled framebuffer to normal framebuffer with texture attachment.</li>
<li>Unbind framebuffer (use default framebuffer).</li>
<li>Use color buffer texture from normal framebuffer in postprocessing shader.</li>
<li>Render quad of screen-size as output of postprocessing shader.</li>
</ol>
<p>The postprocessing shader allows for three type of effects: shake, confuse, and chaos.</p>
<ul>
<li><strong>shake</strong>: slightly shakes the scene with a small blur.</li>
<li><strong>confuse</strong>: inverses the colors of the scene, but also the <code>x</code> and <code>y</code> axis.</li>
<li><strong>chaos</strong>: makes use of an edge detection kernel to create interesting visuals and also moves the textured image in a circular fashion for an interesting <em>chaotic</em> effect.</li>
</ul>
<p>Below is a glimpse of what these effects are going to look like:</p>
<p><a href="#R-image-b520802a39594a01f0721a2083358184" class="lightbox-link"><img src="./assets/postprocessing_effects.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b520802a39594a01f0721a2083358184"><img src="./assets/postprocessing_effects.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Operating on a 2D quad, the vertex shader looks as follows:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec4</span> <span class="n">vertex</span><span class="p">;</span> <span class="c1">// &lt;vec2 position, vec2 texCoords&gt;
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">out</span> <span class="n">vec2</span> <span class="n">TexCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">uniform</span> <span class="kt">bool</span>  <span class="n">chaos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="n">uniform</span> <span class="kt">bool</span>  <span class="n">confuse</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="n">uniform</span> <span class="kt">bool</span>  <span class="n">shake</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="n">uniform</span> <span class="kt">float</span> <span class="n">time</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">vertex</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="n">vec2</span> <span class="n">texture</span> <span class="o">=</span> <span class="n">vertex</span><span class="p">.</span><span class="n">zw</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">chaos</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">        <span class="kt">float</span> <span class="n">strength</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">        <span class="n">vec2</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">vec2</span><span class="p">(</span><span class="n">texture</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">sin</span><span class="p">(</span><span class="n">time</span><span class="p">)</span> <span class="o">*</span> <span class="n">strength</span><span class="p">,</span> <span class="n">texture</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">cos</span><span class="p">(</span><span class="n">time</span><span class="p">)</span> <span class="o">*</span> <span class="n">strength</span><span class="p">);</span>        
</span></span><span class="line"><span class="ln">19</span><span class="cl">        <span class="n">TexCoords</span> <span class="o">=</span> <span class="n">pos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">confuse</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">        <span class="n">TexCoords</span> <span class="o">=</span> <span class="n">vec2</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">texture</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">texture</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl">        <span class="n">TexCoords</span> <span class="o">=</span> <span class="n">texture</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">28</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">29</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">shake</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">30</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln">31</span><span class="cl">        <span class="kt">float</span> <span class="n">strength</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">32</span><span class="cl">        <span class="n">gl_Position</span><span class="p">.</span><span class="n">x</span> <span class="o">+=</span> <span class="n">cos</span><span class="p">(</span><span class="n">time</span> <span class="o">*</span> <span class="mi">10</span><span class="p">)</span> <span class="o">*</span> <span class="n">strength</span><span class="p">;</span>        
</span></span><span class="line"><span class="ln">33</span><span class="cl">        <span class="n">gl_Position</span><span class="p">.</span><span class="n">y</span> <span class="o">+=</span> <span class="n">cos</span><span class="p">(</span><span class="n">time</span> <span class="o">*</span> <span class="mi">15</span><span class="p">)</span> <span class="o">*</span> <span class="n">strength</span><span class="p">;</span>        
</span></span><span class="line"><span class="ln">34</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">35</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>Based on whatever uniform is set to <code>true</code>, the vertex shader takes different paths. If either chaos or confuse is set to <code>true</code>, the vertex shader will manipulate the texture coordinates to move the scene around (either translate texture coordinates in a circle-like fashion, or inverse them). Because we set the texture wrapping methods to <code>GL_REPEAT</code>, the chaos effect will cause the scene to repeat itself at various parts of the quad. Additionally if shake is set to <code>true</code>, it will move the vertex positions around by a small amount, as if the screen shakes. Note that chaos and confuse shouldn&rsquo;t be <code>true</code> at the same time while shake is able to work with any of the other effects on.</p>
<p>In addition to offsetting the vertex positions or texture coordinates, we&rsquo;d also like to create some visual change as soon as any of the effects are active. We can accomplish this within the fragment shader:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">in</span>  <span class="n">vec2</span>  <span class="n">TexCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">out</span> <span class="n">vec4</span>  <span class="n">color</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">scene</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">uniform</span> <span class="n">vec2</span>      <span class="n">offsets</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="n">uniform</span> <span class="kt">int</span>       <span class="n">edge_kernel</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="n">uniform</span> <span class="kt">float</span>     <span class="n">blur_kernel</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="n">uniform</span> <span class="kt">bool</span> <span class="n">chaos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="n">uniform</span> <span class="kt">bool</span> <span class="n">confuse</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="n">uniform</span> <span class="kt">bool</span> <span class="n">shake</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="n">color</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">    <span class="n">vec3</span> <span class="n">sample</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">    <span class="c1">// sample from texture offsets if using convolution matrix
</span></span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">chaos</span> <span class="o">||</span> <span class="n">shake</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">9</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">            <span class="n">sample</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">vec3</span><span class="p">(</span><span class="n">texture</span><span class="p">(</span><span class="n">scene</span><span class="p">,</span> <span class="n">TexCoords</span><span class="p">.</span><span class="n">st</span> <span class="o">+</span> <span class="n">offsets</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">
</span></span><span class="line"><span class="ln">23</span><span class="cl">    <span class="c1">// process effects
</span></span></span><span class="line"><span class="ln">24</span><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">chaos</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl">    <span class="p">{</span>           
</span></span><span class="line"><span class="ln">26</span><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">9</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl">            <span class="n">color</span> <span class="o">+=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">sample</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">edge_kernel</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mf">0.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">28</span><span class="cl">        <span class="n">color</span><span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="mf">1.0f</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">29</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">30</span><span class="cl">    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">confuse</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">31</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln">32</span><span class="cl">        <span class="n">color</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">texture</span><span class="p">(</span><span class="n">scene</span><span class="p">,</span> <span class="n">TexCoords</span><span class="p">).</span><span class="n">rgb</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">33</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">34</span><span class="cl">    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">shake</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">35</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln">36</span><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">9</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">37</span><span class="cl">            <span class="n">color</span> <span class="o">+=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">sample</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">blur_kernel</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mf">0.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">38</span><span class="cl">        <span class="n">color</span><span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="mf">1.0f</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">39</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">40</span><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="ln">41</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln">42</span><span class="cl">        <span class="n">color</span> <span class="o">=</span>  <span class="n">texture</span><span class="p">(</span><span class="n">scene</span><span class="p">,</span> <span class="n">TexCoords</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">43</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">44</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>This long shader almost directly builds upon the fragment shader from the framebuffers chapter and processes several postprocessing effects based on the effect type activated. This time though, the offset matrix and convolution kernels are defined as a uniform that we set from the OpenGL code. The advantage is that we only have to set this once, instead of recalculating these matrices each fragment shader run. For example, the offsets matrix is configured as follows:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">float</span> <span class="n">offset</span> <span class="o">=</span> <span class="mf">1.0f</span> <span class="o">/</span> <span class="mf">300.0f</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="kt">float</span> <span class="n">offsets</span><span class="p">[</span><span class="mi">9</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="p">{</span> <span class="o">-</span><span class="n">offset</span><span class="p">,</span>  <span class="n">offset</span>  <span class="p">},</span>  <span class="c1">// top-left
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1"></span>    <span class="p">{</span>  <span class="mf">0.0f</span><span class="p">,</span>    <span class="n">offset</span>  <span class="p">},</span>  <span class="c1">// top-center
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="c1"></span>    <span class="p">{</span>  <span class="n">offset</span><span class="p">,</span>  <span class="n">offset</span>  <span class="p">},</span>  <span class="c1">// top-right
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="c1"></span>    <span class="p">{</span> <span class="o">-</span><span class="n">offset</span><span class="p">,</span>  <span class="mf">0.0f</span>    <span class="p">},</span>  <span class="c1">// center-left
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1"></span>    <span class="p">{</span>  <span class="mf">0.0f</span><span class="p">,</span>    <span class="mf">0.0f</span>    <span class="p">},</span>  <span class="c1">// center-center
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="c1"></span>    <span class="p">{</span>  <span class="n">offset</span><span class="p">,</span>  <span class="mf">0.0f</span>    <span class="p">},</span>  <span class="c1">// center - right
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1"></span>    <span class="p">{</span> <span class="o">-</span><span class="n">offset</span><span class="p">,</span> <span class="o">-</span><span class="n">offset</span>  <span class="p">},</span>  <span class="c1">// bottom-left
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1"></span>    <span class="p">{</span>  <span class="mf">0.0f</span><span class="p">,</span>   <span class="o">-</span><span class="n">offset</span>  <span class="p">},</span>  <span class="c1">// bottom-center
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="c1"></span>    <span class="p">{</span>  <span class="n">offset</span><span class="p">,</span> <span class="o">-</span><span class="n">offset</span>  <span class="p">}</span>   <span class="c1">// bottom-right    
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="n">glUniform2fv</span><span class="p">(</span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shader</span><span class="p">.</span><span class="n">ID</span><span class="p">,</span> <span class="s">&#34;offsets&#34;</span><span class="p">),</span> <span class="mi">9</span><span class="p">,</span> <span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="n">offsets</span><span class="p">);</span>  
</span></span></code></pre></div><p>Since all of the concepts of managing (multisampled) framebuffers were already extensively discussed in earlier chapters, I won&rsquo;t delve into the details this time. Below you&rsquo;ll find the code of a PostProcessor class that manages initialization, writing/reading the framebuffers, and rendering a screen quad. You should be able to understand the code if you understood the framebuffers and anti-aliasing chapter:</p>
<ul>
<li><strong>PostProcessor</strong>: <a href="https://learnopengl.com/code_viewer_gh.php?code=src/7.in_practice/3.2d_game/0.full_source/post_processor.h" target="_blank">header</a>, <a href="https://learnopengl.com/code_viewer_gh.php?code=src/7.in_practice/3.2d_game/0.full_source/post_processor.cpp" target="_blank">code</a>.</li>
</ul>
<p>What is interesting to note here are the BeginRender and EndRender functions. Since we have to render the entire game scene into the framebuffer we can conventiently call BeginRender() and EndRender() before and after the scene&rsquo;s rendering code respectively. The class will then handle the behind-the-scenes framebuffer operations. For example, using the PostProcessor class will look like this within the game&rsquo;s Render function:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">PostProcessor</span>   <span class="o">*</span><span class="n">Effects</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="kt">void</span> <span class="n">Game</span><span class="o">::</span><span class="n">Render</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">State</span> <span class="o">==</span> <span class="n">GAME_ACTIVE</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">        <span class="n">Effects</span><span class="o">-&gt;</span><span class="n">BeginRender</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">            <span class="c1">// draw background
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1"></span>            <span class="c1">// draw level
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1"></span>            <span class="c1">// draw player
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="c1"></span>            <span class="c1">// draw particles	
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="c1"></span>            <span class="c1">// draw ball
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="c1"></span>        <span class="n">Effects</span><span class="o">-&gt;</span><span class="n">EndRender</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">        <span class="n">Effects</span><span class="o">-&gt;</span><span class="n">Render</span><span class="p">(</span><span class="n">glfwGetTime</span><span class="p">());</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>Wherever we want, we can now conveniently set the required effect property of the postprocessing class to <code>true</code> and its effect will be immediately active.</p>
<h5 id="shake-it">Shake it</h5>
<p>As a (practical) demonstration of these effects we&rsquo;ll emulate the visual impact of the ball when it hits a solid concrete block. By enabling the shake effect for a short period of time wherever a solid collision occurs, it&rsquo;ll look like the collision had a stronger impact.</p>
<p>We want to enable the screen shake effect only over a small period of time. We can get this to work by creating a variable called ShakeTime that manages the duration the shake effect is supposed to be active. Wherever a solid collision occurs, we reset this variable to a specific duration:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">float</span> <span class="n">ShakeTime</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="kt">void</span> <span class="n">Game</span><span class="o">::</span><span class="n">DoCollisions</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">GameObject</span> <span class="o">&amp;</span><span class="nl">box</span> <span class="p">:</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">Levels</span><span class="p">[</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">Level</span><span class="p">].</span><span class="n">Bricks</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">box</span><span class="p">.</span><span class="n">Destroyed</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">            <span class="n">Collision</span> <span class="n">collision</span> <span class="o">=</span> <span class="n">CheckCollision</span><span class="p">(</span><span class="o">*</span><span class="n">Ball</span><span class="p">,</span> <span class="n">box</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">collision</span><span class="p">))</span> <span class="c1">// if collision is true
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="c1"></span>            <span class="p">{</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">                <span class="c1">// destroy block if not solid
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="c1"></span>                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">box</span><span class="p">.</span><span class="n">IsSolid</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">                    <span class="n">box</span><span class="p">.</span><span class="n">Destroyed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">                <span class="k">else</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">                <span class="p">{</span>   <span class="c1">// if block is solid, enable shake effect
</span></span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="c1"></span>                    <span class="n">ShakeTime</span> <span class="o">=</span> <span class="mf">0.05f</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">                    <span class="n">Effects</span><span class="o">-&gt;</span><span class="n">Shake</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">                <span class="p">[...]</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">        <span class="p">}</span>    
</span></span><span class="line"><span class="ln">23</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">    <span class="p">[...]</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>Then within the game&rsquo;s Update function, we decrease the ShakeTime variable until it&rsquo;s <code>0.0</code> after which we disable the shake effect:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="n">Game</span><span class="o">::</span><span class="n">Update</span><span class="p">(</span><span class="kt">float</span> <span class="n">dt</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="p">[...]</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">ShakeTime</span> <span class="o">&gt;</span> <span class="mf">0.0f</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">        <span class="n">ShakeTime</span> <span class="o">-=</span> <span class="n">dt</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">ShakeTime</span> <span class="o">&lt;=</span> <span class="mf">0.0f</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">            <span class="n">Effects</span><span class="o">-&gt;</span><span class="n">Shake</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>Then each time we hit a solid block, the screen briefly starts to shake and blur, giving the player some visual feedback the ball collided with a solid object.</p>
<p><video src="assets/postprocessing_shake.mp4" width="600" height="450" controls="" preload="auto"></video></p>
<p>You can find the updated source code of the game class <a href="https://learnopengl.com/code_viewer_gh.php?code=src/7.in_practice/3.2d_game/0.full_source/progress/7.game.cpp" target="_blank">here</a>.</p>
<p>In the <a href="https://learnopengl.com/In-Practice/2D-Game/Powerups" target="_blank">next</a> chapter about powerups we&rsquo;ll bring the other two postprocessing effects to good use.</p>
<h4 id="powerups">Powerups</h4>
<p>Breakout is close to finished, but it would be cool to add at least one more gameplay mechanic so it&rsquo;s not your average standard Breakout clone; what about powerups?</p>
<p>The idea is that whenever a brick is destroyed, the brick has a small chance of spawning a powerup block. Such a block will slowly fall downwards and if it collides with the player paddle, an interesting effect occurs based on the type of powerup. For example, one powerup makes the paddle larger, and another powerup allows the ball to pass through objects. We also include several negative powerups that affect the player in a negative way.</p>
<p>We can model a powerup as a GameObject with a few extra properties. That&rsquo;s why we define a class PowerUp that inherits from GameObject:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">const</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec2</span> <span class="n">SIZE</span><span class="p">(</span><span class="mf">60.0f</span><span class="p">,</span> <span class="mf">20.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="k">const</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec2</span> <span class="n">VELOCITY</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">150.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="k">class</span> <span class="nc">PowerUp</span> <span class="o">:</span> <span class="k">public</span> <span class="n">GameObject</span> 
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="c1">// powerup state
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Type</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="kt">float</span>       <span class="n">Duration</span><span class="p">;</span>	
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="kt">bool</span>        <span class="n">Activated</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="c1">// constructor
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="c1"></span>    <span class="n">PowerUp</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">type</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">color</span><span class="p">,</span> <span class="kt">float</span> <span class="n">duration</span><span class="p">,</span> 
</span></span><span class="line"><span class="ln">13</span><span class="cl">            <span class="n">glm</span><span class="o">::</span><span class="n">vec2</span> <span class="n">position</span><span class="p">,</span> <span class="n">Texture2D</span> <span class="n">texture</span><span class="p">)</span> 
</span></span><span class="line"><span class="ln">14</span><span class="cl">        <span class="o">:</span> <span class="n">GameObject</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="n">SIZE</span><span class="p">,</span> <span class="n">texture</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="n">VELOCITY</span><span class="p">),</span> 
</span></span><span class="line"><span class="ln">15</span><span class="cl">          <span class="n">Type</span><span class="p">(</span><span class="n">type</span><span class="p">),</span> <span class="n">Duration</span><span class="p">(</span><span class="n">duration</span><span class="p">),</span> <span class="n">Activated</span><span class="p">()</span> 
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="p">{</span> <span class="p">}</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="p">};</span>  
</span></span></code></pre></div><p>A PowerUp is just a GameObject with extra state, so we can simply define it in a single header file which you can find <a href="https://learnopengl.com/code_viewer_gh.php?code=src/7.in_practice/3.2d_game/0.full_source/power_up.h" target="_blank">here</a>.</p>
<p>Each powerup defines its type as a string, a duration for how long it is active, and whether it is currently activated. Within Breakout we&rsquo;re going to feature a total of 4 positive powerups and 2 negative powerups:</p>
<p><a href="#R-image-c225eff3d8574a108a1db92dcc81b504" class="lightbox-link"><img src="./assets/powerups.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c225eff3d8574a108a1db92dcc81b504"><img src="./assets/powerups.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<ul>
<li><strong>Speed</strong>: increases the velocity of the ball by 20%.</li>
<li><strong>Sticky</strong>: when the ball collides with the paddle, the ball remains stuck to the paddle unless the spacebar is pressed again. This allows the player to better position the ball before releasing it.</li>
<li><strong>Pass-Through</strong>: collision resolution is disabled for non-solid blocks, allowing the ball to pass through multiple blocks.</li>
<li><strong>Pad-Size-Increase</strong>: increases the width of the paddle by 50 pixels.</li>
<li><strong>Confuse</strong>: activates the confuse postprocessing effect for a short period of time, confusing the user.</li>
<li><strong>Chaos</strong>: activates the chaos postprocessing effect for a short period of time, heavily disorienting the user.</li>
</ul>
<p>You can find the textures here:</p>
<ul>
<li><strong>Textures</strong>: <a href="https://learnopengl.com/img/in-practice/breakout/textures/powerup_speed.png" target="_blank">Speed</a>, <a href="https://learnopengl.com/img/in-practice/breakout/textures/powerup_sticky.png" target="_blank">Sticky</a>, <a href="https://learnopengl.com/img/in-practice/breakout/textures/powerup_passthrough.png" target="_blank">Pass-Through</a>, <a href="https://learnopengl.com/img/in-practice/breakout/textures/powerup_increase.png" target="_blank">Pad-Size-Increase</a>, <a href="https://learnopengl.com/img/in-practice/breakout/textures/powerup_confuse.png" target="_blank">Confuse</a>, <a href="https://learnopengl.com/img/in-practice/breakout/textures/powerup_chaos.png" target="_blank">Chaos</a>.</li>
</ul>
<p>Similar to the level block textures, each of the powerup textures is completely grayscale. This makes sure the color of the powerups remain balanced whenever we multiply them with a color vector.</p>
<p>Because powerups have state, a duration, and certain effects associated with them, we would like to keep track of all the powerups currently active in the game; we store them in a vector:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">class</span> <span class="nc">Game</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">    <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">        <span class="p">[...]</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">PowerUp</span><span class="o">&gt;</span>  <span class="n">PowerUps</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">        <span class="p">[...]</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">        <span class="kt">void</span> <span class="n">SpawnPowerUps</span><span class="p">(</span><span class="n">GameObject</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl">        <span class="kt">void</span> <span class="nf">UpdatePowerUps</span><span class="p">(</span><span class="kt">float</span> <span class="n">dt</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">8</span><span class="cl"><span class="p">};</span></span></span></code></pre></div><p>We&rsquo;ve also defined two functions for managing powerups. SpawnPowerUps spawns a powerups at the location of a given block and UpdatePowerUps manages all powerups currently active within the game.</p>
<h5 id="spawning-powerups">Spawning PowerUps</h5>
<p>Each time a block is destroyed we would like to, given a small chance, spawn a powerup. This functionality is found inside the game&rsquo;s SpawnPowerUps function:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">bool</span> <span class="nf">ShouldSpawn</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">chance</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">random</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="n">chance</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="k">return</span> <span class="n">random</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="kt">void</span> <span class="n">Game</span><span class="o">::</span><span class="n">SpawnPowerUps</span><span class="p">(</span><span class="n">GameObject</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">ShouldSpawn</span><span class="p">(</span><span class="mi">75</span><span class="p">))</span> <span class="c1">// 1 in 75 chance
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1"></span>        <span class="k">this</span><span class="o">-&gt;</span><span class="n">PowerUps</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">             <span class="n">PowerUp</span><span class="p">(</span><span class="s">&#34;speed&#34;</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.5f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">),</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="n">block</span><span class="p">.</span><span class="n">Position</span><span class="p">,</span> <span class="n">tex_speed</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">         <span class="p">));</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">ShouldSpawn</span><span class="p">(</span><span class="mi">75</span><span class="p">))</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">        <span class="k">this</span><span class="o">-&gt;</span><span class="n">PowerUps</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">            <span class="n">PowerUp</span><span class="p">(</span><span class="s">&#34;sticky&#34;</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.5f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">),</span> <span class="mf">20.0f</span><span class="p">,</span> <span class="n">block</span><span class="p">.</span><span class="n">Position</span><span class="p">,</span> <span class="n">tex_sticky</span> 
</span></span><span class="line"><span class="ln">15</span><span class="cl">        <span class="p">);</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">ShouldSpawn</span><span class="p">(</span><span class="mi">75</span><span class="p">))</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">        <span class="k">this</span><span class="o">-&gt;</span><span class="n">PowerUps</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">            <span class="n">PowerUp</span><span class="p">(</span><span class="s">&#34;pass-through&#34;</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.5f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.5f</span><span class="p">),</span> <span class="mf">10.0f</span><span class="p">,</span> <span class="n">block</span><span class="p">.</span><span class="n">Position</span><span class="p">,</span> <span class="n">tex_pass</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">        <span class="p">));</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">ShouldSpawn</span><span class="p">(</span><span class="mi">75</span><span class="p">))</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">        <span class="k">this</span><span class="o">-&gt;</span><span class="n">PowerUps</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">            <span class="n">PowerUp</span><span class="p">(</span><span class="s">&#34;pad-size-increase&#34;</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.6f</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">),</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="n">block</span><span class="p">.</span><span class="n">Position</span><span class="p">,</span> <span class="n">tex_size</span>    
</span></span><span class="line"><span class="ln">23</span><span class="cl">        <span class="p">));</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">ShouldSpawn</span><span class="p">(</span><span class="mi">15</span><span class="p">))</span> <span class="c1">// negative powerups should spawn more often
</span></span></span><span class="line"><span class="ln">25</span><span class="cl"><span class="c1"></span>        <span class="k">this</span><span class="o">-&gt;</span><span class="n">PowerUps</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl">            <span class="n">PowerUp</span><span class="p">(</span><span class="s">&#34;confuse&#34;</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.3f</span><span class="p">,</span> <span class="mf">0.3f</span><span class="p">),</span> <span class="mf">15.0f</span><span class="p">,</span> <span class="n">block</span><span class="p">.</span><span class="n">Position</span><span class="p">,</span> <span class="n">tex_confuse</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl">        <span class="p">));</span>
</span></span><span class="line"><span class="ln">28</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">ShouldSpawn</span><span class="p">(</span><span class="mi">15</span><span class="p">))</span>
</span></span><span class="line"><span class="ln">29</span><span class="cl">        <span class="k">this</span><span class="o">-&gt;</span><span class="n">PowerUps</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span>
</span></span><span class="line"><span class="ln">30</span><span class="cl">            <span class="n">PowerUp</span><span class="p">(</span><span class="s">&#34;chaos&#34;</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.9f</span><span class="p">,</span> <span class="mf">0.25f</span><span class="p">,</span> <span class="mf">0.25f</span><span class="p">),</span> <span class="mf">15.0f</span><span class="p">,</span> <span class="n">block</span><span class="p">.</span><span class="n">Position</span><span class="p">,</span> <span class="n">tex_chaos</span>
</span></span><span class="line"><span class="ln">31</span><span class="cl">        <span class="p">));</span>
</span></span><span class="line"><span class="ln">32</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>The SpawnPowerUps function creates a new PowerUp object based on a given chance (1 in 75 for normal powerups and 1 in 15 for negative powerups) and sets their properties. Each powerup is given a specific color to make them more recognizable for the user and a duration in seconds based on its type; here a duration of <code>0.0f</code> means its duration is infinite. Additionally, each powerup is given the position of the destroyed block and one of the textures from the beginning of this chapter.</p>
<h5 id="activating-powerups">Activating PowerUps</h5>
<p>We then have to update the game&rsquo;s DoCollisions function to not only check for brick and paddle collisions, but also collisions between the paddle and each non-destroyed PowerUp. Note that we call SpawnPowerUps directly after a block is destroyed.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="n">Game</span><span class="o">::</span><span class="n">DoCollisions</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">GameObject</span> <span class="o">&amp;</span><span class="nl">box</span> <span class="p">:</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">Levels</span><span class="p">[</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">Level</span><span class="p">].</span><span class="n">Bricks</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">box</span><span class="p">.</span><span class="n">Destroyed</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">            <span class="n">Collision</span> <span class="n">collision</span> <span class="o">=</span> <span class="n">CheckCollision</span><span class="p">(</span><span class="o">*</span><span class="n">Ball</span><span class="p">,</span> <span class="n">box</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">collision</span><span class="p">))</span> <span class="c1">// if collision is true
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1"></span>            <span class="p">{</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">                <span class="c1">// destroy block if not solid
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="c1"></span>                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">box</span><span class="p">.</span><span class="n">IsSolid</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">                <span class="p">{</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">                    <span class="n">box</span><span class="p">.</span><span class="n">Destroyed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">                    <span class="k">this</span><span class="o">-&gt;</span><span class="n">SpawnPowerUps</span><span class="p">(</span><span class="n">box</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">                <span class="p">[...]</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">    <span class="p">}</span>        
</span></span><span class="line"><span class="ln">20</span><span class="cl">    <span class="p">[...]</span> 
</span></span><span class="line"><span class="ln">21</span><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">PowerUp</span> <span class="o">&amp;</span><span class="nl">powerUp</span> <span class="p">:</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">PowerUps</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">powerUp</span><span class="p">.</span><span class="n">Destroyed</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">powerUp</span><span class="p">.</span><span class="n">Position</span><span class="p">.</span><span class="n">y</span> <span class="o">&gt;=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">Height</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl">                <span class="n">powerUp</span><span class="p">.</span><span class="n">Destroyed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">CheckCollision</span><span class="p">(</span><span class="o">*</span><span class="n">Player</span><span class="p">,</span> <span class="n">powerUp</span><span class="p">))</span>
</span></span><span class="line"><span class="ln">28</span><span class="cl">            <span class="p">{</span>	<span class="c1">// collided with player, now activate powerup
</span></span></span><span class="line"><span class="ln">29</span><span class="cl"><span class="c1"></span>                <span class="n">ActivatePowerUp</span><span class="p">(</span><span class="n">powerUp</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">30</span><span class="cl">                <span class="n">powerUp</span><span class="p">.</span><span class="n">Destroyed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">31</span><span class="cl">                <span class="n">powerUp</span><span class="p">.</span><span class="n">Activated</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">32</span><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="ln">33</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln">34</span><span class="cl">    <span class="p">}</span>  
</span></span><span class="line"><span class="ln">35</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>For all powerups not yet destroyed, we check if the powerup either reached the bottom edge of the screen or collided with the paddle. In both cases the powerup is destroyed, but when collided with the paddle, it is also activated.</p>
<p>Activating a powerup is accomplished by settings its Activated property to <code>true</code> and enabling the powerup&rsquo;s effect by giving it to the ActivatePowerUp function:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="nf">ActivatePowerUp</span><span class="p">(</span><span class="n">PowerUp</span> <span class="o">&amp;</span><span class="n">powerUp</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">powerUp</span><span class="p">.</span><span class="n">Type</span> <span class="o">==</span> <span class="s">&#34;speed&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">        <span class="n">Ball</span><span class="o">-&gt;</span><span class="n">Velocity</span> <span class="o">*=</span> <span class="mf">1.2</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">powerUp</span><span class="p">.</span><span class="n">Type</span> <span class="o">==</span> <span class="s">&#34;sticky&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">        <span class="n">Ball</span><span class="o">-&gt;</span><span class="n">Sticky</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">        <span class="n">Player</span><span class="o">-&gt;</span><span class="n">Color</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.5f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">powerUp</span><span class="p">.</span><span class="n">Type</span> <span class="o">==</span> <span class="s">&#34;pass-through&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">        <span class="n">Ball</span><span class="o">-&gt;</span><span class="n">PassThrough</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">        <span class="n">Ball</span><span class="o">-&gt;</span><span class="n">Color</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.5f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">powerUp</span><span class="p">.</span><span class="n">Type</span> <span class="o">==</span> <span class="s">&#34;pad-size-increase&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">        <span class="n">Player</span><span class="o">-&gt;</span><span class="n">Size</span><span class="p">.</span><span class="n">x</span> <span class="o">+=</span> <span class="mi">50</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">powerUp</span><span class="p">.</span><span class="n">Type</span> <span class="o">==</span> <span class="s">&#34;confuse&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Effects</span><span class="o">-&gt;</span><span class="n">Chaos</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">            <span class="n">Effects</span><span class="o">-&gt;</span><span class="n">Confuse</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// only activate if chaos wasn&#39;t already active
</span></span></span><span class="line"><span class="ln">25</span><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl">    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">powerUp</span><span class="p">.</span><span class="n">Type</span> <span class="o">==</span> <span class="s">&#34;chaos&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln">28</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Effects</span><span class="o">-&gt;</span><span class="n">Confuse</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">29</span><span class="cl">            <span class="n">Effects</span><span class="o">-&gt;</span><span class="n">Chaos</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">30</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">31</span><span class="cl"><span class="p">}</span> 
</span></span></code></pre></div><p>The purpose of ActivatePowerUp is exactly as it sounds: it activates the effect of a powerup as we&rsquo;ve described at the start of this chapter. We check the type of the powerup and change the game state accordingly. For the <code>&quot;sticky&quot;</code> and <code>&quot;pass-through&quot;</code> effect, we also change the color of the paddle and the ball respectively to give the user some feedback as to which effect is currently active.</p>
<p>Because the sticky and pass-through effects somewhat change the game logic we store their effect as a property of the ball object; this way we can change the game logic based on whatever effect on the ball is currently active. The only thing we&rsquo;ve changed in the BallObject header is the addition of these two properties, but for completeness&rsquo; sake its updated code is listed below:</p>
<ul>
<li><strong>BallObject</strong>: <a href="https://learnopengl.com/code_viewer_gh.php?code=src/7.in_practice/3.2d_game/0.full_source/ball_object.h" target="_blank">header</a>, <a href="https://learnopengl.com/code_viewer_gh.php?code=src/7.in_practice/3.2d_game/0.full_source/ball_object.cpp" target="_blank">code</a>.</li>
</ul>
<p>We can then easily implement the sticky effect by slightly updating the DoCollisions function at the collision code between the ball and the paddle:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Ball</span><span class="o">-&gt;</span><span class="n">Stuck</span> <span class="o">&amp;&amp;</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="p">[...]</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="n">Ball</span><span class="o">-&gt;</span><span class="n">Stuck</span> <span class="o">=</span> <span class="n">Ball</span><span class="o">-&gt;</span><span class="n">Sticky</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>Here we set the ball&rsquo;s Stuck property equal to the ball&rsquo;s Sticky property. If the sticky effect is activated, the ball will end up stuck to the player paddle whenever it collides; the user then has to press the spacebar again to release the ball.</p>
<p>A similar small change is made for the pass-through effect within the same DoCollisions function. When the ball&rsquo;s PassThrough property is set to <code>true</code> we do not perform any collision resolution on the non-solid bricks.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">Direction</span> <span class="n">dir</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">collision</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">vec2</span> <span class="n">diff_vector</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">collision</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">Ball</span><span class="o">-&gt;</span><span class="n">PassThrough</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">box</span><span class="p">.</span><span class="n">IsSolid</span><span class="p">))</span> 
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">dir</span> <span class="o">==</span> <span class="n">LEFT</span> <span class="o">||</span> <span class="n">dir</span> <span class="o">==</span> <span class="n">RIGHT</span><span class="p">)</span> <span class="c1">// horizontal collision
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="c1"></span>    <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">        <span class="p">[...]</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="k">else</span> 
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">        <span class="p">[...]</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>The other effects are activated by simply modifying the game&rsquo;s state like the ball&rsquo;s velocity, the paddle&rsquo;s size, or an effect of the PostProcesser object.</p>
<h5 id="updating-powerups">Updating PowerUps</h5>
<p>Now all that is left to do is make sure that powerups are able to move once they&rsquo;ve spawned and that they&rsquo;re deactivated as soon as their duration runs out; otherwise powerups will stay active forever.</p>
<p>Within the game&rsquo;s UpdatePowerUps function we move the powerups based on their velocity and decrease the active powerups their duration. Whenever a powerup&rsquo;s duration is decreased to <code>0.0f</code>, its effect is deactivated and the relevant variables are reset to their original state:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="n">Game</span><span class="o">::</span><span class="n">UpdatePowerUps</span><span class="p">(</span><span class="kt">float</span> <span class="n">dt</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">PowerUp</span> <span class="o">&amp;</span><span class="nl">powerUp</span> <span class="p">:</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">PowerUps</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">        <span class="n">powerUp</span><span class="p">.</span><span class="n">Position</span> <span class="o">+=</span> <span class="n">powerUp</span><span class="p">.</span><span class="n">Velocity</span> <span class="o">*</span> <span class="n">dt</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">powerUp</span><span class="p">.</span><span class="n">Activated</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">            <span class="n">powerUp</span><span class="p">.</span><span class="n">Duration</span> <span class="o">-=</span> <span class="n">dt</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">
</span></span><span class="line"><span class="ln">10</span><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">powerUp</span><span class="p">.</span><span class="n">Duration</span> <span class="o">&lt;=</span> <span class="mf">0.0f</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">                <span class="c1">// remove powerup from list (will later be removed)
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="c1"></span>                <span class="n">powerUp</span><span class="p">.</span><span class="n">Activated</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">                <span class="c1">// deactivate effects
</span></span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="c1"></span>                <span class="k">if</span> <span class="p">(</span><span class="n">powerUp</span><span class="p">.</span><span class="n">Type</span> <span class="o">==</span> <span class="s">&#34;sticky&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">                <span class="p">{</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">                    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isOtherPowerUpActive</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">PowerUps</span><span class="p">,</span> <span class="s">&#34;sticky&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">                    <span class="p">{</span>	<span class="c1">// only reset if no other PowerUp of type sticky is active
</span></span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="c1"></span>                        <span class="n">Ball</span><span class="o">-&gt;</span><span class="n">Sticky</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">                        <span class="n">Player</span><span class="o">-&gt;</span><span class="n">Color</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">                    <span class="p">}</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">                <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">powerUp</span><span class="p">.</span><span class="n">Type</span> <span class="o">==</span> <span class="s">&#34;pass-through&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">                <span class="p">{</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl">                    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isOtherPowerUpActive</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">PowerUps</span><span class="p">,</span> <span class="s">&#34;pass-through&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl">                    <span class="p">{</span>	<span class="c1">// only reset if no other PowerUp of type pass-through is active
</span></span></span><span class="line"><span class="ln">27</span><span class="cl"><span class="c1"></span>                        <span class="n">Ball</span><span class="o">-&gt;</span><span class="n">PassThrough</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">28</span><span class="cl">                        <span class="n">Ball</span><span class="o">-&gt;</span><span class="n">Color</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">29</span><span class="cl">                    <span class="p">}</span>
</span></span><span class="line"><span class="ln">30</span><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="ln">31</span><span class="cl">                <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">powerUp</span><span class="p">.</span><span class="n">Type</span> <span class="o">==</span> <span class="s">&#34;confuse&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">32</span><span class="cl">                <span class="p">{</span>
</span></span><span class="line"><span class="ln">33</span><span class="cl">                    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isOtherPowerUpActive</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">PowerUps</span><span class="p">,</span> <span class="s">&#34;confuse&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="ln">34</span><span class="cl">                    <span class="p">{</span>	<span class="c1">// only reset if no other PowerUp of type confuse is active
</span></span></span><span class="line"><span class="ln">35</span><span class="cl"><span class="c1"></span>                        <span class="n">Effects</span><span class="o">-&gt;</span><span class="n">Confuse</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">36</span><span class="cl">                    <span class="p">}</span>
</span></span><span class="line"><span class="ln">37</span><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="ln">38</span><span class="cl">                <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">powerUp</span><span class="p">.</span><span class="n">Type</span> <span class="o">==</span> <span class="s">&#34;chaos&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">39</span><span class="cl">                <span class="p">{</span>
</span></span><span class="line"><span class="ln">40</span><span class="cl">                    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isOtherPowerUpActive</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">PowerUps</span><span class="p">,</span> <span class="s">&#34;chaos&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="ln">41</span><span class="cl">                    <span class="p">{</span>	<span class="c1">// only reset if no other PowerUp of type chaos is active
</span></span></span><span class="line"><span class="ln">42</span><span class="cl"><span class="c1"></span>                        <span class="n">Effects</span><span class="o">-&gt;</span><span class="n">Chaos</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">43</span><span class="cl">                    <span class="p">}</span>
</span></span><span class="line"><span class="ln">44</span><span class="cl">                <span class="p">}</span>                
</span></span><span class="line"><span class="ln">45</span><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="ln">46</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln">47</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">48</span><span class="cl">    <span class="k">this</span><span class="o">-&gt;</span><span class="n">PowerUps</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">remove_if</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">PowerUps</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">PowerUps</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
</span></span><span class="line"><span class="ln">49</span><span class="cl">        <span class="p">[](</span><span class="k">const</span> <span class="n">PowerUp</span> <span class="o">&amp;</span><span class="n">powerUp</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">powerUp</span><span class="p">.</span><span class="n">Destroyed</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">powerUp</span><span class="p">.</span><span class="n">Activated</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="ln">50</span><span class="cl">    <span class="p">),</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">PowerUps</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="ln">51</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>You can see that for each effect we disable it by resetting the relevant items to their original state. We also set the powerup&rsquo;s Activated property to <code>false</code>. At the end of UpdatePowerUps we then loop through the PowerUps vector and erase each powerup if they are destroyed <strong>and</strong> deactivated. We use the remove_if function from the algorithm header to erase these items given a lambda predicate.</p>
<p><note>The remove_if function moves all elements for which the lambda predicate is true to the end of the container object and returns an iterator to the start of this <em>removed elements</em> range. The container&rsquo;s erase function then takes this iterator and the vector&rsquo;s end iterator to remove all the elements between these two iterators.</note></p>
<p>It may happen that while one of the powerup effects is active, another powerup of the same type collides with the player paddle. In that case we have more than 1 powerup of that type currently active within the game&rsquo;s PowerUps vector. Whenever one of these powerups gets deactivated, we don&rsquo;t want to disable its effects yet since another powerup of the same type may still be active. For this reason we use the IsOtherPowerUpActive function to check if there is still another powerup active of the same type. Only if this function returns <code>false</code> we deactivate the powerup. This way, the powerup&rsquo;s duration of a given type is extended to the duration of its last activated powerup:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">bool</span> <span class="nf">IsOtherPowerUpActive</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">PowerUp</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">powerUps</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">type</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="n">PowerUp</span> <span class="o">&amp;</span><span class="nl">powerUp</span> <span class="p">:</span> <span class="n">powerUps</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">powerUp</span><span class="p">.</span><span class="n">Activated</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">powerUp</span><span class="p">.</span><span class="n">Type</span> <span class="o">==</span> <span class="n">type</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>The function checks for all activated powerups if there is still a powerup active of the same type and if so, returns <code>true</code>.</p>
<p>The last thing left to do is render the powerups:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="n">Game</span><span class="o">::</span><span class="n">Render</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">State</span> <span class="o">==</span> <span class="n">GAME_ACTIVE</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">        <span class="p">[...]</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="n">PowerUp</span> <span class="o">&amp;</span><span class="nl">powerUp</span> <span class="p">:</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">PowerUps</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">powerUp</span><span class="p">.</span><span class="n">Destroyed</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">                <span class="n">powerUp</span><span class="p">.</span><span class="n">Draw</span><span class="p">(</span><span class="o">*</span><span class="n">Renderer</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">        <span class="p">[...]</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="p">}</span>    
</span></span></code></pre></div><p>Combine all this functionality and we have a working powerup system that not only makes the game more fun, but also a lot more challenging. It&rsquo;ll look a bit like this:</p>
<p><video src="assets/powerups.mp4" width="600" height="450" controls="" preload="auto"></video></p>
<p>You can find the updated game code here (there we also reset all powerup effects whenever the level is reset):</p>
<ul>
<li><strong>Game</strong>: <a href="https://learnopengl.com/code_viewer_gh.php?code=src/7.in_practice/3.2d_game/0.full_source/progress/8.game.h" target="_blank">header</a>, <a href="https://learnopengl.com/code_viewer_gh.php?code=src/7.in_practice/3.2d_game/0.full_source/progress/8.game.cpp" target="_blank">code</a>.</li>
</ul>
<h4 id="audio">Audio</h4>
<p>The game&rsquo;s making great progress, but it still feels a bit empty as there&rsquo;s no audio whatsoever. In this chapter we&rsquo;re going to fix that.</p>
<p>OpenGL doesn&rsquo;t offer us any support for audio capabilities (like many other aspects of game development). We have to manually load audio files into a collection of bytes, process and convert them to an audio stream, and manage multiple audio streams appropriately for use in our game. This can get complicated pretty quick and requires some low-level knowledge of audio engineering.</p>
<p>If it is your cup of tea then feel free to manually load audio streams from one or more audio file extensions. We are, however, going to make use of a library for audio management called <strong>irrKlang</strong>.</p>
<h5 id="irrklang">Irrklang</h5>
<p><img src="./assets/irrklang.png" class="right medium" /></p>
<p>IrrKlang is a high level 2D and 3D cross platform (Windows, Mac OS X, Linux) sound engine and audio library that plays WAV, MP3, OGG, and FLAC files to name a few. It also features several audio effects like reverb, delay, and distortion that can be extensively tweaked.</p>
<p><note>3D audio means that an audio source can have a 3D position that will attenuate its volume based on the camera&rsquo;s distance to the audio source, making it feel natural in a 3D world (think of gunfire in a 3D world; most often you&rsquo;ll be able to hear where it came from just by the direction/location of the sound).</note></p>
<p>IrrKlang is an easy-to-use audio library that can play most audio files with just a few lines of code, making it a perfect candidate for our Breakout game. Note that irrKlang has a slightly restrictive license: you are allowed to use irrKlang as you see fit for non-commercial purposes, but you have to pay for their pro version whenever you want to use irrKlang commercially.</p>
<p>You can download irrKlang from their <a href="http://www.ambiera.com/irrklang/downloads.html" target="_blank">download</a> page; we&rsquo;re using version 1.5 for this chapter. Because irrKlang is closed-source, we cannot compile the library ourselves so we&rsquo;ll have to do with whatever irrKlang provided for us. Luckily they have plenty of precompiled library files.</p>
<p>Once you include the header files of irrKlang, add their (64-bit) library (<code>irrKlang.lib</code>) to the linker settings, and copy the dll file(s) to the appropriate locations (usually the same location where the <code>.exe</code> resides) we&rsquo;re set to go. Note that if you want to load MP3 files, you&rsquo;ll also have to include the <code>ikpMP3.dll</code> file.</p>
<h5 id="adding-music">Adding music</h5>
<p>Specifically for this game I created a small little audio track so the game feels a bit more alive. You can find the audio track <a href="https://learnopengl.com/audio/in-practice/breakout/breakout.mp3" target="_blank">here</a> that we&rsquo;ll use as the game&rsquo;s background music. This track is what we&rsquo;ll play whenever the game starts and that continuously loops until the player closes the game. Feel free to replace it with your own tracks or use it in any way you like.</p>
<audio controls="">
  <source src="./assets/breakout.mp3" type="audio/mpeg">
  Your browser does not support the audio element.
</audio>
<p>Adding this to the Breakout game is extremely easy with the irrKlang library. We include the irrKlang header file, create an <code>irrKlang::ISoundEngine</code>, initialize it with createIrrKlangDevice, and then use the engine to load and play audio files:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;irrklang/irrKlang.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">irrklang</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">ISoundEngine</span> <span class="o">*</span><span class="n">SoundEngine</span> <span class="o">=</span> <span class="n">createIrrKlangDevice</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="kt">void</span> <span class="n">Game</span><span class="o">::</span><span class="n">Init</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="p">[...]</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="n">SoundEngine</span><span class="o">-&gt;</span><span class="n">play2D</span><span class="p">(</span><span class="s">&#34;audio/breakout.mp3&#34;</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>Here we created a SoundEngine that we use for all audio-related code. Once we&rsquo;ve initialized the sound engine, all we need to do to play audio is simply call its play2D function. Its first parameter is the filename, and the second parameter whether we want the file to loop (play again once it&rsquo;s finished).</p>
<p>And that is all there is to it! Running the game should now cause your speakers (or headset) to violently blast out sound waves.</p>
<h5 id="adding-sounds">Adding sounds</h5>
<p>We&rsquo;re not there yet, since music by itself is not enough to make the game as great as it could be. We want to play sounds whenever something interesting happens in the game, as extra feedback to the player. Like when we hit a brick, or when we activate a powerup. Below you can find all the sounds we&rsquo;re going to use (courtesy of freesound.org):</p>
<p><a href="https://learnopengl.com/audio/in-practice/breakout/bleep.mp3" target="_blank"><strong>bleep.mp3</strong></a>: the sound for when the ball hit a non-solid block.</p>
<audio controls="">
  <source src="./assets/bleep.mp3" type="audio/mpeg">
  Your browser does not support the audio element.
</audio>
<p><a href="https://learnopengl.com/audio/in-practice/breakout/solid.wav" target="_blank"><strong>solid.wav</strong></a>: the sound for when the ball hit a solid block.</p>
<audio controls="">
  <source src="./assets/solid.wav" type="audio/mpeg">
  Your browser does not support the audio element.
</audio>
<p><a href="https://learnopengl.com/audio/in-practice/breakout/powerup.wav" target="_blank"><strong>powerup.wav</strong></a>: the sound for when we the player paddle collided with a powerup block.</p>
<audio controls="">
  <source src="./assets/powerup.wav" type="audio/mpeg">
  Your browser does not support the audio element.
</audio>
<p><a href="https://learnopengl.com/audio/in-practice/breakout/bleep.wav" target="_blank"><strong>bleep.wav</strong></a>: the sound for when we the ball bounces of the player paddle.</p>
<audio controls="">
  <source src="./assets/bleep.wav" type="audio/mpeg">
  Your browser does not support the audio element.
</audio>
<p>Wherever a collision occurs, we play the corresponding sound. I won&rsquo;t walk through each of the lines of code where this is supposed to happen, but simply list the updated game code <a href="https://learnopengl.com/code_viewer_gh.php?code=src/7.in_practice/3.2d_game/0.full_source/progress/9.game.cpp" target="_blank">here</a>. You should easily be able to add the sound effects at their appropriate locations.</p>
<p>Putting it all together gives us a game that feels a lot more complete. All together it looks (and sounds) like this:</p>
<p><video src="assets/audio.mp4" width="600" height="450" controls="" preload="auto"></video></p>
<p>IrrKlang allows for much more fine-grained control of audio controls like advanced memory management, audio effects, or sound event callbacks. Check out their simple C++ <a href="http://www.ambiera.com/irrklang/tutorials.html" target="_blank">tutorials</a> and try to experiment with its features.</p>
<h4 id="render-text">Render text</h4>
<p>In this chapter we&rsquo;ll be adding the final enhancements to the game by adding a life system, a win condition, and feedback in the form of rendered text. This chapter heavily builds upon the earlier introduced <a href="https://learnopengl.com/In-Practice/Text-Rendering" target="_blank">Text Rendering</a> chapter so it is highly advised to first work your way through that chapter if you haven&rsquo;t already.</p>
<p>In Breakout all text rendering code is encapsulated within a class called TextRenderer that features the initialization of the FreeType library, render configuration, and the actual render code. You can find the code of the TextRenderer class here:</p>
<ul>
<li><strong>TextRenderer</strong>: <a href="https://learnopengl.com/code_viewer_gh.php?code=src/7.in_practice/3.2d_game/0.full_source/text_renderer.h" target="_blank">header</a>, <a href="https://learnopengl.com/code_viewer_gh.php?code=src/7.in_practice/3.2d_game/0.full_source/text_renderer.cpp" target="_blank">code</a>.</li>
<li><strong>Text shaders</strong>: <a href="https://learnopengl.com/code_viewer_gh.php?code=src/7.in_practice/3.2d_game/0.full_source/shaders/text.vs" target="_blank">vertex</a>, <a href="https://learnopengl.com/code_viewer_gh.php?code=src/7.in_practice/3.2d_game/0.full_source/shaders/text.frag" target="_blank">fragment</a>.</li>
</ul>
<p>The content of the text renderer&rsquo;s functions is almost exactly the same as the code from the text rendering chapter. However, the code for rendering glyphs onto the screen is slightly different:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="n">TextRenderer</span><span class="o">::</span><span class="n">RenderText</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">text</span><span class="p">,</span> <span class="kt">float</span> <span class="n">x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">y</span><span class="p">,</span> <span class="kt">float</span> <span class="n">scale</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">color</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="p">[...]</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">c</span> <span class="o">=</span> <span class="n">text</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">c</span> <span class="o">!=</span> <span class="n">text</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">c</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">        <span class="kt">float</span> <span class="n">xpos</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">ch</span><span class="p">.</span><span class="n">Bearing</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">scale</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">        <span class="kt">float</span> <span class="n">ypos</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">Characters</span><span class="p">[</span><span class="sc">&#39;H&#39;</span><span class="p">].</span><span class="n">Bearing</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">ch</span><span class="p">.</span><span class="n">Bearing</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="n">scale</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">        <span class="kt">float</span> <span class="n">w</span> <span class="o">=</span> <span class="n">ch</span><span class="p">.</span><span class="n">Size</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">scale</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">        <span class="kt">float</span> <span class="n">h</span> <span class="o">=</span> <span class="n">ch</span><span class="p">.</span><span class="n">Size</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">scale</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">        <span class="c1">// update VBO for each character
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="c1"></span>        <span class="kt">float</span> <span class="n">vertices</span><span class="p">[</span><span class="mi">6</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">            <span class="p">{</span> <span class="n">xpos</span><span class="p">,</span>     <span class="n">ypos</span> <span class="o">+</span> <span class="n">h</span><span class="p">,</span>   <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">1.0f</span> <span class="p">},</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">            <span class="p">{</span> <span class="n">xpos</span> <span class="o">+</span> <span class="n">w</span><span class="p">,</span> <span class="n">ypos</span><span class="p">,</span>       <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.0f</span> <span class="p">},</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">            <span class="p">{</span> <span class="n">xpos</span><span class="p">,</span>     <span class="n">ypos</span><span class="p">,</span>       <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span> <span class="p">},</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">
</span></span><span class="line"><span class="ln">17</span><span class="cl">            <span class="p">{</span> <span class="n">xpos</span><span class="p">,</span>     <span class="n">ypos</span> <span class="o">+</span> <span class="n">h</span><span class="p">,</span>   <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">1.0f</span> <span class="p">},</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">            <span class="p">{</span> <span class="n">xpos</span> <span class="o">+</span> <span class="n">w</span><span class="p">,</span> <span class="n">ypos</span> <span class="o">+</span> <span class="n">h</span><span class="p">,</span>   <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">1.0f</span> <span class="p">},</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">            <span class="p">{</span> <span class="n">xpos</span> <span class="o">+</span> <span class="n">w</span><span class="p">,</span> <span class="n">ypos</span><span class="p">,</span>       <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.0f</span> <span class="p">}</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">        <span class="p">};</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">        <span class="p">[...]</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl"><span class="p">}</span>    
</span></span></code></pre></div><p>The reason for it being slightly different is that we use a different orthographic projection matrix from the one we&rsquo;ve used in the text rendering chapter. In the text rendering chapter all <code>y</code> values ranged from bottom to top, while in the Breakout game all <code>y</code> values range from top to bottom with a <code>y</code> coordinate of <code>0.0</code> corresponding to the top edge of the screen. This means we have to slightly modify how we calculate the vertical offset.</p>
<p>Since we now render downwards from RenderText&rsquo;s y parameter, we calculate the vertical offset as the distance a glyph is pushed downwards from the top of the glyph space. Looking back at the glyph metrics image from FreeType, this is indicated by the red arrow:</p>
<p><a href="#R-image-a61b1297f4e2f0ec9f5661500aff5fdf" class="lightbox-link"><img src="./assets/glyph_offset_1.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a61b1297f4e2f0ec9f5661500aff5fdf"><img src="./assets/glyph_offset_1.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>To calculate this vertical offset we need to get the top of the glyph space (the length of the black vertical arrow from the origin). Unfortunately, FreeType has no such metric for us. What we do know is that that some glyphs always touch this top edge; characters like &lsquo;H&rsquo;, &lsquo;T&rsquo; or &lsquo;X&rsquo;. So what if we calculate the length of this red vector by subtracting <code>bearingY</code> from any of these <em>top-reaching</em> glyphs by <code>bearingY</code> of the glyph in question. This way, we push the glyph down based on how far its top point differs from the top edge.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">float</span> <span class="n">ypos</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">Characters</span><span class="p">[</span><span class="sc">&#39;H&#39;</span><span class="p">].</span><span class="n">Bearing</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">ch</span><span class="p">.</span><span class="n">Bearing</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="n">scale</span><span class="p">;</span>  
</span></span></code></pre></div><p>In addition to updating the <code>ypos</code> calculation, we also switched the order of the vertices a bit to make sure all the vertices are still front facing when multiplied with the current orthographic projection matrix (as discussed in the <a href="https://learnopengl.com/Advanced-OpenGL/Face-culling" target="_blank">face culling</a> chapter).</p>
<p>Adding the TextRenderer to the game is easy:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">TextRenderer</span>  <span class="o">*</span><span class="n">Text</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">  
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="kt">void</span> <span class="n">Game</span><span class="o">::</span><span class="n">Init</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">    <span class="p">[...]</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">    <span class="n">Text</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TextRenderer</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">Width</span><span class="p">,</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">Height</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl">    <span class="n">Text</span><span class="o">-&gt;</span><span class="n">Load</span><span class="p">(</span><span class="s">&#34;fonts/ocraext.TTF&#34;</span><span class="p">,</span> <span class="mi">24</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">8</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>The text renderer is initialized with a font called OCR A Extended that you can download from <a href="http://fontzone.net/font-details/ocr-a-extended" target="_blank">here</a>. If the font is not to your liking, feel free to use a different font.</p>
<p>Now that we have a text renderer, let&rsquo;s finish the gameplay mechanics.</p>
<h5 id="player-lives">Player lives</h5>
<p>Instead of immediately resetting the game as soon as the ball reaches the bottom edge, we&rsquo;d like to give the player a few extra chances. We do this in the form of player lives, where the player begins with an initial number of lives (say <code>3</code>) and each time the ball touches the bottom edge, the player&rsquo;s life total is decreased by 1. Only when the player&rsquo;s life total becomes <code>0</code> we reset the game. This makes it easier for the player to finish a level while also building tension.</p>
<p>We keep count of the lives of a player by adding it to the game class (initialized within the constructor to a value of <code>3</code>):</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">class</span> <span class="nc">Game</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="p">[...]</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="k">public</span><span class="o">:</span>  
</span></span><span class="line"><span class="ln">5</span><span class="cl">        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">Lives</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>We then modify the game&rsquo;s Update function to, instead of resetting the game, decrease the player&rsquo;s life total, and only reset the game once the life total reaches <code>0</code>:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="n">Game</span><span class="o">::</span><span class="n">Update</span><span class="p">(</span><span class="kt">float</span> <span class="n">dt</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="p">[...]</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">Ball</span><span class="o">-&gt;</span><span class="n">Position</span><span class="p">.</span><span class="n">y</span> <span class="o">&gt;=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">Height</span><span class="p">)</span> <span class="c1">// did ball reach bottom edge?
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="c1"></span>    <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">        <span class="o">--</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">Lives</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">        <span class="c1">// did the player lose all his lives? : Game over
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">Lives</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">            <span class="k">this</span><span class="o">-&gt;</span><span class="n">ResetLevel</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">            <span class="k">this</span><span class="o">-&gt;</span><span class="n">State</span> <span class="o">=</span> <span class="n">GAME_MENU</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">        <span class="k">this</span><span class="o">-&gt;</span><span class="n">ResetPlayer</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>As soon as the player is game over (lives equals <code>0</code>), we reset the level and change the game state to GAME_MENU which we&rsquo;ll get to later.</p>
<p>Don&rsquo;t forget to reset the player&rsquo;s life total as soon as we reset the game/level:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">void</span> <span class="n">Game</span><span class="o">::</span><span class="n">ResetLevel</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="p">[...]</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="k">this</span><span class="o">-&gt;</span><span class="n">Lives</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>The player now has a working life total, but has no way of seeing how many lives he currently has while playing the game. That&rsquo;s where the text renderer comes in:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">void</span> <span class="n">Game</span><span class="o">::</span><span class="n">Render</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">State</span> <span class="o">==</span> <span class="n">GAME_ACTIVE</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">        <span class="p">[...]</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">stringstream</span> <span class="n">ss</span><span class="p">;</span> <span class="n">ss</span> <span class="o">&lt;&lt;</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">Lives</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl">        <span class="n">Text</span><span class="o">-&gt;</span><span class="n">RenderText</span><span class="p">(</span><span class="s">&#34;Lives:&#34;</span> <span class="o">+</span> <span class="n">ss</span><span class="p">.</span><span class="n">str</span><span class="p">(),</span> <span class="mf">5.0f</span><span class="p">,</span> <span class="mf">5.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">8</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">9</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>Here we convert the number of lives to a string, and display it at the top-left of the screen. It&rsquo;ll now look a bit like this:</p>
<p><a href="#R-image-801163f75da0ce10a27241657a930c18" class="lightbox-link"><img src="./assets/render_text_lives.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-801163f75da0ce10a27241657a930c18"><img src="./assets/render_text_lives.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>As soon as the ball touches the bottom edge, the player&rsquo;s life total is decreased which is instantly visible at the top-left of the screen.</p>
<h5 id="level-selection">Level selection</h5>
<p>Whenever the user is in the game state GAME_MENU, we&rsquo;d like to give the player the control to select the level he&rsquo;d like to play in. With either the &lsquo;w&rsquo; or &rsquo;s&rsquo; key the player should be able to scroll through any of the levels we loaded. Whenever the player feels like the chosen level is indeed the level he&rsquo;d like to play in, he can press the enter key to switch from the game&rsquo;s GAME_MENU state to the GAME_ACTIVE state.</p>
<p>Allowing the player to choose a level is not too difficult. All we have to do is increase or decrease the game class&rsquo;s Level variable based on whether he pressed &lsquo;w&rsquo; or &rsquo;s&rsquo; respectively:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">State</span> <span class="o">==</span> <span class="n">GAME_MENU</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">[</span><span class="n">GLFW_KEY_ENTER</span><span class="p">])</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">        <span class="k">this</span><span class="o">-&gt;</span><span class="n">State</span> <span class="o">=</span> <span class="n">GAME_ACTIVE</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">[</span><span class="n">GLFW_KEY_W</span><span class="p">])</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">        <span class="k">this</span><span class="o">-&gt;</span><span class="n">Level</span> <span class="o">=</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">Level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">4</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">[</span><span class="n">GLFW_KEY_S</span><span class="p">])</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">Level</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">            <span class="o">--</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">Level</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">        <span class="k">else</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">            <span class="k">this</span><span class="o">-&gt;</span><span class="n">Level</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>   
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>We use the modulus operator (<code>%</code>) to make sure the Level variable remains within the acceptable level range (between <code>0</code> and <code>3</code>).</p>
<p>We also want to define what we want to render when we&rsquo;re in the menu state. We&rsquo;d like to give the player some instructions in the form of text and also display the selected level in the background.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="n">Game</span><span class="o">::</span><span class="n">Render</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">State</span> <span class="o">==</span> <span class="n">GAME_ACTIVE</span> <span class="o">||</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">State</span> <span class="o">==</span> <span class="n">GAME_MENU</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">        <span class="p">[...]</span> <span class="c1">// Game state&#39;s rendering code
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">State</span> <span class="o">==</span> <span class="n">GAME_MENU</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">        <span class="n">Text</span><span class="o">-&gt;</span><span class="n">RenderText</span><span class="p">(</span><span class="s">&#34;Press ENTER to start&#34;</span><span class="p">,</span> <span class="mf">250.0f</span><span class="p">,</span> <span class="n">Height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">        <span class="n">Text</span><span class="o">-&gt;</span><span class="n">RenderText</span><span class="p">(</span><span class="s">&#34;Press W or S to select level&#34;</span><span class="p">,</span> <span class="mf">245.0f</span><span class="p">,</span> <span class="n">Height</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mf">20.0f</span><span class="p">,</span> <span class="mf">0.75f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>Here we render the game whenever we&rsquo;re in either the GAME_ACTIVE state or the GAME_MENU state, and whenever we&rsquo;re in the GAME_MENU state we also render two lines of text to inform the player to select a level and/or accept his choice. Note that for this to work when launching the game you do have to set the game&rsquo;s state as GAME_MENU by default.</p>
<p><a href="#R-image-c5ab9c2ea37e9429500b3a440139319f" class="lightbox-link"><img src="./assets/render_text_select.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c5ab9c2ea37e9429500b3a440139319f"><img src="./assets/render_text_select.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>It looks great, but once you try to run the code you&rsquo;ll probably notice that as soon as you press either the &lsquo;w&rsquo; or the &rsquo;s&rsquo; key, the game rapidly scrolls through the levels making it difficult to select the level you want to play in. This happens because the game records the key press over frames until we release the key. This causes the ProcessInput function to process the pressed key more than once.</p>
<p>We can solve this issue with a little trick commonly found within GUI systems. The trick is to, not only record the keys currently pressed, but also store the keys that have been processed once, until released again. We then check (before processing) whether the key has not yet been processed, and if so, process this key after which we store this key as being processed. Once we want to process the same key again without the key having been released, we do not process the key. This probably sounds somewhat confusing, but as soon as you see it in practice it (probably) starts to make sense.</p>
<p>First we have to create another array of bool values to indicate which keys have been processed. We define this within the game class:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">class</span> <span class="nc">Game</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="p">[...]</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="k">public</span><span class="o">:</span>  
</span></span><span class="line"><span class="ln">5</span><span class="cl">        <span class="kt">bool</span> <span class="n">KeysProcessed</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="p">}</span> 
</span></span></code></pre></div><p>We then set the relevant key(s) to <code>true</code> as soon as they&rsquo;re processed and make sure to only process the key if it wasn&rsquo;t processed before (until released):</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="n">Game</span><span class="o">::</span><span class="n">ProcessInput</span><span class="p">(</span><span class="kt">float</span> <span class="n">dt</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">State</span> <span class="o">==</span> <span class="n">GAME_MENU</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">[</span><span class="n">GLFW_KEY_ENTER</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">KeysProcessed</span><span class="p">[</span><span class="n">GLFW_KEY_ENTER</span><span class="p">])</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">            <span class="k">this</span><span class="o">-&gt;</span><span class="n">State</span> <span class="o">=</span> <span class="n">GAME_ACTIVE</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">            <span class="k">this</span><span class="o">-&gt;</span><span class="n">KeysProcessed</span><span class="p">[</span><span class="n">GLFW_KEY_ENTER</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">[</span><span class="n">GLFW_KEY_W</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">KeysProcessed</span><span class="p">[</span><span class="n">GLFW_KEY_W</span><span class="p">])</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">            <span class="k">this</span><span class="o">-&gt;</span><span class="n">Level</span> <span class="o">=</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">Level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">4</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">            <span class="k">this</span><span class="o">-&gt;</span><span class="n">KeysProcessed</span><span class="p">[</span><span class="n">GLFW_KEY_W</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">[</span><span class="n">GLFW_KEY_S</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">KeysProcessed</span><span class="p">[</span><span class="n">GLFW_KEY_S</span><span class="p">])</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">Level</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">                <span class="o">--</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">Level</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">            <span class="k">else</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">                <span class="k">this</span><span class="o">-&gt;</span><span class="n">Level</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">            <span class="k">this</span><span class="o">-&gt;</span><span class="n">KeysProcessed</span><span class="p">[</span><span class="n">GLFW_KEY_S</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">    <span class="p">[...]</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>Now as soon as the key&rsquo;s value in the KeysProcessed array has not yet been set, we process the key and set its value to <code>true</code>. Next time we reach the <code>if</code> condition of the same key, it will have been processed so we&rsquo;ll pretend we never pressed the button until it&rsquo;s released again.</p>
<p>Within GLFW&rsquo;s key callback function we then need to reset the key&rsquo;s processed value as soon as it&rsquo;s released so we can process it again the next time it&rsquo;s pressed:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="nf">key_callback</span><span class="p">(</span><span class="n">GLFWwindow</span><span class="o">*</span> <span class="n">window</span><span class="p">,</span> <span class="kt">int</span> <span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">scancode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">action</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="p">[...]</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="mi">1024</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">action</span> <span class="o">==</span> <span class="n">GLFW_PRESS</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">            <span class="n">Breakout</span><span class="p">.</span><span class="n">Keys</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">action</span> <span class="o">==</span> <span class="n">GLFW_RELEASE</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">            <span class="n">Breakout</span><span class="p">.</span><span class="n">Keys</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">            <span class="n">Breakout</span><span class="p">.</span><span class="n">KeysProcessed</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>Launching the game gives us a neat level select screen that now precisely selects a single level per key press, no matter how long we press he key.</p>
<h5 id="winning">Winning</h5>
<p>Currently the player is able to select levels, play the game, and fail in doing so to lose. It is kind of unfortunate if the player finds out after destroying all the bricks he cannot in any way win the game. So let&rsquo;s fix that.</p>
<p>The player wins when all of the non-solid blocks have been destroyed. We already created a function to check for this condition in the GameLevel class:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">bool</span> <span class="n">GameLevel</span><span class="o">::</span><span class="n">IsCompleted</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">GameObject</span> <span class="o">&amp;</span><span class="nl">tile</span> <span class="p">:</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">Bricks</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tile</span><span class="p">.</span><span class="n">IsSolid</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">tile</span><span class="p">.</span><span class="n">Destroyed</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>We check all bricks in the game level and if a single non-solid brick isn&rsquo;t yet destroyed we return <code>false</code>. All we have to do is check for this condition in the game&rsquo;s Update function and as soon as it returns <code>true</code> we change the game state to GAME_WIN:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="n">Game</span><span class="o">::</span><span class="n">Update</span><span class="p">(</span><span class="kt">float</span> <span class="n">dt</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="p">[...]</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">State</span> <span class="o">==</span> <span class="n">GAME_ACTIVE</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">Levels</span><span class="p">[</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">Level</span><span class="p">].</span><span class="n">IsCompleted</span><span class="p">())</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">        <span class="k">this</span><span class="o">-&gt;</span><span class="n">ResetLevel</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">        <span class="k">this</span><span class="o">-&gt;</span><span class="n">ResetPlayer</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        <span class="n">Effects</span><span class="o">-&gt;</span><span class="n">Chaos</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">        <span class="k">this</span><span class="o">-&gt;</span><span class="n">State</span> <span class="o">=</span> <span class="n">GAME_WIN</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>Whenever the level is completed while the game is active, we reset the game and display a small victory message in the GAME_WIN state. For fun we&rsquo;ll also enable the chaos effect while in the GAME_WIN screen. In the Render function we&rsquo;ll congratulate the player and ask him to either restart or quit the game:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="n">Game</span><span class="o">::</span><span class="n">Render</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="p">[...]</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">State</span> <span class="o">==</span> <span class="n">GAME_WIN</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">        <span class="n">Text</span><span class="o">-&gt;</span><span class="n">RenderText</span><span class="p">(</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">            <span class="s">&#34;You WON!!!&#34;</span><span class="p">,</span> <span class="mf">320.0</span><span class="p">,</span> <span class="n">Height</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mf">20.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        <span class="p">);</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">        <span class="n">Text</span><span class="o">-&gt;</span><span class="n">RenderText</span><span class="p">(</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">            <span class="s">&#34;Press ENTER to retry or ESC to quit&#34;</span><span class="p">,</span> <span class="mf">130.0</span><span class="p">,</span> <span class="n">Height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">        <span class="p">);</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>Then we of course have to actually catch the mentioned keys:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="n">Game</span><span class="o">::</span><span class="n">ProcessInput</span><span class="p">(</span><span class="kt">float</span> <span class="n">dt</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="p">[...]</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">State</span> <span class="o">==</span> <span class="n">GAME_WIN</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">[</span><span class="n">GLFW_KEY_ENTER</span><span class="p">])</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">            <span class="k">this</span><span class="o">-&gt;</span><span class="n">KeysProcessed</span><span class="p">[</span><span class="n">GLFW_KEY_ENTER</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">            <span class="n">Effects</span><span class="o">-&gt;</span><span class="n">Chaos</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">            <span class="k">this</span><span class="o">-&gt;</span><span class="n">State</span> <span class="o">=</span> <span class="n">GAME_MENU</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="p">}</span>  
</span></span></code></pre></div><p>If you&rsquo;re then good enough to actually win the game, you&rsquo;d get the following image:</p>
<p><a href="#R-image-b9a809e037b0e45483797ce4ade42437" class="lightbox-link"><img src="./assets/render_text_win.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b9a809e037b0e45483797ce4ade42437"><img src="./assets/render_text_win.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>And that is it! The final piece of the puzzle of the Breakout game we&rsquo;ve been actively working on. Try it out, customize it to your liking, and show it to all your family and friends!</p>
<p>You can find the final version of the game&rsquo;s code below:</p>
<ul>
<li><strong>Game</strong>: <a href="https://learnopengl.com/code_viewer_gh.php?code=src/7.in_practice/3.2d_game/0.full_source/game.h" target="_blank">header</a>, <a href="https://learnopengl.com/code_viewer_gh.php?code=src/7.in_practice/3.2d_game/0.full_source/game.cpp" target="_blank">code</a>.</li>
</ul>
<h5 id="further-reading-6">Further reading</h5>
<ul>
<li><a href="https://www.websiteplanet.com/blog/best-free-fonts/" target="_blank">70+ Best Free Fonts for Designers</a>: summarized list of a large group of fonts to use in your project for personal or commercial use.</li>
</ul>
<h4 id="final-thoughts">Final thoughts</h4>
<p>These last chapter gave a glimpse of what it&rsquo;s like to create something more than just a tech demo in OpenGL. We created a complete 2D game from scratch and learned how to abstract from certain low-level graphics concepts, use basic collision detection techniques, create particles, and we&rsquo;ve shown a practical scenario for an orthographic projection matrix. All this using concepts we&rsquo;ve discussed in all previous chapters. We didn&rsquo;t really learn new and exciting graphics techniques using OpenGL, but more as to how to combine all the knowledge so far into a larger whole.</p>
<p>Creating a simple game like Breakout can be accomplished in thousands of different ways, of which this approach is just one of many. The larger a game becomes, the more you start applying abstractions and design patterns. For further reading you can find a lot more on these abstractions and design patterns in the wonderful <a href="http://gameprogrammingpatterns.com/" target="_blank">game programming patterns</a> website.</p>
<p>Keep in mind that it is a difficult feat to create a game with extremely clean and well-thought out code (often close to impossible). Simply make your game in whatever way you think feels right at the time. The more you practice video-game development, the more you learn new and better approaches to solve problems. Don&rsquo;t let the struggle to want to create perfect code demotivate you; keep on coding!</p>
<h5 id="optimizations">Optimizations</h5>
<p>The content of these chapters and the finished game code were all focused on explaining concepts as simple as possible, without delving too much in optimization details. Therefore, many performance considerations were left out of the chapters. We&rsquo;ll list some of the more common improvements you&rsquo;ll find in modern 2D OpenGL games to boost performance for when your framerate starts to drop:</p>
<ul>
<li><strong>Sprite sheet / Texture atlas</strong>: instead of rendering a sprite with a single texture at a time, we combine all required textures into a single large texture (like bitmap fonts) and select the appropriate sprite texture with a targeted set of texture coordinates. Switching texture states can be expensive so a sprite sheet makes sure we rarely have to switch between textures; this also allows the GPU to more efficiently cache the texture in memory for faster lookups.</li>
<li><strong>Instanced rendering</strong>: instead of rendering a quad at a time, we could&rsquo;ve also batched all the quads we want to render and then, with an <a href="https://learnopengl.com/Advanced-OpenGL/Instancing" target="_blank">instanced renderer</a>, render all the batched sprites with just a single draw call. This is relatively easy to do since each sprite is composed of the same vertices, but differs in only a model matrix; something that we can easily include in an instanced array. This allows OpenGL to render a lot more sprites per frame. Instanced rendering can also be used to render particles and/or characters glyphs.</li>
<li><strong>Triangle strips</strong>: instead of rendering each quad as two triangles, we could&rsquo;ve rendered them with OpenGL&rsquo;s TRIANGLE_STRIP render primitive that takes only <code>4</code> vertices instead of <code>6</code>. This saves a third of the data sent to the GPU.</li>
<li><strong>Space partitioning algorithms</strong>: when checking for collisions, we compare the ball object to <strong>each</strong> of the bricks in the active level. This is a bit of a waste of CPU resources since we can easily tell that most of the bricks won&rsquo;t even come close to the ball within this frame. Using space partitioning algorithms like BSP, Octrees, or k-d trees, we partition the visible space into several smaller regions and first determine in which region(s) the ball is in. We then only check collisions between other bricks in whatever region(s) the ball is in, saving us a significant amount of collision checks. For a simple game like Breakout this will likely be overkill, but for more complicated games with more complicated collision detection algorithms this will significantly increase performance.</li>
<li><strong>Minimize state changes</strong>: state changes (like binding textures or switching shaders) are generally quite expensive in OpenGL, so you want to avoid doing a large amount of state changes. One approach to minimize state changes is to create your own state manager that stores the current value of an OpenGL state (like which texture is bound) and only switch if this value needs to change; this prevents unnecessary state changes. Another approach is to sort all the renderable objects by state change: first render all the objects with shader one, then all objects with shader two, and so on; this can of course be extended to blend state changes, texture binds, framebuffer switches etc.</li>
</ul>
<p>These should give you some hints as to what kind of advanced tricks we can apply to further boost the performance of a 2D game. This also gives you a glimpse of the power of OpenGL: by doing most rendering by hand we have full control over the entire process and thus also complete power over how to optimize the process. If you&rsquo;re not satisfied with Breakout&rsquo;s performance then feel free to take any of these as an exercise.</p>
<h5 id="get-creative">Get creative</h5>
<p>Now that you&rsquo;ve seen how to create a simple game in OpenGL it is up to you to create your own rendering/game applications. Many of the techniques that we&rsquo;ve discussed so far can be used in most 2D (and even 3D) games like sprite rendering, collision detection, postprocessing, text rendering, and particles. It is now up to you to take these techniques and combine/modify them in whichever way you think is right and develop your own handcrafted game.</p>
<h2 id="guest-articles">Guest Articles</h2>
<h3 id="2020">2020</h3>
<h4 id="oit">OIT</h4>
<h5 id="introduction-1">Introduction</h5>
<p>In the <a href="https://learnopengl.com/Advanced-OpenGL/Blending" target="_blank">Blending</a> chapter, the subject of color blending was introduced. Blending is the way of implementing transparent surfaces in a 3D scene. In short, transparency delves into the subject of drawing semi-solid or fully see-through objects like glasses in computer graphics. The idea is explained up to a suitable point in that chapter, so if you&rsquo;re unfamiliar with the topic, better read Blending first.</p>
<p>In this article, we are scratching the surface of this topic a bit further, since there are so many techniques involved in implementing such an effect in a 3D environment.</p>
<p>To begin with, we are going to discuss about the limitations of the graphics library/hardware and the hardships they entail, and the reason that why transparency is such a tricky subject. Later on, we will introduce and briefly review some of the more well-known transparency techniques that have been invented and used for the past twenty years associated with the current hardware. Ultimately, we are going to focus on explaining and implementing one of them, which will be the subject of the following part of this article.</p>
<p>Note that the goal of this article is to introduce techniques which have significantly better performance than the technique that was used in the Blending chapter. Otherwise, there isn&rsquo;t a genuinely compelling reason to expand on that matter.</p>
<h5 id="graphics-libraryhardware-limitations">Graphics library/hardware limitations</h5>
<p>The reason that this article exists, and you&rsquo;re reading it, is that there is no direct way to draw transparent surfaces with the current technology. Many people wish, that it was as simple as turning on a flag in their graphics API, but that&rsquo;s a fairy tale. Whether, this is a limitation of the graphics libraries or video cards, that&rsquo;s debatable.</p>
<p>As explained in the Blending chapter, the source of this problem arises from combining depth testing and color blending. At the fragment stage, there is no buffer like the depth buffer for transparent pixels that would tell the graphics library, which pixels are fully visible or semi-visible. One of the reasons could be, that there is no efficient way of storing the information of transparent pixels in such a buffer that can hold an infinite number of pixels for each coordinate on the screen. Since each transparent pixel could expose its underlying pixels, therefore there needs to be a way to store different layers of all pixels for all screen coordinates.</p>
<p>This limitation leaves us to think for a way to overcome such an issue and since neither the graphics library nor the hardware gives us a hand, this all has to be done by the developer with the tools at hand. We will examine two methods which are prominent in this subject. One being, ordered transparency and the other order-independent transparency.</p>
<h5 id="ordered-transparency">Ordered transparency</h5>
<p>The most convenient solution to overcome this issue, is to sort your transparent objects, so they&rsquo;re either drawn from the furthest to the nearest, or from the nearest to the furthest in relation to the camera&rsquo;s position. This way, the depth testing wouldn&rsquo;t affect the outcome of those pixels that have been drawn after/before but over/under a further/closer object. However major the expenditure this method entails for the CPU, it was used in many early games that probably most of us have played.</p>
<p>For example, the sample image below shows the importance of blending order. The top part of the image produces an incorrect result with unordered alpha blending, while the bottom correctly sorts the geometry. Note lower visibility of the skeletal structure without correct depth ordering. This image is from <a href="http://gpuopen.com/archive/gpu-demos/radeon-hd-5000-series-graphics-real-time-demos/" target="_blank">ATI Mecha Demo</a>:</p>
<p><a href="#R-image-fc4294db09c962d5187aee9440586ae4" class="lightbox-link"><img src="./assets/ATI_Mecha_Demo_Screenshot.jpg" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-fc4294db09c962d5187aee9440586ae4"><img src="./assets/ATI_Mecha_Demo_Screenshot.jpg" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>So far, we have understood that in order to overcome the limitation of current technology to draw transparent objects, we need order for our transparent objects to be displayed properly on the screen. Ordering takes away performance from your application, and since most of 3D applications are running in real-time, this will be so much more evident as you perform sorting at every frame.</p>
<p>Therefore, we will be looking into the world of order-independent transparency techniques and to find one which better suits our purpose and furthermore our pipeline, so we don&rsquo;t have to sort the objects before drawing.</p>
<h5 id="order-independent-transparency">Order-independent transparency</h5>
<p>Order-independent transparency or for short OIT, is a technique which doesn&rsquo;t require us to draw our transparent objects in an orderly fashion. At first glance, this will give us back the CPU cycles that we were taking for sorting the objects, but at the same time OIT techniques have their pros and cons.</p>
<p>The goal of OIT techniques is to eliminate the need of sorting transparent objects at draw time. Depending on the technique, some of them must sort fragments for an accurate result, but only at a later stage when all the draw calls have been made, and some of them don&rsquo;t require sorting, but results are approximated.</p>
<h5 id="history">History</h5>
<p>Some of the more advanced techniques that have been invented to overcome the limitation of rendering transparent surfaces, explicitly use a buffer (e.g. a linked list or a 3D array such as [x][y][z]) that can hold multiple layers of pixels&rsquo; information and can sort pixels on the GPU, normally because of its parallel processing power, as opposed to CPU.</p>
<p><note>The <a href="https://en.wikipedia.org/wiki/A-buffer" target="_blank">A-buffer</a> is a computer graphics technique introduced in 1984 which stores per-pixel lists of fragment data (including <a href="https://en.wikipedia.org/wiki/Micropolygon" target="_blank">micro-polygon</a> information) in a software rasterizer, <a href="https://en.wikipedia.org/wiki/Reyes_rendering" target="_blank">REYES</a>, originally designed for anti-aliasing but also supporting transparency.</note></p>
<p>At the same time, there has been hardware capable of facilitating this task by performing on-hardware calculations which is the most convenient way for a developer to have access to transparency out of the box.</p>
<p><note><a href="https://en.wikipedia.org/wiki/Dreamcast#Hardware" target="_blank">SEGA Dreamcast</a> was one of the few consoles that had automatic per-pixel translucency sorting, implemented in its hardware.</note></p>
<p>Commonly, OIT techniques are separated into two categories which are exact and approximate. Respectively, exact will result in better images with an accurate transparency which suits every scenario, while approximate although resulting in good-looking images, lacks accuracy in complex scenes.</p>
<h5 id="exact-oit">Exact OIT</h5>
<p>These techniques accurately compute the final color, for which all fragments must be sorted. For high depth complexity scenes, sorting becomes the bottleneck.</p>
<p>One issue with the sorting stage is local memory limited occupancy, in this case a <a href="https://en.wikipedia.org/wiki/Single_Instruction_Multiple_Threads" target="_blank">single instruction, multiple threads</a> attribute relating to the throughput and operation latency hiding of GPUs. Although, <a href="http://diglib.eg.org/handle/10.2312/PE.PG.PG2013short.059-064" target="_blank">BMA</a> (backwards memory allocation) can group pixels by their depth complexity and sort them in batches to improve the occupancy and hence performance of low depth complexity pixels in the context of a potentially high depth complexity scene. Up to a 3× overall OIT performance increase is reported.</p>
<p><note>The sorting stage requires relatively large amounts of temporary memory in shaders that is usually conservatively allocated at a maximum, which impacts memory occupancy and performance.</note></p>
<p>Sorting is typically performed in a local array, however performance can be improved further by making use of the GPU&rsquo;s memory hierarchy and sorting in registers, similarly to an <a href="https://en.wikipedia.org/wiki/External_sorting#External_merge_sort" target="_blank">external merge sort</a>, especially in conjunction with BMA.</p>
<h5 id="approximate-oit">Approximate OIT</h5>
<p>Approximate OIT techniques relax the constraint of exact rendering to provide faster results. Higher performance can be gained from not having to store all fragments or only partially sorting the geometry. A number of techniques also compress, or reduce, the fragment data. These include:</p>
<ul>
<li>Stochastic Transparency: draw in a higher resolution in full opacity but discard some fragments. Down-sampling will then yield transparency.</li>
<li>Adaptive Transparency: a two-pass technique where the first constructs a visibility function which compresses on the fly (this compression avoids having to fully sort the fragments) and the second uses this data to composite unordered fragments. Intel&rsquo;s pixel synchronization avoids the need to store all fragments, removing the unbounded memory requirement of many other OIT techniques.</li>
</ul>
<h5 id="techniques">Techniques</h5>
<p>Some of the OIT techniques that have been commonly used in the industry are as follows:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Depth_peeling" target="_blank">Depth peeling</a>: Introduced in 2001, described a hardware accelerated OIT technique which utilizes the depth buffer to peel a layer of pixels at each pass. With limitations in graphics hardware the scene&rsquo;s geometry had to be rendered many times.</li>
<li><a href="http://developer.download.nvidia.com/SDK/10/opengl/src/dual_depth_peeling/doc/DualDepthPeeling.pdf" target="_blank">Dual depth peeling</a>: Introduced in 2008, improves on the performance of depth peeling, still with many-pass rendering limitation.</li>
<li><a href="http://jcgt.org/published/0002/02/09/" target="_blank">Weighted, blended</a>: Published in 2013, utilizes a weighting function and two buffers for pixel color and pixel reveal threshold for the final composition pass. Results in an approximated image with a decent quality in complex scenes.</li>
</ul>
<h5 id="implementation">Implementation</h5>
<p>The usual way of performing OIT in 3D applications is to do it in multiple passes. There are at least three passes required for an OIT technique to be performed, so in order to do this, you&rsquo;ll have to have a perfect understanding of how <a href="https://learnopengl.com/Advanced-OpenGL/Framebuffers" target="_blank">Framebuffers</a> work in OpenGL. Once you&rsquo;re comfortable with Framebuffers, it all boils down to the implementation complexity of the technique you are trying to implement.</p>
<p>Briefly explained, the three passes involved are as follows:</p>
<ol>
<li>First pass, is where you draw all of your solid objects, this means any object that does not let the light travel through its geometry.</li>
<li>Second pass, is where you draw all of your translucent objects. Objects that need alpha discarding, can be rendered in the first pass.</li>
<li>Third pass, is where you composite the images that resulted from two previous passes and draw that image onto your backbuffer.</li>
</ol>
<p>This routine is almost identical in implementing OIT techniques across all different pipelines.</p>
<p>In the next part of this article, we are going to implement weighted, blended OIT which is one of the easiest and high performance OIT techniques that has been used in the video game industry for the past ten years.</p>
<h5 id="further-reading-7">Further reading</h5>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Dreamcast#Hardware" target="_blank">SEGA Dreamcast Hardware</a>: Dreamcast was one of the few consoles that had hardware implemented order-independent transparency.</li>
<li><a href="https://en.wikipedia.org/wiki/Order-independent_transparency" target="_blank">Order-independent transparency</a>: A series of techniques that have a great performance and produce nice results even with the approximated methods.</li>
<li><a href="http://casual-effects.blogspot.com/2014/03/weighted-blended-order-independent.html" target="_blank">Weighted, blended order-independent transparency</a>: One of the easiest OIT techniques in terms of implementation while producing highly acceptable images for complex scenes.</li>
</ul>
<h5 id="weighted-blended">Weighted Blended</h5>
<p>Weighted, Blended is an approximate order-independent transparency technique which was published in the <a href="http://jcgt.org/published/0002/02/09/" target="_blank">journal of computer graphics techniques</a> in 2013 by Morgan McGuire and Louis Bavoil at NVIDIA to address the transparency problem on a broad class of then gaming platforms.</p>
<p>Their approach to avoid the cost of storing and sorting primitives or fragments is to alter the compositing operator so that it is order independent, thus allowing a pure streaming approach.</p>
<p>Most games have ad-hoc and scene-dependent ways of working around transparent surface rendering limitations. These include limited sorting, additive-only blending, and hard-coded render and composite ordering. Most of these methods also break at some point during gameplay and create visual artifacts. One not-viable alternative is <a href="http://developer.download.nvidia.com/SDK/10/opengl/screenshots/samples/dual_depth_peeling.html" target="_blank">depth peeling</a>, which produces good images, but is too slow for scenes with many layers both in theory and practice.</p>
<p>There are many <a href="https://en.wikipedia.org/wiki/Asymptotic_analysis" target="_blank">asymptotically</a> fast solutions for transparency rendering, such as bounded A-buffer approximations using programmable blending (e.g., <a href="http://software.intel.com/en-us/articles/multi-layer-alpha-blending" target="_blank">Marco Salvi&rsquo;s work</a>), stochastic transparency (as <a href="https://www.computer.org/csdl/journal/tg/2011/08/ttg2011081036/13rRUxBa55X" target="_blank">explained by Eric Enderton and others</a>), and ray tracing. One or more of these will probably dominate at some point, but all were impractical on the game platforms of five or six years ago, including PC DX11/GL4 GPUs, mobile devices with OpenGL ES 3.0 GPUs, and last-generation consoles like PlayStation 4.</p>
<p><note>In mathematical analysis, asymptotic analysis, also known as asymptotics, is a method of describing limiting behavior.</note></p>
<p>The below image is a transparent CAD view of a car engine rendered by this technique.</p>
<p><a href="#R-image-eefb9ecdeaffc94c254774446913af2e" class="lightbox-link"><img src="./assets/cad_view_of_an_engine.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-eefb9ecdeaffc94c254774446913af2e"><img src="./assets/cad_view_of_an_engine.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<h5 id="theory-1">Theory</h5>
<p>This technique renders non-refractive, monochrome transmission through surfaces that themselves have color, without requiring sorting or new hardware features. In fact, it can be implemented with a simple shader for any GPU that supports blending to render targets with more than 8 bits per channel.</p>
<p>It works best on GPUs with multiple render targets and floating-point texture, where it is faster than sorted transparency and avoids sorting artifacts and popping for particle systems. It also consumes less bandwidth than even a 4-deep RGBA8 K-buffer and allows mixing low-resolution particles with full-resolution surfaces such as glass.</p>
<p>For the mixed resolution case, the peak memory cost remains that of the higher resolution render target but bandwidth cost falls based on the proportional of low-resolution surfaces.</p>
<p>The basic idea of Weighted, Blended method is to compute the coverage of the background by transparent surfaces exactly, but to only approximate the light scattered towards the camera by the transparent surfaces themselves. The algorithm imposes a heuristic on inter-occlusion factor among transparent surfaces that increases with distance from the camera.</p>
<p><note>A heuristic technique, or a heuristic, is any approach to problem solving or self-discovery that employs a practical method that is not guaranteed to be optimal, perfect, or rational, but is nevertheless sufficient for reaching an immediate, short-term goal or approximation. In our case, the heuristic is the weighting function.</note></p>
<p>After all transparent surfaces have been rendered, it then performs a full-screen normalization and compositing pass to reduce errors where the heuristic was a poor approximation of the true inter-occlusion.</p>
<p>The below image is a glass chess set rendered with this technique. Note that the glass pieces are not refracting any light.</p>
<p><a href="#R-image-0789b61a98acf993c96ea7b8c350605b" class="lightbox-link"><img src="./assets/a_glass_chess_set.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-0789b61a98acf993c96ea7b8c350605b"><img src="./assets/a_glass_chess_set.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>For a better understanding and a more detailed explanation of the weight function, please refer to page 5, 6 and 7 of the original paper as the Blended OIT has been implemented and improved by different methods along the years. Link to the paper is provided at the end of this article.</p>
<h5 id="limitation">Limitation</h5>
<p>The primary limitation of the technique is that the weighting heuristic must be tuned for the anticipated depth range and opacity of transparent surfaces.</p>
<p>The technique was implemented in OpenGL for the <a href="http://g3d.sf.net/" target="_blank">G3D Innovation Engine</a> and DirectX for the <a href="http://www.unrealengine.com/" target="_blank">Unreal Engine</a> to produce the results live and in the paper. Dan Bagnell and Patrick Cozzi <a href="http://bagnell.github.io/cesium/Apps/Sandcastle/gallery/OIT.html" target="_blank">implemented it in WebGL</a> for their open-source Cesium engine (see also their <a href="http://cesiumjs.org/2014/03/14/Weighted-Blended-Order-Independent-Transparency/" target="_blank">blog post</a> discussing it).</p>
<p>From those implementations, a good set of weighting functions were found, which are reported in the journal paper. In the paper, they also discuss how to spot artifacts from a poorly-tuned weighting function and fix them.</p>
<p>Also, I haven&rsquo;t been able to find a proper way to implement this technique in a deferred renderer. Since pixels override each other in a deferred renderer, we lose information about the previous layers so we cannot correctly accumulate the color values for the lighting stage.</p>
<p>One feasible solution is to apply this technique as you would ordinarily do in a forward renderer. This is basically borrowing the transparency pass of a forward renderer and incorporate it in a deferred one.</p>
<h5 id="implementation-1">Implementation</h5>
<p>This technique is fairly straight forward to implement and the shader modifications are very simple. If you&rsquo;re familiar with how Framebuffers work in OpenGL, you&rsquo;re almost halfway there.</p>
<p>The only caveat is we need to write our code in OpenGL ^4.0 to be able to use blending to multiple render targets (e.g. utilizing glBlendFunci). In the paper, different ways of implementation have been discussed for libraries that do not support rendering or blending to multiple targets.</p>
<p><warning>Don&rsquo;t forget to change your OpenGL version when initializng GLFW and also your GLSL version in your shaders.</warning></p>
<h5 id="overview">Overview</h5>
<p>During the transparent surface rendering, shade surfaces as usual, but output to two render targets. The first render target (accum) must have at least RGBA16F precision and the second (revealage) must have at least R8 precision. Clear the first render target to vec4(0) and the second render target to 1 (using a pixel shader or glClearBuffer + glClear).</p>
<p>Then, render the surfaces in any order to these render targets, adding the following to the bottom of the pixel shader and using the specified blending modes:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="c1">// your first render target which is used to accumulate pre-multiplied color values
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1"></span><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">out</span> <span class="n">vec4</span> <span class="n">accum</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1">// your second render target which is used to store pixel revealage
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="c1"></span><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="n">out</span> <span class="kt">float</span> <span class="n">reveal</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1">// output linear (not gamma encoded!), unmultiplied color from the rest of the shader
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1"></span><span class="n">vec4</span> <span class="n">color</span> <span class="o">=</span> <span class="p">...</span> <span class="c1">// regular shading code
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="c1">// insert your favorite weighting function here. the color-based factor
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="c1">// avoids color pollution from the edges of wispy clouds. the z-based
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="c1">// factor gives precedence to nearer surfaces
</span></span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="c1"></span><span class="kt">float</span> <span class="n">weight</span> <span class="o">=</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="n">max</span><span class="p">(</span><span class="n">min</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">max</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">color</span><span class="p">.</span><span class="n">r</span><span class="p">,</span> <span class="n">color</span><span class="p">.</span><span class="n">g</span><span class="p">),</span> <span class="n">color</span><span class="p">.</span><span class="n">b</span><span class="p">)</span> <span class="o">*</span> <span class="n">color</span><span class="p">.</span><span class="n">a</span><span class="p">),</span> <span class="n">color</span><span class="p">.</span><span class="n">a</span><span class="p">)</span> <span class="o">*</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">    <span class="n">clamp</span><span class="p">(</span><span class="mf">0.03</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1e-5</span> <span class="o">+</span> <span class="n">pow</span><span class="p">(</span><span class="n">z</span> <span class="o">/</span> <span class="mi">200</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">)),</span> <span class="mf">1e-2</span><span class="p">,</span> <span class="mf">3e3</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">
</span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="c1">// blend func: GL_ONE, GL_ONE
</span></span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="c1">// switch to pre-multiplied alpha and weight
</span></span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="c1"></span><span class="n">accum</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">color</span><span class="p">.</span><span class="n">rgb</span> <span class="o">*</span> <span class="n">color</span><span class="p">.</span><span class="n">a</span><span class="p">,</span> <span class="n">color</span><span class="p">.</span><span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="n">weight</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">
</span></span><span class="line"><span class="ln">23</span><span class="cl"><span class="c1">// blend func: GL_ZERO, GL_ONE_MINUS_SRC_ALPHA
</span></span></span><span class="line"><span class="ln">24</span><span class="cl"><span class="c1"></span><span class="n">reveal</span> <span class="o">=</span> <span class="n">color</span><span class="p">.</span><span class="n">a</span><span class="p">;</span></span></span></code></pre></div><p>Finally, after all surfaces have been rendered, composite the result onto the screen using a full-screen pass:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="c1">// bind your accum render target to this texture unit
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1"></span><span class="n">layout</span> <span class="p">(</span><span class="n">binding</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">rt0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1">// bind your reveal render target to this texture unit
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="c1"></span><span class="n">layout</span> <span class="p">(</span><span class="n">binding</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">rt1</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1">// shader output
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="c1"></span><span class="n">out</span> <span class="n">vec4</span> <span class="n">color</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1">// fetch pixel information
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="c1"></span><span class="n">vec4</span> <span class="n">accum</span> <span class="o">=</span> <span class="n">texelFetch</span><span class="p">(</span><span class="n">rt0</span><span class="p">,</span> <span class="n">int2</span><span class="p">(</span><span class="n">gl_FragCoord</span><span class="p">.</span><span class="n">xy</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="kt">float</span> <span class="n">reveal</span> <span class="o">=</span> <span class="n">texelFetch</span><span class="p">(</span><span class="n">rt1</span><span class="p">,</span> <span class="n">int2</span><span class="p">(</span><span class="n">gl_FragCoord</span><span class="p">.</span><span class="n">xy</span><span class="p">),</span> <span class="mi">0</span><span class="p">).</span><span class="n">r</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="c1">// blend func: GL_ONE_MINUS_SRC_ALPHA, GL_SRC_ALPHA
</span></span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="c1"></span><span class="n">color</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">accum</span><span class="p">.</span><span class="n">rgb</span> <span class="o">/</span> <span class="n">max</span><span class="p">(</span><span class="n">accum</span><span class="p">.</span><span class="n">a</span><span class="p">,</span> <span class="mf">1e-5</span><span class="p">),</span> <span class="n">reveal</span><span class="p">);</span></span></span></code></pre></div><p>Use this table as a reference for your render targets:</p>
<p><a href="#R-image-56988c715d7f6e3b0300d1d30023c91a" class="lightbox-link"><img src="./assets/20240215115113.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-56988c715d7f6e3b0300d1d30023c91a"><img src="./assets/20240215115113.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>A total of three rendering passes are needed to accomplish the finished result which is down below:</p>
<p><a href="#R-image-ff62d10142c47242c5e72546d506b4fd" class="lightbox-link"><img src="./assets/weighted_blended_result.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-ff62d10142c47242c5e72546d506b4fd"><img src="./assets/weighted_blended_result.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<h5 id="details">Details</h5>
<p>To get started, we would have to setup a quad for our solid and transparent surfaces. The red quad will be the solid one, and the green and blue will be the transparent one. Since we&rsquo;re using the same quad for our screen quad as well, here we define UV values for texture mapping purposes at the screen pass.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">float</span> <span class="n">quadVertices</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    <span class="c1">// positions        // uv
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="c1"></span>    <span class="o">-</span><span class="mf">1.0f</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span>	<span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">     <span class="mf">1.0f</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">     <span class="mf">1.0f</span><span class="p">,</span>  <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">     <span class="mf">1.0f</span><span class="p">,</span>  <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="o">-</span><span class="mf">1.0f</span><span class="p">,</span>  <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="o">-</span><span class="mf">1.0f</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="c1">// quad VAO
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="c1"></span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">quadVAO</span><span class="p">,</span> <span class="n">quadVBO</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="n">glGenVertexArrays</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">quadVAO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="n">glGenBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">quadVBO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">quadVAO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">quadVBO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">quadVertices</span><span class="p">),</span> <span class="n">quadVertices</span><span class="p">,</span> <span class="n">GL_STATIC_DRAW</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="mi">5</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl"><span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="mi">5</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)(</span><span class="mi">3</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)));</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl"><span class="n">glBindVertexArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span></span></span></code></pre></div><p>Next, we will create two framebuffers for our solid and transparent passes. Our solid pass needs a color buffer and a depth buffer to store color and depth information. Our transparent pass needs two color buffers to store color accumulation and pixel revealage threshold. We will also attach the opaque framebuffer&rsquo;s depth texture to our transparent framebuffer, to utilize it for depth testing when rendering our transparent surfaces.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="c1">// set up framebuffers
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1"></span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">opaqueFBO</span><span class="p">,</span> <span class="n">transparentFBO</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">glGenFramebuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">opaqueFBO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">glGenFramebuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">transparentFBO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="c1">// set up attachments for opaque framebuffer
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1"></span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">opaqueTexture</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="n">glGenTextures</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">opaqueTexture</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">opaqueTexture</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="n">glTexImage2D</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGBA16F</span><span class="p">,</span> <span class="n">SCR_WIDTH</span><span class="p">,</span> <span class="n">SCR_HEIGHT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGBA</span><span class="p">,</span> <span class="n">GL_HALF_FLOAT</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MIN_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MAG_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">depthTexture</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="n">glGenTextures</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">depthTexture</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">depthTexture</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="n">glTexImage2D</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_DEPTH_COMPONENT</span><span class="p">,</span> <span class="n">SCR_WIDTH</span><span class="p">,</span> <span class="n">SCR_HEIGHT</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">             <span class="mi">0</span><span class="p">,</span> <span class="n">GL_DEPTH_COMPONENT</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">
</span></span><span class="line"><span class="ln">22</span><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">
</span></span><span class="line"><span class="ln">24</span><span class="cl"><span class="c1">// set up attachments for transparent framebuffer
</span></span></span><span class="line"><span class="ln">25</span><span class="cl"><span class="c1"></span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">accumTexture</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl"><span class="n">glGenTextures</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">accumTexture</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl"><span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">accumTexture</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">28</span><span class="cl"><span class="n">glTexImage2D</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGBA16F</span><span class="p">,</span> <span class="n">SCR_WIDTH</span><span class="p">,</span> <span class="n">SCR_HEIGHT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGBA</span><span class="p">,</span> <span class="n">GL_HALF_FLOAT</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">29</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MIN_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">30</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MAG_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">31</span><span class="cl"><span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">32</span><span class="cl">
</span></span><span class="line"><span class="ln">33</span><span class="cl"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">revealTexture</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">34</span><span class="cl"><span class="n">glGenTextures</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">revealTexture</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">35</span><span class="cl"><span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">revealTexture</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">36</span><span class="cl"><span class="n">glTexImage2D</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_R8</span><span class="p">,</span> <span class="n">SCR_WIDTH</span><span class="p">,</span> <span class="n">SCR_HEIGHT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RED</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">37</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MIN_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">38</span><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MAG_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">39</span><span class="cl"><span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">40</span><span class="cl">
</span></span><span class="line"><span class="ln">41</span><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="ln">42</span><span class="cl">
</span></span><span class="line"><span class="ln">43</span><span class="cl"><span class="c1">// don&#39;t forget to explicitly tell OpenGL that your transparent framebuffer has two draw buffers
</span></span></span><span class="line"><span class="ln">44</span><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="n">GLenum</span> <span class="n">transparentDrawBuffers</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">GL_COLOR_ATTACHMENT0</span><span class="p">,</span> <span class="n">GL_COLOR_ATTACHMENT1</span> <span class="p">};</span>
</span></span><span class="line"><span class="ln">45</span><span class="cl"><span class="n">glDrawBuffers</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">transparentDrawBuffers</span><span class="p">);</span></span></span></code></pre></div><p><note>For the sake of this article, we are creating two separate framebuffers, so it would be easier to understand how the technique unfolds. We could omit the opaque framebuffer and use backbuffer for our solid pass or just create a single framebuffer with four attachments all together (opaque, accumulation, revealage, depth) and render to different render targets at each pass.</note></p>
<p>Before rendering, setup some model matrices for your quads. You can set the Z axis however you want since this is an order-independent technique and objects closer or further to the camera would not impose any problem.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span> <span class="n">redModelMat</span> <span class="o">=</span> <span class="n">calculate_model_matrix</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span> <span class="n">greenModelMat</span> <span class="o">=</span> <span class="n">calculate_model_matrix</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span> <span class="n">blueModelMat</span> <span class="o">=</span> <span class="n">calculate_model_matrix</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">2.0f</span><span class="p">));</span></span></span></code></pre></div><p>At this point, we have to perform our solid pass, so configure the render states and bind the opaque framebuffer.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="c1">// configure render states
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1"></span><span class="n">glEnable</span><span class="p">(</span><span class="n">GL_DEPTH_TEST</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">glDepthFunc</span><span class="p">(</span><span class="n">GL_LESS</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">glDepthMask</span><span class="p">(</span><span class="n">GL_TRUE</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">glDisable</span><span class="p">(</span><span class="n">GL_BLEND</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">glClearColor</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="c1">// bind opaque framebuffer to render solid objects
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1"></span><span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">opaqueFBO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="n">glClear</span><span class="p">(</span><span class="n">GL_COLOR_BUFFER_BIT</span> <span class="o">|</span> <span class="n">GL_DEPTH_BUFFER_BIT</span><span class="p">);</span></span></span></code></pre></div><p>We have to reset our depth function and depth mask for the solid pass at every frame since pipeline changes these states further down the line.</p>
<p>Now, draw the solid objects using the solid shader. You can draw alpha cutout objects both at this stage and the next stage as well. The solid shader is just a simple shader that transforms the vertices and draws the mesh with the supplied color.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="c1">// use solid shader
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="c1"></span><span class="n">solidShader</span><span class="p">.</span><span class="n">use</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="c1">// draw red quad
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="c1"></span><span class="n">solidShader</span><span class="p">.</span><span class="n">setMat4</span><span class="p">(</span><span class="s">&#34;mvp&#34;</span><span class="p">,</span> <span class="n">vp</span> <span class="o">*</span> <span class="n">redModelMat</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="n">solidShader</span><span class="p">.</span><span class="n">setVec3</span><span class="p">(</span><span class="s">&#34;color&#34;</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">quadVAO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">8</span><span class="cl"><span class="n">glDrawArrays</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span></span></span></code></pre></div><p>So far so good. For our transparent pass, like in the solid pass, configure the render states to blend to these render targets as below, then bind the transparent framebuffer and clear its two color buffers to vec4(0.0f) and vec4(1.0).</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="c1">// configure render states
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1">// disable depth writes so transparent objects wouldn&#39;t interfere with solid pass depth values
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="c1"></span><span class="n">glDepthMask</span><span class="p">(</span><span class="n">GL_FALSE</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">glEnable</span><span class="p">(</span><span class="n">GL_BLEND</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">glBlendFunci</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">GL_ONE</span><span class="p">,</span> <span class="n">GL_ONE</span><span class="p">);</span> <span class="c1">// accumulation blend target
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="c1"></span><span class="n">glBlendFunci</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">GL_ZERO</span><span class="p">,</span> <span class="n">GL_ONE_MINUS_SRC_COLOR</span><span class="p">);</span> <span class="c1">// revealge blend target
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1"></span><span class="n">glBlendEquation</span><span class="p">(</span><span class="n">GL_FUNC_ADD</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1">// bind transparent framebuffer to render transparent objects
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1"></span><span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">transparentFBO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="c1">// use a four component float array or a glm::vec4(0.0)
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="c1"></span><span class="n">glClearBufferfv</span><span class="p">(</span><span class="n">GL_COLOR</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zeroFillerVec</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> 
</span></span><span class="line"><span class="ln">13</span><span class="cl"> <span class="c1">// use a four component float array or a glm::vec4(1.0)
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="c1"></span><span class="n">glClearBufferfv</span><span class="p">(</span><span class="n">GL_COLOR</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oneFillerVec</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span></span></span></code></pre></div><p>Then, draw the transparent surfaces with your preferred alpha values.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="c1">// use transparent shader
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1"></span><span class="n">transparentShader</span><span class="p">.</span><span class="n">use</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1">// draw green quad
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="c1"></span><span class="n">transparentShader</span><span class="p">.</span><span class="n">setMat4</span><span class="p">(</span><span class="s">&#34;mvp&#34;</span><span class="p">,</span> <span class="n">vp</span> <span class="o">*</span> <span class="n">greenModelMat</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">transparentShader</span><span class="p">.</span><span class="n">setVec4</span><span class="p">(</span><span class="s">&#34;color&#34;</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec4</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.5f</span><span class="p">));</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">quadVAO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="n">glDrawArrays</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1">// draw blue quad
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="c1"></span><span class="n">transparentShader</span><span class="p">.</span><span class="n">setMat4</span><span class="p">(</span><span class="s">&#34;mvp&#34;</span><span class="p">,</span> <span class="n">vp</span> <span class="o">*</span> <span class="n">blueModelMat</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="n">transparentShader</span><span class="p">.</span><span class="n">setVec4</span><span class="p">(</span><span class="s">&#34;color&#34;</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec4</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.5f</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">quadVAO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="n">glDrawArrays</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span></span></span></code></pre></div><p>The transparent shader is where half the work is done. It&rsquo;s primarily a shader that collects pixel information for our composite pass:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="c1">// shader outputs
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1"></span><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">out</span> <span class="n">vec4</span> <span class="n">accum</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="n">out</span> <span class="kt">float</span> <span class="n">reveal</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="c1">// material color
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="c1"></span><span class="n">uniform</span> <span class="n">vec4</span> <span class="n">color</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="c1">// weight function
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="c1"></span>    <span class="kt">float</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">clamp</span><span class="p">(</span><span class="n">pow</span><span class="p">(</span><span class="n">min</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">color</span><span class="p">.</span><span class="n">a</span> <span class="o">*</span> <span class="mf">10.0</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1e8</span> <span class="o">*</span> 
</span></span><span class="line"><span class="ln">12</span><span class="cl">                         <span class="n">pow</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">gl_FragCoord</span><span class="p">.</span><span class="n">z</span> <span class="o">*</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">),</span> <span class="mf">1e-2</span><span class="p">,</span> <span class="mf">3e3</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="c1">// store pixel color accumulation
</span></span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="c1"></span>    <span class="n">accum</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">color</span><span class="p">.</span><span class="n">rgb</span> <span class="o">*</span> <span class="n">color</span><span class="p">.</span><span class="n">a</span><span class="p">,</span> <span class="n">color</span><span class="p">.</span><span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="n">weight</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">
</span></span><span class="line"><span class="ln">17</span><span class="cl">    <span class="c1">// store pixel revealage threshold
</span></span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="c1"></span>    <span class="n">reveal</span> <span class="o">=</span> <span class="n">color</span><span class="p">.</span><span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>Note that, we are directly using the color passed to the shader as our final fragment color. Normally, if you are in a lighting shader, you want to use the final result of the lighting to store in accumulation and revealage render targets.</p>
<p>Now that everything has been rendered, we have to composite these two images so we can have the finished result.</p>
<p><note>Compositing is a common method in many techniques that use a post-processing quad drawn all over the screen. Think of it as merging two layers in a photo editing software like Photoshop or Gimp.</note></p>
<p>In OpenGL, we can achieve this by color blending feature:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="c1">// set render states
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1"></span><span class="n">glDepthFunc</span><span class="p">(</span><span class="n">GL_ALWAYS</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">glEnable</span><span class="p">(</span><span class="n">GL_BLEND</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">glBlendFunc</span><span class="p">(</span><span class="n">GL_SRC_ALPHA</span><span class="p">,</span> <span class="n">GL_ONE_MINUS_SRC_ALPHA</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="c1">// bind opaque framebuffer
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1"></span><span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">opaqueFBO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1">// use composite shader
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1"></span><span class="n">compositeShader</span><span class="p">.</span><span class="n">use</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="c1">// draw screen quad
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="c1"></span><span class="n">glActiveTexture</span><span class="p">(</span><span class="n">GL_TEXTURE0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">accumTexture</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="n">glActiveTexture</span><span class="p">(</span><span class="n">GL_TEXTURE1</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">revealTexture</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">quadVAO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="n">glDrawArrays</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span></span></span></code></pre></div><p>Composite shader is where the other half of the work is done. We&rsquo;re basically merging two layers, one being the solid objects image and the other being the transparent objects image. Accumulation buffer tells us about the color and revealage buffer determines the visibility of the the underlying pixel:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="c1">// shader outputs
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1"></span><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">out</span> <span class="n">vec4</span> <span class="n">frag</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1">// color accumulation buffer
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="c1"></span><span class="n">layout</span> <span class="p">(</span><span class="n">binding</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">accum</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1">// revealage threshold buffer
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="c1"></span><span class="n">layout</span> <span class="p">(</span><span class="n">binding</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">reveal</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1">// epsilon number
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">float</span> <span class="n">EPSILON</span> <span class="o">=</span> <span class="mf">0.00001f</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="c1">// calculate floating point numbers equality accurately
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="c1"></span><span class="kt">bool</span> <span class="nf">isApproximatelyEqual</span><span class="p">(</span><span class="kt">float</span> <span class="n">a</span><span class="p">,</span> <span class="kt">float</span> <span class="n">b</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="k">return</span> <span class="n">abs</span><span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">abs</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">?</span> <span class="n">abs</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">:</span> <span class="n">abs</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="o">*</span> <span class="n">EPSILON</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">
</span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="c1">// get the max value between three values
</span></span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="c1"></span><span class="kt">float</span> <span class="nf">max3</span><span class="p">(</span><span class="n">vec3</span> <span class="n">v</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">    <span class="k">return</span> <span class="n">max</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">y</span><span class="p">),</span> <span class="n">v</span><span class="p">.</span><span class="n">z</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">
</span></span><span class="line"><span class="ln">25</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl">    <span class="c1">// fragment coordination
</span></span></span><span class="line"><span class="ln">28</span><span class="cl"><span class="c1"></span>    <span class="n">ivec2</span> <span class="n">coords</span> <span class="o">=</span> <span class="n">ivec2</span><span class="p">(</span><span class="n">gl_FragCoord</span><span class="p">.</span><span class="n">xy</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">29</span><span class="cl">
</span></span><span class="line"><span class="ln">30</span><span class="cl">    <span class="c1">// fragment revealage
</span></span></span><span class="line"><span class="ln">31</span><span class="cl"><span class="c1"></span>    <span class="kt">float</span> <span class="n">revealage</span> <span class="o">=</span> <span class="n">texelFetch</span><span class="p">(</span><span class="n">reveal</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="mi">0</span><span class="p">).</span><span class="n">r</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">32</span><span class="cl">
</span></span><span class="line"><span class="ln">33</span><span class="cl">    <span class="c1">// save the blending and color texture fetch cost if there is not a transparent fragment
</span></span></span><span class="line"><span class="ln">34</span><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">isApproximatelyEqual</span><span class="p">(</span><span class="n">revealage</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">))</span>
</span></span><span class="line"><span class="ln">35</span><span class="cl">        <span class="n">discard</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">36</span><span class="cl">
</span></span><span class="line"><span class="ln">37</span><span class="cl">    <span class="c1">// fragment color
</span></span></span><span class="line"><span class="ln">38</span><span class="cl"><span class="c1"></span>    <span class="n">vec4</span> <span class="n">accumulation</span> <span class="o">=</span> <span class="n">texelFetch</span><span class="p">(</span><span class="n">accum</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">39</span><span class="cl">
</span></span><span class="line"><span class="ln">40</span><span class="cl">    <span class="c1">// suppress overflow
</span></span></span><span class="line"><span class="ln">41</span><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">isinf</span><span class="p">(</span><span class="n">max3</span><span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">accumulation</span><span class="p">.</span><span class="n">rgb</span><span class="p">))))</span>
</span></span><span class="line"><span class="ln">42</span><span class="cl">        <span class="n">accumulation</span><span class="p">.</span><span class="n">rgb</span> <span class="o">=</span> <span class="n">vec3</span><span class="p">(</span><span class="n">accumulation</span><span class="p">.</span><span class="n">a</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">43</span><span class="cl">
</span></span><span class="line"><span class="ln">44</span><span class="cl">    <span class="c1">// prevent floating point precision bug
</span></span></span><span class="line"><span class="ln">45</span><span class="cl"><span class="c1"></span>    <span class="n">vec3</span> <span class="n">average_color</span> <span class="o">=</span> <span class="n">accumulation</span><span class="p">.</span><span class="n">rgb</span> <span class="o">/</span> <span class="n">max</span><span class="p">(</span><span class="n">accumulation</span><span class="p">.</span><span class="n">a</span><span class="p">,</span> <span class="n">EPSILON</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">46</span><span class="cl">
</span></span><span class="line"><span class="ln">47</span><span class="cl">    <span class="c1">// blend pixels
</span></span></span><span class="line"><span class="ln">48</span><span class="cl"><span class="c1"></span>    <span class="n">frag</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">average_color</span><span class="p">,</span> <span class="mf">1.0f</span> <span class="o">-</span> <span class="n">revealage</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">49</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>Note that, we are using some helper functions like isApproximatelyEqual or max3 to help us with the accurate calculation of floating-point numbers. Due to inaccuracy of floating-point numbers calculation in current generation processors, we need to compare our values with an extremely small amount called an epsilon to avoid underflows or overflows.</p>
<p>Also, we don&rsquo;t need an intermediate framebuffer to do compositing. We can use our opaque framebuffer as the base framebuffer and paint over it since it already has the opaque pass information. Plus, we&rsquo;re stating that all depth tests should pass since we want to paint over the opaque image.</p>
<p>Finally, draw your composited image (which is the opaque texture attachment since you rendered your transparent image over it in the last pass) onto the backbuffer and observe the result.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="c1">// set render states
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1"></span><span class="n">glDisable</span><span class="p">(</span><span class="n">GL_DEPTH</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">glDepthMask</span><span class="p">(</span><span class="n">GL_TRUE</span><span class="p">);</span> <span class="c1">// enable depth writes so glClear won&#39;t ignore clearing the depth buffer
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1"></span><span class="n">glDisable</span><span class="p">(</span><span class="n">GL_BLEND</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="c1">// bind backbuffer
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1"></span><span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="n">glClearColor</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="n">glClear</span><span class="p">(</span><span class="n">GL_COLOR_BUFFER_BIT</span> <span class="o">|</span> <span class="n">GL_DEPTH_BUFFER_BIT</span> <span class="o">|</span> <span class="n">GL_STENCIL_BUFFER_BIT</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="c1">// use screen shader
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="c1"></span><span class="n">screenShader</span><span class="p">.</span><span class="n">use</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="c1">// draw final screen quad
</span></span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="c1"></span><span class="n">glActiveTexture</span><span class="p">(</span><span class="n">GL_TEXTURE0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">opaqueTexture</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">quadVAO</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="n">glDrawArrays</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span></span></span></code></pre></div><p>Screen shader is just a simple post-processing shader which draws a full-screen quad.</p>
<p>In a regular pipeline, you would also apply gamma-correction, tone-mapping, etc. in an intermediate post-processing framebuffer before you render to backbuffer, but ensure you are not applying them while rendering your solid and transparent surfaces and also not before composition since this transparency technique needs raw color values for calculating transparent pixels.</p>
<p>Now, the interesting part is to play with the Z axis of your objects to see order-independence in action. Try to place your transparent objects behind the solid object or mess up the orders entirely.</p>
<p><a href="#R-image-605e60c993836870666fe6e3f8a09277" class="lightbox-link"><img src="./assets/weighted_blended_reordered.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-605e60c993836870666fe6e3f8a09277"><img src="./assets/weighted_blended_reordered.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>In the image above, the green quad is rendered after the red quad, but behind it, and if you move the camera around to see the green quad from behind, you won&rsquo;t see any artifacts.</p>
<p>As stated earlier, one limitation that this technique imposes is that for scenes with higher depth/alpha complexity we need to tune the weighting function to achieve the correct result. Luckily, a number of tested weighting functions are provided in the paper which you can refer and investigate them for your environment.</p>
<p>Be sure to also check the colored transmission transparency which is the improved version of this technique in the links below.</p>
<p>You can find the source code for this demo <a href="https://learnopengl.com/code_viewer_gh.php?code=src/8.guest/2020/oit/weighted_blended.cpp" target="_blank">here</a>.</p>
<h5 id="further-reading-8">Further reading</h5>
<ul>
<li><a href="http://jcgt.org/published/0002/02/09" target="_blank">Weighted, Blended paper</a>: The original paper published in the journal of computer graphics. A brief history of the transparency and the emergence of the technique itself is provided. This is a must for the dedicated readers.</li>
<li><a href="http://casual-effects.blogspot.com/2014/03/weighted-blended-order-independent.html" target="_blank">Weighted, Blended introduction</a>: Casual Effects is Morgan McGuire&rsquo;s personal blog. This post is the introduction of their technique which goes into further details and is definitely worth to read. Plus, there are videos of their implementation live in action that you would not want to miss.</li>
<li><a href="http://casual-effects.blogspot.com/2015/03/implemented-weighted-blended-order.html" target="_blank">Weighted, Blended for implementors</a>: And also another blog post by him on implementing the technique for implementors.</li>
<li><a href="http://casual-effects.blogspot.com/2015/03/colored-blended-order-independent.html" target="_blank">Weighted, Blended and colored transmission</a>: And another blog post on colored transmission for transparent surfaces.</li>
<li><a href="http://bagnell.github.io/cesium/Apps/Sandcastle/gallery/OIT.html" target="_blank">A live implementation of the technique</a>: This is a live WebGL visualization from Cesium engine which accepts weighting functions for you to test in your browser!</li>
</ul>
<h4 id="skeletal-animation">Skeletal Animation</h4>
<p>3D Animations can bring our games to life. Objects in 3D world like humans and animals feel more organic when they move their limbs to do certain things like walking, running &amp; attacking. This tutorial is about Skeletal animation which you all have been waiting for. We will first understand the concept thoroughly and then understand the data we need to animate a 3D model using Assimp. I&rsquo;d recommend you to finish the <a href="https://learnopengl.com/Model-Loading/Assimp" target="_blank">Model Loading</a> section of this saga as this tutorial code continues from there. You can still understand the concept and implement it in your way. So let&rsquo;s get started.</p>
<h5 id="interpolation">Interpolation</h5>
<p>To understand how animation works at basic level we need to understand the concept of Interpolation. Interpolation can be defined as something happening over time. Like an enemy moving from point A to point B in time T i.e Translation happening over time . A gun turret smoothly rotates to face the target i.e Rotation happening over time and a tree is scaling up from size A to size B in time T i.e Scaling happening over time.</p>
<p>A simple interpolation equation used for Translation and Scale looks like this..</p>
<p><strong>a = a * (1 - t) + b * t</strong></p>
<p>It is known as as Linear Interpolation equation or Lerp. For Rotation we cannot use Vector. The reason for that is if we went ahead and tried to use the linear interpolation equation on a vector of X(Pitch),Y(Yaw) &amp; Z(Roll), the interpolation won&rsquo;t be linear. You will encounter weird issues like The Gimbal Lock(See references section below to learn about it). To avoid this issue we use Quaternion for rotations. Quaternion provides something called The Spherical Interpolation or Slerp equation which gives the same result as Lerp but for two rotations A &amp; B. I won&rsquo;t be able to explain how the equation works because its out of the scope for now. You can surely checkout references section below to understand The Quaternion.</p>
<h5 id="components-of-an-animated-model--skin-bones-and-keyframes">Components of An Animated Model : Skin, Bones and Keyframes</h5>
<p>The whole process of an animation starts with the addition of the first component which is The Skin in a software like blender or Maya. Skin is nothing but meshes which add visual aspect to the model to tell the viewer how it looks like. But If you want to move any mesh then just like the real world, you need to add Bones. You can see the images below to understand how it looks in software like blender&hellip;.</p>
<p><a href="#R-image-2b1a4456ade423381d9b3d22bd9ed47e" class="lightbox-link"><img src="./assets/skin.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-2b1a4456ade423381d9b3d22bd9ed47e"><img src="./assets/skin.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><a href="#R-image-652358795e784179714a90e1ecb5c0bb" class="lightbox-link"><img src="./assets/bones.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-652358795e784179714a90e1ecb5c0bb"><img src="./assets/bones.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><a href="#R-image-ac78a6459cbdd2ac0865f474ea7eb012" class="lightbox-link"><img src="./assets/merged.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-ac78a6459cbdd2ac0865f474ea7eb012"><img src="./assets/merged.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>These bones are usually added in hierarchical fashion for characters like humans &amp; animals and the reason is pretty obvious. We want parent-child relationship among limbs. For example, If we move our right shoulder then our right bicep, forearm, hand and fingers should move as well. This is how the hierarchy looks like&hellip;.</p>
<p><a href="#R-image-1b5687479e571a6dd1ad7c3cdd885d23" class="lightbox-link"><img src="./assets/parent_child.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-1b5687479e571a6dd1ad7c3cdd885d23"><img src="./assets/parent_child.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>In the above diagram if you grab the hip bone and move it, all limbs will be affected by its movement.</p>
<p>At this point, we are ready to create KeyFrames for an animation. Keyframes are poses at different point of time in an animation. We will interpolate between these Keyframes to go from one pose to another pose smoothly in our code. Below you can see how poses are created for a simple 4 frame jump animation&hellip;</p>
<p><a href="#R-image-01b71d6e2cbba84ab672a2171ff52373" class="lightbox-link"><img src="./assets/poses.gif" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-01b71d6e2cbba84ab672a2171ff52373"><img src="./assets/poses.gif" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><a href="#R-image-4e972f74f120ad6eed0fbc661f825658" class="lightbox-link"><img src="./assets/interpolating.gif" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-4e972f74f120ad6eed0fbc661f825658"><img src="./assets/interpolating.gif" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<h5 id="how-assimp-holds-animation-data">How Assimp holds animation data</h5>
<p>We are almost there to the code part but first we need to understand how assimp holds imported animation data. Look at the diagram below..</p>
<p><a href="#R-image-85687503da176d82898d81adcd4b8858" class="lightbox-link"><img src="./assets/assimp1.jpeg" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-85687503da176d82898d81adcd4b8858"><img src="./assets/assimp1.jpeg" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Just like the <a href="https://learnopengl.com/Model-Loading/Assimp" target="_blank">Model Loading</a> section, we will start with the <code>aiScene</code> pointer which holds a pointer to the root node and look what do we have here, an array of Animations. This array of <code>aiAnimation</code> contains the general information like duration of an animation represented here as <code>mDuration</code> and then we have a <code>mTicksPerSecond</code> variable, which controls how fast we should interpolate between frames. If you remember from the last section that an animation has keyframes. Similary, an <code>aiAnimation</code> contains an <code>aiNodeAnim</code> array called Channels. This array of contains all bones and their keyframes which are going to be engaged in an animation. An <code>aiNodeAnim</code> contains name of the bone and you will find 3 types of keys to interpolate between here, Translation,Rotation &amp; Scale.</p>
<p>Alright, there&rsquo;s one last thing we need to understand and we are good to go for writing some code.</p>
<h5 id="influence-of-multiple-bones-on-vertices">Influence of multiple bones on vertices</h5>
<p>When we curl our forearm and we see our biceps muscle pop up. We can also say that forearm bone transformation is affecting vertices on our biceps. Similary, there could be multiple bones affecting a single vertex in a mesh. For characters like solid metal robots all forearm vertices will only be affected by forearm bone but for characters like humans, animals etc, there could be upto 4 bones which can affect a vertex. Let&rsquo;s see how assimp stores that information&hellip;</p>
<p><a href="#R-image-7ed65e79c5bbdb84cf479acd866d791c" class="lightbox-link"><img src="./assets/assimp2.jpeg" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7ed65e79c5bbdb84cf479acd866d791c"><img src="./assets/assimp2.jpeg" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>We start with the <code>aiScene</code> pointer again which contains an array of all aiMeshes. Each <code>aiMesh</code> object has an array of <code>aiBone</code> which contains the information like how much influence this <code>aiBone</code> will have on set of vertices on the mesh. aiBone contains the name of the bone, an array of <code>aiVertexWeight</code> which basically tells us how much influence this <code>aiBone</code> will have on what vertices on the mesh. Now we have one more member of <code>aiBone</code> which is offsetMatrix. It&rsquo;s a 4x4 matrix used to transform vertices from model space to their bone space. You can see this in action in images below&hellip;.</p>
<p><a href="#R-image-8595ad8be8f25f197bfc49022b1a1d99" class="lightbox-link"><img src="./assets/mesh_space.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-8595ad8be8f25f197bfc49022b1a1d99"><img src="./assets/mesh_space.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><a href="#R-image-d2124f1bfac56ac7c3f5f78156ab36ce" class="lightbox-link"><img src="./assets/bone_space.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d2124f1bfac56ac7c3f5f78156ab36ce"><img src="./assets/bone_space.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>When vertices are in bone space they will be transformed relative to their bone as they are supposed to. You will soon see this in action in code.</p>
<h5 id="finally-lets-code">Finally! Let&rsquo;s code.</h5>
<p>Thank you for making it this far. We will start with directly looking at the end result which is our final vertex shader code. This will give us good sense what we need at the end..</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 430 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">pos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">norm</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec2</span> <span class="n">tex</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">5</span><span class="p">)</span> <span class="n">in</span> <span class="n">ivec4</span> <span class="n">boneIds</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="n">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">6</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec4</span> <span class="n">weights</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">	
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="n">uniform</span> <span class="n">mat4</span> <span class="n">projection</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="n">uniform</span> <span class="n">mat4</span> <span class="n">view</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="n">uniform</span> <span class="n">mat4</span> <span class="n">model</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">	
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">MAX_BONES</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">MAX_BONE_INFLUENCE</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="n">uniform</span> <span class="n">mat4</span> <span class="n">finalBonesMatrices</span><span class="p">[</span><span class="n">MAX_BONES</span><span class="p">];</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">	
</span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="n">out</span> <span class="n">vec2</span> <span class="n">TexCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">	
</span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">    <span class="n">vec4</span> <span class="n">totalPosition</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_BONE_INFLUENCE</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">boneIds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> 
</span></span><span class="line"><span class="ln">25</span><span class="cl">            <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">boneIds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span><span class="n">MAX_BONES</span><span class="p">)</span> 
</span></span><span class="line"><span class="ln">27</span><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="ln">28</span><span class="cl">            <span class="n">totalPosition</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span><span class="mf">1.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">29</span><span class="cl">            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">30</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln">31</span><span class="cl">        <span class="n">vec4</span> <span class="n">localPosition</span> <span class="o">=</span> <span class="n">finalBonesMatrices</span><span class="p">[</span><span class="n">boneIds</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span><span class="mf">1.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">32</span><span class="cl">        <span class="n">totalPosition</span> <span class="o">+=</span> <span class="n">localPosition</span> <span class="o">*</span> <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="ln">33</span><span class="cl">        <span class="n">vec3</span> <span class="n">localNormal</span> <span class="o">=</span> <span class="n">mat3</span><span class="p">(</span><span class="n">finalBonesMatrices</span><span class="p">[</span><span class="n">boneIds</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span> <span class="o">*</span> <span class="n">norm</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">34</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">35</span><span class="cl">		
</span></span><span class="line"><span class="ln">36</span><span class="cl">    <span class="n">mat4</span> <span class="n">viewModel</span> <span class="o">=</span> <span class="n">view</span> <span class="o">*</span> <span class="n">model</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">37</span><span class="cl">    <span class="n">gl_Position</span> <span class="o">=</span>  <span class="n">projection</span> <span class="o">*</span> <span class="n">viewModel</span> <span class="o">*</span> <span class="n">totalPosition</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">38</span><span class="cl">    <span class="n">TexCoords</span> <span class="o">=</span> <span class="n">tex</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">39</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>Fragment shader remains the same from the <a href="https://learnopengl.com/Model-Loading/Model" target="_blank">this tutorial.</a> Starting from the top you see two new attributes layout declaration. First <code>boneIds</code> and second is <code>weights</code>. we also have a uniform array <code>finalBonesMatrices</code> which stores transformations of all bones.  <code>boneIds</code> contains indices which are used to read the <code>finalBonesMatrices</code> array and apply those transformation to <code>pos</code> vertex with their respective weights stored in <code>weights </code>array. This happens inside <code>for </code>loop above. Now let&rsquo;s add support in our <code>Mesh</code> class for bone weights first..</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#define MAX_BONE_INFLUENCE 4
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="k">struct</span> <span class="nc">Vertex</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="c1">// position
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="c1"></span>    <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">Position</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="c1">// normal
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1"></span>    <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">Normal</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="c1">// texCoords
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1"></span>    <span class="n">glm</span><span class="o">::</span><span class="n">vec2</span> <span class="n">TexCoords</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">	
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="c1">// tangent
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="c1"></span>    <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">Tangent</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="c1">// bitangent
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="c1"></span>    <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">Bitangent</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="c1">//bone indexes which will influence this vertex
</span></span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">m_BoneIDs</span><span class="p">[</span><span class="n">MAX_BONE_INFLUENCE</span><span class="p">];</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">    <span class="c1">//weights from each bone
</span></span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="c1"></span>    <span class="kt">float</span> <span class="n">m_Weights</span><span class="p">[</span><span class="n">MAX_BONE_INFLUENCE</span><span class="p">];</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">  
</span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="p">};</span></span></span></code></pre></div><p>We have added two new attributes for the <code>Vertex</code>, just like we saw in our vertex shader. Now&rsquo;s let&rsquo;s load them in GPU buffers just like other attributes in our <code>Mesh::setupMesh </code>function&hellip;</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">class</span> <span class="nc">Mesh</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="kt">void</span> <span class="n">setupMesh</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">        <span class="p">....</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">        <span class="c1">// ids
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1"></span>        <span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">        <span class="n">glVertexAttribIPointer</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">GL_INT</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Vertex</span><span class="p">),</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">offsetof</span><span class="p">(</span><span class="n">Vertex</span><span class="p">,</span> <span class="n">m_BoneIDs</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">
</span></span><span class="line"><span class="ln">13</span><span class="cl">        <span class="c1">// weights
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="c1"></span>        <span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">        <span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Vertex</span><span class="p">),</span> 
</span></span><span class="line"><span class="ln">16</span><span class="cl">            <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">offsetof</span><span class="p">(</span><span class="n">Vertex</span><span class="p">,</span> <span class="n">m_Weights</span><span class="p">));</span>   
</span></span><span class="line"><span class="ln">17</span><span class="cl">  
</span></span><span class="line"><span class="ln">18</span><span class="cl">        <span class="p">...</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">    <span class="p">}</span>    
</span></span><span class="line"><span class="ln">20</span><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>Just like before, except now we have added 3 and 4 layout location ids for <code>boneIds</code> and <code>weights</code>. One imporant thing to notice here is how we are passing data for <code>boneIds</code>. We are using <code>glVertexAttribIPointer</code> and we passed GL_INT as third parameter.</p>
<p>Now we can extract the bone-weight information from the assimp data structure. Let&rsquo;s make some changes in Model class&hellip;</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">struct</span> <span class="nc">BoneInfo</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="cm">/*id is index in finalBoneMatrices*/</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="kt">int</span> <span class="n">id</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">
</span></span><span class="line"><span class="ln">6</span><span class="cl">    <span class="cm">/*offset matrix transforms vertex from model space to bone space*/</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl">    <span class="n">glm</span><span class="o">::</span><span class="n">mat4</span> <span class="n">offset</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">8</span><span class="cl">
</span></span><span class="line"><span class="ln">9</span><span class="cl"><span class="p">};</span></span></span></code></pre></div><p>This <code>BoneInfo </code>will store our offset matrix and also a unique id which will be used as an index to store it in <code>finalBoneMatrices</code> array we saw earlier in our shader. Now we will add bone weight extraction support in <code>Model</code>&hellip;</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">  1</span><span class="cl"><span class="k">class</span> <span class="nc">Model</span> 
</span></span><span class="line"><span class="ln">  2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">  3</span><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="ln">  4</span><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="ln">  5</span><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">BoneInfo</span><span class="o">&gt;</span> <span class="n">m_BoneInfoMap</span><span class="p">;</span> <span class="c1">//
</span></span></span><span class="line"><span class="ln">  6</span><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">m_BoneCounter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">  7</span><span class="cl">
</span></span><span class="line"><span class="ln">  8</span><span class="cl">    <span class="k">auto</span><span class="o">&amp;</span> <span class="n">GetBoneInfoMap</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_BoneInfoMap</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="ln">  9</span><span class="cl">    <span class="kt">int</span><span class="o">&amp;</span> <span class="n">GetBoneCount</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_BoneCounter</span><span class="p">;</span> <span class="p">}</span>    
</span></span><span class="line"><span class="ln"> 10</span><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="ln"> 11</span><span class="cl">    <span class="kt">void</span> <span class="n">SetVertexBoneDataToDefault</span><span class="p">(</span><span class="n">Vertex</span><span class="o">&amp;</span> <span class="n">vertex</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 12</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 13</span><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_BONE_WEIGHTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 14</span><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 15</span><span class="cl">            <span class="n">vertex</span><span class="p">.</span><span class="n">m_BoneIDs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 16</span><span class="cl">            <span class="n">vertex</span><span class="p">.</span><span class="n">m_Weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 17</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln"> 18</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln"> 19</span><span class="cl">
</span></span><span class="line"><span class="ln"> 20</span><span class="cl">    <span class="n">Mesh</span> <span class="nf">processMesh</span><span class="p">(</span><span class="n">aiMesh</span><span class="o">*</span> <span class="n">mesh</span><span class="p">,</span> <span class="k">const</span> <span class="n">aiScene</span><span class="o">*</span> <span class="n">scene</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 21</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 22</span><span class="cl">        <span class="n">vector</span> <span class="n">vertices</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 23</span><span class="cl">        <span class="n">vector</span> <span class="n">indices</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 24</span><span class="cl">        <span class="n">vector</span> <span class="n">textures</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 25</span><span class="cl">
</span></span><span class="line"><span class="ln"> 26</span><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mesh</span><span class="o">-&gt;</span><span class="n">mNumVertices</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 27</span><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 28</span><span class="cl">            <span class="n">Vertex</span> <span class="n">vertex</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 29</span><span class="cl">
</span></span><span class="line"><span class="ln"> 30</span><span class="cl">            <span class="n">SetVertexBoneDataToDefault</span><span class="p">(</span><span class="n">vertex</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 31</span><span class="cl">
</span></span><span class="line"><span class="ln"> 32</span><span class="cl">            <span class="n">vertex</span><span class="p">.</span><span class="n">Position</span> <span class="o">=</span> <span class="n">AssimpGLMHelpers</span><span class="o">::</span><span class="n">GetGLMVec</span><span class="p">(</span><span class="n">mesh</span><span class="o">-&gt;</span><span class="n">mVertices</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="ln"> 33</span><span class="cl">            <span class="n">vertex</span><span class="p">.</span><span class="n">Normal</span> <span class="o">=</span> <span class="n">AssimpGLMHelpers</span><span class="o">::</span><span class="n">GetGLMVec</span><span class="p">(</span><span class="n">mesh</span><span class="o">-&gt;</span><span class="n">mNormals</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="ln"> 34</span><span class="cl">			
</span></span><span class="line"><span class="ln"> 35</span><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">mesh</span><span class="o">-&gt;</span><span class="n">mTextureCoords</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</span></span><span class="line"><span class="ln"> 36</span><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 37</span><span class="cl">                <span class="n">glm</span><span class="o">::</span><span class="n">vec2</span> <span class="n">vec</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 38</span><span class="cl">                <span class="n">vec</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">-&gt;</span><span class="n">mTextureCoords</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 39</span><span class="cl">                <span class="n">vec</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">-&gt;</span><span class="n">mTextureCoords</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 40</span><span class="cl">                <span class="n">vertex</span><span class="p">.</span><span class="n">TexCoords</span> <span class="o">=</span> <span class="n">vec</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 41</span><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="ln"> 42</span><span class="cl">            <span class="k">else</span>
</span></span><span class="line"><span class="ln"> 43</span><span class="cl">                <span class="n">vertex</span><span class="p">.</span><span class="n">TexCoords</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec2</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 44</span><span class="cl">
</span></span><span class="line"><span class="ln"> 45</span><span class="cl">            <span class="n">vertices</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">vertex</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 46</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln"> 47</span><span class="cl">        <span class="p">...</span>
</span></span><span class="line"><span class="ln"> 48</span><span class="cl">        <span class="n">ExtractBoneWeightForVertices</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span><span class="n">mesh</span><span class="p">,</span><span class="n">scene</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 49</span><span class="cl">
</span></span><span class="line"><span class="ln"> 50</span><span class="cl">        <span class="k">return</span> <span class="n">Mesh</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">textures</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 51</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln"> 52</span><span class="cl">
</span></span><span class="line"><span class="ln"> 53</span><span class="cl">    <span class="kt">void</span> <span class="nf">SetVertexBoneData</span><span class="p">(</span><span class="n">Vertex</span><span class="o">&amp;</span> <span class="n">vertex</span><span class="p">,</span> <span class="kt">int</span> <span class="n">boneID</span><span class="p">,</span> <span class="kt">float</span> <span class="n">weight</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 54</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 55</span><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_BONE_WEIGHTS</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 56</span><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 57</span><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">vertex</span><span class="p">.</span><span class="n">m_BoneIDs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 58</span><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 59</span><span class="cl">                <span class="n">vertex</span><span class="p">.</span><span class="n">m_Weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">weight</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 60</span><span class="cl">                <span class="n">vertex</span><span class="p">.</span><span class="n">m_BoneIDs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">boneID</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 61</span><span class="cl">                <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 62</span><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="ln"> 63</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln"> 64</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln"> 65</span><span class="cl">
</span></span><span class="line"><span class="ln"> 66</span><span class="cl">    <span class="kt">void</span> <span class="nf">ExtractBoneWeightForVertices</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&amp;</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">aiMesh</span><span class="o">*</span> <span class="n">mesh</span><span class="p">,</span> <span class="k">const</span> <span class="n">aiScene</span><span class="o">*</span> <span class="n">scene</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 67</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 68</span><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">boneIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">boneIndex</span> <span class="o">&lt;</span> <span class="n">mesh</span><span class="o">-&gt;</span><span class="n">mNumBones</span><span class="p">;</span> <span class="o">++</span><span class="n">boneIndex</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 69</span><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 70</span><span class="cl">            <span class="kt">int</span> <span class="n">boneID</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 71</span><span class="cl">            <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">boneName</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">-&gt;</span><span class="n">mBones</span><span class="p">[</span><span class="n">boneIndex</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">mName</span><span class="p">.</span><span class="n">C_Str</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 72</span><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">m_BoneInfoMap</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">boneName</span><span class="p">)</span> <span class="o">==</span> <span class="n">m_BoneInfoMap</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
</span></span><span class="line"><span class="ln"> 73</span><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 74</span><span class="cl">                <span class="n">BoneInfo</span> <span class="n">newBoneInfo</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 75</span><span class="cl">                <span class="n">newBoneInfo</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">m_BoneCounter</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 76</span><span class="cl">                <span class="n">newBoneInfo</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">AssimpGLMHelpers</span><span class="o">::</span><span class="n">ConvertMatrixToGLMFormat</span><span class="p">(</span>
</span></span><span class="line"><span class="ln"> 77</span><span class="cl">                    <span class="n">mesh</span><span class="o">-&gt;</span><span class="n">mBones</span><span class="p">[</span><span class="n">boneIndex</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">mOffsetMatrix</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 78</span><span class="cl">                <span class="n">m_BoneInfoMap</span><span class="p">[</span><span class="n">boneName</span><span class="p">]</span> <span class="o">=</span> <span class="n">newBoneInfo</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 79</span><span class="cl">                <span class="n">boneID</span> <span class="o">=</span> <span class="n">m_BoneCounter</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 80</span><span class="cl">                <span class="n">m_BoneCounter</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 81</span><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="ln"> 82</span><span class="cl">            <span class="k">else</span>
</span></span><span class="line"><span class="ln"> 83</span><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 84</span><span class="cl">                <span class="n">boneID</span> <span class="o">=</span> <span class="n">m_BoneInfoMap</span><span class="p">[</span><span class="n">boneName</span><span class="p">].</span><span class="n">id</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 85</span><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="ln"> 86</span><span class="cl">            <span class="n">assert</span><span class="p">(</span><span class="n">boneID</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 87</span><span class="cl">            <span class="k">auto</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">-&gt;</span><span class="n">mBones</span><span class="p">[</span><span class="n">boneIndex</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">mWeights</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 88</span><span class="cl">            <span class="kt">int</span> <span class="n">numWeights</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">-&gt;</span><span class="n">mBones</span><span class="p">[</span><span class="n">boneIndex</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">mNumWeights</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 89</span><span class="cl">
</span></span><span class="line"><span class="ln"> 90</span><span class="cl">            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">weightIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">weightIndex</span> <span class="o">&lt;</span> <span class="n">numWeights</span><span class="p">;</span> <span class="o">++</span><span class="n">weightIndex</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 91</span><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 92</span><span class="cl">                <span class="kt">int</span> <span class="n">vertexId</span> <span class="o">=</span> <span class="n">weights</span><span class="p">[</span><span class="n">weightIndex</span><span class="p">].</span><span class="n">mVertexId</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 93</span><span class="cl">                <span class="kt">float</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">weights</span><span class="p">[</span><span class="n">weightIndex</span><span class="p">].</span><span class="n">mWeight</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 94</span><span class="cl">                <span class="n">assert</span><span class="p">(</span><span class="n">vertexId</span> <span class="o">&lt;=</span> <span class="n">vertices</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</span></span><span class="line"><span class="ln"> 95</span><span class="cl">                <span class="n">SetVertexBoneData</span><span class="p">(</span><span class="n">vertices</span><span class="p">[</span><span class="n">vertexId</span><span class="p">],</span> <span class="n">boneID</span><span class="p">,</span> <span class="n">weight</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 96</span><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="ln"> 97</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln"> 98</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln"> 99</span><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="ln">100</span><span class="cl"><span class="p">};</span></span></span></code></pre></div><p>We start by declaring a map <code>m_BoneInfoMap</code> and a counter <code>m_BoneCounter</code> which will be incremented as soon as we read a new bone. we saw in the diagram earlier that each <code>aiMesh</code> contains all aiBones which are associated with the <code>aiMesh</code>. The whole process of the bone-weight extraction starts from the <code>processMesh </code>function. For each loop iteration we are setting <code>m_BoneIDs</code> and <code>m_Weights</code> to their default values by calling function <code>SetVertexBoneDataToDefault</code>. Just before the <code>processMesh</code> function ends, we call the <code>ExtractBoneWeightData</code>. In the <code>ExtractBoneWeightData</code> we run a for loop for each <code>aiBone</code> and check if this bone already exists in the <code>m_BoneInfoMap</code>. If we couldn&rsquo;t find it then it&rsquo;s considered a new bone and we create new <code>BoneInfo</code> with an id and store its associated <code>mOffsetMatrix</code> to it. Then we store this new <code>BoneInfo</code> in <code>m_BoneInfoMap</code> and then we increment the <code>m_BoneCounter</code> counter to create an id for next bone. In case we find the bone name in <code>m_BoneInfoMap</code> then that means this bone affects vertices of mesh out of its scope. So we take it&rsquo;s Id and proceed further to know which vertices it affects.</p>
<p>One thing to notice that we are calling <code>AssimpGLMHelpers::ConvertMatrixToGLMFormat</code>. Assimp store its matrix data in different format than GLM so this function just gives us our matrix in GLM format.</p>
<p>We have extracted the offsetMatrix for the bone and now we will simply iterate its <code>aiVertexWeight</code>array and extract all vertices indices which will be influenced by this bone along with their respective weights and call <code>SetVertexBoneData</code> to fill up <code>Vertex.boneIds</code> and <code>Vertex.weights</code> with extracted information.</p>
<p>Phew! You deserve a coffee break at this point.</p>
<h5 id="boneanimation--animator-classes">Bone,Animation &amp; Animator classes</h5>
<p>Here&rsquo;s high level view of classes..</p>
<p><a href="#R-image-a5b9e0e2dd322eac15d3bcaaab433836" class="lightbox-link"><img src="./assets/bird_eye_view.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a5b9e0e2dd322eac15d3bcaaab433836"><img src="./assets/bird_eye_view.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Let us remind ourselves what we are trying to achieve. For each rendering frame we want to interpolate all bones in heirarchy smoothly and get their final transformations matrices which will be supplied to shader uniform <code>finalBonesMatrices</code>. Here&rsquo;s what each class does&hellip;</p>
<p><strong>Bone</strong> : A single bone which reads all keyframes data from <code>aiNodeAnim</code>. It will also interpolate between its keys i.e Translation,Scale &amp; Rotation based on the current animation time.</p>
<p><strong>AssimpNodeData</strong> : This struct will help us to isolate our <code>**Animation** from Assimp.</code></p>
<p><strong>Animation</strong> : An asset which reads data from aiAnimation and create a heirarchical record of <code>**Bone**</code>s</p>
<p><strong>Animator</strong> : This will read the heirarchy of <code>AssimpNodeData</code>, Interpolate all bones in a recursive manner and then prepare final bone transformation matrices for us that we need.</p>
<p>Here&rsquo;s the code for <code>Bone</code>&hellip;</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">  1</span><span class="cl"><span class="k">struct</span> <span class="nc">KeyPosition</span>
</span></span><span class="line"><span class="ln">  2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">  3</span><span class="cl">    <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">position</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">  4</span><span class="cl">    <span class="kt">float</span> <span class="n">timeStamp</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">  5</span><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="ln">  6</span><span class="cl">
</span></span><span class="line"><span class="ln">  7</span><span class="cl"><span class="k">struct</span> <span class="nc">KeyRotation</span>
</span></span><span class="line"><span class="ln">  8</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">  9</span><span class="cl">    <span class="n">glm</span><span class="o">::</span><span class="n">quat</span> <span class="n">orientation</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 10</span><span class="cl">    <span class="kt">float</span> <span class="n">timeStamp</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 11</span><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="ln"> 12</span><span class="cl">
</span></span><span class="line"><span class="ln"> 13</span><span class="cl"><span class="k">struct</span> <span class="nc">KeyScale</span>
</span></span><span class="line"><span class="ln"> 14</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 15</span><span class="cl">    <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">scale</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 16</span><span class="cl">    <span class="kt">float</span> <span class="n">timeStamp</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 17</span><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="ln"> 18</span><span class="cl">
</span></span><span class="line"><span class="ln"> 19</span><span class="cl"><span class="k">class</span> <span class="nc">Bone</span>
</span></span><span class="line"><span class="ln"> 20</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 21</span><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="ln"> 22</span><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">KeyPosition</span><span class="o">&gt;</span> <span class="n">m_Positions</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 23</span><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">KeyRotation</span><span class="o">&gt;</span> <span class="n">m_Rotations</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 24</span><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">KeyScale</span><span class="o">&gt;</span> <span class="n">m_Scales</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 25</span><span class="cl">    <span class="kt">int</span> <span class="n">m_NumPositions</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 26</span><span class="cl">    <span class="kt">int</span> <span class="n">m_NumRotations</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 27</span><span class="cl">    <span class="kt">int</span> <span class="n">m_NumScalings</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 28</span><span class="cl">	
</span></span><span class="line"><span class="ln"> 29</span><span class="cl">    <span class="n">glm</span><span class="o">::</span><span class="n">mat4</span> <span class="n">m_LocalTransform</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 30</span><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m_Name</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 31</span><span class="cl">    <span class="kt">int</span> <span class="n">m_ID</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 32</span><span class="cl">
</span></span><span class="line"><span class="ln"> 33</span><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="ln"> 34</span><span class="cl">
</span></span><span class="line"><span class="ln"> 35</span><span class="cl"><span class="cm">/*reads keyframes from aiNodeAnim*/</span>
</span></span><span class="line"><span class="ln"> 36</span><span class="cl">    <span class="n">Bone</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ID</span><span class="p">,</span> <span class="k">const</span> <span class="n">aiNodeAnim</span><span class="o">*</span> <span class="n">channel</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 37</span><span class="cl">        <span class="o">:</span>
</span></span><span class="line"><span class="ln"> 38</span><span class="cl">        <span class="n">m_Name</span><span class="p">(</span><span class="n">name</span><span class="p">),</span>
</span></span><span class="line"><span class="ln"> 39</span><span class="cl">        <span class="n">m_ID</span><span class="p">(</span><span class="n">ID</span><span class="p">),</span>
</span></span><span class="line"><span class="ln"> 40</span><span class="cl">        <span class="n">m_LocalTransform</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 41</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 42</span><span class="cl">        <span class="n">m_NumPositions</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">mNumPositionKeys</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 43</span><span class="cl">
</span></span><span class="line"><span class="ln"> 44</span><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">positionIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">positionIndex</span> <span class="o">&lt;</span> <span class="n">m_NumPositions</span><span class="p">;</span> <span class="o">++</span><span class="n">positionIndex</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 45</span><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 46</span><span class="cl">            <span class="n">aiVector3D</span> <span class="n">aiPosition</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">mPositionKeys</span><span class="p">[</span><span class="n">positionIndex</span><span class="p">].</span><span class="n">mValue</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 47</span><span class="cl">            <span class="kt">float</span> <span class="n">timeStamp</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">mPositionKeys</span><span class="p">[</span><span class="n">positionIndex</span><span class="p">].</span><span class="n">mTime</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 48</span><span class="cl">            <span class="n">KeyPosition</span> <span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 49</span><span class="cl">            <span class="n">data</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">AssimpGLMHelpers</span><span class="o">::</span><span class="n">GetGLMVec</span><span class="p">(</span><span class="n">aiPosition</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 50</span><span class="cl">            <span class="n">data</span><span class="p">.</span><span class="n">timeStamp</span> <span class="o">=</span> <span class="n">timeStamp</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 51</span><span class="cl">            <span class="n">m_Positions</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 52</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln"> 53</span><span class="cl">
</span></span><span class="line"><span class="ln"> 54</span><span class="cl">        <span class="n">m_NumRotations</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">mNumRotationKeys</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 55</span><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">rotationIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">rotationIndex</span> <span class="o">&lt;</span> <span class="n">m_NumRotations</span><span class="p">;</span> <span class="o">++</span><span class="n">rotationIndex</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 56</span><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 57</span><span class="cl">            <span class="n">aiQuaternion</span> <span class="n">aiOrientation</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">mRotationKeys</span><span class="p">[</span><span class="n">rotationIndex</span><span class="p">].</span><span class="n">mValue</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 58</span><span class="cl">            <span class="kt">float</span> <span class="n">timeStamp</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">mRotationKeys</span><span class="p">[</span><span class="n">rotationIndex</span><span class="p">].</span><span class="n">mTime</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 59</span><span class="cl">            <span class="n">KeyRotation</span> <span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 60</span><span class="cl">            <span class="n">data</span><span class="p">.</span><span class="n">orientation</span> <span class="o">=</span> <span class="n">AssimpGLMHelpers</span><span class="o">::</span><span class="n">GetGLMQuat</span><span class="p">(</span><span class="n">aiOrientation</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 61</span><span class="cl">            <span class="n">data</span><span class="p">.</span><span class="n">timeStamp</span> <span class="o">=</span> <span class="n">timeStamp</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 62</span><span class="cl">            <span class="n">m_Rotations</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 63</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln"> 64</span><span class="cl">
</span></span><span class="line"><span class="ln"> 65</span><span class="cl">        <span class="n">m_NumScalings</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">mNumScalingKeys</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 66</span><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">keyIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">keyIndex</span> <span class="o">&lt;</span> <span class="n">m_NumScalings</span><span class="p">;</span> <span class="o">++</span><span class="n">keyIndex</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 67</span><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 68</span><span class="cl">            <span class="n">aiVector3D</span> <span class="n">scale</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">mScalingKeys</span><span class="p">[</span><span class="n">keyIndex</span><span class="p">].</span><span class="n">mValue</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 69</span><span class="cl">            <span class="kt">float</span> <span class="n">timeStamp</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">mScalingKeys</span><span class="p">[</span><span class="n">keyIndex</span><span class="p">].</span><span class="n">mTime</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 70</span><span class="cl">            <span class="n">KeyScale</span> <span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 71</span><span class="cl">            <span class="n">data</span><span class="p">.</span><span class="n">scale</span> <span class="o">=</span> <span class="n">AssimpGLMHelpers</span><span class="o">::</span><span class="n">GetGLMVec</span><span class="p">(</span><span class="n">scale</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 72</span><span class="cl">            <span class="n">data</span><span class="p">.</span><span class="n">timeStamp</span> <span class="o">=</span> <span class="n">timeStamp</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 73</span><span class="cl">            <span class="n">m_Scales</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 74</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln"> 75</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln"> 76</span><span class="cl">	
</span></span><span class="line"><span class="ln"> 77</span><span class="cl">    <span class="cm">/*interpolates  b/w positions,rotations &amp; scaling keys based on the curren time of 
</span></span></span><span class="line"><span class="ln"> 78</span><span class="cl"><span class="cm">    the animation and prepares the local transformation matrix by combining all keys 
</span></span></span><span class="line"><span class="ln"> 79</span><span class="cl"><span class="cm">    tranformations*/</span>
</span></span><span class="line"><span class="ln"> 80</span><span class="cl">    <span class="kt">void</span> <span class="nf">Update</span><span class="p">(</span><span class="kt">float</span> <span class="n">animationTime</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 81</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 82</span><span class="cl">        <span class="n">glm</span><span class="o">::</span><span class="n">mat4</span> <span class="n">translation</span> <span class="o">=</span> <span class="n">InterpolatePosition</span><span class="p">(</span><span class="n">animationTime</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 83</span><span class="cl">        <span class="n">glm</span><span class="o">::</span><span class="n">mat4</span> <span class="n">rotation</span> <span class="o">=</span> <span class="n">InterpolateRotation</span><span class="p">(</span><span class="n">animationTime</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 84</span><span class="cl">        <span class="n">glm</span><span class="o">::</span><span class="n">mat4</span> <span class="n">scale</span> <span class="o">=</span> <span class="n">InterpolateScaling</span><span class="p">(</span><span class="n">animationTime</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 85</span><span class="cl">        <span class="n">m_LocalTransform</span> <span class="o">=</span> <span class="n">translation</span> <span class="o">*</span> <span class="n">rotation</span> <span class="o">*</span> <span class="n">scale</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 86</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln"> 87</span><span class="cl">
</span></span><span class="line"><span class="ln"> 88</span><span class="cl">    <span class="n">glm</span><span class="o">::</span><span class="n">mat4</span> <span class="n">GetLocalTransform</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_LocalTransform</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="ln"> 89</span><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">GetBoneName</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_Name</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="ln"> 90</span><span class="cl">    <span class="kt">int</span> <span class="nf">GetBoneID</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_ID</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="ln"> 91</span><span class="cl">	
</span></span><span class="line"><span class="ln"> 92</span><span class="cl">
</span></span><span class="line"><span class="ln"> 93</span><span class="cl">    <span class="cm">/* Gets the current index on mKeyPositions to interpolate to based on 
</span></span></span><span class="line"><span class="ln"> 94</span><span class="cl"><span class="cm">    the current animation time*/</span>
</span></span><span class="line"><span class="ln"> 95</span><span class="cl">    <span class="kt">int</span> <span class="nf">GetPositionIndex</span><span class="p">(</span><span class="kt">float</span> <span class="n">animationTime</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 96</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 97</span><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">m_NumPositions</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">index</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 98</span><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 99</span><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">animationTime</span> <span class="o">&lt;</span> <span class="n">m_Positions</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">].</span><span class="n">timeStamp</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">100</span><span class="cl">                <span class="k">return</span> <span class="n">index</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">101</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln">102</span><span class="cl">        <span class="n">assert</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">103</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">104</span><span class="cl">
</span></span><span class="line"><span class="ln">105</span><span class="cl">    <span class="cm">/* Gets the current index on mKeyRotations to interpolate to based on the 
</span></span></span><span class="line"><span class="ln">106</span><span class="cl"><span class="cm">    current animation time*/</span>
</span></span><span class="line"><span class="ln">107</span><span class="cl">    <span class="kt">int</span> <span class="nf">GetRotationIndex</span><span class="p">(</span><span class="kt">float</span> <span class="n">animationTime</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">108</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln">109</span><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">m_NumRotations</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">index</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">110</span><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="ln">111</span><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">animationTime</span> <span class="o">&lt;</span> <span class="n">m_Rotations</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">].</span><span class="n">timeStamp</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">112</span><span class="cl">                <span class="k">return</span> <span class="n">index</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">113</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln">114</span><span class="cl">        <span class="n">assert</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">115</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">116</span><span class="cl">
</span></span><span class="line"><span class="ln">117</span><span class="cl">    <span class="cm">/* Gets the current index on mKeyScalings to interpolate to based on the 
</span></span></span><span class="line"><span class="ln">118</span><span class="cl"><span class="cm">    current animation time */</span>
</span></span><span class="line"><span class="ln">119</span><span class="cl">    <span class="kt">int</span> <span class="nf">GetScaleIndex</span><span class="p">(</span><span class="kt">float</span> <span class="n">animationTime</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">120</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln">121</span><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">m_NumScalings</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">index</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">122</span><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="ln">123</span><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">animationTime</span> <span class="o">&lt;</span> <span class="n">m_Scales</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">].</span><span class="n">timeStamp</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">124</span><span class="cl">                <span class="k">return</span> <span class="n">index</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">125</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln">126</span><span class="cl">        <span class="n">assert</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">127</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">128</span><span class="cl">
</span></span><span class="line"><span class="ln">129</span><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="ln">130</span><span class="cl">
</span></span><span class="line"><span class="ln">131</span><span class="cl">    <span class="cm">/* Gets normalized value for Lerp &amp; Slerp*/</span>
</span></span><span class="line"><span class="ln">132</span><span class="cl">    <span class="kt">float</span> <span class="n">GetScaleFactor</span><span class="p">(</span><span class="kt">float</span> <span class="n">lastTimeStamp</span><span class="p">,</span> <span class="kt">float</span> <span class="n">nextTimeStamp</span><span class="p">,</span> <span class="kt">float</span> <span class="n">animationTime</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">133</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln">134</span><span class="cl">        <span class="kt">float</span> <span class="n">scaleFactor</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">135</span><span class="cl">        <span class="kt">float</span> <span class="n">midWayLength</span> <span class="o">=</span> <span class="n">animationTime</span> <span class="o">-</span> <span class="n">lastTimeStamp</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">136</span><span class="cl">        <span class="kt">float</span> <span class="n">framesDiff</span> <span class="o">=</span> <span class="n">nextTimeStamp</span> <span class="o">-</span> <span class="n">lastTimeStamp</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">137</span><span class="cl">        <span class="n">scaleFactor</span> <span class="o">=</span> <span class="n">midWayLength</span> <span class="o">/</span> <span class="n">framesDiff</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">138</span><span class="cl">        <span class="k">return</span> <span class="n">scaleFactor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">139</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">140</span><span class="cl">
</span></span><span class="line"><span class="ln">141</span><span class="cl">    <span class="cm">/*figures out which position keys to interpolate b/w and performs the interpolation 
</span></span></span><span class="line"><span class="ln">142</span><span class="cl"><span class="cm">    and returns the translation matrix*/</span>
</span></span><span class="line"><span class="ln">143</span><span class="cl">    <span class="n">glm</span><span class="o">::</span><span class="n">mat4</span> <span class="n">InterpolatePosition</span><span class="p">(</span><span class="kt">float</span> <span class="n">animationTime</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">144</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln">145</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="mi">1</span> <span class="o">==</span> <span class="n">m_NumPositions</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">146</span><span class="cl">            <span class="k">return</span> <span class="n">glm</span><span class="o">::</span><span class="n">translate</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">),</span> <span class="n">m_Positions</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">position</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">147</span><span class="cl">
</span></span><span class="line"><span class="ln">148</span><span class="cl">        <span class="kt">int</span> <span class="n">p0Index</span> <span class="o">=</span> <span class="n">GetPositionIndex</span><span class="p">(</span><span class="n">animationTime</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">149</span><span class="cl">        <span class="kt">int</span> <span class="n">p1Index</span> <span class="o">=</span> <span class="n">p0Index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">150</span><span class="cl">        <span class="kt">float</span> <span class="n">scaleFactor</span> <span class="o">=</span> <span class="n">GetScaleFactor</span><span class="p">(</span><span class="n">m_Positions</span><span class="p">[</span><span class="n">p0Index</span><span class="p">].</span><span class="n">timeStamp</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">151</span><span class="cl">            <span class="n">m_Positions</span><span class="p">[</span><span class="n">p1Index</span><span class="p">].</span><span class="n">timeStamp</span><span class="p">,</span> <span class="n">animationTime</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">152</span><span class="cl">        <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">finalPosition</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">mix</span><span class="p">(</span><span class="n">m_Positions</span><span class="p">[</span><span class="n">p0Index</span><span class="p">].</span><span class="n">position</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">153</span><span class="cl">            <span class="n">m_Positions</span><span class="p">[</span><span class="n">p1Index</span><span class="p">].</span><span class="n">position</span><span class="p">,</span> <span class="n">scaleFactor</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">154</span><span class="cl">        <span class="k">return</span> <span class="n">glm</span><span class="o">::</span><span class="n">translate</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">),</span> <span class="n">finalPosition</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">155</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">156</span><span class="cl">
</span></span><span class="line"><span class="ln">157</span><span class="cl">    <span class="cm">/*figures out which rotations keys to interpolate b/w and performs the interpolation 
</span></span></span><span class="line"><span class="ln">158</span><span class="cl"><span class="cm">    and returns the rotation matrix*/</span>
</span></span><span class="line"><span class="ln">159</span><span class="cl">    <span class="n">glm</span><span class="o">::</span><span class="n">mat4</span> <span class="n">InterpolateRotation</span><span class="p">(</span><span class="kt">float</span> <span class="n">animationTime</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">160</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln">161</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="mi">1</span> <span class="o">==</span> <span class="n">m_NumRotations</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">162</span><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="ln">163</span><span class="cl">            <span class="k">auto</span> <span class="n">rotation</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">normalize</span><span class="p">(</span><span class="n">m_Rotations</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">orientation</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">164</span><span class="cl">            <span class="k">return</span> <span class="n">glm</span><span class="o">::</span><span class="n">toMat4</span><span class="p">(</span><span class="n">rotation</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">165</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln">166</span><span class="cl">
</span></span><span class="line"><span class="ln">167</span><span class="cl">        <span class="kt">int</span> <span class="n">p0Index</span> <span class="o">=</span> <span class="n">GetRotationIndex</span><span class="p">(</span><span class="n">animationTime</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">168</span><span class="cl">        <span class="kt">int</span> <span class="n">p1Index</span> <span class="o">=</span> <span class="n">p0Index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">169</span><span class="cl">        <span class="kt">float</span> <span class="n">scaleFactor</span> <span class="o">=</span> <span class="n">GetScaleFactor</span><span class="p">(</span><span class="n">m_Rotations</span><span class="p">[</span><span class="n">p0Index</span><span class="p">].</span><span class="n">timeStamp</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">170</span><span class="cl">            <span class="n">m_Rotations</span><span class="p">[</span><span class="n">p1Index</span><span class="p">].</span><span class="n">timeStamp</span><span class="p">,</span> <span class="n">animationTime</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">171</span><span class="cl">        <span class="n">glm</span><span class="o">::</span><span class="n">quat</span> <span class="n">finalRotation</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">slerp</span><span class="p">(</span><span class="n">m_Rotations</span><span class="p">[</span><span class="n">p0Index</span><span class="p">].</span><span class="n">orientation</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">172</span><span class="cl">            <span class="n">m_Rotations</span><span class="p">[</span><span class="n">p1Index</span><span class="p">].</span><span class="n">orientation</span><span class="p">,</span> <span class="n">scaleFactor</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">173</span><span class="cl">        <span class="n">finalRotation</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">normalize</span><span class="p">(</span><span class="n">finalRotation</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">174</span><span class="cl">        <span class="k">return</span> <span class="n">glm</span><span class="o">::</span><span class="n">toMat4</span><span class="p">(</span><span class="n">finalRotation</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">175</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">176</span><span class="cl">
</span></span><span class="line"><span class="ln">177</span><span class="cl">    <span class="cm">/*figures out which scaling keys to interpolate b/w and performs the interpolation 
</span></span></span><span class="line"><span class="ln">178</span><span class="cl"><span class="cm">    and returns the scale matrix*/</span>
</span></span><span class="line"><span class="ln">179</span><span class="cl">    <span class="n">glm</span><span class="o">::</span><span class="n">mat4</span> <span class="n">Bone</span><span class="o">::</span><span class="n">InterpolateScaling</span><span class="p">(</span><span class="kt">float</span> <span class="n">animationTime</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">180</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln">181</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="mi">1</span> <span class="o">==</span> <span class="n">m_NumScalings</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">182</span><span class="cl">            <span class="k">return</span> <span class="n">glm</span><span class="o">::</span><span class="n">scale</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">),</span> <span class="n">m_Scales</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">scale</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">183</span><span class="cl">
</span></span><span class="line"><span class="ln">184</span><span class="cl">        <span class="kt">int</span> <span class="n">p0Index</span> <span class="o">=</span> <span class="n">GetScaleIndex</span><span class="p">(</span><span class="n">animationTime</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">185</span><span class="cl">        <span class="kt">int</span> <span class="n">p1Index</span> <span class="o">=</span> <span class="n">p0Index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">186</span><span class="cl">        <span class="kt">float</span> <span class="n">scaleFactor</span> <span class="o">=</span> <span class="n">GetScaleFactor</span><span class="p">(</span><span class="n">m_Scales</span><span class="p">[</span><span class="n">p0Index</span><span class="p">].</span><span class="n">timeStamp</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">187</span><span class="cl">            <span class="n">m_Scales</span><span class="p">[</span><span class="n">p1Index</span><span class="p">].</span><span class="n">timeStamp</span><span class="p">,</span> <span class="n">animationTime</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">188</span><span class="cl">        <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">finalScale</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">mix</span><span class="p">(</span><span class="n">m_Scales</span><span class="p">[</span><span class="n">p0Index</span><span class="p">].</span><span class="n">scale</span><span class="p">,</span> <span class="n">m_Scales</span><span class="p">[</span><span class="n">p1Index</span><span class="p">].</span><span class="n">scale</span>
</span></span><span class="line"><span class="ln">189</span><span class="cl">            <span class="p">,</span> <span class="n">scaleFactor</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">190</span><span class="cl">        <span class="k">return</span> <span class="n">glm</span><span class="o">::</span><span class="n">scale</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">),</span> <span class="n">finalScale</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">191</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">192</span><span class="cl">	
</span></span><span class="line"><span class="ln">193</span><span class="cl"><span class="p">};</span></span></span></code></pre></div><p>We start by creating 3 structs for our key types. Each struct holds a value and a time stamp. Timestamp tells us at what point of an animation we need to interpolate to its value. <code>Bone</code> has a constructor which reads from <code>aiNodeAnim</code> and stores keys and their timestamps to <code>mPositionKeys, mRotationKeys &amp; mScalingKeys </code>. The main interpolation process starts from <code>Update(float animationTime)</code> which gets called every frame. This function calls respective interpolation functions for all key types and combines all final interpolation results and store it to a 4x4 Matrix <code>m_LocalTransform</code>. The interpolations functions for translation &amp; scale keys are similar but for rotation we are using <code>Slerp</code> to interpolate between quaternions. Both <code>Lerp</code> &amp; <code>Slerp</code> takes 3 arguments. First argument takes last key, second argument takes next key and third argument takes value of range 0-1,we call it scale factor here. Let&rsquo;s see how we calculate this scale factor in function <code>GetScaleFactor</code>&hellip;</p>
<p><a href="#R-image-1e4c8db758edb8cad43b679544487e59" class="lightbox-link"><img src="./assets/scale_factor.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-1e4c8db758edb8cad43b679544487e59"><img src="./assets/scale_factor.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>In code&hellip;</p>
<p><strong>float midWayLength = animationTime - lastTimeStamp;</strong></p>
<p><strong>float framesDiff = nextTimeStamp - lastTimeStamp;</strong></p>
<p><strong>scaleFactor = midWayLength / framesDiff;</strong></p>
<p>Let&rsquo;s move on to <code>**Animation**</code> class now&hellip;</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">  1</span><span class="cl"><span class="k">struct</span> <span class="nc">AssimpNodeData</span>
</span></span><span class="line"><span class="ln">  2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">  3</span><span class="cl">    <span class="n">glm</span><span class="o">::</span><span class="n">mat4</span> <span class="n">transformation</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">  4</span><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">  5</span><span class="cl">    <span class="kt">int</span> <span class="n">childrenCount</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">  6</span><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">AssimpNodeData</span><span class="o">&gt;</span> <span class="n">children</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">  7</span><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="ln">  8</span><span class="cl">
</span></span><span class="line"><span class="ln">  9</span><span class="cl"><span class="k">class</span> <span class="nc">Animation</span>
</span></span><span class="line"><span class="ln"> 10</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 11</span><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="ln"> 12</span><span class="cl">    <span class="n">Animation</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 13</span><span class="cl">
</span></span><span class="line"><span class="ln"> 14</span><span class="cl">    <span class="n">Animation</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">animationPath</span><span class="p">,</span> <span class="n">Model</span><span class="o">*</span> <span class="n">model</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 15</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 16</span><span class="cl">        <span class="n">Assimp</span><span class="o">::</span><span class="n">Importer</span> <span class="n">importer</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 17</span><span class="cl">        <span class="k">const</span> <span class="n">aiScene</span><span class="o">*</span> <span class="n">scene</span> <span class="o">=</span> <span class="n">importer</span><span class="p">.</span><span class="n">ReadFile</span><span class="p">(</span><span class="n">animationPath</span><span class="p">,</span> <span class="n">aiProcess_Triangulate</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 18</span><span class="cl">        <span class="n">assert</span><span class="p">(</span><span class="n">scene</span> <span class="o">&amp;&amp;</span> <span class="n">scene</span><span class="o">-&gt;</span><span class="n">mRootNode</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 19</span><span class="cl">        <span class="k">auto</span> <span class="n">animation</span> <span class="o">=</span> <span class="n">scene</span><span class="o">-&gt;</span><span class="n">mAnimations</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="ln"> 20</span><span class="cl">        <span class="n">m_Duration</span> <span class="o">=</span> <span class="n">animation</span><span class="o">-&gt;</span><span class="n">mDuration</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 21</span><span class="cl">        <span class="n">m_TicksPerSecond</span> <span class="o">=</span> <span class="n">animation</span><span class="o">-&gt;</span><span class="n">mTicksPerSecond</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 22</span><span class="cl">        <span class="n">ReadHeirarchyData</span><span class="p">(</span><span class="n">m_RootNode</span><span class="p">,</span> <span class="n">scene</span><span class="o">-&gt;</span><span class="n">mRootNode</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 23</span><span class="cl">        <span class="n">ReadMissingBones</span><span class="p">(</span><span class="n">animation</span><span class="p">,</span> <span class="o">*</span><span class="n">model</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 24</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln"> 25</span><span class="cl">
</span></span><span class="line"><span class="ln"> 26</span><span class="cl">    <span class="o">~</span><span class="n">Animation</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 27</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 28</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln"> 29</span><span class="cl">
</span></span><span class="line"><span class="ln"> 30</span><span class="cl">    <span class="n">Bone</span><span class="o">*</span> <span class="nf">FindBone</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 31</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 32</span><span class="cl">        <span class="k">auto</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">find_if</span><span class="p">(</span><span class="n">m_Bones</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">m_Bones</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
</span></span><span class="line"><span class="ln"> 33</span><span class="cl">            <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span> <span class="n">Bone</span><span class="o">&amp;</span> <span class="n">Bone</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 34</span><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 35</span><span class="cl">                <span class="k">return</span> <span class="n">Bone</span><span class="p">.</span><span class="n">GetBoneName</span><span class="p">()</span> <span class="o">==</span> <span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 36</span><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="ln"> 37</span><span class="cl">        <span class="p">);</span>
</span></span><span class="line"><span class="ln"> 38</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">iter</span> <span class="o">==</span> <span class="n">m_Bones</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 39</span><span class="cl">        <span class="k">else</span> <span class="k">return</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">iter</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 40</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln"> 41</span><span class="cl">
</span></span><span class="line"><span class="ln"> 42</span><span class="cl">	
</span></span><span class="line"><span class="ln"> 43</span><span class="cl">    <span class="kr">inline</span> <span class="kt">float</span> <span class="nf">GetTicksPerSecond</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_TicksPerSecond</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="ln"> 44</span><span class="cl">
</span></span><span class="line"><span class="ln"> 45</span><span class="cl">    <span class="kr">inline</span> <span class="kt">float</span> <span class="nf">GetDuration</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_Duration</span><span class="p">;}</span>
</span></span><span class="line"><span class="ln"> 46</span><span class="cl">
</span></span><span class="line"><span class="ln"> 47</span><span class="cl">    <span class="kr">inline</span> <span class="k">const</span> <span class="n">AssimpNodeData</span><span class="o">&amp;</span> <span class="n">GetRootNode</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_RootNode</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="ln"> 48</span><span class="cl">
</span></span><span class="line"><span class="ln"> 49</span><span class="cl">    <span class="kr">inline</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="n">BoneInfo</span><span class="o">&gt;&amp;</span> <span class="n">GetBoneIDMap</span><span class="p">()</span> 
</span></span><span class="line"><span class="ln"> 50</span><span class="cl">    <span class="p">{</span> 
</span></span><span class="line"><span class="ln"> 51</span><span class="cl">        <span class="k">return</span> <span class="n">m_BoneInfoMap</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 52</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln"> 53</span><span class="cl">
</span></span><span class="line"><span class="ln"> 54</span><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="ln"> 55</span><span class="cl">    <span class="kt">void</span> <span class="n">ReadMissingBones</span><span class="p">(</span><span class="k">const</span> <span class="n">aiAnimation</span><span class="o">*</span> <span class="n">animation</span><span class="p">,</span> <span class="n">Model</span><span class="o">&amp;</span> <span class="n">model</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 56</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 57</span><span class="cl">        <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">animation</span><span class="o">-&gt;</span><span class="n">mNumChannels</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 58</span><span class="cl">
</span></span><span class="line"><span class="ln"> 59</span><span class="cl">        <span class="k">auto</span><span class="o">&amp;</span> <span class="n">boneInfoMap</span> <span class="o">=</span> <span class="n">model</span><span class="p">.</span><span class="n">GetBoneInfoMap</span><span class="p">();</span><span class="c1">//getting m_BoneInfoMap from Model class
</span></span></span><span class="line"><span class="ln"> 60</span><span class="cl"><span class="c1"></span>        <span class="kt">int</span><span class="o">&amp;</span> <span class="n">boneCount</span> <span class="o">=</span> <span class="n">model</span><span class="p">.</span><span class="n">GetBoneCount</span><span class="p">();</span> <span class="c1">//getting the m_BoneCounter from Model class
</span></span></span><span class="line"><span class="ln"> 61</span><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="ln"> 62</span><span class="cl">        <span class="c1">//reading channels(bones engaged in an animation and their keyframes)
</span></span></span><span class="line"><span class="ln"> 63</span><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 64</span><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 65</span><span class="cl">            <span class="k">auto</span> <span class="n">channel</span> <span class="o">=</span> <span class="n">animation</span><span class="o">-&gt;</span><span class="n">mChannels</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="ln"> 66</span><span class="cl">            <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">boneName</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">mNodeName</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 67</span><span class="cl">
</span></span><span class="line"><span class="ln"> 68</span><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">boneInfoMap</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">boneName</span><span class="p">)</span> <span class="o">==</span> <span class="n">boneInfoMap</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
</span></span><span class="line"><span class="ln"> 69</span><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 70</span><span class="cl">                <span class="n">boneInfoMap</span><span class="p">[</span><span class="n">boneName</span><span class="p">].</span><span class="n">id</span> <span class="o">=</span> <span class="n">boneCount</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 71</span><span class="cl">                <span class="n">boneCount</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 72</span><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="ln"> 73</span><span class="cl">            <span class="n">m_Bones</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Bone</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">mNodeName</span><span class="p">.</span><span class="n">data</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 74</span><span class="cl">                <span class="n">boneInfoMap</span><span class="p">[</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">mNodeName</span><span class="p">.</span><span class="n">data</span><span class="p">].</span><span class="n">id</span><span class="p">,</span> <span class="n">channel</span><span class="p">));</span>
</span></span><span class="line"><span class="ln"> 75</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln"> 76</span><span class="cl">
</span></span><span class="line"><span class="ln"> 77</span><span class="cl">        <span class="n">m_BoneInfoMap</span> <span class="o">=</span> <span class="n">boneInfoMap</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 78</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln"> 79</span><span class="cl">
</span></span><span class="line"><span class="ln"> 80</span><span class="cl">    <span class="kt">void</span> <span class="nf">ReadHeirarchyData</span><span class="p">(</span><span class="n">AssimpNodeData</span><span class="o">&amp;</span> <span class="n">dest</span><span class="p">,</span> <span class="k">const</span> <span class="n">aiNode</span><span class="o">*</span> <span class="n">src</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 81</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 82</span><span class="cl">        <span class="n">assert</span><span class="p">(</span><span class="n">src</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 83</span><span class="cl">
</span></span><span class="line"><span class="ln"> 84</span><span class="cl">        <span class="n">dest</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">mName</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 85</span><span class="cl">        <span class="n">dest</span><span class="p">.</span><span class="n">transformation</span> <span class="o">=</span> <span class="n">AssimpGLMHelpers</span><span class="o">::</span><span class="n">ConvertMatrixToGLMFormat</span><span class="p">(</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">mTransformation</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 86</span><span class="cl">        <span class="n">dest</span><span class="p">.</span><span class="n">childrenCount</span> <span class="o">=</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">mNumChildren</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 87</span><span class="cl">
</span></span><span class="line"><span class="ln"> 88</span><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">mNumChildren</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 89</span><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 90</span><span class="cl">            <span class="n">AssimpNodeData</span> <span class="n">newData</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 91</span><span class="cl">            <span class="n">ReadHeirarchyData</span><span class="p">(</span><span class="n">newData</span><span class="p">,</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">mChildren</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="ln"> 92</span><span class="cl">            <span class="n">dest</span><span class="p">.</span><span class="n">children</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">newData</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 93</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln"> 94</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln"> 95</span><span class="cl">    <span class="kt">float</span> <span class="n">m_Duration</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 96</span><span class="cl">    <span class="kt">int</span> <span class="n">m_TicksPerSecond</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 97</span><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Bone</span><span class="o">&gt;</span> <span class="n">m_Bones</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 98</span><span class="cl">    <span class="n">AssimpNodeData</span> <span class="n">m_RootNode</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 99</span><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">BoneInfo</span><span class="o">&gt;</span> <span class="n">m_BoneInfoMap</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">100</span><span class="cl"><span class="p">};</span></span></span></code></pre></div><p>Here, creation of an <code>Animation</code> object starts with a constructor. It takes two arguments. First, path to the animation file &amp; second parameter is the <code>Model</code> for this animation. You will see later ahead why we need this <code>Model</code> reference here. We then create an <code>Assimp::Importer</code> to read the animation file, followed by an <code>assert</code> check which will throw an error if animation could not be found. Then we read general animation data like how long is this animation which is <code>mDuration</code> and the animation speed represented by <code>mTicksPerSecond</code>. We then call <code>ReadHeirarchyData</code> which replicates <code>aiNode</code> heirarchy of Assimp and creates heirarchy of <code>AssimpNodeData</code>.</p>
<p>Then we call a function called <code>ReadMissingBones</code>. I had to write this function because sometimes when I loaded FBX model separately, it had some bones missing and I found those missing bones in the animation file. This function reads the missing bones information and stores their information in <code>m_BoneInfoMap</code> of <code>Model</code> and saves a reference of <code>m_BoneInfoMap</code> locally in the m_BoneInfoMap.</p>
<p>And we have our animation ready. Now let&rsquo;s look at our final stage, The Animator class&hellip;</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">class</span> <span class="nc">Animator</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>	
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="n">Animator</span><span class="o">::</span><span class="n">Animator</span><span class="p">(</span><span class="n">Animation</span><span class="o">*</span> <span class="n">Animation</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">        <span class="n">m_CurrentTime</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">        <span class="n">m_CurrentAnimation</span> <span class="o">=</span> <span class="n">currentAnimation</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">        <span class="n">m_FinalBoneMatrices</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">
</span></span><span class="line"><span class="ln">11</span><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">            <span class="n">m_FinalBoneMatrices</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">	
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="kt">void</span> <span class="n">Animator</span><span class="o">::</span><span class="n">UpdateAnimation</span><span class="p">(</span><span class="kt">float</span> <span class="n">dt</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">        <span class="n">m_DeltaTime</span> <span class="o">=</span> <span class="n">dt</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">m_CurrentAnimation</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">            <span class="n">m_CurrentTime</span> <span class="o">+=</span> <span class="n">m_CurrentAnimation</span><span class="o">-&gt;</span><span class="n">GetTicksPerSecond</span><span class="p">()</span> <span class="o">*</span> <span class="n">dt</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">            <span class="n">m_CurrentTime</span> <span class="o">=</span> <span class="n">fmod</span><span class="p">(</span><span class="n">m_CurrentTime</span><span class="p">,</span> <span class="n">m_CurrentAnimation</span><span class="o">-&gt;</span><span class="n">GetDuration</span><span class="p">());</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">            <span class="n">CalculateBoneTransform</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_CurrentAnimation</span><span class="o">-&gt;</span><span class="n">GetRootNode</span><span class="p">(),</span> <span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl">	
</span></span><span class="line"><span class="ln">26</span><span class="cl">    <span class="kt">void</span> <span class="n">Animator</span><span class="o">::</span><span class="n">PlayAnimation</span><span class="p">(</span><span class="n">Animation</span><span class="o">*</span> <span class="n">pAnimation</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln">28</span><span class="cl">        <span class="n">m_CurrentAnimation</span> <span class="o">=</span> <span class="n">pAnimation</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">29</span><span class="cl">        <span class="n">m_CurrentTime</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">30</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">31</span><span class="cl">	
</span></span><span class="line"><span class="ln">32</span><span class="cl">    <span class="kt">void</span> <span class="n">Animator</span><span class="o">::</span><span class="n">CalculateBoneTransform</span><span class="p">(</span><span class="k">const</span> <span class="n">AssimpNodeData</span><span class="o">*</span> <span class="n">node</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">mat4</span> <span class="n">parentTransform</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">33</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln">34</span><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">nodeName</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">35</span><span class="cl">        <span class="n">glm</span><span class="o">::</span><span class="n">mat4</span> <span class="n">nodeTransform</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">transformation</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">36</span><span class="cl">	
</span></span><span class="line"><span class="ln">37</span><span class="cl">        <span class="n">Bone</span><span class="o">*</span> <span class="n">Bone</span> <span class="o">=</span> <span class="n">m_CurrentAnimation</span><span class="o">-&gt;</span><span class="n">FindBone</span><span class="p">(</span><span class="n">nodeName</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">38</span><span class="cl">	
</span></span><span class="line"><span class="ln">39</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">Bone</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">40</span><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="ln">41</span><span class="cl">            <span class="n">Bone</span><span class="o">-&gt;</span><span class="n">Update</span><span class="p">(</span><span class="n">m_CurrentTime</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">42</span><span class="cl">            <span class="n">nodeTransform</span> <span class="o">=</span> <span class="n">Bone</span><span class="o">-&gt;</span><span class="n">GetLocalTransform</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">43</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln">44</span><span class="cl">	
</span></span><span class="line"><span class="ln">45</span><span class="cl">        <span class="n">glm</span><span class="o">::</span><span class="n">mat4</span> <span class="n">globalTransformation</span> <span class="o">=</span> <span class="n">parentTransform</span> <span class="o">*</span> <span class="n">nodeTransform</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">46</span><span class="cl">	
</span></span><span class="line"><span class="ln">47</span><span class="cl">        <span class="k">auto</span> <span class="n">boneInfoMap</span> <span class="o">=</span> <span class="n">m_CurrentAnimation</span><span class="o">-&gt;</span><span class="n">GetBoneIDMap</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">48</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">boneInfoMap</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">nodeName</span><span class="p">)</span> <span class="o">!=</span> <span class="n">boneInfoMap</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
</span></span><span class="line"><span class="ln">49</span><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="ln">50</span><span class="cl">            <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">boneInfoMap</span><span class="p">[</span><span class="n">nodeName</span><span class="p">].</span><span class="n">id</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">51</span><span class="cl">            <span class="n">glm</span><span class="o">::</span><span class="n">mat4</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">boneInfoMap</span><span class="p">[</span><span class="n">nodeName</span><span class="p">].</span><span class="n">offset</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">52</span><span class="cl">            <span class="n">m_FinalBoneMatrices</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">globalTransformation</span> <span class="o">*</span> <span class="n">offset</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">53</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln">54</span><span class="cl">	
</span></span><span class="line"><span class="ln">55</span><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">childrenCount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">56</span><span class="cl">            <span class="n">CalculateBoneTransform</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">globalTransformation</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">57</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">58</span><span class="cl">	
</span></span><span class="line"><span class="ln">59</span><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="o">&gt;</span> <span class="n">GetFinalBoneMatrices</span><span class="p">()</span> 
</span></span><span class="line"><span class="ln">60</span><span class="cl">    <span class="p">{</span> 
</span></span><span class="line"><span class="ln">61</span><span class="cl">        <span class="k">return</span> <span class="n">m_FinalBoneMatrices</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">62</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">63</span><span class="cl">		
</span></span><span class="line"><span class="ln">64</span><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="ln">65</span><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="o">&gt;</span> <span class="n">m_FinalBoneMatrices</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">66</span><span class="cl">    <span class="n">Animation</span><span class="o">*</span> <span class="n">m_CurrentAnimation</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">67</span><span class="cl">    <span class="kt">float</span> <span class="n">m_CurrentTime</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">68</span><span class="cl">    <span class="kt">float</span> <span class="n">m_DeltaTime</span><span class="p">;</span>	
</span></span><span class="line"><span class="ln">69</span><span class="cl"><span class="p">};</span></span></span></code></pre></div><p><code>Animator</code> constructor takes an animation to play and then it proceeds to reset the animation time <code>m_CurrentTime</code> to 0. It also initializes <code>m_FinalBoneMatrices</code> which is a <code>std::vector&lt;glm::mat4&gt;</code>. The main point of attention here is <code>UpdateAnimation(float deltaTime)</code> function. It advances the <code>m_CurrentTime</code> with rate of <code>m_TicksPerSecond</code> and then calls the <code>CalculateBoneTransform</code> function. We will pass two arguments in the start, first is the <code>m_RootNode</code> of <code>m_CurrentAnimation</code> and second is an identity matrix passed as <code>parentTransform</code> This function then check if <code>m_RootNode</code>s bone is engaged in this animation by finding it in <code>m_Bones</code> array of <code>Animation</code>. If bone is found then it calls <code>Bone.Update()</code> function which interpolates all bones and return local bone transform matrix to <code>nodeTransform</code>. But this is local space matrix and will move bone around origin if passed in shaders. So we multiply this <code>nodeTransform</code> with <code>parentTransform</code> and we store the result in <code>globalTransformation</code>. This would be enough but vertices are still in default model space. we find offset matrix in <code>m_BoneInfoMap</code> and then multiply it with <code>globalTransfromMatrix</code>. We will also get the id index which will be used to write final transformation of this bone to m_FinalBoneMatrices.</p>
<p>Finally! we call <code>CalculateBoneTransform</code> for each child nodes of this node and pass <code>globalTransformation</code> as <code>parentTransform</code>. We break this recursive loop when there will no children left to process further.</p>
<h5 id="lets-animate">Let&rsquo;s Animate</h5>
<p>Fruit of our hardwork is finally here! Here&rsquo;s how we will play the animation in <code>main.cpp</code> &hellip;</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">	
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="n">Model</span> <span class="n">ourModel</span><span class="p">(</span><span class="n">FileSystem</span><span class="o">::</span><span class="n">getPath</span><span class="p">(</span><span class="s">&#34;resources/objects/vampire/dancing_vampire.dae&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="n">Animation</span> <span class="n">danceAnimation</span><span class="p">(</span><span class="n">FileSystem</span><span class="o">::</span><span class="n">getPath</span><span class="p">(</span><span class="s">&#34;resources/objects/vampire/dancing_vampire.dae&#34;</span><span class="p">),</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">        <span class="o">&amp;</span><span class="n">ourModel</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="n">Animator</span> <span class="n">animator</span><span class="p">(</span><span class="o">&amp;</span><span class="n">danceAnimation</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="c1">// draw in wireframe
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="c1"></span>    <span class="c1">//glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="c1">// render loop
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="c1"></span>    <span class="c1">// -----------
</span></span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="c1"></span>    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">glfwWindowShouldClose</span><span class="p">(</span><span class="n">window</span><span class="p">))</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">        <span class="c1">// per-frame time logic
</span></span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="c1"></span>        <span class="c1">// --------------------
</span></span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="c1"></span>        <span class="kt">float</span> <span class="n">currentFrame</span> <span class="o">=</span> <span class="n">glfwGetTime</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">        <span class="n">deltaTime</span> <span class="o">=</span> <span class="n">currentFrame</span> <span class="o">-</span> <span class="n">lastFrame</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">        <span class="n">lastFrame</span> <span class="o">=</span> <span class="n">currentFrame</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">
</span></span><span class="line"><span class="ln">23</span><span class="cl">        <span class="c1">// input
</span></span></span><span class="line"><span class="ln">24</span><span class="cl"><span class="c1"></span>        <span class="c1">// -----
</span></span></span><span class="line"><span class="ln">25</span><span class="cl"><span class="c1"></span>        <span class="n">processInput</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl">        <span class="n">animator</span><span class="p">.</span><span class="n">UpdateAnimation</span><span class="p">(</span><span class="n">deltaTime</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl">		
</span></span><span class="line"><span class="ln">28</span><span class="cl">        <span class="c1">// render
</span></span></span><span class="line"><span class="ln">29</span><span class="cl"><span class="c1"></span>        <span class="c1">// ------
</span></span></span><span class="line"><span class="ln">30</span><span class="cl"><span class="c1"></span>        <span class="n">glClearColor</span><span class="p">(</span><span class="mf">0.05f</span><span class="p">,</span> <span class="mf">0.05f</span><span class="p">,</span> <span class="mf">0.05f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">31</span><span class="cl">        <span class="n">glClear</span><span class="p">(</span><span class="n">GL_COLOR_BUFFER_BIT</span> <span class="o">|</span> <span class="n">GL_DEPTH_BUFFER_BIT</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">32</span><span class="cl">
</span></span><span class="line"><span class="ln">33</span><span class="cl">        <span class="c1">// don&#39;t forget to enable shader before setting uniforms
</span></span></span><span class="line"><span class="ln">34</span><span class="cl"><span class="c1"></span>        <span class="n">ourShader</span><span class="p">.</span><span class="n">use</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">35</span><span class="cl">
</span></span><span class="line"><span class="ln">36</span><span class="cl">        <span class="c1">// view/projection transformations
</span></span></span><span class="line"><span class="ln">37</span><span class="cl"><span class="c1"></span>        <span class="n">glm</span><span class="o">::</span><span class="n">mat4</span> <span class="n">projection</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">perspective</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">radians</span><span class="p">(</span><span class="n">camera</span><span class="p">.</span><span class="n">Zoom</span><span class="p">),</span> 
</span></span><span class="line"><span class="ln">38</span><span class="cl">            <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">SCR_WIDTH</span> <span class="o">/</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">SCR_HEIGHT</span><span class="p">,</span> <span class="mf">0.1f</span><span class="p">,</span> <span class="mf">100.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">39</span><span class="cl">        <span class="n">glm</span><span class="o">::</span><span class="n">mat4</span> <span class="n">view</span> <span class="o">=</span> <span class="n">camera</span><span class="p">.</span><span class="n">GetViewMatrix</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">40</span><span class="cl">        <span class="n">ourShader</span><span class="p">.</span><span class="n">setMat4</span><span class="p">(</span><span class="s">&#34;projection&#34;</span><span class="p">,</span> <span class="n">projection</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">41</span><span class="cl">        <span class="n">ourShader</span><span class="p">.</span><span class="n">setMat4</span><span class="p">(</span><span class="s">&#34;view&#34;</span><span class="p">,</span> <span class="n">view</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">42</span><span class="cl">
</span></span><span class="line"><span class="ln">43</span><span class="cl">        <span class="k">auto</span> <span class="n">transforms</span> <span class="o">=</span> <span class="n">animator</span><span class="p">.</span><span class="n">GetFinalBoneMatrices</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">44</span><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">transforms</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">45</span><span class="cl">            <span class="n">ourShader</span><span class="p">.</span><span class="n">setMat4</span><span class="p">(</span><span class="s">&#34;finalBonesMatrices[&#34;</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#34;]&#34;</span><span class="p">,</span> <span class="n">transforms</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="ln">46</span><span class="cl">
</span></span><span class="line"><span class="ln">47</span><span class="cl">        <span class="c1">// render the loaded model
</span></span></span><span class="line"><span class="ln">48</span><span class="cl"><span class="c1"></span>        <span class="n">glm</span><span class="o">::</span><span class="n">mat4</span> <span class="n">model</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">49</span><span class="cl">        <span class="c1">// translate it down so it&#39;s at the center of the scene
</span></span></span><span class="line"><span class="ln">50</span><span class="cl"><span class="c1"></span>        <span class="n">model</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">translate</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.4f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">));</span> 
</span></span><span class="line"><span class="ln">51</span><span class="cl">        <span class="c1">// it&#39;s a bit too big for our scene, so scale it down
</span></span></span><span class="line"><span class="ln">52</span><span class="cl"><span class="c1"></span>        <span class="n">model</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">scale</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">.5f</span><span class="p">,</span> <span class="mf">.5f</span><span class="p">,</span> <span class="mf">.5f</span><span class="p">));</span>	
</span></span><span class="line"><span class="ln">53</span><span class="cl">        <span class="n">ourShader</span><span class="p">.</span><span class="n">setMat4</span><span class="p">(</span><span class="s">&#34;model&#34;</span><span class="p">,</span> <span class="n">model</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">54</span><span class="cl">        <span class="n">ourModel</span><span class="p">.</span><span class="n">Draw</span><span class="p">(</span><span class="n">ourShader</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">55</span><span class="cl">
</span></span><span class="line"><span class="ln">56</span><span class="cl">        <span class="c1">// glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.)
</span></span></span><span class="line"><span class="ln">57</span><span class="cl"><span class="c1"></span>        <span class="c1">// -------------------------------------------------------------------------------
</span></span></span><span class="line"><span class="ln">58</span><span class="cl"><span class="c1"></span>        <span class="n">glfwSwapBuffers</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">59</span><span class="cl">        <span class="n">glfwPollEvents</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">60</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">61</span><span class="cl">
</span></span><span class="line"><span class="ln">62</span><span class="cl">    <span class="c1">// glfw: terminate, clearing all previously allocated GLFW resources.
</span></span></span><span class="line"><span class="ln">63</span><span class="cl"><span class="c1"></span>    <span class="c1">// ------------------------------------------------------------------
</span></span></span><span class="line"><span class="ln">64</span><span class="cl"><span class="c1"></span>    <span class="n">glfwTerminate</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">65</span><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span></span></span></code></pre></div><p>We start with loading our <code>Model</code> which will setup bone weight data for the shader and then create an <code>Animation</code> by giving it the path. Then we create our <code>Animator</code> object by passing it the created <code>Animation</code>. In render loop we then update our <code>Animator</code>, take the final bone transformations and give it to shaders. Here&rsquo;s the output we all have been waiting for&hellip;</p>
<p><a href="#R-image-168754ee64fbb7ed8a318e3f59403c6c" class="lightbox-link"><img src="./assets/output.gif" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-168754ee64fbb7ed8a318e3f59403c6c"><img src="./assets/output.gif" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Download the model used from <a href="https://learnopengl.com/Model-Loading/Assimp" target="_blank">Here.</a> Note that animations and meshes are baked in single DAE(collada) file. You can find the full source code for this demo <a href="https://learnopengl.com/code_viewer_gh.php?code=src/8.guest/2020/skeletal_animation/skeletal_animation.cpp" target="_blank">here</a>.</p>
<h5 id="further-reading-9">Further reading</h5>
<ul>
<li><a href="http://www.songho.ca/math/quaternion/quaternion.html" target="_blank">Quaternions</a>: An article by songho to understand quaternions in depth.</li>
<li><a href="http://ogldev.atspace.co.uk/www/tutorial38/tutorial38.html" target="_blank">Skeletal Animation with Assimp</a>: An article by OGL Dev.</li>
<li><a href="https://youtu.be/f3Cr8Yx3GGA" target="_blank">Skeletal Animation with Java</a>: A fantastic youtube playlist by Thin Matrix.</li>
<li><a href="https://www.gamasutra.com/view/feature/131686/rotating_objects_using_quaternions.php" target="_blank">Why Quaternions should be used for Rotation</a>: An awesome gamasutra article.</li>
</ul>
<h3 id="2022">2022</h3>
<h4 id="compute-shaders">Compute Shaders</h4>
<h5 id="introduction-2">Introduction</h5>
<h6 id="gpu-computing">GPU Computing</h6>
<p>In this chapter, we will have a look on the compute shader and try to understand how it works and how we can create and run a compute shader. While traditionally the graphics card (GPU) has been a rendering co-processor which is handling graphics, it got more and more common to use graphics cards for other (not necessarily graphics related) computational tasks (General Purpose Computing on Graphics Processing Units; short: GPGPU-Programming). The reason for this purpose change is performance, as GPUs perform floating-point calculations much faster than today&rsquo;s CPUs. However, this performance boost comes with a hurdle in programming algorithms. Since the GPU is not a serial but a stream processor it&rsquo;s not trivial to program the same algorithms which were designed for the CPU to run on the GPU as well.</p>
<p><a href="#R-image-774761f3b0eb5ffebd82464d1de35368" class="lightbox-link"><img src="./assets/gpu_processing.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-774761f3b0eb5ffebd82464d1de35368"><img src="./assets/gpu_processing.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>A stream processor uses a function/kernel (e.g. a fragment Shader) to run over a set of input records/stream (e.g. fragments) to produce a set of output records (pixels for the final image) in parallel. Due to the parallel execution, each element is processed independently, without any dependencies between elements.</p>
<p>As stated above the most important (mandatory) aspect of programs running on GPUs is that they must be parallelizable. Sharing of memory is not easily possible and very limited for kernels running on the graphics card, this means that calculations that the kernel performs must be computed independently of each other. For example, it&rsquo;s easy to implement a program that multiplies each element in one stream with the corresponding element (e.g. by index) in a second stream while it&rsquo;s more complicated (or not completely possible in parallel) to accumulate the values of one stream to one single sum value as it always needs the result of the executions before.</p>
<p>(Even though this operation can be enhanced by the GPU using a kernel that accumulates sub-stream data in parallel and reducing the amount of serial accumulations for bigger streams. The results of the sub-stream data has to be combined in the host program afterwards).</p>
<p>It is important to keep this mandatory parallelism in mind when writing GPU kernels as the GPU is not suitable for all problems due to its stream programming model.</p>
<p><warning>In order to complete this chapter, you will need to be able to create an OpenGL 4.3+ context. The compute shaders to be discussed are only available starting in OpenGL 4.3. Using OpenGL 3.3 or earlier will result in errors. The sample shader code will use OpenGL 4.3.</warning></p>
<p>To summarize, compute shaders work great for many small parallel batches. Check out: <a href="https://www.youtube.com/watch?v=-P28LKWTzrI" target="_blank">Mythbusters Demo GPU versus CPU</a></p>
<h5 id="compute-shader-stage">Compute Shader Stage</h5>
<p>To make GPU computing easier accessible especially for graphics applications while sharing common memory mappings, the OpenGL standard introduced the compute shader in OpenGL version 4.3 as a shader stage for computing arbitrary information. While other GPGPU APIs like OpenCL and CUDA offer more features as they are aimed for heavyweight GPGPU projects, the OpenGL compute shader is intentionally designed to incorporate with other OpenGL functionality and uses GLSL to make it easier to integrate with the existing OpenGL graphics pipeline/application. Using the compute shader in OpenGL graphics applications makes it possible to avoid complicated interfacing, as it would be needed with OpenCL or CUDA.</p>
<p><a href="#R-image-2c0ad536c296c4426919aa2352c2be88" class="lightbox-link"><img src="./assets/opengl4_3_with_computeShaders.jpg" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-2c0ad536c296c4426919aa2352c2be88"><img src="./assets/opengl4_3_with_computeShaders.jpg" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Compute shaders are general-purpose shaders and in contrast to the other shader stages, they operate differently as they are not part of the graphics pipeline. (see OpenGL 4.3 with Computer Shaders). The compute shader itself defines the data &ldquo;space&rdquo; it operates on. An OpenGL function can be used to define the amount of executions that also initiates the execution of the compute operation. The computer shader does not have user-defined inputs or any outputs as known from the other shaders.</p>
<p>To pass data to the compute shader, the shader needs to fetch the data for example via texture access, image loads or shader storage block access, which has to be used as target to explicitly write the computed data to an image or shader storage block as well.</p>
<p>The following table shows the data any shader stage operates on. As shown below, the compute shaders works on an &ldquo;abstract work item&rdquo;.</p>
<p><a href="#R-image-4fa9cd0aa24eaf33d40a402d415e748a" class="lightbox-link"><img src="./assets/20240215141839.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-4fa9cd0aa24eaf33d40a402d415e748a"><img src="./assets/20240215141839.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<h6 id="compute-space">Compute space</h6>
<p>The user can use a concept called work groups to define the space the compute shader is operating on. Work Groups are the smallest amount of compute operations that the user can execute (from the host application). Wile the space of the work groups is a three-dimensional space (&ldquo;X&rdquo;, &ldquo;Y&rdquo;, &ldquo;Z&rdquo;) the user can set any of the dimension to 1 to perform the computation in one- or two-dimensional space. In the image below every green cube is one work group.</p>
<p><a href="#R-image-148314844080140d4348e977a947f5ce" class="lightbox-link"><img src="./assets/global_work_groups.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-148314844080140d4348e977a947f5ce"><img src="./assets/global_work_groups.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>During execution of the work groups the order might vary arbitrarily and the program should not rely on the order in which individual groups are processed.</p>
<p>The work group may contain many compute shader invocations. The amount of invocations of the shader is defined by the local size of the work group, which is again three-dimensional.</p>
<p>The image below shows how every work group is splitted in its local space invocations represented by the red cubes.</p>
<p><a href="#R-image-779991646954e5c3b5601ee07324939a" class="lightbox-link"><img src="./assets/local_space.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-779991646954e5c3b5601ee07324939a"><img src="./assets/local_space.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><em>An example</em>:
Given the local size of a computer shader of (128, 1, 1) and executing the shader with a work group count of (16, 8, 64). The shader will be 1,048,576 times invoked separately. This is the product of work group dimensions times the product of the local size of the compute shader: (128 * 1 * 1 * 16 * 8 * 64 = 1,048,576). Each invocation can be uniquely identified by a unique set of inputs.</p>
<p>While it is possible to communicate using shared variables and special functions between different invocations in a specific work group, it is not effectively possible to communicate between different work groups without potentially deadlocking the system.</p>
<h5 id="create-your-first-compute-shader">Create your first compute shader</h5>
<p>Now that we have a broad overview about compute shaders let&rsquo;s put it into practice by creating a &ldquo;Hello-World&rdquo; program. The program should write (color) data to the pixels of an image/texture object in the compute shader. After finishing the compute shader execution it will display the texture on the screen using a second shader program which uses a vertex shader to draw a simple screen filling quad and a fragment shader.</p>
<p>Since compute shaders are introduced in OpenGL 4.3 we need to adjust the context version first:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glfwWindowHint</span><span class="p">(</span><span class="n">GLFW_CONTEXT_VERSION_MAJOR</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glfwWindowHint</span><span class="p">(</span><span class="n">GLFW_CONTEXT_VERSION_MINOR</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span></span></span></code></pre></div><h6 id="compile-the-compute-shader">Compile the Compute Shader</h6>
<p>To being able to compile a compute shader program we need to create a new shader class. We create a new ComputeShader class, that is almost identically to the normal Shader class, but as we want to use it in combination to the normal shader stage we have to give it a new unique class name.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">class</span> <span class="nc">ComputeShader</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">     <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">          <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ID</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">		
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">          <span class="n">ComputeShader</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">computePath</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">          <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">               <span class="p">...</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">          <span class="p">}</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>Note: we could as well add a second constructor in the Shader class, which only has one parameter where we would assume that this is a compute shader but in the sake of clarity, we split them in two different classes.Additionally it is not possible to bake compute shaders into an OpenGL program object alongside other shaders.</p>
<p>The code to create and compile the shader is as well almost identically to the one for other shaders. But as the compute shader is not bound to the rest of the render pipeline we attach the shader solely to the new program using the shader type GL_COMPUTE_SHADER after creating the program itself.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">compute</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1">// compute shader
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="c1"></span><span class="n">compute</span> <span class="o">=</span> <span class="n">glCreateShader</span><span class="p">(</span><span class="n">GL_COMPUTE_SHADER</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">glShaderSource</span><span class="p">(</span><span class="n">compute</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cShaderCode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">glCompileShader</span><span class="p">(</span><span class="n">compute</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">checkCompileErrors</span><span class="p">(</span><span class="n">compute</span><span class="p">,</span> <span class="s">&#34;COMPUTE&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="c1">// shader Program
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1"></span><span class="n">ID</span> <span class="o">=</span> <span class="n">glCreateProgram</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="n">glAttachShader</span><span class="p">(</span><span class="n">ID</span><span class="p">,</span> <span class="n">compute</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="n">glLinkProgram</span><span class="p">(</span><span class="n">ID</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="n">checkCompileErrors</span><span class="p">(</span><span class="n">ID</span><span class="p">,</span> <span class="s">&#34;PROGRAM&#34;</span><span class="p">);</span></span></span></code></pre></div><p>Check out the chapter <a href="https://learnopengl.com/Getting-started/Shaders" target="_blank">Getting Started - Shaders</a> to get more information about the Shader class.</p>
<h6 id="create-the-compute-shader">Create the Compute Shader</h6>
<p>With the shader class updated, we can now write our compute shader. As always, we start by defining the version on top of the shader as well as defining the size of the local invocations per dimension in the compute shader.</p>
<p>This can be done using the special layout input declaration in the code below. By default, the local sizes are 1 so if you only want a 1D or 2D work group space, you can specify just the local_size_x or the local_size_x and local_size_y component. For the sake of completeness, we will explicitly set all components as shown below.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="cp">#version 430 core
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">local_size_x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">local_size_y</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">local_size_z</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="n">in</span><span class="p">;</span></span></span></code></pre></div><p>Since we will execute our shader for every pixel of an image, we will keep our local size at 1 in every dimension (1 pixel per work group). We will alter this value later. OpenGL will handle this local size in the background. The values must be an integral constant expression of a value greater than 0 and it must abide by limitations shown in the warning paragraph below.</p>
<p><warning>There is a limitation of work groups that can be dispatched in a single compute shader dispatch call. This limit is defined by GL_MAX_COMPUTE_WORK_GROUP_COUNT, which must/can be queried using the function glGetIntegeri_v where the indices <em>0</em>, <em>1</em> and <em>2</em> corresponds to the <em>X</em>, <em>Y</em> and <em>Z</em> dimensions, respectively.<br>There is as well a limitation on the local size which can be queried with GL_MAX_COMPUTE_WORK_GROUP_SIZE and another limitation of the total number of invocations within a work group, which is that the product of the X, Y and Z components of the local size must be less than GL_MAX_COMPUTE_WORK_GROUP_INVOCATIONS.<br>As we define and divide the tasks and the compute shader groups sizes ourselves, we have to keep these limitations in mind.</warning></p>
<p>We will bind the a 2d image in our shader as the object to write our data onto. The internal format (here rgba32f) needs to be the same as the format of the texture in the host program.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">layout</span><span class="p">(</span><span class="n">rgba32f</span><span class="p">,</span> <span class="n">binding</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">uniform</span> <span class="n">image2D</span> <span class="n">imgOutput</span><span class="p">;</span></span></span></code></pre></div><p>We have to use image2d as this represents a single image from a texture. While sampler variables use the entire texture including mipmap levels and array layers, images only have a single image from a texture. <em>Note</em> while most texture sampling functions use normalized texture coordinates [0,1], for images we need the absolute integer texel coordinates. Images and samplers are completely separated including their bindings. While samplers can only read data from textures, image variables can read and/or write data.</p>
<p>With this set up, we can now write our main function in the shader where we fill the imgOutput with color values. To determine on which pixel we are currently operating in our shader execution we can use the following GLSL Built-in variables shown in the table below:</p>
<p><a href="#R-image-783bc8d8d1c183961c1ae91b859309cd" class="lightbox-link"><img src="./assets/20240215142429.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-783bc8d8d1c183961c1ae91b859309cd"><img src="./assets/20240215142429.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Using the built-in variables from the table above we will create a simple color gradient (st-map) on our image.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">    <span class="n">vec4</span> <span class="n">value</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="n">ivec2</span> <span class="n">texelCoord</span> <span class="o">=</span> <span class="n">ivec2</span><span class="p">(</span><span class="n">gl_GlobalInvocationID</span><span class="p">.</span><span class="n">xy</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">	
</span></span><span class="line"><span class="ln">5</span><span class="cl">    <span class="n">value</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="kt">float</span><span class="p">(</span><span class="n">texelCoord</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">gl_NumWorkGroups</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">    <span class="n">value</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="kt">float</span><span class="p">(</span><span class="n">texelCoord</span><span class="p">.</span><span class="n">y</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">gl_NumWorkGroups</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl">	
</span></span><span class="line"><span class="ln">8</span><span class="cl">    <span class="n">imageStore</span><span class="p">(</span><span class="n">imgOutput</span><span class="p">,</span> <span class="n">texelCoord</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">9</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>We will setup the execution of the compute shader that every invocation corresponds to one pixel, though the global x and y size will be equal to the image&rsquo;s x and y dimension. Therefore, the gl_GlobalInvocationID gives us the absolute coordinate of the current pixel.Remember that we only have one single invocation per work group as we set all local dimensions to 1. Using the gl_NumWorkGroups variable, we can calculate the relative coordinate of the image in the range [0, 1] per dimension.</p>
<p>We can then write our calculated pixel data to the image using the imageStore function. The imageStore function takes the image unit to write to as first argument, the <strong>absolute</strong> texel coordinate as second argument and the data value to store at this texel as third.</p>
<h6 id="create-the-image-objecte">Create the Image Objecte</h6>
<p>In the host program, we can now create the actual image to write onto. We will create a 512x512 pixel texture.</p>
<div class="wrap-code highlight"><pre tabindex="0"><code>// texture size
const unsigned int TEXTURE_WIDTH = 512, TEXTURE_HEIGHT = 512;
...
unsigned int texture;

glGenTextures(1, &amp;texture);
glActiveTexture(GL_TEXTURE0);
glBindTexture(GL_TEXTURE_2D, texture);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA32F, TEXTURE_WIDTH, TEXTURE_HEIGHT, 0, GL_RGBA, 
             GL_FLOAT, NULL);

glBindImageTexture(0, texture, 0, GL_FALSE, 0, GL_READ, GL_RGBA32F);</code></pre></div><p>To find a deeper explanation of the functions used to setup a texture check out the <a href="https://learnopengl.com/Getting-started/Textures" target="_blank">Getting Started - Textures</a> chapter. Here the glBindImageTexture function is used to bind a specific level of a texture to an image unit. Since we use image2D we need to use this function instead of the glBindTexture function. <em>Note</em> that we use GL_RGBA32F as internal format corresponding to the layout format used in the compute shader.</p>
<h6 id="executing-the-compute-shader">Executing the Compute Shader</h6>
<p>With everything set up we can now finally execute our compute shader. In the drawing loop we can use/bind our compute shader and execute it using the glDispatchCompute function.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="c1">// render loop
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="c1">// -----------
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="n">computeShader</span><span class="p">.</span><span class="n">use</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="n">glDispatchCompute</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">TEXTURE_WIDTH</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">TEXTURE_HEIGHT</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">
</span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="c1">// make sure writing to image has finished before read
</span></span></span><span class="line"><span class="ln">8</span><span class="cl"><span class="c1"></span><span class="n">glMemoryBarrier</span><span class="p">(</span><span class="n">GL_SHADER_IMAGE_ACCESS_BARRIER_BIT</span><span class="p">);</span></span></span></code></pre></div><p>We first bind our shader using the use() function of the ComputeShader. The glDispatchCompute function launches one or more compute work groups based on the given 3 dimensions as arguments. Here we launch the execution two-dimensional corresponding to the image size and leave the third component to 1. While the individual shader invocations within the work group are executed as a unit, work groups are executed completely independent and in unspecific order.</p>
<p>Before accessing the image data after the compute shader execution we need to define a barrier to make sure the data writing is completly finished. The glMemoryBarrier defines such a barrier which orders memory transactions. The GLbitfield parameter barriers specifies the barriers to insert. They must be a bit wise combination of any GL barrier_bit constants (see: <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMemoryBarrier.xhtml" target="_blank">glMemoryBarrier - Khronos</a>). In this case, we only need the GL_SHADER_IMAGE_ACCESS_BARRIER_BIT which assures access using the image functions will reflect data written by shaders prior to the barrier.</p>
<p><note>It is also possible to use the GL_ALL_BARRIER_BITS variable to have a generic barrier for all types of writing.</note></p>
<p><warning>The glMemoryBarrier function will stop the execution of the host program at this point though it makes sense to insert this function right before accessing the barrier&rsquo;s data.</warning></p>
<h6 id="rendering-the-image">Rendering the image</h6>
<p>Lastly, we will render a rectangle and apply the texture in the fragment shader.</p>
<div class="wrap-code highlight"><pre tabindex="0"><code>// render image to quad
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
screenQuad.use();
screenQuad.setInt(&#34;tex&#34;, 0);
glActiveTexture(GL_TEXTURE0);
glBindTexture(GL_TEXTURE_2D, texture);
renderQuad();</code></pre></div><p>We will bind our texture now as sampler2D and use the texture coordinates of the rectangle to sample it.</p>
<p>The vertex and fragment shader are very simple as seen below.</p>
<p><strong>Vertex Shader</strong></p>
<div class="wrap-code highlight"><pre tabindex="0"><code>#version 430 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec2 aTexCoords;
	
out vec2 TexCoords;
	
void main()
{
    TexCoords = aTexCoords;
    gl_Position = vec4(aPos, 1.0);
}</code></pre></div><p><strong>Fragment Shader</strong></p>
<div class="wrap-code highlight"><pre tabindex="0"><code>#version 430 core
out vec4 FragColor;
	
in vec2 TexCoords;
	
uniform sampler2D tex;
	
void main()
{             
    vec3 texCol = texture(tex, TexCoords).rgb;      
    FragColor = vec4(texCol, 1.0);
}</code></pre></div><p><strong>Image Output</strong></p>
<p><a href="#R-image-9ce703f5b6b814e7a743cd28c3871a2b" class="lightbox-link"><img src="./assets/outputColor.jpg" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-9ce703f5b6b814e7a743cd28c3871a2b"><img src="./assets/outputColor.jpg" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<h5 id="adding-time-variable-and-speed-measuring">Adding Time Variable and Speed Measuring</h5>
<p>We will now add time to the program for performance measuring to test which settings (work group amount/local size) work best for us.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="c1">// timing 
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1"></span><span class="kt">float</span> <span class="n">deltaTime</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span> <span class="c1">// time between current frame and last frame
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="c1"></span><span class="kt">float</span> <span class="n">lastFrame</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span> <span class="c1">// time of last frame
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">fCounter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="c1">// render loop
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1">// -----------
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="c1"></span><span class="p">...</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1">// Set frame time
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1"></span><span class="kt">float</span> <span class="n">currentFrame</span> <span class="o">=</span> <span class="n">glfwGetTime</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="n">deltaTime</span> <span class="o">=</span> <span class="n">currentFrame</span> <span class="o">-</span> <span class="n">lastFrame</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="n">lastFrame</span> <span class="o">=</span> <span class="n">currentFrame</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="k">if</span><span class="p">(</span><span class="n">fCounter</span> <span class="o">&gt;</span> <span class="mi">500</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;FPS: &#34;</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">deltaTime</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">        <span class="n">fCounter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">    <span class="n">fCounter</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="p">}</span>		
</span></span></code></pre></div><p>The code above prints the frames per second limited to one print every 500 frames as too frequent printing slows the program down. When running our program with this &ldquo;stopwatch&rdquo; we will see that it will never get over 60 frames per second as glfw locks the refresh rate by default to 60fps.</p>
<p>To bypass this lock we can set the swap interval for the current OpenGL Context to 0 to get a bigger refresh rate than 60 fps. We can use the function glfwSwapInterval function for this when initializing the glfw context:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glfwMakeContextCurrent</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">glfwSetFramebufferSizeCallback</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">framebuffer_size_callback</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">glfwSwapInterval</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span></span></span></code></pre></div><p>Now we can get much more frames per seconds rendered/calculated. To be fair this example/hello world program is very easy and actually doesnt have any complex calculations so the calcuation times are very low.</p>
<p>We can now make our texture animated (moving from left to write) using the time variable. First, we change our computeShader to be animated:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 430 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">local_size_x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">local_size_y</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">local_size_z</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="n">in</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">	
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="c1">// images 
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="c1"></span><span class="n">layout</span><span class="p">(</span><span class="n">rgba32f</span><span class="p">,</span> <span class="n">binding</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">uniform</span> <span class="n">image2D</span> <span class="n">imgOutput</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="c1">// variables
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1"></span><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">uniform</span> <span class="kt">float</span> <span class="n">t</span><span class="p">;</span>                 <span class="cm">/** Time */</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">	
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="n">vec4</span> <span class="n">value</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="n">ivec2</span> <span class="n">texelCoord</span> <span class="o">=</span> <span class="n">ivec2</span><span class="p">(</span><span class="n">gl_GlobalInvocationID</span><span class="p">.</span><span class="n">xy</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="kt">float</span> <span class="n">speed</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="c1">// the width of the texture
</span></span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="c1"></span>    <span class="kt">float</span> <span class="n">width</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">
</span></span><span class="line"><span class="ln">18</span><span class="cl">    <span class="n">value</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">mod</span><span class="p">(</span><span class="kt">float</span><span class="p">(</span><span class="n">texelCoord</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="n">speed</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">gl_NumWorkGroups</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">    <span class="n">value</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="kt">float</span><span class="p">(</span><span class="n">texelCoord</span><span class="p">.</span><span class="n">y</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">gl_NumWorkGroups</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">    <span class="n">imageStore</span><span class="p">(</span><span class="n">imgOutput</span><span class="p">,</span> <span class="n">texelCoord</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>We create a uniform variable t, which will hold the current time. To animate a repeating rolling of the texture from left to right we can use the module operation %. We animate the texture using the time variable t multiplied by the a speed value as offset for the x coordinate. Having the offseted x coordinate we can use the width of the texture (which in this case is hard-codeded) as divisor to get the rest which will be the new coordinate. We divide this value by the by the Workgroup size in x to get the ratio value between 0 and 1 we do the same for the y value, where we just simply divide the texel coordinate by the number of workgroups in the y dimension.</p>
<p>In the host program, we can assign the variable value the same way as we assign them for any other shader using glUniform functions, which is wrapped in the setFloat function of the ComputeShader class. We use setFloat to set the value of the variable t.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">computeShader</span><span class="p">.</span><span class="n">use</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">computeShader</span><span class="p">.</span><span class="n">setFloat</span><span class="p">(</span><span class="s">&#34;t&#34;</span><span class="p">,</span> <span class="n">currentFrame</span><span class="p">);</span></span></span></code></pre></div><p>Hence currentFrame is an altering value, we have to do the assignment in the render loop for every iteration.</p>
<p><note>The layout (location = 0) definition in front of the float variable is in general not necessary as the shader implementation queries the location of every variable on each uniform assignment. This might slow down the program execution speed if executed for multiple variables every render loop.<br>glUniform1f(glGetUniformLocation(ID, name.c_str()), value);
If you know that the location won&rsquo;t change and you want to increase the performance of the program as much as possible you can either query the location just once before the render loop and save it in the host program or hardcode it in the host program.</note></p>
<h5 id="altering-local-size">Altering local size</h5>
<p>Lastly, we can make use of the local size. As it can be seen in the image below the total amount of n dimensional executions is the product of the amount of work groups times local invocations. (compare the calculation in the compute space section above). Currently one pixel corresponds to one work group as we set the local size to 1 in all dimensions (dark gray boxes).</p>
<p>In this last section, we are going to add some local invocations (small light grey boxes) per work group. In other words, we will split the image in batches of a specific size and run over each of these batches per work group. So we have to alter our shader a little bit to calculate and write to the right texel. You could imagine the final image as an overlay over the work group sheet below where each invocation will then be one pixel of the image:</p>
<p><a href="#R-image-da4cfb2526efe780b63f535d32d35fe1" class="lightbox-link"><img src="./assets/computeShaderLogicalStructure.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-da4cfb2526efe780b63f535d32d35fe1"><img src="./assets/computeShaderLogicalStructure.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>For simplicity, we increase the resolution of our texture to get a number that can be divided by 10 without a rest. Here we will have 1,000,000 pixels though need 1 million shader invocations.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="c1">// texture size
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">TEXTURE_WIDTH</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">TEXTURE_HEIGHT</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span></span></span></code></pre></div><p>We can now lower the amount of work groups dispatches by the ratio of 10 for each dimension. This means we will execute 10,000 work groups.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glDispatchCompute</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">TEXTURE_WIDTH</span><span class="o">/</span><span class="mi">10</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">TEXTURE_HEIGHT</span><span class="o">/</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span></span></span></code></pre></div><p>If we run the program without altering the shader we will see that only 1/100 of the image will be calculated.</p>
<p><a href="#R-image-7994eb728eb4e5535d2aafa9ca616065" class="lightbox-link"><img src="./assets/outputColorAlteringDispatch.jpg" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7994eb728eb4e5535d2aafa9ca616065"><img src="./assets/outputColorAlteringDispatch.jpg" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>To calculate the whole image again we have to adjust the local_size of the compute shader accordingly. Here we distribute the invocations as well only in 2 dimensions (X and Y).</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 430 core
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="n">layout</span> <span class="p">(</span><span class="n">local_size_x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">local_size_y</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">local_size_z</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="n">in</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">layout</span><span class="p">(</span><span class="n">rgba32f</span><span class="p">,</span> <span class="n">binding</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">uniform</span> <span class="n">image2D</span> <span class="n">imgOutput</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">uniform</span> <span class="kt">float</span> <span class="n">t</span><span class="p">;</span>                 <span class="cm">/** Time */</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="n">vec4</span> <span class="n">value</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="n">ivec2</span> <span class="n">texelCoord</span> <span class="o">=</span> <span class="n">ivec2</span><span class="p">(</span><span class="n">gl_GlobalInvocationID</span><span class="p">.</span><span class="n">xy</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="kt">float</span> <span class="n">speed</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="c1">// the width of the texture
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="c1"></span>    <span class="kt">float</span> <span class="n">width</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="n">value</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">mod</span><span class="p">(</span><span class="kt">float</span><span class="p">(</span><span class="n">texelCoord</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="n">speed</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">gl_NumWorkGroups</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">gl_WorkGroupSize</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">    <span class="n">value</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="kt">float</span><span class="p">(</span><span class="n">texelCoord</span><span class="p">.</span><span class="n">y</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">gl_NumWorkGroups</span><span class="p">.</span><span class="n">y</span><span class="o">*</span><span class="n">gl_WorkGroupSize</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">    <span class="n">imageStore</span><span class="p">(</span><span class="n">imgOutput</span><span class="p">,</span> <span class="n">texelCoord</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>As seen above we have to adjust the ratio for the relative texel coordinate calculation. The gl_NumWorkGroups variable gives us the amount of the local size per work group. This makes it obvious that the amount of dimensions is the product of the amount of work groups times the amount of local invocations as stated in the introduction.</p>
<p><a href="#R-image-2e378d90e9b53b3cb9a944eda61e4d4b" class="lightbox-link"><img src="./assets/finalOutput.gif" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-2e378d90e9b53b3cb9a944eda61e4d4b"><img src="./assets/finalOutput.gif" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>You can find the full source code for this demo <a href="https://learnopengl.com/code_viewer_gh.php?code=src/8.guest/2022/5.computeshader_helloworld/compute_shader_hello_world.cpp" target="_blank">here</a>.</p>
<h5 id="final-words">Final Words</h5>
<p>The above introduction is meant as a very simple overview of the compute shader and how to make it work. As it is not part of the render pipeline, it can get even more complicated to debug non-working shaders/programs. This implementation only shows one of the ways to manipulate data with the compute shader using image access. Using Uniform Buffers or Shader Storage Buffers is a more common way to manipulate geometry itself like particle or cloth simulations.</p>
<p>In upcoming following articles we will go into creating a particle simulation and deal with buffer objects to work on input data and output data after manipulation. As well as having a look on Shared Memory and atomic operations. The upcoming articles will build on these basics and go more into details of the compute shader and more complex calculations like simulations or image manipulations.</p>
<h5 id="exercises-13">Exercises</h5>
<p>Check <a href="https://thebookofshaders.com/" target="_blank">The book of shaders</a> and try to apply some of the generative designs in the compute shader to get more complex calculations. Compare different ratios between work groups and local sizes and see how the FPS differ.</p>
<p>Try to add noise/pattern parameters as uniform variables for the implementation in the first excersise.</p>
<p>In a later article we will go over blurring with compute shaders and compare it with the fragment shader implementations. Feel free to go ahead and try it on your own. Check the GLSL function imageLoad(image, texelCoordinate)</p>
<h5 id="references">References</h5>
<ul>
<li><a href="https://developer.nvidia.com/gpugems/gpugems/part-vi-beyond-triangles/chapter-37-toolkit-computation-gpus" target="_blank">GPU Gems - A Toolkit for Computation on GPUs</a></li>
<li><a href="https://antongerdelan.net/opengl/compute.html" target="_blank">Simple Raytracer with Compute Shaders</a></li>
</ul>

            <footer class="footline">
            </footer>
          </article>
        </div>
      </main>
    </div>
    <aside id="R-sidebar" class="default-animation">
      <div id="R-header-topbar" class="default-animation"></div>
      <div id="R-header-wrapper" class="default-animation">
        <div id="R-header" class="default-animation">
          
<span style="font-size:26px">晟世清风</span>
        </div>
        <form action="../../../../search.html" method="get"><div class="searchbox default-animation">
          <button class="search-detail" type="submit" title="Search (CTRL+ALT+f)"><i class="fas fa-search"></i></button>
          <label class="a11y-only" for="R-search-by">Search</label>
          <input data-search-input id="R-search-by" name="search-by" class="search-by" type="search" placeholder="Search...">
          <button class="search-clear" type="button" data-search-clear="" title="Clear search"><i class="fas fa-times" title="Clear search"></i></button>
        </div></form>
        <script>
          var contentLangs=['en'];
        </script>
        <script src="../../../../js/auto-complete.js?1708235002" defer></script>
        <script src="../../../../js/lunr/lunr.min.js?1708235002" defer></script>
        <script src="../../../../js/lunr/lunr.stemmer.support.min.js?1708235002" defer></script>
        <script src="../../../../js/lunr/lunr.multi.min.js?1708235002" defer></script>
        <script src="../../../../js/lunr/lunr.en.min.js?1708235002" defer></script>
        <script src="../../../../js/search.js?1708235002" defer></script>
      </div>
      <div id="R-homelinks" class="default-animation homelinks">
        <ul>
          <li><a class="padding" href="../../../../index.html"><i class='fas fa-home'></i> Home</a></li>
        </ul>
        <hr class="padding">
      </div>
      <div id="R-content-wrapper" class="highlightable">
        <div id="R-topics">
          <ul class="enlarge morespace collapsible-menu">
          <li data-nav-id="/programming/index.html" class=""><input type="checkbox" id="R-section-d205f2b94e06f539e77f2bc392064cb6" aria-controls="R-subsections-d205f2b94e06f539e77f2bc392064cb6"><label for="R-section-d205f2b94e06f539e77f2bc392064cb6"><i class="fas fa-chevron-down"></i><i class="fas fa-chevron-right"></i><span class="a11y-only">Submenu 程序设计与开发</span></label><a class="padding" href="../../../../programming/index.html">程序设计与开发</a><ul id="R-subsections-d205f2b94e06f539e77f2bc392064cb6" class="morespace collapsible-menu">
          <li data-nav-id="/programming/java/index.html" class="alwaysopen"><input type="checkbox" id="R-section-1a585580994f9dab2d4547c8eaf11987" aria-controls="R-subsections-1a585580994f9dab2d4547c8eaf11987" checked><label for="R-section-1a585580994f9dab2d4547c8eaf11987"><i class="fas fa-chevron-down"></i><i class="fas fa-chevron-right"></i><span class="a11y-only">Submenu Java 语言</span></label><a class="padding" href="../../../../programming/java/index.html">Java 语言</a><ul id="R-subsections-1a585580994f9dab2d4547c8eaf11987" class="morespace collapsible-menu">
          <li data-nav-id="/programming/java/java_basics/index.html" class=""><a class="padding" href="../../../../programming/java/java_basics/index.html">Java 基础知识</a></li>
          <li data-nav-id="/programming/java/java_collection_framework/index.html" class=""><a class="padding" href="../../../../programming/java/java_collection_framework/index.html">Java 集合框架</a></li>
          <li data-nav-id="/programming/java/java_concurrency/index.html" class=""><a class="padding" href="../../../../programming/java/java_concurrency/index.html">Java 并发编程</a></li>
          <li data-nav-id="/programming/java/java_memory_model/index.html" class=""><a class="padding" href="../../../../programming/java/java_memory_model/index.html">Java 内存模型</a></li>
          <li data-nav-id="/programming/java/java_annotation/index.html" class=""><a class="padding" href="../../../../programming/java/java_annotation/index.html">Java 注解相关</a></li></ul></li></ul></li>
          <li data-nav-id="/test/index.html" class=""><input type="checkbox" id="R-section-40aaf63da4d8c6f43df4cc726b56321f" aria-controls="R-subsections-40aaf63da4d8c6f43df4cc726b56321f"><label for="R-section-40aaf63da4d8c6f43df4cc726b56321f"><i class="fas fa-chevron-down"></i><i class="fas fa-chevron-right"></i><span class="a11y-only">Submenu Test</span></label><a class="padding" href="../../../../test/index.html">Test</a><ul id="R-subsections-40aaf63da4d8c6f43df4cc726b56321f" class="morespace collapsible-menu">
          <li data-nav-id="/test/demo/index.html" class=""><a class="padding" href="../../../../test/demo/index.html">Test</a></li></ul></li>
          <li data-nav-id="/algorithms_and_data_structures/index.html" class=""><a class="padding" href="../../../../algorithms_and_data_structures/index.html">数据结构与算法</a></li>
          <li data-nav-id="/computer_graphics/index.html" class="parent "><input type="checkbox" id="R-section-17dabdd0438dc68716ce11b90ee5aa30" aria-controls="R-subsections-17dabdd0438dc68716ce11b90ee5aa30" checked><label for="R-section-17dabdd0438dc68716ce11b90ee5aa30"><i class="fas fa-chevron-down"></i><i class="fas fa-chevron-right"></i><span class="a11y-only">Submenu 计算机图形学</span></label><a class="padding" href="../../../../computer_graphics/index.html">计算机图形学</a><ul id="R-subsections-17dabdd0438dc68716ce11b90ee5aa30" class="morespace collapsible-menu">
          <li data-nav-id="/computer_graphics/classic_tutorial/index.html" class="parent "><input type="checkbox" id="R-section-0e0951862a264269c87df7fac4f297fb" aria-controls="R-subsections-0e0951862a264269c87df7fac4f297fb" checked><label for="R-section-0e0951862a264269c87df7fac4f297fb"><i class="fas fa-chevron-down"></i><i class="fas fa-chevron-right"></i><span class="a11y-only">Submenu 经典教程</span></label><a class="padding" href="../../../../computer_graphics/classic_tutorial/index.html">经典教程</a><ul id="R-subsections-0e0951862a264269c87df7fac4f297fb" class="morespace collapsible-menu">
          <li data-nav-id="/computer_graphics/classic_tutorial/basics_tutorial/index.html" class=""><a class="padding" href="../../../../computer_graphics/classic_tutorial/basics_tutorial/index.html">基础教程</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/shader_tutorial/index.html" class=""><a class="padding" href="../../../../computer_graphics/classic_tutorial/shader_tutorial/index.html">着色教程</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/raytracing_tutorial/index.html" class=""><input type="checkbox" id="R-section-06ac295778bd74c824886a3ab22c212c" aria-controls="R-subsections-06ac295778bd74c824886a3ab22c212c"><label for="R-section-06ac295778bd74c824886a3ab22c212c"><i class="fas fa-chevron-down"></i><i class="fas fa-chevron-right"></i><span class="a11y-only">Submenu 光线追踪</span></label><a class="padding" href="../../../../computer_graphics/classic_tutorial/raytracing_tutorial/index.html">光线追踪</a><ul id="R-subsections-06ac295778bd74c824886a3ab22c212c" class="morespace collapsible-menu">
          <li data-nav-id="/computer_graphics/classic_tutorial/raytracing_tutorial/ray_tracing_in_one_weekend/index.html" class=""><a class="padding" href="../../../../computer_graphics/classic_tutorial/raytracing_tutorial/ray_tracing_in_one_weekend/index.html">Ray Tracing in One Weekend</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/raytracing_tutorial/ray_tracing_the_next_week/index.html" class=""><a class="padding" href="../../../../computer_graphics/classic_tutorial/raytracing_tutorial/ray_tracing_the_next_week/index.html">Ray Tracing The Next Week</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/raytracing_tutorial/ray_tracing_the_rest_of_your_life/index.html" class=""><a class="padding" href="../../../../computer_graphics/classic_tutorial/raytracing_tutorial/ray_tracing_the_rest_of_your_life/index.html">Ray Tracing The Rest of Your Life</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/index.html" class=""><input type="checkbox" id="R-section-c33da7e0886830ccf91b260ac3fff456" aria-controls="R-subsections-c33da7e0886830ccf91b260ac3fff456"><label for="R-section-c33da7e0886830ccf91b260ac3fff456"><i class="fas fa-chevron-down"></i><i class="fas fa-chevron-right"></i><span class="a11y-only">Submenu Scratchapixe 系列短文</span></label><a class="padding" href="../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/index.html">Scratchapixe 系列短文</a><ul id="R-subsections-c33da7e0886830ccf91b260ac3fff456" class="morespace collapsible-menu">
          <li data-nav-id="/computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/index.html" class=""><a class="padding" href="../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/index.html">Chapter - 1</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-2/index.html" class=""><a class="padding" href="../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-2/index.html">Chapter - 2</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/index.html" class=""><a class="padding" href="../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/index.html">Chapter - 3</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/index.html" class=""><a class="padding" href="../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/index.html">Chapter - 4</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/index.html" class=""><a class="padding" href="../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/index.html">Chapter - 5</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/index.html" class=""><a class="padding" href="../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/index.html">Chapter - 6</a></li></ul></li></ul></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/index.html" class="parent "><input type="checkbox" id="R-section-23d956a7f1e516a9e3d46517dfb799dd" aria-controls="R-subsections-23d956a7f1e516a9e3d46517dfb799dd" checked><label for="R-section-23d956a7f1e516a9e3d46517dfb799dd"><i class="fas fa-chevron-down"></i><i class="fas fa-chevron-right"></i><span class="a11y-only">Submenu OpenGL教程</span></label><a class="padding" href="../../../../computer_graphics/classic_tutorial/opengl_tutorial/index.html">OpenGL教程</a><ul id="R-subsections-23d956a7f1e516a9e3d46517dfb799dd" class="morespace collapsible-menu">
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/learn_opengl/index.html" class="active"><a class="padding" href="../../../../computer_graphics/classic_tutorial/opengl_tutorial/learn_opengl/index.html">Learn OpenGL</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/index.html" class=""><input type="checkbox" id="R-section-ae6b71edd18a266dbd92162060f7614e" aria-controls="R-subsections-ae6b71edd18a266dbd92162060f7614e"><label for="R-section-ae6b71edd18a266dbd92162060f7614e"><i class="fas fa-chevron-down"></i><i class="fas fa-chevron-right"></i><span class="a11y-only">Submenu OGL dev 教程</span></label><a class="padding" href="../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/index.html">OGL dev 教程</a><ul id="R-subsections-ae6b71edd18a266dbd92162060f7614e" class="morespace collapsible-menu">
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_1_open_a_window/index.html" class=""><a class="padding" href="../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_1_open_a_window/index.html">Chapter - 1</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_2_hello_dot/index.html" class=""><a class="padding" href="../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_2_hello_dot/index.html">Chapter - 2</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_3_first_triangle/index.html" class=""><a class="padding" href="../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_3_first_triangle/index.html">Chapter - 3</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_4_shaders/index.html" class=""><a class="padding" href="../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_4_shaders/index.html">Chapter - 4</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_5_uniform_variables/index.html" class=""><a class="padding" href="../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_5_uniform_variables/index.html">Chapter - 5</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_6_translation_transformation/index.html" class=""><a class="padding" href="../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_6_translation_transformation/index.html">Chapter - 6</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_7_rotation_transformation/index.html" class=""><a class="padding" href="../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_7_rotation_transformation/index.html">Chapter - 7</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_8_scaling_transformation/index.html" class=""><a class="padding" href="../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_8_scaling_transformation/index.html">Chapter - 8</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_9_interpolation/index.html" class=""><a class="padding" href="../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_9_interpolation/index.html">Chapter - 9</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_10_indexed_draws/index.html" class=""><a class="padding" href="../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_10_indexed_draws/index.html">Chapter - 10</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_11_concatenating_transformations/index.html" class=""><a class="padding" href="../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_11_concatenating_transformations/index.html">Chapter - 11</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_12_perspective_projection/index.html" class=""><a class="padding" href="../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_12_perspective_projection/index.html">Chapter - 12</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_13_camera_space/index.html" class=""><a class="padding" href="../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_13_camera_space/index.html">Chapter - 13</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_14_camera_control_-_part_1/index.html" class=""><a class="padding" href="../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_14_camera_control_-_part_1/index.html">Chapter - 14</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_15_camera_control_-_part_2/index.html" class=""><a class="padding" href="../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_15_camera_control_-_part_2/index.html">Chapter - 15</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_16_basic_texture_mapping/index.html" class=""><a class="padding" href="../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_16_basic_texture_mapping/index.html">Chapter - 16</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_17_ambient_lighting/index.html" class=""><a class="padding" href="../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_17_ambient_lighting/index.html">Chapter - 17</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_18_diffuse_lighting/index.html" class=""><a class="padding" href="../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_18_diffuse_lighting/index.html">Chapter - 18</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_19_specular_lighting/index.html" class=""><a class="padding" href="../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_19_specular_lighting/index.html">Chapter - 19</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_20_point_light/index.html" class=""><a class="padding" href="../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_20_point_light/index.html">Chapter - 20</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_21_spot_light/index.html" class=""><a class="padding" href="../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_21_spot_light/index.html">Chapter - 21</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_22_loading_models_using_the_open_asset_import_library/index.html" class=""><a class="padding" href="../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_22_loading_models_using_the_open_asset_import_library/index.html">Chapter - 22</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_23_shadow_mapping_-_part_1/index.html" class=""><a class="padding" href="../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_23_shadow_mapping_-_part_1/index.html">Chapter - 23</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_24_shadow_mapping_-_part_2/index.html" class=""><a class="padding" href="../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_24_shadow_mapping_-_part_2/index.html">Chapter - 24</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_25_skybox/index.html" class=""><a class="padding" href="../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_25_skybox/index.html">Chapter - 25</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_26_normal_mapping/index.html" class=""><a class="padding" href="../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_26_normal_mapping/index.html">Chapter - 26</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_27_billboarding_and_the_geometry_shader/index.html" class=""><a class="padding" href="../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_27_billboarding_and_the_geometry_shader/index.html">Chapter - 27</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_28_particle_system_using_transform_feedback/index.html" class=""><a class="padding" href="../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_28_particle_system_using_transform_feedback/index.html">Chapter - 28</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_29_3d_picking/index.html" class=""><a class="padding" href="../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_29_3d_picking/index.html">Chapter - 29</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_30_basic_tessellation/index.html" class=""><a class="padding" href="../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_30_basic_tessellation/index.html">Chapter - 30</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_31_pn_triangles_tessellation/index.html" class=""><a class="padding" href="../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_31_pn_triangles_tessellation/index.html">Chapter - 31</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_32_vertex_array_objects/index.html" class=""><a class="padding" href="../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_32_vertex_array_objects/index.html">Chapter - 32</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_33_instanced_rendering/index.html" class=""><a class="padding" href="../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_33_instanced_rendering/index.html">Chapter - 33</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_34_glfx_-_an_opengl_effect_library/index.html" class=""><a class="padding" href="../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_34_glfx_-_an_opengl_effect_library/index.html">Chapter - 34</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_35_deferred_shading_-_part_1/index.html" class=""><a class="padding" href="../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_35_deferred_shading_-_part_1/index.html">Chapter - 35</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_36_deferred_shading_-_part_2/index.html" class=""><a class="padding" href="../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_36_deferred_shading_-_part_2/index.html">Chapter - 36</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_37_deferred_shading_-_part_3/index.html" class=""><a class="padding" href="../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_37_deferred_shading_-_part_3/index.html">Chapter - 37</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_38_skeletal_animation_with_assimp/index.html" class=""><a class="padding" href="../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_38_skeletal_animation_with_assimp/index.html">Chapter - 38</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_39_silhouette_detection/index.html" class=""><a class="padding" href="../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_39_silhouette_detection/index.html">Chapter - 39</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_40_stencil_shadow_volume/index.html" class=""><a class="padding" href="../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_40_stencil_shadow_volume/index.html">Chapter - 40</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_41_object_motion_blur/index.html" class=""><a class="padding" href="../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_41_object_motion_blur/index.html">Chapter - 41</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_42_percentage_closer_filtering/index.html" class=""><a class="padding" href="../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_42_percentage_closer_filtering/index.html">Chapter - 42</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_43_multipass_shadow_mapping_with_point_lights/index.html" class=""><a class="padding" href="../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_43_multipass_shadow_mapping_with_point_lights/index.html">Chapter - 43</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_44_glfw/index.html" class=""><a class="padding" href="../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_44_glfw/index.html">Chapter - 44</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_45_screen_space_ambient_occlusion/index.html" class=""><a class="padding" href="../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_45_screen_space_ambient_occlusion/index.html">Chapter - 45</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_46_ssao_with_depth_reconstruction/index.html" class=""><a class="padding" href="../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_46_ssao_with_depth_reconstruction/index.html">Chapter - 46</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_47_shadow_mapping_with_directional_lights/index.html" class=""><a class="padding" href="../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_47_shadow_mapping_with_directional_lights/index.html">Chapter - 47</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_48_user_interface_with_ant_tweak_bar/index.html" class=""><a class="padding" href="../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_48_user_interface_with_ant_tweak_bar/index.html">Chapter - 48</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_49_cascaded_shadow_mapping/index.html" class=""><a class="padding" href="../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_49_cascaded_shadow_mapping/index.html">Chapter - 49</a></li></ul></li></ul></li></ul></li>
          <li data-nav-id="/computer_graphics/book_recommend/index.html" class=""><a class="padding" href="../../../../computer_graphics/book_recommend/index.html">书籍推荐</a></li>
          <li data-nav-id="/computer_graphics/blog_article/index.html" class=""><a class="padding" href="../../../../computer_graphics/blog_article/index.html">博客文章</a></li>
          <li data-nav-id="/computer_graphics/reference/index.html" class=""><a class="padding" href="../../../../computer_graphics/reference/index.html">参考资料</a></li></ul></li>
          <li data-nav-id="/computer_science/index.html" class=""><input type="checkbox" id="R-section-7d71eaebfb32275fa70e6b3397a5fe7c" aria-controls="R-subsections-7d71eaebfb32275fa70e6b3397a5fe7c"><label for="R-section-7d71eaebfb32275fa70e6b3397a5fe7c"><i class="fas fa-chevron-down"></i><i class="fas fa-chevron-right"></i><span class="a11y-only">Submenu 计算机科学</span></label><a class="padding" href="../../../../computer_science/index.html">计算机科学</a><ul id="R-subsections-7d71eaebfb32275fa70e6b3397a5fe7c" class="morespace collapsible-menu">
          <li data-nav-id="/computer_science/blog_article/index.html" class=""><a class="padding" href="../../../../computer_science/blog_article/index.html">博客文章</a></li>
          <li data-nav-id="/computer_science/operating_system/index.html" class=""><a class="padding" href="../../../../computer_science/operating_system/index.html">操作系统</a></li></ul></li>
          <li data-nav-id="/computer_networks/index.html" class=""><a class="padding" href="../../../../computer_networks/index.html">计算机网络</a></li>
          <li data-nav-id="/game_programming/index.html" class=""><a class="padding" href="../../../../game_programming/index.html">游戏编程</a></li>
          <li data-nav-id="/database/index.html" class=""><a class="padding" href="../../../../database/index.html">数据库</a></li>
          </ul>
        </div>
        <div id="R-shortcuts">
          <div class="nav-title padding">More</div>
          <ul class="space">
            <li><a class="padding" href="https://github.com/McShelby/hugo-theme-relearn"><i class='fab fa-fw fa-github'></i> GitHub repo</a></li>
            <li><a class="padding" href="../../../../tags/index.html"><i class='fas fa-fw fa-tags'></i> Tags</a></li>
            <li><a class="padding" href="../../../../categories/index.html"><i class='fas fa-fw fa-layer-group'></i> Categories</a></li>
          </ul>
        </div>
        <div class="padding footermargin footerLangSwitch footerVariantSwitch footerVisitedLinks footerFooter showVariantSwitch showFooter"></div>
        <div id="R-menu-footer">
          <hr class="padding default-animation footerLangSwitch footerVariantSwitch footerVisitedLinks footerFooter showVariantSwitch showFooter">
          <div id="R-prefooter" class="footerLangSwitch footerVariantSwitch footerVisitedLinks showVariantSwitch">
            <ul>
              <li id="R-select-language-container" class="footerLangSwitch">
                <div class="padding menu-control">
                  <i class="fas fa-language fa-fw"></i>
                  <span>&nbsp;</span>
                  <div class="control-style">
                    <label class="a11y-only" for="R-select-language">Language</label>
                    <select id="R-select-language" onchange="location = baseUri + this.value;">
                    </select>
                  </div>
                  <div class="clear"></div>
                </div>
              </li>
              <li id="R-select-variant-container" class="footerVariantSwitch showVariantSwitch">
                <div class="padding menu-control">
                  <i class="fas fa-paint-brush fa-fw"></i>
                  <span>&nbsp;</span>
                  <div class="control-style">
                    <label class="a11y-only" for="R-select-variant">Theme</label>
                    <select id="R-select-variant" onchange="window.variants && variants.changeVariant( this.value );">
                      <option id="R-auto" value="auto" selected>Auto</option>
                      <option id="R-relearn-light" value="relearn-light">Relearn Light</option>
                      <option id="R-relearn-dark" value="relearn-dark">Relearn Dark</option>
                      <option id="R-zen-light" value="zen-light">Zen Light</option>
                      <option id="R-zen-dark" value="zen-dark">Zen Dark</option>
                      <option id="R-neon" value="neon">Neon</option>
                      <option id="R-learn" value="learn">Learn</option>
                      <option id="R-blue" value="blue">Blue</option>
                      <option id="R-green" value="green">Green</option>
                      <option id="R-red" value="red">Red</option>
                    </select>
                  </div>
                  <div class="clear"></div>
                </div>
                <script>window.variants && variants.markSelectedVariant();</script>
              </li>
              <li class="footerVisitedLinks">
                <div class="padding menu-control">
                  <i class="fas fa-history fa-fw"></i>
                  <span>&nbsp;</span>
                  <div class="control-style">
                    <button onclick="clearHistory();">Clear History</button>
                  </div>
                  <div class="clear"></div>
                </div>
              </li>
            </ul>
          </div>
          <div id="R-footer" class="footerFooter showFooter">
          <span class="github-buttons"></span>
          <p>Built with <a href="https://github.com/McShelby/hugo-theme-relearn" title="love"><i class="fas fa-heart"></i></a> by <a href="https://gohugo.io/">Hugo</a></p>
          <script>
            function githubButtonsScheme(){
              var scheme = 'light';
              var colorPropertyValue = window.getComputedStyle( document.querySelector( '#R-sidebar' ) ).getPropertyValue( 'background-color' );
              var colorValues = colorPropertyValue.match( /\d+/g ).map( function( e ){ return parseInt(e,10); });
              if( colorValues.length === 3 && ((0.2126 * colorValues[0]) + (0.7152 * colorValues[1]) + (0.0722 * colorValues[2]) < 165) ){
                
                scheme = 'dark';
              }
              return scheme;
            }
            function githubButtonsInit(){
              if( !window.githubButtons ){
                
                setTimeout( githubButtonsInit, 50 );
                return;
              }
              var scheme = githubButtonsScheme();
              var githubButtonsHTML = `
                <a class="github-button" href="https://github.com/McShelby/hugo-theme-relearn/archive/main.zip" data-color-scheme="${scheme}" data-icon="octicon-cloud-download" aria-label="Download McShelby/hugo-theme-relearn on GitHub">Download</a>
                <a class="github-button" href="https://github.com/McShelby/hugo-theme-relearn" data-color-scheme="${scheme}" data-icon="octicon-star" data-show-count="true" aria-label="Star McShelby/hugo-theme-relearn on GitHub">Star</a>
                <a class="github-button" href="https://github.com/McShelby/hugo-theme-relearn/fork" data-color-scheme="${scheme}" data-icon="octicon-repo-forked" data-show-count="true" aria-label="Fork McShelby/hugo-theme-relearn on GitHub">Fork</a>
               `;
              document.querySelector( '.github-buttons' ).innerHTML = githubButtonsHTML;
              document.querySelectorAll( '.github-button' ).forEach( function( anchor ){
                anchor.dataset.colorScheme = scheme;
                window.githubButtons.render( anchor, function( el ){
                  anchor.parentNode.replaceChild( el, anchor );
                });
              });
            }
            document.addEventListener( 'themeVariantLoaded', function( e ){
              
              setTimeout( githubButtonsInit, 400 );
            });
          </script>
          <script async src="../../../../js/github-buttons.js?1708235002"></script>
          </div>
        </div>
      </div>
    </aside>
    <script src="../../../../js/clipboard.min.js?1708235002" defer></script>
    <script src="../../../../js/perfect-scrollbar.min.js?1708235002" defer></script>
    <script>
      function useMathJax( config ){
        if( !Object.assign ){
          
          return;
        }
        window.MathJax = Object.assign( window.MathJax || {}, {
          loader: {
            load: ['[tex]/mhchem']
          },
          startup: {
            elements: [
              '.math'
            ]
          },
          tex: {
            inlineMath: [
              ['$', '$'], 
              ['\\(', '\\)']
            ]
          },
          options: {
            enableMenu: false 
          }
        }, config );
      }
      useMathJax( JSON.parse("{}") );
    </script>
    <script id="MathJax-script" async src="../../../../js/mathjax/tex-mml-chtml.js?1708235002"></script>
    <script src="../../../../js/theme.js?1708235002" defer></script>
  </body>
</html>
