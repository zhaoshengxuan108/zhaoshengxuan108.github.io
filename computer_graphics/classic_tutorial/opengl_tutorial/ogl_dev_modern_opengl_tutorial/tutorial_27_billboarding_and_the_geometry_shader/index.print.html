<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.122.0">
    <meta name="generator" content="Relearn 5.23.2+tip">
    <meta name="description" content="啊啊啊啊">
    <meta name="author" content="Sören Weber">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="https://example.com/images/hero.png">
    <meta name="twitter:title" content="Tutorial 27:Billboarding and the Geometry Shader :: Hugo Relearn Theme">
    <meta name="twitter:description" content="Background We&rsquo;ve been utilizing the vertex and the fragment shaders from early on in this series of tutorials but in fact we left out an important shader stage called the Geometry Shader (GS). This type of shader was introduced by Microsoft in DirectX10 and was later incorporated into the core OpenGL in version 3.2. While the VS is executed per vertex and the FS is executed per pixel the GS is executed per primitive.">
    <meta property="og:title" content="Tutorial 27:Billboarding and the Geometry Shader :: Hugo Relearn Theme">
    <meta property="og:description" content="Background We&rsquo;ve been utilizing the vertex and the fragment shaders from early on in this series of tutorials but in fact we left out an important shader stage called the Geometry Shader (GS). This type of shader was introduced by Microsoft in DirectX10 and was later incorporated into the core OpenGL in version 3.2. While the VS is executed per vertex and the FS is executed per pixel the GS is executed per primitive.">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://example.com/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_27_billboarding_and_the_geometry_shader/index.html">
    <meta property="og:image" content="https://example.com/images/hero.png">
    <meta property="article:section" content="OGL dev 教程 :: Hugo Relearn Theme">
    <meta property="og:site_name" content="Hugo Relearn Theme">
    <title>Tutorial 27:Billboarding and the Geometry Shader :: Hugo Relearn Theme</title>
    <link href="https://example.com/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_27_billboarding_and_the_geometry_shader/index.html" rel="canonical" type="text/html" title="Tutorial 27:Billboarding and the Geometry Shader :: Hugo Relearn Theme">
    <link href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_27_billboarding_and_the_geometry_shader/index.xml" rel="alternate" type="application/rss+xml" title="Tutorial 27:Billboarding and the Geometry Shader :: Hugo Relearn Theme"><link rel="icon" href="../../../../../images/favicon.ico">
    <!-- https://github.com/filamentgroup/loadCSS/blob/master/README.md#how-to-use -->
    <link href="../../../../../css/fontawesome-all.min.css?1708235002" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../../../../../css/fontawesome-all.min.css?1708235002" rel="stylesheet"></noscript>
    <link href="../../../../../css/nucleus.css?1708235002" rel="stylesheet">
    <link href="../../../../../css/auto-complete.css?1708235002" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../../../../../css/auto-complete.css?1708235002" rel="stylesheet"></noscript>
    <link href="../../../../../css/perfect-scrollbar.min.css?1708235002" rel="stylesheet">
    <link href="../../../../../css/fonts.css?1708235002" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../../../../../css/fonts.css?1708235002" rel="stylesheet"></noscript>
    <link href="../../../../../css/theme.css?1708235002" rel="stylesheet">
    <link href="../../../../../css/theme-auto.css?1708235002" rel="stylesheet" id="R-variant-style">
    <link href="../../../../../css/variant.css?1708235002" rel="stylesheet">
    <link href="../../../../../css/print.css?1708235002" rel="stylesheet" media="print">
    <link href="../../../../../css/format-print.css?1708235002" rel="stylesheet">
    <link href="../../../../../css/ie.css?1708235002" rel="stylesheet">
    <script src="../../../../../js/url.js?1708235002"></script>
    <script src="../../../../../js/variant.js?1708235002"></script>
    <script>
      // hack to let hugo tell us how to get to the root when using relativeURLs, it needs to be called *url= for it to do its magic:
      // https://github.com/gohugoio/hugo/blob/145b3fcce35fbac25c7033c91c1b7ae6d1179da8/transform/urlreplacers/absurlreplacer.go#L72
      window.index_js_url="../../../../../index.search.js";
      var root_url="../../../../../";
      var baseUri=root_url.replace(/\/$/, '');
      window.relearn = window.relearn || {};
      window.relearn.baseUriFull='https:\/\/example.com/';
      // variant stuff
      window.variants && variants.init( [ 'auto', 'relearn-light', 'relearn-dark', 'zen-light', 'zen-dark', 'neon', 'learn', 'blue', 'green', 'red' ] );
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
    </script>
    <style>
      #R-body img.bg-white {
        background-color: white;
      }
    </style>
  </head>
  <body class="mobile-support print" data-url="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_27_billboarding_and_the_geometry_shader/index.html">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide">
              <button class="topbar-control" onclick="toggleNav()" type="button" title="Menu (CTRL&#43;ALT&#43;n)">
                <i class="fa-fw fas fa-bars"></i>
              </button>
            </div>
          </div>
          <ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype="http://schema.org/BreadcrumbList"><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../index.html"><span itemprop="name">主页</span></a><meta itemprop="position" content="1">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../computer_graphics/index.html"><span itemprop="name">计算机图形学</span></a><meta itemprop="position" content="2">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../computer_graphics/classic_tutorial/index.html"><span itemprop="name">经典教程</span></a><meta itemprop="position" content="3">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/index.html"><span itemprop="name">OpenGL教程</span></a><meta itemprop="position" content="4">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/index.html"><span itemprop="name">OGL dev 教程</span></a><meta itemprop="position" content="5">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><span itemprop="name">Tutorial 27:Billboarding and the Geometry Shader</span><meta itemprop="position" content="6"></li>
          </ol>
          <div class="topbar-area topbar-area-end" data-area="end">
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable default" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="default">
            <header class="headline">
            </header>
<h1 id="tutorial-27billboarding-and-the-geometry-shader">Tutorial 27:Billboarding and the Geometry Shader</h1>

<h3 id="background">Background</h3>
<p>We&rsquo;ve been utilizing the vertex and the fragment shaders from early on in this series of tutorials but in fact we left out an important shader stage called the <em>Geometry Shader</em> (GS). This type of shader was introduced by Microsoft in DirectX10 and was later incorporated into the core OpenGL in version 3.2. While the VS is executed per vertex and the FS is executed per pixel the GS is executed per primitive. This means that if we are drawing triangles each invocation of the GS receives exactly one triangle; if we are drawing lines each invocation of the GS receives exactly one line, etc. This provides the GS a unique view of the model where the connectivity between the vertices is exposed to the developer, allowing her to develop new techniques that are based on that knowledge.</p>
<p>While the vertex shader always takes one vertex as input and outputs one vertex (i.e. it cannot create or destroy vertices on the fly) the GS has the unique capability of making changes to the primitives that are passing through it. These changes include:</p>
<ul>
<li>Changing the topology of the incoming primitives. The GS can receive primitives in any topology type but can only output point lists, line strips and triangle strips (the strip topologies are described below).</li>
<li>The GS takes one primitive as input and can either drop it altogether or output one or more primitives (this means that it can produce both less and more vertices than what it got). This capability is known as <em>growing geometry</em>. We will take advantage of this capability in this tutorial.</li>
</ul>
<p>Geometry shaders are optional. If you compile a program without a GS the primitives will simply flow directly from the vertex shader down to the fragment shader. That&rsquo;s why we&rsquo;ve been able to get to this point without mentioning them.</p>
<p>Triangle lists are constructed using trios of vertices. Vertices 0-2 are the first triangle, vertices 3-5 are the second and so forth. To calculate the number of triangles generated from any number of vertices simply divide the number of vertices by 3 (dropping the remainder). Triangle strips are more efficient because instead of adding 3 vertices to get a new triangle most of the time we just need to add one vertex. To construct a triangle strip start out with 3 vertices for the first triangle. When you add a fourth vertex you get the second triangle which is constructed from vertices 1-3. When you add a fifth vertex you get the third triangle which is constructed from vertices 2-4, etc. So from the second triangle and on every new vertex is joined with the previous two to create a new triangle. Here&rsquo;s an example:</p>
<p><a href="#R-image-45b652bd9fc21112693f8d8af242c0b1" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_27_billboarding_and_the_geometry_shader/../assets/triangle_strip.jpeg" alt="img" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-45b652bd9fc21112693f8d8af242c0b1"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_27_billboarding_and_the_geometry_shader/../assets/triangle_strip.jpeg" alt="img" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>As you can see, 7 triangles were created from just 9 vertices. If this was a triangle list we would have only 3 triangles.</p>
<p>Triangle strips have an important property with regard to the winding order inside the triangles - the order is reversed on the odd triangles. This means that the order is as follows: [0,1,2], [1,3,2], [2,3,4], [3,5,4], etc. The following picture shows that ordering:</p>
<p><a href="#R-image-19a61e3b5e9c94c042f8591d15c17bd2" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_27_billboarding_and_the_geometry_shader/../assets/triangle_strip2.jpeg" alt="img" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-19a61e3b5e9c94c042f8591d15c17bd2"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_27_billboarding_and_the_geometry_shader/../assets/triangle_strip2.jpeg" alt="img" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Now that we understand the concept of geometry shaders let&rsquo;s see how they can help us implement a very useful and popular technique called <em>billboarding</em>. A billboard is a quad which always faces the camera. As the camera moves around the scene the billboard turns with it so that the vector from the billboard to the camera is always perpedicular to the billboard face. This is the same idea as billboards in the real world that are placed along the highways in a way that will make them as visible as possible to the cars that are passing by. Once we got the quad to face the camera it is very easy to texture map it with the image of a monster, tree or whatever and create a large number of scene objects that always face the camera. Billboards are often used to create a forest where a large number of trees is required in order to create the effect. Since the texture on the billboard is always facing the camera the player is fooled into thinking that the object has real depth where in fact it is completely flat. Each billboard requires only 4 vertices and therefore it it much cheaper in comparison to a full blown model.</p>
<p>In this tutorial we create a vertex buffer and populate it with world space locations for the billboards. Each location is just a single point (3D vector). We will feed the locations into the GS and grow each location into a quad. This means that the input topology of the GS will be point list while the output topology will be triangle strip. Taking advantage of triangle strips we will create a quad using 4 vertices:</p>
<p><a href="#R-image-4d06ebc2ee6a9b372685e9a50bf14a64" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_27_billboarding_and_the_geometry_shader/../assets/quad.jpeg" alt="img" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-4d06ebc2ee6a9b372685e9a50bf14a64"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_27_billboarding_and_the_geometry_shader/../assets/quad.jpeg" alt="img" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>The GS will take care of turning the quad to face the camera and will attach the proper texture coordinates to each outgoing vertex. The fragment shader will only need to sample the texture and provide the final color.</p>
<p>Let&rsquo;s see how we can make the billboard always face the camera. In the following picture the black dot represents the camera and the red dot represents the location of the billboard. Both dots are in world space and while it looks like they are located on a surface which is parallel to the XZ plane they don&rsquo;t have to be. Any two points will do.</p>
<p><a href="#R-image-5683c9184927094c4495a3e2e0391e89" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_27_billboarding_and_the_geometry_shader/../assets/billboard1.jpeg" alt="img" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-5683c9184927094c4495a3e2e0391e89"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_27_billboarding_and_the_geometry_shader/../assets/billboard1.jpeg" alt="img" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>We now create a vector from the billboard location to the camera:</p>
<p><a href="#R-image-2fe202233773de83f84aa57f9529d09f" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_27_billboarding_and_the_geometry_shader/../assets/billboard2.jpeg" alt="img" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-2fe202233773de83f84aa57f9529d09f"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_27_billboarding_and_the_geometry_shader/../assets/billboard2.jpeg" alt="img" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Next we add the vector (0,1,0):</p>
<p><a href="#R-image-1d3782a840ce9a7b74e880884b237233" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_27_billboarding_and_the_geometry_shader/../assets/billboard3.jpeg" alt="img" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-1d3782a840ce9a7b74e880884b237233"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_27_billboarding_and_the_geometry_shader/../assets/billboard3.jpeg" alt="img" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Now do a cross product between these two vectors. The result is a vector which is perpedicular to the surface created by the two vectors. This vector points in the exact direction along which we need to extend the point and create a quad. The quad will be perpedicular to the vector from the original point to the camera, which is what we want. Looking at the same scene from above we get the following (the yellow vector is the result of the cross product):</p>
<p><a href="#R-image-357bf7144804864f1acc669128097f54" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_27_billboarding_and_the_geometry_shader/../assets/billboard4.jpeg" alt="img" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-357bf7144804864f1acc669128097f54"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_27_billboarding_and_the_geometry_shader/../assets/billboard4.jpeg" alt="img" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>One of the things that often confuses developers is in what order to do the cross product (A cross B or B cross A?). The two options produce two vectors that are opposite to one another. Knowing in advance the resulting vector is critical because we need to output the vertices such that the two triangles that make up the quad will be in clockwise order when looking at them from the point of view of the camera. The left hand rule comes to our rescue here. This rule says that if you are standing at the location of the billboard and your forefinger is pointing towards the camera and your middle finger is pointing upwards (towards the sky) then your thumb will point along the result of &ldquo;forefinger&rdquo; cross &ldquo;middle finger&rdquo; (the remaining two fingers are often kept clamped here). In this tutorial we call the result of the cross product the &ldquo;right&rdquo; vector because it points toward the right when looking at your hand like that from the camera point of view. Doing a &ldquo;middle finger&rdquo; cross &ldquo;forefinger&rdquo; will simply generate the &ldquo;left&rdquo; vector.</p>
<p>(We are using the left hand rule because we are working in a left hand coordinate system (Z grows as we move further into the scene). The right hand coordinate system is exactly the reverse).</p>
<h3 id="source-walkthru">Source walkthru</h3>
<p>(billboard_list.h:27)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">class</span> <span class="nc">BillboardList</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="k">public</span><span class="o">:</span>  
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  <span class="n">BillboardList</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  <span class="o">~</span><span class="n">BillboardList</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  <span class="kt">bool</span> <span class="nf">Init</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">TexFilename</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  <span class="kt">void</span> <span class="nf">Render</span><span class="p">(</span><span class="k">const</span> <span class="n">Matrix4f</span><span class="o">&amp;</span> <span class="n">VP</span><span class="p">,</span> <span class="k">const</span> <span class="n">Vector3f</span><span class="o">&amp;</span> <span class="n">CameraPos</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">  
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="k">private</span><span class="o">:</span>  
</span></span><span class="line"><span class="ln">12</span><span class="cl">  <span class="kt">void</span> <span class="n">CreatePositionBuffer</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln">13</span><span class="cl">  
</span></span><span class="line"><span class="ln">14</span><span class="cl">  <span class="n">GLuint</span> <span class="n">m_VB</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">15</span><span class="cl">  <span class="n">Texture</span><span class="o">*</span> <span class="n">m_pTexture</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">16</span><span class="cl">  <span class="n">BillboardTechnique</span> <span class="n">m_technique</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="p">};</span></span></span></code></pre></div><p>The BillboardList class encapsultes everything you need in order to generate billboards. The Init() function of the class takes the filename that contains the image which will be texture mapped on the billboard. The Render() function is called from the main render loop and takes care of setting up the state and rendering the billboard. This function needs two parameters: the combined view and projection matrix and the location of the camera in world space. Since the billboard location is specified in world space we go directly to view and projection and skip the world transformation part. The class has three private attributes: a vertex buffer to store the location of the billboards, a pointer to the texture to map on the billboard and the billboard technique that contains the relevant shaders.</p>
<p>(billboard_list.cpp:80)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="n">BillboardList</span><span class="o">::</span><span class="n">Render</span><span class="p">(</span><span class="k">const</span> <span class="n">Matrix4f</span><span class="o">&amp;</span> <span class="n">VP</span><span class="p">,</span> <span class="k">const</span> <span class="n">Vector3f</span><span class="o">&amp;</span> <span class="n">CameraPos</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  <span class="n">m_technique</span><span class="p">.</span><span class="n">Enable</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  <span class="n">m_technique</span><span class="p">.</span><span class="n">SetVP</span><span class="p">(</span><span class="n">VP</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  <span class="n">m_technique</span><span class="p">.</span><span class="n">SetCameraPosition</span><span class="p">(</span><span class="n">CameraPos</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  <span class="n">m_pTexture</span><span class="o">-&gt;</span><span class="n">Bind</span><span class="p">(</span><span class="n">COLOR_TEXTURE_UNIT</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  <span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">10</span><span class="cl">  
</span></span><span class="line"><span class="ln">11</span><span class="cl">  <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">m_VB</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">12</span><span class="cl">  <span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Vector3f</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// position  
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="c1"></span>  
</span></span><span class="line"><span class="ln">14</span><span class="cl">  <span class="n">glDrawArrays</span><span class="p">(</span><span class="n">GL_POINTS</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">NUM_ROWS</span> <span class="o">*</span> <span class="n">NUM_COLUMNS</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">15</span><span class="cl">  
</span></span><span class="line"><span class="ln">16</span><span class="cl">  <span class="n">glDisableVertexAttribArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>This function enables the billboard technique, sets the required state into OpenGL and draws the points that are turned into quads in the GS. In this demo the billboards are laid out in strict rows and columns which explains why we multiply them to get the number of points in the buffer. Note that we are using point list as our input topology. The GS will need to match that.</p>
<p>(billboard_technique.h:24)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">class</span> <span class="nc">BillboardTechnique</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Technique</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="k">public</span><span class="o">:</span>  
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  <span class="n">BillboardTechnique</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">  <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">Init</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">  <span class="kt">void</span> <span class="nf">SetVP</span><span class="p">(</span><span class="k">const</span> <span class="n">Matrix4f</span><span class="o">&amp;</span> <span class="n">VP</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  <span class="kt">void</span> <span class="nf">SetCameraPosition</span><span class="p">(</span><span class="k">const</span> <span class="n">Vector3f</span><span class="o">&amp;</span> <span class="n">Pos</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">10</span><span class="cl">  <span class="kt">void</span> <span class="nf">SetColorTextureUnit</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">TextureUnit</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">  
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="k">private</span><span class="o">:</span>  
</span></span><span class="line"><span class="ln">13</span><span class="cl">  <span class="n">GLuint</span> <span class="n">m_VPLocation</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">14</span><span class="cl">  <span class="n">GLuint</span> <span class="n">m_cameraPosLocation</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">15</span><span class="cl">  <span class="n">GLuint</span> <span class="n">m_colorMapLocation</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="p">};</span></span></span></code></pre></div><p>This is the interface of the billboard technique. It requires only three parameters in order to do its job: the combined view/projection matrix, the position of the camera in world space and the number of the texture unit where the billboard texture is bound.</p>
<p>(billboard.vs)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="cp">#version 330
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">Position</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln">7</span><span class="cl">  <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">Position</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">8</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>This is the VS of the billboard technique and with most of the action taking place in the GS you cannot ask for a simpler VS. The vertex buffer contains only position vectors and since they are already specified in world space we only need to pass them through to the GS. That&rsquo;s it.</p>
<p>(billboard.gs:1)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="cp">#version 330
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="n">in</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">triangle_strip</span><span class="p">)</span> <span class="n">out</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">max_vertices</span> <span class="o">=</span> <span class="mi">4</span><span class="p">)</span> <span class="n">out</span><span class="p">;</span></span></span></code></pre></div><p>The core of the billboard technique is located in the GS. Let&rsquo;s take a look at it piece by piece. We start by declaring some global stuff using the &rsquo;layout&rsquo; keyword. We tell the pipeline that the incoming topology is point list and the outgoing topology is triangle strip. We also tell it that we will emit no more than four vertices. This keyword is used to give the graphics driver a hint about the maximum number of vertices that can be emitted by the GS. Knowning the limit in advance gives the driver an opportunity to optimize the behavior of the GS for the particular case. Since we know that we are going to emit a quad for each incoming vertex we declare the maximum as four vertices.</p>
<p>(billboard.gs:7)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">uniform</span> <span class="n">mat4</span> <span class="n">gVP</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">uniform</span> <span class="n">vec3</span> <span class="n">gCameraPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="n">out</span> <span class="n">vec2</span> <span class="n">TexCoord</span><span class="p">;</span></span></span></code></pre></div><p>The GS gets the position in world space so it only needs a view/projection matrix. It also needs the camera location in order to calculate how to orient the billboard towards it. The GS generates texture coordinates for the FS so we must declare them.</p>
<p>(billboard.gs:12)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln">3</span><span class="cl">  <span class="n">vec3</span> <span class="n">Pos</span> <span class="o">=</span> <span class="n">gl_in</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">gl_Position</span><span class="p">.</span><span class="n">xyz</span><span class="p">;</span></span></span></code></pre></div><p>The line above is unique to the GS. Since it is executed on a complete primitive we actually have access to each of the vertices that comprise it. This is done using the built-in variable &lsquo;gl_in&rsquo;. This variable is an array of structures that contains, among other things, the position that was written into gl_Position in the VS. To access it we go to the slot we are interested in using the index of the vertex. In this specific example the input topology is point list so there is only a single vertex. We access it using &lsquo;gl_in[0]&rsquo;. If the input topology was a triangle we could also have written &lsquo;gl_in[1]&rsquo; and &lsquo;gl_in[2]&rsquo;. We only need the first three components of the position vector and we extract them to a local variable using &lsquo;.xyz&rsquo;.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">vec3</span> <span class="n">toCamera</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">gCameraPos</span> <span class="o">-</span> <span class="n">Pos</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">vec3</span> <span class="n">up</span> <span class="o">=</span> <span class="n">vec3</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">vec3</span> <span class="n">right</span> <span class="o">=</span> <span class="n">cross</span><span class="p">(</span><span class="n">toCamera</span><span class="p">,</span> <span class="n">up</span><span class="p">);</span></span></span></code></pre></div><p>Here we make the billboard face the camera per the explanation at the end of the background section. We do a cross product between the vector from the point to the camera and a vector that points straight up. This provides the vector that points right when looking at the point from the camera point of view. We will now use it to &lsquo;grow&rsquo; a quad around the point.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">Pos</span> <span class="o">-=</span> <span class="p">(</span><span class="n">right</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="n">gl_Position</span> <span class="o">=</span> <span class="n">gVP</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">Pos</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">TexCoord</span> <span class="o">=</span> <span class="n">vec2</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">EmitVertex</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">Pos</span><span class="p">.</span><span class="n">y</span> <span class="o">+=</span> <span class="mf">1.0</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="n">gl_Position</span> <span class="o">=</span> <span class="n">gVP</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">Pos</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="n">TexCoord</span> <span class="o">=</span> <span class="n">vec2</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="n">EmitVertex</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln">10</span><span class="cl">
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="n">Pos</span><span class="p">.</span><span class="n">y</span> <span class="o">-=</span> <span class="mf">1.0</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="n">Pos</span> <span class="o">+=</span> <span class="n">right</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="n">gl_Position</span> <span class="o">=</span> <span class="n">gVP</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">Pos</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="n">TexCoord</span> <span class="o">=</span> <span class="n">vec2</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="n">EmitVertex</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln">16</span><span class="cl">
</span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="n">Pos</span><span class="p">.</span><span class="n">y</span> <span class="o">+=</span> <span class="mf">1.0</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="n">gl_Position</span> <span class="o">=</span> <span class="n">gVP</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">Pos</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="n">TexCoord</span> <span class="o">=</span> <span class="n">vec2</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="n">EmitVertex</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="n">EndPrimitive</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>The point in the vertex buffer is considered to be at the center of the bottom of the quad. We need to generate two front facing triangles from it. We start by going left to the bottom left corner of the quad. This is done by substracting half of the &lsquo;right&rsquo; vector from the point. Next we calculate the position in clip space by mutiplying the point by the view/projection matrix. We also set the texture coordinate to (0,0) because we plan to cover the entire texture space using the quad. To send the newly generated vertex down the pipe we call the built-in function EmitVertex(). After this functionn is called the variables that we have written to are considered undefined and we have to set new data for them. In a similar way we generate the top left and bottom right corners of the quad. This is the first front facing triangle. Since the output topology of the GS is triangle strip we only need one more vertex for the second triangle. It will be structured using the new vertex and the last two vertices (which are the quad diagonal). The fourth and final vertex is the top right corner of the quad. To end the triangle strip we call the built-in function EndPrimitive().</p>
<p>(billboard.fs)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">gColorMap</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">in</span> <span class="n">vec2</span> <span class="n">TexCoord</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">out</span> <span class="n">vec4</span> <span class="n">FragColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln">10</span><span class="cl">  <span class="n">FragColor</span> <span class="o">=</span> <span class="n">texture2D</span><span class="p">(</span><span class="n">gColorMap</span><span class="p">,</span> <span class="n">TexCoord</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">11</span><span class="cl">  
</span></span><span class="line"><span class="ln">12</span><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">FragColor</span><span class="p">.</span><span class="n">r</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">FragColor</span><span class="p">.</span><span class="n">g</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">FragColor</span><span class="p">.</span><span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>   
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="n">discard</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">14</span><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>The FS is very simple - most of its work is to sample the texture using the texture coordinates generated by the GS. There is a new feature here - the built-in keyword &lsquo;discard&rsquo; is used in order to drop a pixel completely on certain cases. The picture of the hell-knight from Doom which is included in this tutorial shows the monster on a black background. Using this texture as-is will make the billboard look like a full sized card which is much larger than the monster itself. To overcome this we test the texel color and if it is black we drop the pixel. This allows us to select only the pixels that actually make up the monster. Try to disable &lsquo;discard&rsquo; and see the difference.</p>

            <footer class="footline">
            </footer>
          </article>

        </div>
      </main>
    </div>
    <script src="../../../../../js/clipboard.min.js?1708235002" defer></script>
    <script src="../../../../../js/perfect-scrollbar.min.js?1708235002" defer></script>
    <script src="../../../../../js/theme.js?1708235002" defer></script>
  </body>
</html>
