<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.122.0">
    <meta name="generator" content="Relearn 5.23.2+tip">
    <meta name="description" content="啊啊啊啊">
    <meta name="author" content="Sören Weber">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="https://example.com/images/hero.png">
    <meta name="twitter:title" content="Tutorial 40:Stencil Shadow Volume :: Hugo Relearn Theme">
    <meta name="twitter:description" content="Background In tutorials 23 &amp; 24 we studied the shadow map technique which is a relatively simple way to get shadows into your 3D world. Shadow maps are in a disadvantage when trying to generate a shadow for a point light source. You need a direction vector in order to generate the shadow map and since a point light casts its light all over the place it is difficult to get such a vector.">
    <meta property="og:title" content="Tutorial 40:Stencil Shadow Volume :: Hugo Relearn Theme">
    <meta property="og:description" content="Background In tutorials 23 &amp; 24 we studied the shadow map technique which is a relatively simple way to get shadows into your 3D world. Shadow maps are in a disadvantage when trying to generate a shadow for a point light source. You need a direction vector in order to generate the shadow map and since a point light casts its light all over the place it is difficult to get such a vector.">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://example.com/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_40_stencil_shadow_volume/index.html">
    <meta property="og:image" content="https://example.com/images/hero.png">
    <meta property="article:section" content="OGL dev 教程 :: Hugo Relearn Theme">
    <meta property="og:site_name" content="Hugo Relearn Theme">
    <title>Tutorial 40:Stencil Shadow Volume :: Hugo Relearn Theme</title>
    <link href="https://example.com/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_40_stencil_shadow_volume/index.html" rel="canonical" type="text/html" title="Tutorial 40:Stencil Shadow Volume :: Hugo Relearn Theme">
    <link href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_40_stencil_shadow_volume/index.xml" rel="alternate" type="application/rss+xml" title="Tutorial 40:Stencil Shadow Volume :: Hugo Relearn Theme"><link rel="icon" href="../../../../../images/favicon.ico">
    <!-- https://github.com/filamentgroup/loadCSS/blob/master/README.md#how-to-use -->
    <link href="../../../../../css/fontawesome-all.min.css?1708235002" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../../../../../css/fontawesome-all.min.css?1708235002" rel="stylesheet"></noscript>
    <link href="../../../../../css/nucleus.css?1708235002" rel="stylesheet">
    <link href="../../../../../css/auto-complete.css?1708235002" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../../../../../css/auto-complete.css?1708235002" rel="stylesheet"></noscript>
    <link href="../../../../../css/perfect-scrollbar.min.css?1708235002" rel="stylesheet">
    <link href="../../../../../css/fonts.css?1708235002" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../../../../../css/fonts.css?1708235002" rel="stylesheet"></noscript>
    <link href="../../../../../css/theme.css?1708235002" rel="stylesheet">
    <link href="../../../../../css/theme-auto.css?1708235002" rel="stylesheet" id="R-variant-style">
    <link href="../../../../../css/variant.css?1708235002" rel="stylesheet">
    <link href="../../../../../css/print.css?1708235002" rel="stylesheet" media="print">
    <link href="../../../../../css/format-print.css?1708235002" rel="stylesheet">
    <link href="../../../../../css/ie.css?1708235002" rel="stylesheet">
    <script src="../../../../../js/url.js?1708235002"></script>
    <script src="../../../../../js/variant.js?1708235002"></script>
    <script>
      // hack to let hugo tell us how to get to the root when using relativeURLs, it needs to be called *url= for it to do its magic:
      // https://github.com/gohugoio/hugo/blob/145b3fcce35fbac25c7033c91c1b7ae6d1179da8/transform/urlreplacers/absurlreplacer.go#L72
      window.index_js_url="../../../../../index.search.js";
      var root_url="../../../../../";
      var baseUri=root_url.replace(/\/$/, '');
      window.relearn = window.relearn || {};
      window.relearn.baseUriFull='https:\/\/example.com/';
      // variant stuff
      window.variants && variants.init( [ 'auto', 'relearn-light', 'relearn-dark', 'zen-light', 'zen-dark', 'neon', 'learn', 'blue', 'green', 'red' ] );
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
    </script>
    <style>
      #R-body img.bg-white {
        background-color: white;
      }
    </style>
  </head>
  <body class="mobile-support print" data-url="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_40_stencil_shadow_volume/index.html">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide">
              <button class="topbar-control" onclick="toggleNav()" type="button" title="Menu (CTRL&#43;ALT&#43;n)">
                <i class="fa-fw fas fa-bars"></i>
              </button>
            </div>
          </div>
          <ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype="http://schema.org/BreadcrumbList"><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../index.html"><span itemprop="name">主页</span></a><meta itemprop="position" content="1">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../computer_graphics/index.html"><span itemprop="name">计算机图形学</span></a><meta itemprop="position" content="2">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../computer_graphics/classic_tutorial/index.html"><span itemprop="name">经典教程</span></a><meta itemprop="position" content="3">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/index.html"><span itemprop="name">OpenGL教程</span></a><meta itemprop="position" content="4">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/index.html"><span itemprop="name">OGL dev 教程</span></a><meta itemprop="position" content="5">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><span itemprop="name">Tutorial 40:Stencil Shadow Volume</span><meta itemprop="position" content="6"></li>
          </ol>
          <div class="topbar-area topbar-area-end" data-area="end">
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable default" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="default">
            <header class="headline">
            </header>
<h1 id="tutorial-40stencil-shadow-volume">Tutorial 40:Stencil Shadow Volume</h1>

<h3 id="background">Background</h3>
<p>In <a href="https://ogldev.org/www/tutorial23/tutorial23.html" target="_blank">tutorials 23 &amp; 24</a> we studied the shadow map technique which is a relatively simple way to get shadows into your 3D world. Shadow maps are in a disadvantage when trying to generate a shadow for a point light source. You need a direction vector in order to generate the shadow map and since a point light casts its light all over the place it is difficult to get such a vector. While there are methods to overcome this, they are a bit complex and make the shadow map technique more suitable for spot lights. The <em>Stencil Shadow Volume</em> is an interesting technique that provides a straightforward solution to the problem of point lights. This technique was discovered by William Bilodeau and Michael Songy in 1998 and was popularized by John Carmack in his Doom 3 engine (2002).</p>
<p>If you&rsquo;ve followed the tutorials thus far you&rsquo;ve actually seen a variation of this technique in our mini series of tutorials on <a href="https://ogldev.org/www/tutorial35/tutorial35.html" target="_blank">Deferred Shading</a>. With deferred shading we needed a way to block the light influence and we&rsquo;ve used a light volume for that purpose. We processed lighting only on stuff within the light volume. Now we are going to do the opposite. We will create a shadow volume and process lighting only on stuff outside of it. Same as in light volume we will use the stencil buffer as a key component of the algorithm. Hence the name - Stencil Shadow Volume.</p>
<p>The idea behind the shadow volume algorithm is to extend the silhouette of an object which is created when light falls upon it into a volume and then render that volume into the stencil buffer using a couple of simple stencil operations. The key idea is that <strong>when an object is inside the volume (and therefore in shadow) the front polygons of the volume win the depth test against the polygons of the object and the back polygons of the volume fail the same test</strong>.</p>
<p>We are going to setup the stencil operation according to a method known as <em>Depth Fail</em>. People often start the description of the shadow volume technique using a more straighforward method called <em>Depth Pass</em>, however, that method has a known problem when the viewer itself is inside the shadow volume and Depth Fail fixes that problem. Therefore, I&rsquo;ve skipped Depth Pass altogether and went directly to Depth Fail. Take a look at the following picture:</p>
<p><a href="#R-image-1779f4346d78dac5949682ec54fde038" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_40_stencil_shadow_volume/../assets/shadow_volume1.jpeg" alt="img" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-1779f4346d78dac5949682ec54fde038"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_40_stencil_shadow_volume/../assets/shadow_volume1.jpeg" alt="img" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>We have a light bulb at the bottom left corner and a green object (called an occluder) which casts shadow due to that light. Three round objects are rendered in this scene as well. Object B is shadowed while A &amp; C are not. The red arrows bound the area of the shadow volume (the dashed part of the line is not part of it).</p>
<p>Let&rsquo;s see how we can utilize the stencil buffer to get shadows working here. We start by rendering the actual objects (A, B, C and the green box) into the depth buffer. When we are done we have the depth of the closest pixels available to us. Then we go over the objects in the scene one by one and create a shadow volume for each one. The example here shows only the shadow volume of the green box but in a complete application we would also create volumes for the round objects because they cast shadows of their own. The shadow volume is created by detecting its silhouette (make sure you fully understand <a href="https://ogldev.org/www/tutorial39/tutorial39.html" target="_blank">tutorial 39</a> before starting this one) and extending it into infinity. We render that volume into the stencil buffer using the following simple rules:</p>
<ul>
<li>If the depth test fails when rendering the <strong>back</strong> facing polygons of the shadow volume we <strong>increment</strong> the value in the stencil buffer.</li>
<li>If the depth test fails when rendering the <strong>front</strong> facing polygons of the shadow volume we <strong>decrement</strong> the value in the stencil buffer.</li>
<li>We do nothing in the following cases: depth test pass, stencil test fails.</li>
</ul>
<p>Let&rsquo;s see what happens to the stencil buffer using the above scheme. The front and back facing triangles of the volume that are covered by object A fail the depth test. We increment and decrement the values of the pixels covered by object A in the stencil buffer which means they are left at zero. In the case of object B the front facing triangles of the volume win the depth test while the back facing ones fails. Therefore, we only increment the stencil value. The volume triangles (front and back facing) that cover object C win the depth test. Therefore, the stencil value is not updated and remains at zero.</p>
<p>Note that up till now we haven&rsquo;t touched the color buffer. When we complete all of the above we render all objects once again using the standard lighting shader but this time we set the stencil test such that only pixels whose stencil value is zero will be rendered. This means that only objects A &amp; C will make it to the screen.</p>
<p>Here&rsquo;s a more complex scene that includes two occluders:</p>
<p><a href="#R-image-1c7c60984d4c3d5943cca3773553f1d3" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_40_stencil_shadow_volume/../assets/shadow_volume2.jpeg" alt="img" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-1c7c60984d4c3d5943cca3773553f1d3"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_40_stencil_shadow_volume/../assets/shadow_volume2.jpeg" alt="img" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>To make it simpler to detect the shadow volume of the second occluder it is marked by thinner red arrows. You can follow the changes to the stencil buffer (marked by +1 and -1) and see that the algorithm works fine in this case as well. The change from the previous picture is that now A is also in shadow.</p>
<p>Let&rsquo;s see how to put that knowledge into practice. As we said earlier, we need to render a volume which is created when we extend the silhouette of an occluder. We can start with the code from the previous tutorial which detects the silhouette. All we need to do is to extend the silhouette edges into a volume. This is done by emitting a quad (or actually, four vertices in triangle strip topology) from the GS for each silhouette edge. The first two vertices come from the silhouette edge and the other two vertices are generated when we extend the edge vertices into infinity along the vector from the light position to the vertices. By extending into infinity we make sure the volume captures everything which lies in the path of the shadow. This quad is depicted in the following picture:</p>
<p><a href="#R-image-e3e40f43ef444c89d394890c00cbb631" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_40_stencil_shadow_volume/../assets/quad1.jpeg" alt="img" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-e3e40f43ef444c89d394890c00cbb631"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_40_stencil_shadow_volume/../assets/quad1.jpeg" alt="img" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>When we repeat this process of emitting quads from all silhouette edges a volume is created. Is that enough? definitely not. The problem is that this volume looks kind of like a truncated cone without its caps. Since our algorithm depends on checking the depth test of the front and back triangles of the volume we might end up with a case where the vector from the eye to the pixel goes through only either the front or back of the volume:</p>
<p><a href="#R-image-95bce66ea29154f9b1a75b0c63d48663" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_40_stencil_shadow_volume/../assets/caps.jpeg" alt="img" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-95bce66ea29154f9b1a75b0c63d48663"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_40_stencil_shadow_volume/../assets/caps.jpeg" alt="img" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>The solution to this problem is to generate a volume which is closed on both sides. This is done by creating a front and a back cap to the volume (the dotted lines in the picture above). Creating the front cap is very easy. Every triangle which faces the light becomes part of the front cap. While this may not be the most efficient solution and you could probably create a front cap using fewer triangles it is definitely the simplest solution. The back cap is almost as simple. We just need to extend the vertices of light facing triangle to infinity (along the vector from the light to each vertex) and reverse their order (else the resulting triangle will point inside the volume).</p>
<p>The word &lsquo;infinity&rsquo; has been mentioned here a few times and we now need to define exactly what this means. Take a look at the following picture:</p>
<p><a href="#R-image-1ccbc437385d9d37f2c5bf9952e3a064" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_40_stencil_shadow_volume/../assets/infinity.jpeg" alt="img" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-1ccbc437385d9d37f2c5bf9952e3a064"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_40_stencil_shadow_volume/../assets/infinity.jpeg" alt="img" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>What we see is a picture of the frustum taken from above. The light bulb emits a ray which goes through point &lsquo;p&rsquo; and continues to infinity. In other words, &lsquo;p&rsquo; is extended to infinity. Obviously, at infinity the position of point p is simply (infinity, infinity, infinity), but we don&rsquo;t care about that. We need to find a way to rasterize the triangles of the shadow volume which means we must project its vertices on the projection plane. This projection plane is in fact the near plane. While &lsquo;p&rsquo; is extended to infinity along the light vector we can still project it back on the near plane. This is done by the dotted line that goes from the origin and crosses the light vector somewhere. We want to find &lsquo;Xp&rsquo; which is the X value of the point where that vector crosses the near plane.</p>
<p>Let&rsquo;s describe any point on the light vector as &lsquo;p + vt&rsquo; where &lsquo;v&rsquo; is the vector from the light source to point &lsquo;p&rsquo; and &rsquo;t&rsquo; is a scalar which goes from 0 towards infinity. From the above picture and due to triangle similarities we can say that:</p>
<p><a href="#R-image-141c202b2ba13ea7b850d84cf41195c1" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_40_stencil_shadow_volume/../assets/infinity1.jpeg" alt="img" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-141c202b2ba13ea7b850d84cf41195c1"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_40_stencil_shadow_volume/../assets/infinity1.jpeg" alt="img" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Where &rsquo;n&rsquo; is the Z value of the near plane. As &rsquo;t&rsquo; goes to infinity we are left with:</p>
<p><a href="#R-image-d1f12fcff78e96dce21b1cfec41f3d67" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_40_stencil_shadow_volume/../assets/infinity2.jpeg" alt="img" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d1f12fcff78e96dce21b1cfec41f3d67"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_40_stencil_shadow_volume/../assets/infinity2.jpeg" alt="img" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>So this is how we find the projection of &lsquo;p&rsquo; at infinity on the near plane. Now here&rsquo;s a bit of magic - turns out that to calculate Xp and Yp according to the above we just need to multiply the vector (Vx, Vy, Vz, 0) (where &lsquo;V&rsquo; is the vector from the light source to point &lsquo;p&rsquo;) by the view/projection matrix and apply perspective divide on it. We are not going to prove it here by you can try this yourself and see the result. So the bottom line is that whenever we need to rasterize a triangle that contains a vertex which was extended to infinity along some vector we simply multiply that vector by the view/projection matrix while adding a &lsquo;w&rsquo; component with the value of zero to it. We will use that technique extensively in the GS below.</p>
<h3 id="source-walkthru">Source walkthru</h3>
<p>(glut_backend.cpp:171)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glutInitDisplayMode</span><span class="p">(</span><span class="n">GLUT_DOUBLE</span><span class="o">|</span><span class="n">GLUT_RGBA</span><span class="o">|</span><span class="n">GLUT_DEPTH</span><span class="o">|</span><span class="n">GLUT_STENCIL</span><span class="p">);</span></span></span></code></pre></div><p>Before you start working on this tutorial make sure you initialize FreeGLUT per the code in bold face above. Without it the framebuffer will be created without a stencil buffer and nothing will work. I wasted some time before realizing this was missing so make sure you add this.</p>
<p>(tutorial40.cpp:139)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">virtual</span> <span class="kt">void</span> <span class="nf">RenderSceneCB</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  <span class="n">CalcFPS</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  <span class="n">m_scale</span> <span class="o">+=</span> <span class="mf">0.1f</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  <span class="n">m_pGameCamera</span><span class="o">-&gt;</span><span class="n">OnRender</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  <span class="n">glDepthMask</span><span class="p">(</span><span class="n">GL_TRUE</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">10</span><span class="cl">  
</span></span><span class="line"><span class="ln">11</span><span class="cl">  <span class="n">glClear</span><span class="p">(</span><span class="n">GL_COLOR_BUFFER_BIT</span> <span class="o">|</span> <span class="n">GL_DEPTH_BUFFER_BIT</span> <span class="o">|</span> <span class="n">GL_STENCIL_BUFFER_BIT</span><span class="p">);</span>  <span class="n">RenderSceneIntoDepth</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln">12</span><span class="cl">  
</span></span><span class="line"><span class="ln">13</span><span class="cl">  <span class="n">glEnable</span><span class="p">(</span><span class="n">GL_STENCIL_TEST</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">14</span><span class="cl">  
</span></span><span class="line"><span class="ln">15</span><span class="cl">  <span class="n">RenderShadowVolIntoStencil</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln">16</span><span class="cl">  
</span></span><span class="line"><span class="ln">17</span><span class="cl">  <span class="n">RenderShadowedScene</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln">18</span><span class="cl">  
</span></span><span class="line"><span class="ln">19</span><span class="cl">  <span class="n">glDisable</span><span class="p">(</span><span class="n">GL_STENCIL_TEST</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">20</span><span class="cl">  
</span></span><span class="line"><span class="ln">21</span><span class="cl">  <span class="n">RenderAmbientLight</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln">22</span><span class="cl">  
</span></span><span class="line"><span class="ln">23</span><span class="cl">  <span class="n">RenderFPS</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln">24</span><span class="cl">  
</span></span><span class="line"><span class="ln">25</span><span class="cl">  <span class="n">glutSwapBuffers</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>The main render loop function executes the three stages of the algorithm. First we render the entire scene into the depth buffer (without touching the color buffer). Then we render the shadow volume into the stencil buffer while setting up the stencil test as described in the background session. And finally the scene itself is rendered while taking into account the values in the stencil buffer (i.e. only those pixels whose stencil value is zero are rendered).</p>
<p>An important difference between this method and shadow map is that shadowed pixels in the stencil shadow volume method never reach the fragment shader. When we were using shadow map we had the opportunity to calculate ambient lighting on shadowed pixels. We don&rsquo;t have that opportunity here. Therefore, we add an ambient pass outside the stencil test.</p>
<p>Note that we enable writing to the depth buffer before the call to glClear. Without it the depth buffer will not be cleared (because we play with the mask later on).</p>
<p>(tutorial40.cpp:198)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="nf">RenderSceneIntoDepth</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  <span class="n">glDrawBuffer</span><span class="p">(</span><span class="n">GL_NONE</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  <span class="n">m_nullTech</span><span class="p">.</span><span class="n">Enable</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  <span class="n">Pipeline</span> <span class="n">p</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  <span class="n">p</span><span class="p">.</span><span class="n">SetCamera</span><span class="p">(</span><span class="n">m_pGameCamera</span><span class="o">-&gt;</span><span class="n">GetPos</span><span class="p">(),</span> <span class="n">m_pGameCamera</span><span class="o">-&gt;</span><span class="n">GetTarget</span><span class="p">(),</span> <span class="n">m_pGameCamera</span><span class="o">-&gt;</span><span class="n">GetUp</span><span class="p">());</span>  
</span></span><span class="line"><span class="ln">10</span><span class="cl">  <span class="n">p</span><span class="p">.</span><span class="n">SetPerspectiveProj</span><span class="p">(</span><span class="n">m_persProjInfo</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">11</span><span class="cl">  
</span></span><span class="line"><span class="ln">12</span><span class="cl">  <span class="n">m_boxOrientation</span><span class="p">.</span><span class="n">m_rotation</span> <span class="o">=</span> <span class="n">Vector3f</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">m_scale</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">13</span><span class="cl">  <span class="n">p</span><span class="p">.</span><span class="n">Orient</span><span class="p">(</span><span class="n">m_boxOrientation</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">14</span><span class="cl">  <span class="n">m_nullTech</span><span class="p">.</span><span class="n">SetWVP</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">GetWVPTrans</span><span class="p">());</span>  
</span></span><span class="line"><span class="ln">15</span><span class="cl">  <span class="n">m_box</span><span class="p">.</span><span class="n">Render</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln">16</span><span class="cl">  
</span></span><span class="line"><span class="ln">17</span><span class="cl">  <span class="n">p</span><span class="p">.</span><span class="n">Orient</span><span class="p">(</span><span class="n">m_quadOrientation</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">18</span><span class="cl">  <span class="n">m_nullTech</span><span class="p">.</span><span class="n">SetWVP</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">GetWVPTrans</span><span class="p">());</span>  
</span></span><span class="line"><span class="ln">19</span><span class="cl">  <span class="n">m_quad</span><span class="p">.</span><span class="n">Render</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>Here we render the entire scene into the depth buffer, while disabling writes to the color buffer. We have to do this because in the next step we render the shadow volume and we need the depth fail algorithm to be performed correctly. If the depth buffer is only partially updated we will get incorrect results.</p>
<p>(tutorial40.cpp:219)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="nf">RenderShadowVolIntoStencil</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  <span class="n">glDepthMask</span><span class="p">(</span><span class="n">GL_FALSE</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  <span class="n">glEnable</span><span class="p">(</span><span class="n">GL_DEPTH_CLAMP</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  <span class="n">glDisable</span><span class="p">(</span><span class="n">GL_CULL_FACE</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  <span class="c1">// We need the stencil test to be enabled but we want it  
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="c1"></span>  <span class="c1">// to succeed always. Only the depth test matters.  
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1"></span>  <span class="n">glStencilFunc</span><span class="p">(</span><span class="n">GL_ALWAYS</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">10</span><span class="cl">  
</span></span><span class="line"><span class="ln">11</span><span class="cl">  <span class="c1">// Set the stencil test per the depth fail algorithm  
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="c1"></span>  <span class="n">glStencilOpSeparate</span><span class="p">(</span><span class="n">GL_BACK</span><span class="p">,</span> <span class="n">GL_KEEP</span><span class="p">,</span> <span class="n">GL_INCR_WRAP</span><span class="p">,</span> <span class="n">GL_KEEP</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">13</span><span class="cl">  <span class="n">glStencilOpSeparate</span><span class="p">(</span><span class="n">GL_FRONT</span><span class="p">,</span> <span class="n">GL_KEEP</span><span class="p">,</span> <span class="n">GL_DECR_WRAP</span><span class="p">,</span> <span class="n">GL_KEEP</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">14</span><span class="cl">  
</span></span><span class="line"><span class="ln">15</span><span class="cl">  <span class="n">m_ShadowVolTech</span><span class="p">.</span><span class="n">Enable</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln">16</span><span class="cl">  
</span></span><span class="line"><span class="ln">17</span><span class="cl">  <span class="n">m_ShadowVolTech</span><span class="p">.</span><span class="n">SetLightPos</span><span class="p">(</span><span class="n">m_pointLight</span><span class="p">.</span><span class="n">Position</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">18</span><span class="cl">  
</span></span><span class="line"><span class="ln">19</span><span class="cl">  <span class="c1">// Render the occluder  
</span></span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="c1"></span>  <span class="n">Pipeline</span> <span class="n">p</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">21</span><span class="cl">  <span class="n">p</span><span class="p">.</span><span class="n">SetCamera</span><span class="p">(</span><span class="n">m_pGameCamera</span><span class="o">-&gt;</span><span class="n">GetPos</span><span class="p">(),</span> <span class="n">m_pGameCamera</span><span class="o">-&gt;</span><span class="n">GetTarget</span><span class="p">(),</span> <span class="n">m_pGameCamera</span><span class="o">-&gt;</span><span class="n">GetUp</span><span class="p">());</span>  
</span></span><span class="line"><span class="ln">22</span><span class="cl">  <span class="n">p</span><span class="p">.</span><span class="n">SetPerspectiveProj</span><span class="p">(</span><span class="n">m_persProjInfo</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">23</span><span class="cl">  <span class="n">m_boxOrientation</span><span class="p">.</span><span class="n">m_rotation</span> <span class="o">=</span> <span class="n">Vector3f</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">m_scale</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">24</span><span class="cl">  <span class="n">p</span><span class="p">.</span><span class="n">Orient</span><span class="p">(</span><span class="n">m_boxOrientation</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">25</span><span class="cl">  <span class="n">m_ShadowVolTech</span><span class="p">.</span><span class="n">SetVP</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">GetVPTrans</span><span class="p">());</span>  
</span></span><span class="line"><span class="ln">26</span><span class="cl">  <span class="n">m_ShadowVolTech</span><span class="p">.</span><span class="n">SetWorldMatrix</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">GetWorldTrans</span><span class="p">());</span>  
</span></span><span class="line"><span class="ln">27</span><span class="cl">  <span class="n">m_box</span><span class="p">.</span><span class="n">Render</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln">28</span><span class="cl">  
</span></span><span class="line"><span class="ln">29</span><span class="cl">  <span class="c1">// Restore local stuff  
</span></span></span><span class="line"><span class="ln">30</span><span class="cl"><span class="c1"></span>  <span class="n">glDisable</span><span class="p">(</span><span class="n">GL_DEPTH_CLAMP</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">31</span><span class="cl">  <span class="n">glEnable</span><span class="p">(</span><span class="n">GL_CULL_FACE</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">32</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>This is where things become interesting. We use a special technique which is based on the silhouette technique from the previous tutorial. It generates the volume (and its caps) from the silhouette of the occluder. First we disable writes to the depth buffer (writes to the color are already disabled from the previous step). We are only going to update the stencil buffer. We enable depth clamp which will cause our projected-to-infinity-vertices (from the far cap) to be clamped to the maximum depth value. Otherwise, the far cap will simply be clipped away. We also disable back face culling because our algorithm depends on rendering all the triangles of the volume. Then we set the stencil test (which has been enabled in the main render function) to always succeed and we set the stencil operations for the front and back faces according to the depth fail algorithm. After that we simply set everything the shader needs and render the occluder.</p>
<p>(tutorial40.cpp:250)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="nf">RenderShadowedScene</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  <span class="n">glDrawBuffer</span><span class="p">(</span><span class="n">GL_BACK</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  <span class="c1">// Draw only if the corresponding stencil value is zero  
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="c1"></span>  <span class="n">glStencilFunc</span><span class="p">(</span><span class="n">GL_EQUAL</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">  <span class="c1">// prevent update to the stencil buffer  
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1"></span>  <span class="n">glStencilOpSeparate</span><span class="p">(</span><span class="n">GL_BACK</span><span class="p">,</span> <span class="n">GL_KEEP</span><span class="p">,</span> <span class="n">GL_KEEP</span><span class="p">,</span> <span class="n">GL_KEEP</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">10</span><span class="cl">  
</span></span><span class="line"><span class="ln">11</span><span class="cl">  <span class="n">m_LightingTech</span><span class="p">.</span><span class="n">Enable</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln">12</span><span class="cl">  
</span></span><span class="line"><span class="ln">13</span><span class="cl">  <span class="n">m_pointLight</span><span class="p">.</span><span class="n">AmbientIntensity</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">14</span><span class="cl">  <span class="n">m_pointLight</span><span class="p">.</span><span class="n">DiffuseIntensity</span> <span class="o">=</span> <span class="mf">0.8f</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">15</span><span class="cl">  
</span></span><span class="line"><span class="ln">16</span><span class="cl">  <span class="n">m_LightingTech</span><span class="p">.</span><span class="n">SetPointLights</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m_pointLight</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">17</span><span class="cl">  
</span></span><span class="line"><span class="ln">18</span><span class="cl">  <span class="n">Pipeline</span> <span class="n">p</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">19</span><span class="cl">  <span class="n">p</span><span class="p">.</span><span class="n">SetPerspectiveProj</span><span class="p">(</span><span class="n">m_persProjInfo</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">20</span><span class="cl">  <span class="n">p</span><span class="p">.</span><span class="n">SetCamera</span><span class="p">(</span><span class="n">m_pGameCamera</span><span class="o">-&gt;</span><span class="n">GetPos</span><span class="p">(),</span> <span class="n">m_pGameCamera</span><span class="o">-&gt;</span><span class="n">GetTarget</span><span class="p">(),</span> <span class="n">m_pGameCamera</span><span class="o">-&gt;</span><span class="n">GetUp</span><span class="p">());</span>  
</span></span><span class="line"><span class="ln">21</span><span class="cl">  
</span></span><span class="line"><span class="ln">22</span><span class="cl">  <span class="n">m_boxOrientation</span><span class="p">.</span><span class="n">m_rotation</span> <span class="o">=</span> <span class="n">Vector3f</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">m_scale</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">23</span><span class="cl">  <span class="n">p</span><span class="p">.</span><span class="n">Orient</span><span class="p">(</span><span class="n">m_boxOrientation</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">24</span><span class="cl">  <span class="n">m_LightingTech</span><span class="p">.</span><span class="n">SetWVP</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">GetWVPTrans</span><span class="p">());</span>  
</span></span><span class="line"><span class="ln">25</span><span class="cl">  <span class="n">m_LightingTech</span><span class="p">.</span><span class="n">SetWorldMatrix</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">GetWorldTrans</span><span class="p">());</span>  
</span></span><span class="line"><span class="ln">26</span><span class="cl">  <span class="n">m_box</span><span class="p">.</span><span class="n">Render</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln">27</span><span class="cl">  
</span></span><span class="line"><span class="ln">28</span><span class="cl">  <span class="n">p</span><span class="p">.</span><span class="n">Orient</span><span class="p">(</span><span class="n">m_quadOrientation</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">29</span><span class="cl">  <span class="n">m_LightingTech</span><span class="p">.</span><span class="n">SetWVP</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">GetWVPTrans</span><span class="p">());</span>  
</span></span><span class="line"><span class="ln">30</span><span class="cl">  <span class="n">m_LightingTech</span><span class="p">.</span><span class="n">SetWorldMatrix</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">GetWorldTrans</span><span class="p">());</span>  
</span></span><span class="line"><span class="ln">31</span><span class="cl">  <span class="n">m_pGroundTex</span><span class="o">-&gt;</span><span class="n">Bind</span><span class="p">(</span><span class="n">COLOR_TEXTURE_UNIT</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">32</span><span class="cl">  <span class="n">m_quad</span><span class="p">.</span><span class="n">Render</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">33</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>We can now put the updated stencil buffer into use. Based on our algorithm we set rendering to succeed only when the stencil value of the pixel is exactly zero. In addition, we also prevent updates to the stencil buffer by setting the stencil test action to GL_KEEP. And that&rsquo;s it! We can now use the standard lighting shader to render the scene. Just remember to enable writing into the color buffer before you start&hellip;</p>
<p>(tutorial40.cpp:285)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="nf">RenderAmbientLight</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  <span class="n">glEnable</span><span class="p">(</span><span class="n">GL_BLEND</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  <span class="n">glBlendEquation</span><span class="p">(</span><span class="n">GL_FUNC_ADD</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  <span class="n">glBlendFunc</span><span class="p">(</span><span class="n">GL_ONE</span><span class="p">,</span> <span class="n">GL_ONE</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  <span class="n">m_LightingTech</span><span class="p">.</span><span class="n">Enable</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  <span class="n">m_pointLight</span><span class="p">.</span><span class="n">AmbientIntensity</span> <span class="o">=</span> <span class="mf">0.2f</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">10</span><span class="cl">  <span class="n">m_pointLight</span><span class="p">.</span><span class="n">DiffuseIntensity</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">11</span><span class="cl">  
</span></span><span class="line"><span class="ln">12</span><span class="cl">  <span class="n">m_LightingTech</span><span class="p">.</span><span class="n">SetPointLights</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m_pointLight</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">13</span><span class="cl">  
</span></span><span class="line"><span class="ln">14</span><span class="cl">  <span class="n">m_pGroundTex</span><span class="o">-&gt;</span><span class="n">Bind</span><span class="p">(</span><span class="n">GL_TEXTURE0</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">15</span><span class="cl">  
</span></span><span class="line"><span class="ln">16</span><span class="cl">  <span class="n">Pipeline</span> <span class="n">p</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">17</span><span class="cl">  <span class="n">p</span><span class="p">.</span><span class="n">SetPerspectiveProj</span><span class="p">(</span><span class="n">m_persProjInfo</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">18</span><span class="cl">  <span class="n">p</span><span class="p">.</span><span class="n">SetCamera</span><span class="p">(</span><span class="n">m_pGameCamera</span><span class="o">-&gt;</span><span class="n">GetPos</span><span class="p">(),</span> <span class="n">m_pGameCamera</span><span class="o">-&gt;</span><span class="n">GetTarget</span><span class="p">(),</span> <span class="n">m_pGameCamera</span><span class="o">-&gt;</span><span class="n">GetUp</span><span class="p">());</span>  
</span></span><span class="line"><span class="ln">19</span><span class="cl">  
</span></span><span class="line"><span class="ln">20</span><span class="cl">  <span class="n">m_boxOrientation</span><span class="p">.</span><span class="n">m_rotation</span> <span class="o">=</span> <span class="n">Vector3f</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">m_scale</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">21</span><span class="cl">  <span class="n">p</span><span class="p">.</span><span class="n">Orient</span><span class="p">(</span><span class="n">m_boxOrientation</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">22</span><span class="cl">  <span class="n">m_LightingTech</span><span class="p">.</span><span class="n">SetWVP</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">GetWVPTrans</span><span class="p">());</span>  
</span></span><span class="line"><span class="ln">23</span><span class="cl">  <span class="n">m_LightingTech</span><span class="p">.</span><span class="n">SetWorldMatrix</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">GetWorldTrans</span><span class="p">());</span>  
</span></span><span class="line"><span class="ln">24</span><span class="cl">  <span class="n">m_box</span><span class="p">.</span><span class="n">Render</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln">25</span><span class="cl">  
</span></span><span class="line"><span class="ln">26</span><span class="cl">  <span class="n">p</span><span class="p">.</span><span class="n">Orient</span><span class="p">(</span><span class="n">m_quadOrientation</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">27</span><span class="cl">  <span class="n">m_LightingTech</span><span class="p">.</span><span class="n">SetWVP</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">GetWVPTrans</span><span class="p">());</span>  
</span></span><span class="line"><span class="ln">28</span><span class="cl">  <span class="n">m_LightingTech</span><span class="p">.</span><span class="n">SetWorldMatrix</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">GetWorldTrans</span><span class="p">());</span>  
</span></span><span class="line"><span class="ln">29</span><span class="cl">  <span class="n">m_pGroundTex</span><span class="o">-&gt;</span><span class="n">Bind</span><span class="p">(</span><span class="n">COLOR_TEXTURE_UNIT</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">30</span><span class="cl">  <span class="n">m_quad</span><span class="p">.</span><span class="n">Render</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln">31</span><span class="cl">  
</span></span><span class="line"><span class="ln">32</span><span class="cl">  <span class="n">glDisable</span><span class="p">(</span><span class="n">GL_BLEND</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">33</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>The ambient pass helps us avoid completely black pixels that were dropped by the stencil test. In real life we usually don&rsquo;t see such extreme shadows so we add a bit of ambient light to all pixels. This is done by simply doing another lighting pass outside the boundaries of the stencil test. Couple of things to note here: we zero out the diffuse intensity (because that one is affected by the shadow) and we enable blending (to merge the results of the previous pass with this one). Now let&rsquo;s take a look at the shaders of the shadow volume technique.</p>
<p>(shadow_volume.vs)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">Position</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec2</span> <span class="n">TexCoord</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">Normal</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="n">out</span> <span class="n">vec3</span> <span class="n">PosL</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln">11</span><span class="cl">  <span class="n">PosL</span> <span class="o">=</span> <span class="n">Position</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>In the VS we simply forward the position as-is (in local space). The entire algorithm is implemented in the GS.</p>
<p>(shadow_volume.gs)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">  1</span><span class="cl"><span class="cp">#version 330
</span></span></span><span class="line"><span class="ln">  2</span><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="ln">  3</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">triangles_adjacency</span><span class="p">)</span> <span class="n">in</span><span class="p">;</span> <span class="c1">// six vertices in
</span></span></span><span class="line"><span class="ln">  4</span><span class="cl"><span class="c1"></span><span class="n">layout</span> <span class="p">(</span><span class="n">triangle_strip</span><span class="p">,</span> <span class="n">max_vertices</span> <span class="o">=</span> <span class="mi">18</span><span class="p">)</span> <span class="n">out</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">  5</span><span class="cl">
</span></span><span class="line"><span class="ln">  6</span><span class="cl"><span class="n">in</span> <span class="n">vec3</span> <span class="n">PosL</span><span class="p">[];</span> <span class="c1">// an array of 6 vertices (triangle with adjacency)
</span></span></span><span class="line"><span class="ln">  7</span><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="ln">  8</span><span class="cl"><span class="n">uniform</span> <span class="n">vec3</span> <span class="n">gLightPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">  9</span><span class="cl"><span class="n">uniform</span> <span class="n">mat4</span> <span class="n">gWVP</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 10</span><span class="cl">
</span></span><span class="line"><span class="ln"> 11</span><span class="cl"><span class="kt">float</span> <span class="n">EPSILON</span> <span class="o">=</span> <span class="mf">0.0001</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 12</span><span class="cl">
</span></span><span class="line"><span class="ln"> 13</span><span class="cl"><span class="c1">// Emit a quad using a triangle strip
</span></span></span><span class="line"><span class="ln"> 14</span><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">EmitQuad</span><span class="p">(</span><span class="n">vec3</span> <span class="n">StartVertex</span><span class="p">,</span> <span class="n">vec3</span> <span class="n">EndVertex</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 15</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln"> 16</span><span class="cl">  <span class="c1">// Vertex #1: the starting vertex (just a tiny bit below the original edge)  
</span></span></span><span class="line"><span class="ln"> 17</span><span class="cl"><span class="c1"></span>  <span class="n">vec3</span> <span class="n">LightDir</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">StartVertex</span> <span class="o">-</span> <span class="n">gLightPos</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 18</span><span class="cl">  <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">gWVP</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">((</span><span class="n">StartVertex</span> <span class="o">+</span> <span class="n">LightDir</span> <span class="o">*</span> <span class="n">EPSILON</span><span class="p">),</span> <span class="mf">1.0</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 19</span><span class="cl">  <span class="n">EmitVertex</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln"> 20</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 21</span><span class="cl">  <span class="c1">// Vertex #2: the starting vertex projected to infinity  
</span></span></span><span class="line"><span class="ln"> 22</span><span class="cl"><span class="c1"></span>  <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">gWVP</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">LightDir</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 23</span><span class="cl">  <span class="n">EmitVertex</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln"> 24</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 25</span><span class="cl">  <span class="c1">// Vertex #3: the ending vertex (just a tiny bit below the original edge)  
</span></span></span><span class="line"><span class="ln"> 26</span><span class="cl"><span class="c1"></span>  <span class="n">LightDir</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">EndVertex</span> <span class="o">-</span> <span class="n">gLightPos</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 27</span><span class="cl">  <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">gWVP</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">((</span><span class="n">EndVertex</span> <span class="o">+</span> <span class="n">LightDir</span> <span class="o">*</span> <span class="n">EPSILON</span><span class="p">),</span> <span class="mf">1.0</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 28</span><span class="cl">  <span class="n">EmitVertex</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln"> 29</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 30</span><span class="cl">  <span class="c1">// Vertex #4: the ending vertex projected to infinity  
</span></span></span><span class="line"><span class="ln"> 31</span><span class="cl"><span class="c1"></span>  <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">gWVP</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">LightDir</span> <span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 32</span><span class="cl">  <span class="n">EmitVertex</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln"> 33</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 34</span><span class="cl">  <span class="n">EndPrimitive</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 35</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln"> 36</span><span class="cl">
</span></span><span class="line"><span class="ln"> 37</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">(){</span>  
</span></span><span class="line"><span class="ln"> 38</span><span class="cl">  <span class="n">vec3</span> <span class="n">e1</span> <span class="o">=</span> <span class="n">WorldPos</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">WorldPos</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>  
</span></span><span class="line"><span class="ln"> 39</span><span class="cl">  <span class="n">vec3</span> <span class="n">e2</span> <span class="o">=</span> <span class="n">WorldPos</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">-</span> <span class="n">WorldPos</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>  
</span></span><span class="line"><span class="ln"> 40</span><span class="cl">  <span class="n">vec3</span> <span class="n">e3</span> <span class="o">=</span> <span class="n">WorldPos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">WorldPos</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>  
</span></span><span class="line"><span class="ln"> 41</span><span class="cl">  <span class="n">vec3</span> <span class="n">e4</span> <span class="o">=</span> <span class="n">WorldPos</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">WorldPos</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>  
</span></span><span class="line"><span class="ln"> 42</span><span class="cl">  <span class="n">vec3</span> <span class="n">e5</span> <span class="o">=</span> <span class="n">WorldPos</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">-</span> <span class="n">WorldPos</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>  
</span></span><span class="line"><span class="ln"> 43</span><span class="cl">  <span class="n">vec3</span> <span class="n">e6</span> <span class="o">=</span> <span class="n">WorldPos</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">-</span> <span class="n">WorldPos</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>  
</span></span><span class="line"><span class="ln"> 44</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 45</span><span class="cl">  <span class="n">vec3</span> <span class="n">Normal</span> <span class="o">=</span> <span class="n">cross</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span><span class="n">e2</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 46</span><span class="cl">  <span class="n">vec3</span> <span class="n">LightDir</span> <span class="o">=</span> <span class="n">gLightPos</span> <span class="o">-</span> <span class="n">WorldPos</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>  
</span></span><span class="line"><span class="ln"> 47</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 48</span><span class="cl">  <span class="c1">// Handle only light facing triangles  
</span></span></span><span class="line"><span class="ln"> 49</span><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">Normal</span><span class="p">,</span> <span class="n">LightDir</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>    
</span></span><span class="line"><span class="ln"> 50</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 51</span><span class="cl">    <span class="n">Normal</span> <span class="o">=</span> <span class="n">cross</span><span class="p">(</span><span class="n">e3</span><span class="p">,</span><span class="n">e1</span><span class="p">);</span>    
</span></span><span class="line"><span class="ln"> 52</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 53</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">Normal</span><span class="p">,</span> <span class="n">LightDir</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>      
</span></span><span class="line"><span class="ln"> 54</span><span class="cl">      <span class="n">vec3</span> <span class="n">StartVertex</span> <span class="o">=</span> <span class="n">WorldPos</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>      
</span></span><span class="line"><span class="ln"> 55</span><span class="cl">      <span class="n">vec3</span> <span class="n">EndVertex</span> <span class="o">=</span> <span class="n">WorldPos</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>      
</span></span><span class="line"><span class="ln"> 56</span><span class="cl">      <span class="n">EmitQuad</span><span class="p">(</span><span class="n">StartVertex</span><span class="p">,</span> <span class="n">EndVertex</span><span class="p">);</span>    
</span></span><span class="line"><span class="ln"> 57</span><span class="cl">    <span class="p">}</span>    
</span></span><span class="line"><span class="ln"> 58</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 59</span><span class="cl">    <span class="n">Normal</span> <span class="o">=</span> <span class="n">cross</span><span class="p">(</span><span class="n">e4</span><span class="p">,</span><span class="n">e5</span><span class="p">);</span>    
</span></span><span class="line"><span class="ln"> 60</span><span class="cl">    <span class="n">LightDir</span> <span class="o">=</span> <span class="n">gLightPos</span> <span class="o">-</span> <span class="n">WorldPos</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>    
</span></span><span class="line"><span class="ln"> 61</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 62</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">Normal</span><span class="p">,</span> <span class="n">LightDir</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>      
</span></span><span class="line"><span class="ln"> 63</span><span class="cl">      <span class="n">vec3</span> <span class="n">StartVertex</span> <span class="o">=</span> <span class="n">WorldPos</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>      
</span></span><span class="line"><span class="ln"> 64</span><span class="cl">      <span class="n">vec3</span> <span class="n">EndVertex</span> <span class="o">=</span> <span class="n">WorldPos</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>      
</span></span><span class="line"><span class="ln"> 65</span><span class="cl">      <span class="n">EmitQuad</span><span class="p">(</span><span class="n">StartVertex</span><span class="p">,</span> <span class="n">EndVertex</span><span class="p">);</span>    
</span></span><span class="line"><span class="ln"> 66</span><span class="cl">    <span class="p">}</span>    
</span></span><span class="line"><span class="ln"> 67</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 68</span><span class="cl">    <span class="n">Normal</span> <span class="o">=</span> <span class="n">cross</span><span class="p">(</span><span class="n">e2</span><span class="p">,</span><span class="n">e6</span><span class="p">);</span>    
</span></span><span class="line"><span class="ln"> 69</span><span class="cl">    <span class="n">LightDir</span> <span class="o">=</span> <span class="n">gLightPos</span> <span class="o">-</span> <span class="n">WorldPos</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>    
</span></span><span class="line"><span class="ln"> 70</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 71</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">Normal</span><span class="p">,</span> <span class="n">LightDir</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>      
</span></span><span class="line"><span class="ln"> 72</span><span class="cl">      <span class="n">vec3</span> <span class="n">StartVertex</span> <span class="o">=</span> <span class="n">WorldPos</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>      
</span></span><span class="line"><span class="ln"> 73</span><span class="cl">      <span class="n">vec3</span> <span class="n">EndVertex</span> <span class="o">=</span> <span class="n">WorldPos</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>      
</span></span><span class="line"><span class="ln"> 74</span><span class="cl">      <span class="n">EmitQuad</span><span class="p">(</span><span class="n">StartVertex</span><span class="p">,</span> <span class="n">EndVertex</span><span class="p">);</span>    
</span></span><span class="line"><span class="ln"> 75</span><span class="cl">    <span class="p">}</span>    
</span></span><span class="line"><span class="ln"> 76</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 77</span><span class="cl">    <span class="c1">// render the front cap    
</span></span></span><span class="line"><span class="ln"> 78</span><span class="cl"><span class="c1"></span>    <span class="n">LightDir</span> <span class="o">=</span> <span class="p">(</span><span class="n">normalize</span><span class="p">(</span><span class="n">PosL</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">gLightPos</span><span class="p">));</span>    
</span></span><span class="line"><span class="ln"> 79</span><span class="cl">    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">gWVP</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">((</span><span class="n">PosL</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">LightDir</span> <span class="o">*</span> <span class="n">EPSILON</span><span class="p">),</span> <span class="mf">1.0</span><span class="p">);</span>    
</span></span><span class="line"><span class="ln"> 80</span><span class="cl">    <span class="n">EmitVertex</span><span class="p">();</span>    
</span></span><span class="line"><span class="ln"> 81</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 82</span><span class="cl">    <span class="n">LightDir</span> <span class="o">=</span> <span class="p">(</span><span class="n">normalize</span><span class="p">(</span><span class="n">PosL</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">gLightPos</span><span class="p">));</span>    
</span></span><span class="line"><span class="ln"> 83</span><span class="cl">    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">gWVP</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">((</span><span class="n">PosL</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">LightDir</span> <span class="o">*</span> <span class="n">EPSILON</span><span class="p">),</span> <span class="mf">1.0</span><span class="p">);</span>    
</span></span><span class="line"><span class="ln"> 84</span><span class="cl">    <span class="n">EmitVertex</span><span class="p">();</span>    
</span></span><span class="line"><span class="ln"> 85</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 86</span><span class="cl">    <span class="n">LightDir</span> <span class="o">=</span> <span class="p">(</span><span class="n">normalize</span><span class="p">(</span><span class="n">PosL</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">-</span> <span class="n">gLightPos</span><span class="p">));</span>    
</span></span><span class="line"><span class="ln"> 87</span><span class="cl">    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">gWVP</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">((</span><span class="n">PosL</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="n">LightDir</span> <span class="o">*</span> <span class="n">EPSILON</span><span class="p">),</span> <span class="mf">1.0</span><span class="p">);</span>    
</span></span><span class="line"><span class="ln"> 88</span><span class="cl">    <span class="n">EmitVertex</span><span class="p">();</span>    
</span></span><span class="line"><span class="ln"> 89</span><span class="cl">    <span class="n">EndPrimitive</span><span class="p">();</span>    
</span></span><span class="line"><span class="ln"> 90</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 91</span><span class="cl">    <span class="c1">// render the back cap    
</span></span></span><span class="line"><span class="ln"> 92</span><span class="cl"><span class="c1"></span>    <span class="n">LightDir</span> <span class="o">=</span> <span class="n">PosL</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">gLightPos</span><span class="p">;</span>    
</span></span><span class="line"><span class="ln"> 93</span><span class="cl">    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">gWVP</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">LightDir</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>    
</span></span><span class="line"><span class="ln"> 94</span><span class="cl">    <span class="n">EmitVertex</span><span class="p">();</span>    
</span></span><span class="line"><span class="ln"> 95</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 96</span><span class="cl">    <span class="n">LightDir</span> <span class="o">=</span> <span class="n">PosL</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">-</span> <span class="n">gLightPos</span><span class="p">;</span>    
</span></span><span class="line"><span class="ln"> 97</span><span class="cl">    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">gWVP</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">LightDir</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>    
</span></span><span class="line"><span class="ln"> 98</span><span class="cl">    <span class="n">EmitVertex</span><span class="p">();</span>    
</span></span><span class="line"><span class="ln"> 99</span><span class="cl">    
</span></span><span class="line"><span class="ln">100</span><span class="cl">    <span class="n">LightDir</span> <span class="o">=</span> <span class="n">PosL</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">gLightPos</span><span class="p">;</span>    
</span></span><span class="line"><span class="ln">101</span><span class="cl">    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">gWVP</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">LightDir</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>    
</span></span><span class="line"><span class="ln">102</span><span class="cl">    <span class="n">EmitVertex</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln">103</span><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="ln">104</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>The GS starts in pretty much the same way as the silhouette shader in the sense that we only care about triangles that are light facing. When we detect a silhouette edge we extend a quad from it towards infinity (see below). Remember that the indices of the vertices of the original triangles are 0, 2 and 4 and the adjacent vertices are 1, 3, 5 (see picture in the previous tutorial). After we take care of the quads we emit the front and back caps. Note that for the front cap we don&rsquo;t use the original triangle as-is. Instead, we move it along the light vector by a very small amount (we do it by normalizing the light vector and multiplying it by a small epsilon). The reason is that due to floating point errors we might encounter bizarre corruptions where the volume hides the front cap. Moving the cap away from the volume by just a bit works around this problem.</p>
<p>For the back cap we simply project the original vertices into infinity along the light vector and emit them in reversed order.</p>
<p>In order to emit a quad from an edge we project both vertices to infinity along the light direction and generate a triangle strip. Note that the original vertices are moved along the light vector by a very small amount, to match the front cap.</p>
<p>It is critical that we set the maximum output vertices from the GS correctly (see &lsquo;max_vertices&rsquo; above). We have 3 vertices for the front cap, 3 for the back cap and 4 for each silhouette edge. When I was working on this tutorial I accidently set this value to 10 and got very strange corruptions. Make sure you don&rsquo;t make the same mistake&hellip;</p>

            <footer class="footline">
            </footer>
          </article>

        </div>
      </main>
    </div>
    <script src="../../../../../js/clipboard.min.js?1708235002" defer></script>
    <script src="../../../../../js/perfect-scrollbar.min.js?1708235002" defer></script>
    <script src="../../../../../js/theme.js?1708235002" defer></script>
  </body>
</html>
