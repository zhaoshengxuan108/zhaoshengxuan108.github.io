<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.122.0">
    <meta name="generator" content="Relearn 5.23.2+tip">
    <meta name="description" content="啊啊啊啊">
    <meta name="author" content="Sören Weber">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="https://example.com/images/hero.png">
    <meta name="twitter:title" content="Tutorial 37:Deferred Shading - Part 3 :: Hugo Relearn Theme">
    <meta name="twitter:description" content="Background Our implementation of deferred shading may seem ok right now, but when looking closely you can see a couple of problems that were mentioned at the end of the previous tutorial. The first one is that due to back face culling the light disappears as soon as the camera enters the light volume. The second problem is related to bounding the area effected by the light. The thing is that since we are selecting the pixels to do lighting calculations on by drawing up a sphere around the light source and that sphere gets projected to screen space before rasterization, every pixel covered by the sphere in screen space enters the calculation, even if it is very far away (and effectively outside the light volume).">
    <meta property="og:title" content="Tutorial 37:Deferred Shading - Part 3 :: Hugo Relearn Theme">
    <meta property="og:description" content="Background Our implementation of deferred shading may seem ok right now, but when looking closely you can see a couple of problems that were mentioned at the end of the previous tutorial. The first one is that due to back face culling the light disappears as soon as the camera enters the light volume. The second problem is related to bounding the area effected by the light. The thing is that since we are selecting the pixels to do lighting calculations on by drawing up a sphere around the light source and that sphere gets projected to screen space before rasterization, every pixel covered by the sphere in screen space enters the calculation, even if it is very far away (and effectively outside the light volume).">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://example.com/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_37_deferred_shading_-_part_3/index.html">
    <meta property="og:image" content="https://example.com/images/hero.png">
    <meta property="article:section" content="OGL dev 教程 :: Hugo Relearn Theme">
    <meta property="og:site_name" content="Hugo Relearn Theme">
    <title>Tutorial 37:Deferred Shading - Part 3 :: Hugo Relearn Theme</title>
    <link href="https://example.com/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_37_deferred_shading_-_part_3/index.html" rel="canonical" type="text/html" title="Tutorial 37:Deferred Shading - Part 3 :: Hugo Relearn Theme">
    <link href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_37_deferred_shading_-_part_3/index.xml" rel="alternate" type="application/rss+xml" title="Tutorial 37:Deferred Shading - Part 3 :: Hugo Relearn Theme"><link rel="icon" href="../../../../../images/favicon.ico">
    <!-- https://github.com/filamentgroup/loadCSS/blob/master/README.md#how-to-use -->
    <link href="../../../../../css/fontawesome-all.min.css?1708235103" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../../../../../css/fontawesome-all.min.css?1708235103" rel="stylesheet"></noscript>
    <link href="../../../../../css/nucleus.css?1708235103" rel="stylesheet">
    <link href="../../../../../css/auto-complete.css?1708235103" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../../../../../css/auto-complete.css?1708235103" rel="stylesheet"></noscript>
    <link href="../../../../../css/perfect-scrollbar.min.css?1708235103" rel="stylesheet">
    <link href="../../../../../css/fonts.css?1708235103" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../../../../../css/fonts.css?1708235103" rel="stylesheet"></noscript>
    <link href="../../../../../css/theme.css?1708235103" rel="stylesheet">
    <link href="../../../../../css/theme-auto.css?1708235103" rel="stylesheet" id="R-variant-style">
    <link href="../../../../../css/variant.css?1708235103" rel="stylesheet">
    <link href="../../../../../css/print.css?1708235103" rel="stylesheet" media="print">
    <link href="../../../../../css/format-print.css?1708235103" rel="stylesheet">
    <link href="../../../../../css/ie.css?1708235103" rel="stylesheet">
    <script src="../../../../../js/url.js?1708235103"></script>
    <script src="../../../../../js/variant.js?1708235103"></script>
    <script>
      // hack to let hugo tell us how to get to the root when using relativeURLs, it needs to be called *url= for it to do its magic:
      // https://github.com/gohugoio/hugo/blob/145b3fcce35fbac25c7033c91c1b7ae6d1179da8/transform/urlreplacers/absurlreplacer.go#L72
      window.index_js_url="../../../../../index.search.js";
      var root_url="../../../../../";
      var baseUri=root_url.replace(/\/$/, '');
      window.relearn = window.relearn || {};
      window.relearn.baseUriFull='https:\/\/example.com/';
      // variant stuff
      window.variants && variants.init( [ 'auto', 'relearn-light', 'relearn-dark', 'zen-light', 'zen-dark', 'neon', 'learn', 'blue', 'green', 'red' ] );
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
    </script>
    <style>
      #R-body img.bg-white {
        background-color: white;
      }
    </style>
  </head>
  <body class="mobile-support print" data-url="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_37_deferred_shading_-_part_3/index.html">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide">
              <button class="topbar-control" onclick="toggleNav()" type="button" title="Menu (CTRL&#43;ALT&#43;n)">
                <i class="fa-fw fas fa-bars"></i>
              </button>
            </div>
          </div>
          <ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype="http://schema.org/BreadcrumbList"><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../index.html"><span itemprop="name">主页</span></a><meta itemprop="position" content="1">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../computer_graphics/index.html"><span itemprop="name">计算机图形学</span></a><meta itemprop="position" content="2">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../computer_graphics/classic_tutorial/index.html"><span itemprop="name">经典教程</span></a><meta itemprop="position" content="3">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/index.html"><span itemprop="name">OpenGL教程</span></a><meta itemprop="position" content="4">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/index.html"><span itemprop="name">OGL dev 教程</span></a><meta itemprop="position" content="5">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><span itemprop="name">Tutorial 37:Deferred Shading - Part 3</span><meta itemprop="position" content="6"></li>
          </ol>
          <div class="topbar-area topbar-area-end" data-area="end">
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable default" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="default">
            <header class="headline">
            </header>
<h1 id="tutorial-37deferred-shading---part-3">Tutorial 37:Deferred Shading - Part 3</h1>

<h3 id="background">Background</h3>
<p>Our implementation of deferred shading may seem ok right now, but when looking closely you can see a couple of problems that were mentioned at the end of the previous tutorial. The first one is that due to back face culling the light disappears as soon as the camera enters the light volume. The second problem is related to bounding the area effected by the light. The thing is that since we are selecting the pixels to do lighting calculations on by drawing up a sphere around the light source and that sphere gets projected to screen space before rasterization, every pixel covered by the sphere in screen space enters the calculation, even if it is very far away (and effectively outside the light volume).</p>
<p>What helps us solve these problems is a feature of OpenGL known as the <em>Stencil Buffer</em>. The stencil buffer lives side by side with the color and depth buffer and shares their resolution (for every pixel in the color buffer there is a pixel in the stencil buffer). The type of a pixel in the stencil buffer is an integer and it is usually one byte in width. The stencil buffer serves roughly the same purpose as stencil paper in the real world. A stencil paper is usually used to print letters or any other type of design by having the desired pattern cut into the paper itself. In OpenGL the stencil buffer can be used to limit the pixels where the pixel shader is executed.</p>
<p>The stencil buffer is connected with the <em>Stencil Test</em> which is a per-fragment operation we are seeing here for the first time. In a similar manner to the depth test, the stencil test can be used to discard pixels prior to pixel shader execution. It works by comparing the value at the current pixel location in the stencil buffer with a reference value. There are several comparison functions available:</p>
<ul>
<li>Always pass</li>
<li>Always fail</li>
<li>Less/greater than</li>
<li>Less/greater than or equal</li>
<li>Equal</li>
<li>Not equal</li>
</ul>
<p>Based on the result of <strong>both</strong> the stencil test as well as the depth test you can define an action known as the stencil operation on the stored stencil value. The following operations are available:</p>
<ul>
<li>Keep the stencil value unchanged</li>
<li>Replace the stencil value with zero</li>
<li>Increment/decrement the stencil value</li>
<li>Invert the bits of the stencil value</li>
</ul>
<p>You can configure different operations for each of the following cases:</p>
<ul>
<li>Stencil test failure</li>
<li>Depth test failure</li>
<li>depth test success</li>
</ul>
<p>In addition, you can configure different stencil tests and stencil operations for the two faces of each polygon. For example, you can set the comparison function for the front face to be &lsquo;Less Than&rsquo; with a reference value of 3 while the comparison function for the back face is &lsquo;Equal&rsquo; with a reference value of 5. The same goes for the stencil operation.</p>
<p>This, in a nutshell, is the stencil test. So how can it help us solve the above problems? Well, we are going to take advantage of the ability to increment and decrement the stencil value based on the result of the depth test on the front and back faces of the polygons. Consider the following picture:</p>
<p><a href="#R-image-e6648801ac9b25deea1a6eda33f853cd" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_37_deferred_shading_-_part_3/../assets/light_volume.jpeg" alt="img" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-e6648801ac9b25deea1a6eda33f853cd"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_37_deferred_shading_-_part_3/../assets/light_volume.jpeg" alt="img" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>The picture shows 3 objects - A, B and C and a yellow sphere that is centered on a light source. The sphere gets projected on the virtual screen and according to the previous tutorial we need to render the light volume and for each rasterized pixel calculate the lighting effect. It is very simple to see that while the entire red line (in reality this is a rectangle because we are looking down at the scene) will reach the fragment shader only a very small subset of it is really relevant because only object B is inside the light volume. Both A and C are outside of it and there are many pixels in the G buffer that don&rsquo;t contain any data at all because there is no object along the way.</p>
<p>The way we are going to use the stencil buffer to limit the lighting calculations only to the pixels covered by object B is based on the same concept used in a shadowing technique known as <em>Stencil Shadow Volumes</em> (which will be covered by dedicated tutorial sometime in the future&hellip;). Our technique is based on the following interesting property which is evident in the picture above: when we look at the sphere from the camera point of view both its front and back face polygons are behind object A, the same polygons are infront of object C but in the case of object B the front face polygons are infront of it but the back face polygons are behind it. Let&rsquo;s see how we can take advantage of it in the context of the stencil test.</p>
<p>The techique works as follows:</p>
<ol>
<li>Render the objects as usual into the G buffer so that the depth buffer will be properly populated.</li>
<li>Disable writing into the depth buffer. From now on we want it to be read-only</li>
<li>Disable back face culling. We want the rasterizer to process all polygons of the sphere.</li>
<li>Set the stencil test to always succeed. What we really care about is the stencil operation.</li>
<li>Configure the stencil operation for the <strong>back</strong> facing polygons to <strong>increment</strong> the value in the stencil buffer when the depth test fails but to keep it unchanged when either depth test or stencil test succeed.</li>
<li>Configure the stencil operation for the <strong>front</strong> facing polygons to <strong>decrement</strong> the value in the stencil buffer when the depth test fails but to keep it unchanged when either depth test or stencil test succeed.</li>
<li>Render the light sphere.</li>
</ol>
<p>Let&rsquo;s see the effect of the above scheme on the picture above:</p>
<p><a href="#R-image-31dadc2a0228b3c0c6b675a5f4da0add" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_37_deferred_shading_-_part_3/../assets/light_volume1.jpeg" alt="img" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-31dadc2a0228b3c0c6b675a5f4da0add"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_37_deferred_shading_-_part_3/../assets/light_volume1.jpeg" alt="img" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>The picture shows three example vectors from the camera to the screen that cross both the sphere and one of the objects. Each vector is representative for all pixels covered by that particular object. Since the geometry was already rendered and the depth buffer is populated we can check what happens to the depth test when the vector goes through the front and back pixels of the sphere and update the stencil buffer accordingly. In the case of object A both the front and the back pixels fail the depth test. The back face pixel increments the stencil value but this is nullified by the front pixel which decrements it. In the case of object C both the front and back pixels win the depth test so the stencil value remains unchanged. Now pay attention to what happens to object B - the front face pixel wins the depth test but the back face pixel fails it. This means that we increment the value by one.</p>
<p>This is the core of the technique. We render the geometry into the G buffer, setup the stencil test/operation according to the above and then render the bounding sphere of each light into the stencil buffer. The peculiar stencil setup that we saw guarantees that only the pixels in the stencil buffer covered by objects <strong>inside</strong> the bounding sphere will have a value greater than zero. We call this step the <em>Stencil Pass</em> and since we are only interested in writing into the stencil buffer we use a null fragment shader. Next we render the sphere again using the lighting fragment shader but this time we configure the stencil test to pass only when the stencil value of the pixel is different from zero. All the pixels of objects outside the light volume will fail the stencil test and we will calculate lighting on a very small subset of the pixels that are actually covered by the light sphere.</p>
<p>Let&rsquo;s see another example, this time with more light sources:</p>
<p><a href="#R-image-0efafb4bdce5f1f17ac3b4ec4632e7bf" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_37_deferred_shading_-_part_3/../assets/light_volume2.jpeg" alt="img" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-0efafb4bdce5f1f17ac3b4ec4632e7bf"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_37_deferred_shading_-_part_3/../assets/light_volume2.jpeg" alt="img" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>As you can see, the logic still works (the case when the camera is inside the light source is left as an exercise for the reader).</p>
<p>One last note about the stencil buffer - it is not a separate buffer but actually part of the depth buffer. You can have depth/stencil buffer with 24 or 32 bits for depth and 8 bits for stencil in each pixel.</p>
<h3 id="source-walkthru">Source walkthru</h3>
<p>(tutorial37.cpp:149)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">virtual</span> <span class="kt">void</span> <span class="nf">RenderSceneCB</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  <span class="n">CalcFPS</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  <span class="n">m_scale</span> <span class="o">+=</span> <span class="mf">0.05f</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  <span class="n">m_pGameCamera</span><span class="o">-&gt;</span><span class="n">OnRender</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  <span class="n">m_gbuffer</span><span class="p">.</span><span class="n">StartFrame</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">  
</span></span><span class="line"><span class="ln">11</span><span class="cl">  <span class="n">DSGeometryPass</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln">12</span><span class="cl">  
</span></span><span class="line"><span class="ln">13</span><span class="cl">  <span class="c1">// We need stencil to be enabled in the stencil pass to get the stencil buffer  
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="c1"></span>  <span class="c1">// updated and we also need it in the light pass because we render the light  
</span></span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="c1"></span>  <span class="c1">// only if the stencil passes.  
</span></span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="c1"></span>  <span class="n">glEnable</span><span class="p">(</span><span class="n">GL_STENCIL_TEST</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">
</span></span><span class="line"><span class="ln">18</span><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE_IN_ELEMENTS</span><span class="p">(</span><span class="n">m_pointLight</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">    <span class="n">DSStencilPass</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">    <span class="n">DSPointLightPass</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">
</span></span><span class="line"><span class="ln">23</span><span class="cl">  <span class="c1">// The directional light does not need a stencil test because its volume
</span></span></span><span class="line"><span class="ln">24</span><span class="cl"><span class="c1"></span>  <span class="c1">// is unlimited and the final pass simply copies the texture.
</span></span></span><span class="line"><span class="ln">25</span><span class="cl"><span class="c1"></span>  <span class="n">glDisable</span><span class="p">(</span><span class="n">GL_STENCIL_TEST</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl">  
</span></span><span class="line"><span class="ln">27</span><span class="cl">  <span class="n">DSDirectionalLightPass</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln">28</span><span class="cl">  
</span></span><span class="line"><span class="ln">29</span><span class="cl">  <span class="n">DSFinalPass</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">30</span><span class="cl">  
</span></span><span class="line"><span class="ln">31</span><span class="cl">  <span class="n">RenderFPS</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln">32</span><span class="cl">  
</span></span><span class="line"><span class="ln">33</span><span class="cl">  <span class="n">glutSwapBuffers</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">34</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>The piece of code above is the main render function with changes from the previous tutorial marked in bold. The first change is the call to the StartFrame() API of the GBuffer class. The GBuffer becomes quite complex in this tutorial and needs to be informed about the start of a new frame (changes to this class will be reviewed later but for now we&rsquo;ll just mention that we are not rendering directly to the screen but to an intermediate buffer which will be copied to the main FBO). Next we enable the stencil test because we need it for the two upcoming passes. Now comes the most important change - for each light we do a stencil pass (which marks the relevant pixels) followed by a point light pass which depends on the stencil value. The reason why we need to handle each light source separately is because once a stencil value becomes greater than zero due to one of the lights we cannot tell whether another light source which also overlaps the same pixel is relevant or not.</p>
<p>After we finish with all the point lights we disable the stencil test because for a directional light we need to process all pixels anyway. The last change in the function is the final pass which is also a new pass required due to the complexity of the GBuffer class.</p>
<p>(tutorial37.cpp:185)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="nf">DSGeometryPass</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  <span class="n">m_DSGeomPassTech</span><span class="p">.</span><span class="n">Enable</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  <span class="n">m_gbuffer</span><span class="p">.</span><span class="n">BindForGeomPass</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  <span class="c1">// Only the geometry pass updates the depth buffer  
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="c1"></span>  <span class="n">glDepthMask</span><span class="p">(</span><span class="n">GL_TRUE</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  
</span></span><span class="line"><span class="ln">10</span><span class="cl">  <span class="n">glClear</span><span class="p">(</span><span class="n">GL_COLOR_BUFFER_BIT</span> <span class="o">|</span> <span class="n">GL_DEPTH_BUFFER_BIT</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">11</span><span class="cl">  
</span></span><span class="line"><span class="ln">12</span><span class="cl">  <span class="n">glEnable</span><span class="p">(</span><span class="n">GL_DEPTH_TEST</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">13</span><span class="cl">  
</span></span><span class="line"><span class="ln">14</span><span class="cl">  <span class="n">Pipeline</span> <span class="n">p</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">15</span><span class="cl">  <span class="n">p</span><span class="p">.</span><span class="n">SetCamera</span><span class="p">(</span><span class="n">m_pGameCamera</span><span class="o">-&gt;</span><span class="n">GetPos</span><span class="p">(),</span> <span class="n">m_pGameCamera</span><span class="o">-&gt;</span><span class="n">GetTarget</span><span class="p">(),</span> <span class="n">m_pGameCamera</span><span class="o">-&gt;</span><span class="n">GetUp</span><span class="p">());</span>  
</span></span><span class="line"><span class="ln">16</span><span class="cl">  <span class="n">p</span><span class="p">.</span><span class="n">SetPerspectiveProj</span><span class="p">(</span><span class="n">m_persProjInfo</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">17</span><span class="cl">  <span class="n">p</span><span class="p">.</span><span class="n">Rotate</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="n">m_scale</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">18</span><span class="cl">  
</span></span><span class="line"><span class="ln">19</span><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE_IN_ELEMENTS</span><span class="p">(</span><span class="n">m_boxPositions</span><span class="p">)</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>    
</span></span><span class="line"><span class="ln">20</span><span class="cl">    <span class="n">p</span><span class="p">.</span><span class="n">WorldPos</span><span class="p">(</span><span class="n">m_boxPositions</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>    
</span></span><span class="line"><span class="ln">21</span><span class="cl">    <span class="n">m_DSGeomPassTech</span><span class="p">.</span><span class="n">SetWVP</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">GetWVPTrans</span><span class="p">());</span>    
</span></span><span class="line"><span class="ln">22</span><span class="cl">    <span class="n">m_DSGeomPassTech</span><span class="p">.</span><span class="n">SetWorldMatrix</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">GetWorldTrans</span><span class="p">());</span>    
</span></span><span class="line"><span class="ln">23</span><span class="cl">    <span class="n">m_box</span><span class="p">.</span><span class="n">Render</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln">24</span><span class="cl">  <span class="p">}</span>  
</span></span><span class="line"><span class="ln">25</span><span class="cl">  
</span></span><span class="line"><span class="ln">26</span><span class="cl">  <span class="c1">// When we get here the depth buffer is already populated and the stencil pass  
</span></span></span><span class="line"><span class="ln">27</span><span class="cl"><span class="c1"></span>  <span class="c1">// depends on it, but it does not write to it.  
</span></span></span><span class="line"><span class="ln">28</span><span class="cl"><span class="c1"></span>  <span class="n">glDepthMask</span><span class="p">(</span><span class="n">GL_FALSE</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">29</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>There are minor changes in the geometry pass. The function GBuffer::BindForWriting() has been renamed GBuffer::BindForGeomPass(). In addition, those of you with a sharp eye will notice that we no longer disabling blending and the depth test. Both of these items are now manipulated elsewhere.</p>
<p>(tutorial37.cpp:215)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="nf">DSStencilPass</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">PointLightIndex</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  <span class="n">m_nullTech</span><span class="p">.</span><span class="n">Enable</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  <span class="c1">// Disable color/depth write and enable stencil  
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="c1"></span>  <span class="n">m_gbuffer</span><span class="p">.</span><span class="n">BindForStencilPass</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">  <span class="n">glEnable</span><span class="p">(</span><span class="n">GL_DEPTH_TEST</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  
</span></span><span class="line"><span class="ln">10</span><span class="cl">  <span class="n">glDisable</span><span class="p">(</span><span class="n">GL_CULL_FACE</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">11</span><span class="cl">  
</span></span><span class="line"><span class="ln">12</span><span class="cl">  <span class="n">glClear</span><span class="p">(</span><span class="n">GL_STENCIL_BUFFER_BIT</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">13</span><span class="cl">  
</span></span><span class="line"><span class="ln">14</span><span class="cl">  <span class="c1">// We need the stencil test to be enabled but we want it  
</span></span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="c1"></span>  <span class="c1">// to succeed always. Only the depth test matters.  
</span></span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="c1"></span>  <span class="n">glStencilFunc</span><span class="p">(</span><span class="n">GL_ALWAYS</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">17</span><span class="cl">  
</span></span><span class="line"><span class="ln">18</span><span class="cl">  <span class="n">glStencilOpSeparate</span><span class="p">(</span><span class="n">GL_BACK</span><span class="p">,</span> <span class="n">GL_KEEP</span><span class="p">,</span> <span class="n">GL_INCR_WRAP</span><span class="p">,</span> <span class="n">GL_KEEP</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">19</span><span class="cl">  <span class="n">glStencilOpSeparate</span><span class="p">(</span><span class="n">GL_FRONT</span><span class="p">,</span> <span class="n">GL_KEEP</span><span class="p">,</span> <span class="n">GL_DECR_WRAP</span><span class="p">,</span> <span class="n">GL_KEEP</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">20</span><span class="cl">  
</span></span><span class="line"><span class="ln">21</span><span class="cl">  <span class="n">Pipeline</span> <span class="n">p</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">22</span><span class="cl">  <span class="n">p</span><span class="p">.</span><span class="n">WorldPos</span><span class="p">(</span><span class="n">m_pointLight</span><span class="p">[</span><span class="n">PointLightIndex</span><span class="p">].</span><span class="n">Position</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">23</span><span class="cl">  <span class="kt">float</span> <span class="n">BBoxScale</span> <span class="o">=</span> <span class="n">CalcPointLightBSphere</span><span class="p">(</span><span class="n">m_pointLight</span><span class="p">[</span><span class="n">PointLightIndex</span><span class="p">].</span><span class="n">Color</span><span class="p">,</span>    
</span></span><span class="line"><span class="ln">24</span><span class="cl">                                     <span class="n">m_pointLight</span><span class="p">[</span><span class="n">PointLightIndex</span><span class="p">].</span><span class="n">DiffuseIntensity</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">25</span><span class="cl">  
</span></span><span class="line"><span class="ln">26</span><span class="cl">  <span class="n">p</span><span class="p">.</span><span class="n">Scale</span><span class="p">(</span><span class="n">BBoxScale</span><span class="p">,</span> <span class="n">BBoxScale</span><span class="p">,</span> <span class="n">BBoxScale</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">27</span><span class="cl">  <span class="n">p</span><span class="p">.</span><span class="n">SetCamera</span><span class="p">(</span><span class="n">m_pGameCamera</span><span class="o">-&gt;</span><span class="n">GetPos</span><span class="p">(),</span> <span class="n">m_pGameCamera</span><span class="o">-&gt;</span><span class="n">GetTarget</span><span class="p">(),</span> <span class="n">m_pGameCamera</span><span class="o">-&gt;</span><span class="n">GetUp</span><span class="p">());</span>  
</span></span><span class="line"><span class="ln">28</span><span class="cl">  <span class="n">p</span><span class="p">.</span><span class="n">SetPerspectiveProj</span><span class="p">(</span><span class="n">m_persProjInfo</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">29</span><span class="cl">  
</span></span><span class="line"><span class="ln">30</span><span class="cl">  <span class="n">m_nullTech</span><span class="p">.</span><span class="n">SetWVP</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">GetWVPTrans</span><span class="p">());</span>  
</span></span><span class="line"><span class="ln">31</span><span class="cl">  <span class="n">m_bsphere</span><span class="p">.</span><span class="n">Render</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">32</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>Now comes the real meat - the stencil pass. Let&rsquo;s review it step by step. We start by enabling the null technique. This is an extremely simple technique. The VS includes only a transformation of the position vector by the WVP matrix and the FS is empty. We don&rsquo;t need anything in the FS because we are not updating the color buffer at all. Only the stencil buffer is updated so we just need something to drive rasterization. We bind the GBuffer for this pass and enable the depth test. We will later see that the point light pass disable the depth test but we need it here because the stencil operation depends on it. Next we disable culling because we want to process both the front and back faces of each polygon. After that we clear the stencil buffer and setup the stencil test to always pass and the stencil operation according to the description in the background section. Everything after that is as usual - we render the bounding sphere based on the light params. When we are done the stencil buffer contains positive values only in the pixels of objects inside the light volume. We can now do lighting calculations.</p>
<p>(tutorial37.cpp:246)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="nf">DSPointLightPass</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">PointLightIndex</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  <span class="n">m_gbuffer</span><span class="p">.</span><span class="n">BindForLightPass</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  <span class="n">m_DSPointLightPassTech</span><span class="p">.</span><span class="n">Enable</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">  <span class="n">m_DSPointLightPassTech</span><span class="p">.</span><span class="n">SetEyeWorldPos</span><span class="p">(</span><span class="n">m_pGameCamera</span><span class="o">-&gt;</span><span class="n">GetPos</span><span class="p">());</span>  
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">  <span class="n">glStencilFunc</span><span class="p">(</span><span class="n">GL_NOTEQUAL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  
</span></span><span class="line"><span class="ln">10</span><span class="cl">  <span class="n">glDisable</span><span class="p">(</span><span class="n">GL_DEPTH_TEST</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">11</span><span class="cl">  <span class="n">glEnable</span><span class="p">(</span><span class="n">GL_BLEND</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">12</span><span class="cl">  <span class="n">glBlendEquation</span><span class="p">(</span><span class="n">GL_FUNC_ADD</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">13</span><span class="cl">  <span class="n">glBlendFunc</span><span class="p">(</span><span class="n">GL_ONE</span><span class="p">,</span> <span class="n">GL_ONE</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">14</span><span class="cl">  
</span></span><span class="line"><span class="ln">15</span><span class="cl">  <span class="n">glEnable</span><span class="p">(</span><span class="n">GL_CULL_FACE</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">16</span><span class="cl">  <span class="n">glCullFace</span><span class="p">(</span><span class="n">GL_FRONT</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">17</span><span class="cl">  
</span></span><span class="line"><span class="ln">18</span><span class="cl">  <span class="n">Pipeline</span> <span class="n">p</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">19</span><span class="cl">  <span class="n">p</span><span class="p">.</span><span class="n">WorldPos</span><span class="p">(</span><span class="n">m_pointLight</span><span class="p">[</span><span class="n">PointLightIndex</span><span class="p">].</span><span class="n">Position</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">20</span><span class="cl">  <span class="kt">float</span> <span class="n">BBoxScale</span> <span class="o">=</span> <span class="n">CalcPointLightBSphere</span><span class="p">(</span><span class="n">m_pointLight</span><span class="p">[</span><span class="n">PointLightIndex</span><span class="p">].</span><span class="n">Color</span><span class="p">,</span>                      <span class="n">m_pointLight</span><span class="p">[</span><span class="n">PointLightIndex</span><span class="p">].</span><span class="n">DiffuseIntensity</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">21</span><span class="cl">  
</span></span><span class="line"><span class="ln">22</span><span class="cl">  <span class="n">p</span><span class="p">.</span><span class="n">Scale</span><span class="p">(</span><span class="n">BBoxScale</span><span class="p">,</span> <span class="n">BBoxScale</span><span class="p">,</span> <span class="n">BBoxScale</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">23</span><span class="cl">  <span class="n">p</span><span class="p">.</span><span class="n">SetCamera</span><span class="p">(</span><span class="n">m_pGameCamera</span><span class="o">-&gt;</span><span class="n">GetPos</span><span class="p">(),</span> <span class="n">m_pGameCamera</span><span class="o">-&gt;</span><span class="n">GetTarget</span><span class="p">(),</span> <span class="n">m_pGameCamera</span><span class="o">-&gt;</span><span class="n">GetUp</span><span class="p">());</span>  
</span></span><span class="line"><span class="ln">24</span><span class="cl">  <span class="n">p</span><span class="p">.</span><span class="n">SetPerspectiveProj</span><span class="p">(</span><span class="n">m_persProjInfo</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">25</span><span class="cl">  <span class="n">m_DSPointLightPassTech</span><span class="p">.</span><span class="n">SetWVP</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">GetWVPTrans</span><span class="p">());</span>  
</span></span><span class="line"><span class="ln">26</span><span class="cl">  <span class="n">m_DSPointLightPassTech</span><span class="p">.</span><span class="n">SetPointLight</span><span class="p">(</span><span class="n">m_pointLight</span><span class="p">[</span><span class="n">PointLightIndex</span><span class="p">]);</span>  
</span></span><span class="line"><span class="ln">27</span><span class="cl">  <span class="n">m_bsphere</span><span class="p">.</span><span class="n">Render</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln">28</span><span class="cl">  <span class="n">glCullFace</span><span class="p">(</span><span class="n">GL_BACK</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">29</span><span class="cl">  
</span></span><span class="line"><span class="ln">30</span><span class="cl">  <span class="n">glDisable</span><span class="p">(</span><span class="n">GL_BLEND</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">31</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>Same as the other passes the point light pass starts by setting up the G buffer for what it needs (by calling GBuffer::BindForLightPass()). It sets up the stencil test to pass when the stencil value is not equal to zero. After that it disables the depth test (because we don&rsquo;t need it and on some GPUs we may get some performance by disabling it) and enable blending as usual. The next step is very important - we enable culling of the front face polygons. The reason why we do that is because the camera may be inside the light volume and if we do back face culling as we normally do we will not see the light until we exit its volume. After that we render the bounding sphere as usual.</p>
<p>The directional light pass is pretty much the same as before so we won&rsquo;t review it.</p>
<p>(tutorial37.cpp:296)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">void</span> <span class="nf">DSFinalPass</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln">3</span><span class="cl">  <span class="n">m_gbuffer</span><span class="p">.</span><span class="n">BindForFinalPass</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln">4</span><span class="cl">  <span class="n">glBlitFramebuffer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">WINDOW_WIDTH</span><span class="p">,</span> <span class="n">WINDOW_HEIGHT</span><span class="p">,</span>           
</span></span><span class="line"><span class="ln">5</span><span class="cl">                    <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">WINDOW_WIDTH</span><span class="p">,</span> <span class="n">WINDOW_HEIGHT</span><span class="p">,</span> <span class="n">GL_COLOR_BUFFER_BIT</span><span class="p">,</span> 
</span></span><span class="line"><span class="ln">6</span><span class="cl">                    <span class="n">GL_LINEAR</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>In the final pass we blit from the color buffer inside the G Buffer into the screen. This is a good place to discuss why we added an intermediate color buffer in the G Buffer instead of rendering directly to the screen. The thing is that our G Buffer combines as a target the buffers for the attributes with the depth/stencil buffer. When we run the point light pass we setup the stencil stuff and we need to use the values from the depth buffer. Here we have a problem - if we render into the default FBO we won&rsquo;t have access to the depth buffer from the G Buffer. But the G Buffer must have its own depth buffer because when we render into its FBO we don&rsquo;t have access to the depth buffer from the default FBO. Therefore, the solution is to add to the G Buffer FBO a color buffer to render into and in the final pass blit it to the default FBO color buffer. This is the final pass above.</p>
<p>(gbuffer.h:23)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">class</span> <span class="nc">GBuffer</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="k">public</span><span class="o">:</span>  
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  <span class="k">enum</span> <span class="nc">GBUFFER_TEXTURE_TYPE</span> <span class="p">{</span>    
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="n">GBUFFER_TEXTURE_TYPE_POSITION</span><span class="p">,</span>    
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="n">GBUFFER_TEXTURE_TYPE_DIFFUSE</span><span class="p">,</span>    
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="n">GBUFFER_TEXTURE_TYPE_NORMAL</span><span class="p">,</span>    
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="n">GBUFFER_NUM_TEXTURES</span>  
</span></span><span class="line"><span class="ln">10</span><span class="cl">  <span class="p">};</span>  
</span></span><span class="line"><span class="ln">11</span><span class="cl">  
</span></span><span class="line"><span class="ln">12</span><span class="cl">  <span class="n">GBuffer</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln">13</span><span class="cl">  
</span></span><span class="line"><span class="ln">14</span><span class="cl">  <span class="o">~</span><span class="n">GBuffer</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln">15</span><span class="cl">  
</span></span><span class="line"><span class="ln">16</span><span class="cl">  <span class="kt">bool</span> <span class="nf">Init</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">WindowWidth</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">WindowHeight</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">17</span><span class="cl">  
</span></span><span class="line"><span class="ln">18</span><span class="cl">  <span class="kt">void</span> <span class="nf">StartFrame</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">  <span class="kt">void</span> <span class="nf">BindForGeomPass</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">  <span class="kt">void</span> <span class="nf">BindForStencilPass</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">  <span class="kt">void</span> <span class="nf">BindForLightPass</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">  <span class="kt">void</span> <span class="nf">BindForFinalPass</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">  
</span></span><span class="line"><span class="ln">24</span><span class="cl"><span class="k">private</span><span class="o">:</span>  
</span></span><span class="line"><span class="ln">25</span><span class="cl">  
</span></span><span class="line"><span class="ln">26</span><span class="cl">  <span class="n">GLuint</span> <span class="n">m_fbo</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">27</span><span class="cl">  <span class="n">GLuint</span> <span class="n">m_textures</span><span class="p">[</span><span class="n">GBUFFER_NUM_TEXTURES</span><span class="p">];</span>  
</span></span><span class="line"><span class="ln">28</span><span class="cl">  <span class="n">GLuint</span> <span class="n">m_depthTexture</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">29</span><span class="cl">  <span class="n">GLuint</span> <span class="n">m_finalTexture</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">30</span><span class="cl"><span class="p">};</span></span></span></code></pre></div><p>We&rsquo;ve added a final texture to the GBuffer class for the color and reshuffled the API quite a bit since the last tutorial. Let&rsquo;s review the changes.</p>
<p>(gbuffer.cpp:52)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">bool</span> <span class="n">GBuffer</span><span class="o">::</span><span class="n">Init</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">WindowWidth</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">WindowHeight</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  <span class="p">...</span>  
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  <span class="n">glGenTextures</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m_finalTexture</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  <span class="p">...</span>  
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  <span class="c1">// depth  
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1"></span>  <span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">m_depthTexture</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">11</span><span class="cl">  <span class="n">glTexImage2D</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_DEPTH32F_STENCIL8</span><span class="p">,</span> <span class="n">WindowWidth</span><span class="p">,</span> <span class="n">WindowHeight</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> 
</span></span><span class="line"><span class="ln">12</span><span class="cl">               <span class="n">GL_DEPTH_STENCIL</span><span class="p">,</span>         
</span></span><span class="line"><span class="ln">13</span><span class="cl">               <span class="n">GL_FLOAT_32_UNSIGNED_INT_24_8_REV</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">14</span><span class="cl">  <span class="n">glFramebufferTexture2D</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">GL_DEPTH_STENCIL_ATTACHMENT</span><span class="p">,</span> <span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">m_depthTexture</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">15</span><span class="cl">  
</span></span><span class="line"><span class="ln">16</span><span class="cl">  <span class="c1">// final  
</span></span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="c1"></span>  <span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">m_finalTexture</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">18</span><span class="cl">  <span class="n">glTexImage2D</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGBA</span><span class="p">,</span> <span class="n">WindowWidth</span><span class="p">,</span> <span class="n">WindowHeight</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGB</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">19</span><span class="cl">  <span class="n">glFramebufferTexture2D</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">GL_COLOR_ATTACHMENT4</span><span class="p">,</span> <span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">m_finalTexture</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">20</span><span class="cl">  
</span></span><span class="line"><span class="ln">21</span><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>When we initialize the G Buffer we need to allocate one more texture for the final texture. The final texture is attached to attachment point number 4. The depth texture is no longer created with type GL_DEPTH_COMPONENT32F. Instead we create it as GL_DEPTH32F_STENCIL8. This leave a full byte for the stencil value in each pixel. This depth buffer is attached to GL_DEPTH_STENCIL_ATTACHMENT instead of GL_DEPTH_COMPONENT.</p>
<p>(gbuffer.cpp:97)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">void</span> <span class="n">GBuffer</span><span class="o">::</span><span class="n">StartFrame</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln">3</span><span class="cl">  <span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_DRAW_FRAMEBUFFER</span><span class="p">,</span> <span class="n">m_fbo</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">4</span><span class="cl">  <span class="n">glDrawBuffer</span><span class="p">(</span><span class="n">GL_COLOR_ATTACHMENT4</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">5</span><span class="cl">  <span class="n">glClear</span><span class="p">(</span><span class="n">GL_COLOR_BUFFER_BIT</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>At the start of each frame we need to clear the final texture which is attached to attachment point number 4.</p>
<p>(gbuffer.cpp:105)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="n">GBuffer</span><span class="o">::</span><span class="n">BindForGeomPass</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  <span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_DRAW_FRAMEBUFFER</span><span class="p">,</span> <span class="n">m_fbo</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  <span class="n">GLenum</span> <span class="n">DrawBuffers</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">GL_COLOR_ATTACHMENT0</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">              <span class="n">GL_COLOR_ATTACHMENT1</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">              <span class="n">GL_COLOR_ATTACHMENT2</span> <span class="p">};</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  <span class="n">glDrawBuffers</span><span class="p">(</span><span class="n">ARRAY_SIZE_IN_ELEMENTS</span><span class="p">(</span><span class="n">DrawBuffers</span><span class="p">),</span> <span class="n">DrawBuffers</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>Previously the FBO in the G Buffer was static (in terms of its configuration) and was set up in advance so we just had to bind it for writing when the geometry pass started. Now we keep changing the FBO to we need to config the draw buffers for the attributes each time.</p>
<p>(gbuffer.cpp:117)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">void</span> <span class="n">GBuffer</span><span class="o">::</span><span class="n">BindForStencilPass</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln">3</span><span class="cl">  <span class="c1">// must disable the draw buffers  
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="c1"></span>  <span class="n">glDrawBuffer</span><span class="p">(</span><span class="n">GL_NONE</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>As mentioned earlier, in the stencil test we are not writing to the color buffer, only the stencil buffer. Indeed, even our FS is empty. However, in that case the default output color from the FS is black. In order to avoid garbaging the final buffer with a black image of the bounding sphere we disable the draw buffers here.</p>
<p>(gbuffer.cpp:125)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">void</span> <span class="n">GBuffer</span><span class="o">::</span><span class="n">BindForLightPass</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln">3</span><span class="cl">  <span class="n">glDrawBuffer</span><span class="p">(</span><span class="n">GL_COLOR_ATTACHMENT4</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">4</span><span class="cl">  
</span></span><span class="line"><span class="ln">5</span><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE_IN_ELEMENTS</span><span class="p">(</span><span class="n">m_textures</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>    
</span></span><span class="line"><span class="ln">6</span><span class="cl">    <span class="n">glActiveTexture</span><span class="p">(</span><span class="n">GL_TEXTURE0</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>    
</span></span><span class="line"><span class="ln">7</span><span class="cl">    <span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">m_textures</span><span class="p">[</span><span class="n">GBUFFER_TEXTURE_TYPE_POSITION</span> <span class="o">+</span> <span class="n">i</span><span class="p">]);</span>  
</span></span><span class="line"><span class="ln">8</span><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="ln">9</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>The light pass is straightforward. We set the target to be the final buffer and bind the attribute buffers as a source.</p>
<p>(gbuffer.cpp:136)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">void</span> <span class="n">GBuffer</span><span class="o">::</span><span class="n">BindForFinalPass</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln">3</span><span class="cl">  <span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_DRAW_FRAMEBUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">4</span><span class="cl">  <span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_READ_FRAMEBUFFER</span><span class="p">,</span> <span class="n">m_fbo</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">5</span><span class="cl">  <span class="n">glReadBuffer</span><span class="p">(</span><span class="n">GL_COLOR_ATTACHMENT4</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>When we get to the final pass our final buffer is populated with the final image. Here we set things up for the blitting that takes place in the main application code. The default FBO is the target and the G Buffer FBO is the source.</p>
<p>This tutorial completes our introduction to deferred shading. It is definitely not the only &ldquo;right way&rdquo; to do it and you can find alternatives on the web but the core concepts are probably common. Like everything is life, it has its advantages and disadvantages. In future tutorials we will spend time on both forward and deferred rendering and improve their frameworks with new features.</p>

            <footer class="footline">
            </footer>
          </article>

        </div>
      </main>
    </div>
    <script src="../../../../../js/clipboard.min.js?1708235103" defer></script>
    <script src="../../../../../js/perfect-scrollbar.min.js?1708235103" defer></script>
    <script src="../../../../../js/theme.js?1708235103" defer></script>
  </body>
</html>
