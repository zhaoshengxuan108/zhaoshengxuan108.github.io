<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.122.0">
    <meta name="generator" content="Relearn 5.23.2+tip">
    <meta name="description" content="啊啊啊啊">
    <meta name="author" content="Sören Weber">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="https://example.com/images/hero.png">
    <meta name="twitter:title" content="Tutorial 47:Shadow Mapping with Directional Lights :: Hugo Relearn Theme">
    <meta name="twitter:description" content="Credits: some of the images were take from Clipart Panda and ClipArtHut
Background The Shadow Mapping algorithm that we explored in tutorial 23 and tutorial 24 used a spot light as the light source. The algorithm itself is based on the idea of rendering into a shadow map from the light point of view. This is simple with spot lights because they behave in the same way as our standard camera.">
    <meta property="og:title" content="Tutorial 47:Shadow Mapping with Directional Lights :: Hugo Relearn Theme">
    <meta property="og:description" content="Credits: some of the images were take from Clipart Panda and ClipArtHut
Background The Shadow Mapping algorithm that we explored in tutorial 23 and tutorial 24 used a spot light as the light source. The algorithm itself is based on the idea of rendering into a shadow map from the light point of view. This is simple with spot lights because they behave in the same way as our standard camera.">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://example.com/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_47_shadow_mapping_with_directional_lights/index.html">
    <meta property="og:image" content="https://example.com/images/hero.png">
    <meta property="article:section" content="OGL dev 教程 :: Hugo Relearn Theme">
    <meta property="og:site_name" content="Hugo Relearn Theme">
    <title>Tutorial 47:Shadow Mapping with Directional Lights :: Hugo Relearn Theme</title>
    <link href="https://example.com/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_47_shadow_mapping_with_directional_lights/index.html" rel="canonical" type="text/html" title="Tutorial 47:Shadow Mapping with Directional Lights :: Hugo Relearn Theme">
    <link href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_47_shadow_mapping_with_directional_lights/index.xml" rel="alternate" type="application/rss+xml" title="Tutorial 47:Shadow Mapping with Directional Lights :: Hugo Relearn Theme"><link rel="icon" href="../../../../../images/favicon.ico">
    <!-- https://github.com/filamentgroup/loadCSS/blob/master/README.md#how-to-use -->
    <link href="../../../../../css/fontawesome-all.min.css?1708235103" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../../../../../css/fontawesome-all.min.css?1708235103" rel="stylesheet"></noscript>
    <link href="../../../../../css/nucleus.css?1708235103" rel="stylesheet">
    <link href="../../../../../css/auto-complete.css?1708235103" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../../../../../css/auto-complete.css?1708235103" rel="stylesheet"></noscript>
    <link href="../../../../../css/perfect-scrollbar.min.css?1708235103" rel="stylesheet">
    <link href="../../../../../css/fonts.css?1708235103" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../../../../../css/fonts.css?1708235103" rel="stylesheet"></noscript>
    <link href="../../../../../css/theme.css?1708235103" rel="stylesheet">
    <link href="../../../../../css/theme-auto.css?1708235103" rel="stylesheet" id="R-variant-style">
    <link href="../../../../../css/variant.css?1708235103" rel="stylesheet">
    <link href="../../../../../css/print.css?1708235103" rel="stylesheet" media="print">
    <link href="../../../../../css/format-print.css?1708235103" rel="stylesheet">
    <link href="../../../../../css/ie.css?1708235103" rel="stylesheet">
    <script src="../../../../../js/url.js?1708235103"></script>
    <script src="../../../../../js/variant.js?1708235103"></script>
    <script>
      // hack to let hugo tell us how to get to the root when using relativeURLs, it needs to be called *url= for it to do its magic:
      // https://github.com/gohugoio/hugo/blob/145b3fcce35fbac25c7033c91c1b7ae6d1179da8/transform/urlreplacers/absurlreplacer.go#L72
      window.index_js_url="../../../../../index.search.js";
      var root_url="../../../../../";
      var baseUri=root_url.replace(/\/$/, '');
      window.relearn = window.relearn || {};
      window.relearn.baseUriFull='https:\/\/example.com/';
      // variant stuff
      window.variants && variants.init( [ 'auto', 'relearn-light', 'relearn-dark', 'zen-light', 'zen-dark', 'neon', 'learn', 'blue', 'green', 'red' ] );
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
    </script>
    <style>
      #R-body img.bg-white {
        background-color: white;
      }
    </style>
  </head>
  <body class="mobile-support print" data-url="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_47_shadow_mapping_with_directional_lights/index.html">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide">
              <button class="topbar-control" onclick="toggleNav()" type="button" title="Menu (CTRL&#43;ALT&#43;n)">
                <i class="fa-fw fas fa-bars"></i>
              </button>
            </div>
          </div>
          <ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype="http://schema.org/BreadcrumbList"><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../index.html"><span itemprop="name">主页</span></a><meta itemprop="position" content="1">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../computer_graphics/index.html"><span itemprop="name">计算机图形学</span></a><meta itemprop="position" content="2">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../computer_graphics/classic_tutorial/index.html"><span itemprop="name">经典教程</span></a><meta itemprop="position" content="3">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/index.html"><span itemprop="name">OpenGL教程</span></a><meta itemprop="position" content="4">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/index.html"><span itemprop="name">OGL dev 教程</span></a><meta itemprop="position" content="5">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><span itemprop="name">Tutorial 47:Shadow Mapping with Directional Lights</span><meta itemprop="position" content="6"></li>
          </ol>
          <div class="topbar-area topbar-area-end" data-area="end">
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable default" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="default">
            <header class="headline">
            </header>
<h1 id="tutorial-47shadow-mapping-with-directional-lights">Tutorial 47:Shadow Mapping with Directional Lights</h1>

<p>Credits: some of the images were take from <a href="http://www.clipartpanda.com/" target="_blank">Clipart Panda</a> and <a href="http://www.cliparthut.com/" target="_blank">ClipArtHut</a></p>
<h3 id="background">Background</h3>
<p>The Shadow Mapping algorithm that we explored in <a href="https://ogldev.org/www/tutorial23/tutorial23.html" target="_blank">tutorial 23</a> and <a href="https://ogldev.org/www/tutorial24/tutorial24.html" target="_blank">tutorial 24</a> used a spot light as the light source. The algorithm itself is based on the idea of rendering into a shadow map from the light point of view. This is simple with spot lights because they behave in the same way as our standard camera. The spot light has a location and a direction vector and the area covered by the light grows as we move further away from its source:</p>
<p><a href="#R-image-5672f25bdd5edd384c5a9cc5be55dc82" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_47_shadow_mapping_with_directional_lights/../assets/spotlight.jpeg" alt="img" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-5672f25bdd5edd384c5a9cc5be55dc82"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_47_shadow_mapping_with_directional_lights/../assets/spotlight.jpeg" alt="img" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>The fact that the spotlight behaves like a frustum makes it easier to implement shadow mapping because we can use the same perspective projection matrix as the camera in order to render into the shadow map. Implementing <a href="https://ogldev.org/www/tutorial43/tutorial43.html" target="_blank">Shadow Mapping with Point Lights</a> was a bit of a challenge but we were able to overcome it by rendering into a cubemap. Projection, though, was still perspective.</p>
<p>Now let&rsquo;s think about directional lights. A directional light has a direction but not a position. It is usually used to mimic the behavior of the sun which due to its size and distance seems to cast parallel lights rays:</p>
<p><a href="#R-image-ec99a871ebb044572ce04804e8111433" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_47_shadow_mapping_with_directional_lights/../assets/dirlight.jpeg" alt="img" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-ec99a871ebb044572ce04804e8111433"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_47_shadow_mapping_with_directional_lights/../assets/dirlight.jpeg" alt="img" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>In this case, we can no longer use Perspective Projection. Enter Orthographic Projection. The idea here is that of converging all light rays in one spot (the camera), the light rays remain parallel so no 3D effect is created.</p>
<p>In the following image we see the same box using perspective projection on the left hand side and orthographic projection on the right hand side:</p>
<p><a href="#R-image-d8f2f1b36ae0fa46e20d18349421c986" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_47_shadow_mapping_with_directional_lights/../assets/boxes.jpeg" alt="img" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d8f2f1b36ae0fa46e20d18349421c986"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_47_shadow_mapping_with_directional_lights/../assets/boxes.jpeg" alt="img" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>The left box looks real, just as you would expect it to be and delivers the correct sense of depth. The right one doesn&rsquo;t look real since the front and back rectangles are exactly the same. We know that their dimensions are the same but when looking at a picture we expect the front one to look larger. So how does Orthographic Projection helps us with directional lights? Well, remember that Perspective Projection takes something that looks like a frustum and maps it to a normalized cube (a cube that goes from [-1,-1,-1] to [1,1,1]). After mapping, the XY coordinates are used to find the location in the texture (in our case the shadow map) and the Z is the value which is written there. An Orthographic projection takes a general box and maps it to the normalized cube (l,r,b,t,n,f stands for left, right, bottom, top, near, far, respectively):</p>
<p><a href="#R-image-06ce26a0d45274076cd7482b945d0c62" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_47_shadow_mapping_with_directional_lights/../assets/ortho.jpeg" alt="img" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-06ce26a0d45274076cd7482b945d0c62"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_47_shadow_mapping_with_directional_lights/../assets/ortho.jpeg" alt="img" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Now think about the rays of the directional light as if they are originating from the front face of the box and going parallel to each other until they hit the back face. If we do the mapping between the general box and the normalized box (remember - we call this NDC space) properly the rest of the generation of the shadow map remains the same.</p>
<p>Let&rsquo;s see how this mapping is done. We have three ranges along the XYZ axes that we need to map to (-1,1). This is a simple linear mapping without divide-by-zero after that (since it is orthographic and not perspective). The general form of an equation that maps range (a,b) to (c,d) is:</p>
<p><a href="#R-image-34b7177f6fe97726371e6c1541479f94" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_47_shadow_mapping_with_directional_lights/../assets/calc1.jpeg" alt="img" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-34b7177f6fe97726371e6c1541479f94"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_47_shadow_mapping_with_directional_lights/../assets/calc1.jpeg" alt="img" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Where a&lt;=X&lt;=b. Let&rsquo;s do the mapping on the X-axis. Plug the ranges (l,r) to (-1,1) in the above equation and we get:</p>
<p><a href="#R-image-9ae27fcb7438675eed72241a6481ccd2" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_47_shadow_mapping_with_directional_lights/../assets/calc2.png" alt="img" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-9ae27fcb7438675eed72241a6481ccd2"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_47_shadow_mapping_with_directional_lights/../assets/calc2.png" alt="img" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Following the same logic we do the mapping on the Y-axis from (b,t) to (-1,1):</p>
<p><a href="#R-image-40a241c54db466dc81e072e3f02b3acc" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_47_shadow_mapping_with_directional_lights/../assets/calc3.png" alt="img" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-40a241c54db466dc81e072e3f02b3acc"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_47_shadow_mapping_with_directional_lights/../assets/calc3.png" alt="img" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>In the case of the Z-axis we need to map (n,f) to (-1,1):</p>
<p><a href="#R-image-2cd1169b3494022fb92dcdac2d0bcf3d" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_47_shadow_mapping_with_directional_lights/../assets/calc4.png" alt="img" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-2cd1169b3494022fb92dcdac2d0bcf3d"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_47_shadow_mapping_with_directional_lights/../assets/calc4.png" alt="img" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Now that we have the three mapping equations let&rsquo;s create a matrix to wrap them together nicely:</p>
<p><a href="#R-image-2d091062c0d9de3b3ecc1f368dde1b71" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_47_shadow_mapping_with_directional_lights/../assets/calc5.png" alt="img" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-2d091062c0d9de3b3ecc1f368dde1b71"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_47_shadow_mapping_with_directional_lights/../assets/calc5.png" alt="img" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Compare this matrix with the one we created for perpective projection in <a href="https://ogldev.org/www/tutorial12/tutorial12.html" target="_blank">tutorial 12</a>. An important difference is that in location [3,2] (count starts at zero) we have 0 instead of 1. For perspective projection the 1 was required in order to copy the Z into the W location of the result. This allows the GPU to perform perspective divide when everything is divided automatically by W (and you cannot disable this). In the case of orthographic projection the W will remain as 1, effectively disabling this operation.</p>
<p>When working on shadow mapping with directional lights you need to be careful about how you define the dimensions of orthographic projection. With perspective projection life is a bit simpler. The field-of-view defines how wide the camera is and due to the nature of the frustum we capture more and more as we move further away from the viewer (same as how our eye functions). We also need to define a near and far plane to control clipping based on distance. In many cases the same values of field-of-view, near and far plane will work just fine. But in the case of orthographic projection we have a box rather than a frustum and if we are not careful we may &ldquo;miss&rdquo; the objects and not render anything. Let&rsquo;s see an example. In the scene below left and bottom are -10, right and top are 10, the near plane is -10 and the far plane is 100:</p>
<p><a href="#R-image-a530a056199d0c3824cefa77eb60e6e2" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_47_shadow_mapping_with_directional_lights/../assets/high_res.jpeg" alt="img" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a530a056199d0c3824cefa77eb60e6e2"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_47_shadow_mapping_with_directional_lights/../assets/high_res.jpeg" alt="img" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>The problem is that the objects are placed at distance of 30 from each other so the projection was not wide enough in order to capture everything (remember that the light direction is orthogonal to the viewer so the objects are scattered on a wide field relative to the light). Now let&rsquo;s multiply left/right/bottom/top by 10 (near/far planes unchanged):</p>
<p><a href="#R-image-67997cc25a72c43fb2bf958fcba24161" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_47_shadow_mapping_with_directional_lights/../assets/low_res.jpeg" alt="img" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-67997cc25a72c43fb2bf958fcba24161"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_47_shadow_mapping_with_directional_lights/../assets/low_res.jpeg" alt="img" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Now all the objects have a shadow. However, we have a new problem. The shadows don&rsquo;t look as good as when only one object had a shadow. This problem is called <em>Perspective Aliasing</em> and the reason is that many pixels in view space (when rendering from the camera point of view) are mapped to the same pixel in the shadow map. This makes the shadows look kind of blocky. When we increased the dimensions of the orthographic box we increased that ratio because the shadow map remains the same but a larger part of the world is now rendered to it. Perspective Aliasing can be mitigated somewhat by increasing the size of the shadow map but you cannot go too far with that as there is a negative impact on memory footprint. In future tutorials we will explore advanced techniques to handle this problem.</p>
<h3 id="source-walkthru">Source walkthru</h3>
<p>The main difference between shadow mapping with directional and spot lights is the orthographic vs. perspective projection. This is why I&rsquo;m only going to review the changes required for shadows with directional light. Make sure you are highly familiar with <a href="https://ogldev.org/www/tutorial23/tutorial23.html" target="_blank">tutorial 23</a> and <a href="https://ogldev.org/www/tutorial24/tutorial24.html" target="_blank">tutorial 24</a> before proceeding because most of the code is the same. If you have a working version of shadows with spot lights you will only need to make a few minor changes to get directional lights shadows working.</p>
<p>(matrix_3d.cpp:165)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="n">Matrix4f</span><span class="o">::</span><span class="n">InitOrthoProjTransform</span><span class="p">(</span><span class="k">const</span> <span class="n">OrthoProjInfo</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  <span class="kt">float</span> <span class="n">l</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">l</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  <span class="kt">float</span> <span class="n">r</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">r</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  <span class="kt">float</span> <span class="n">b</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">b</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">  <span class="kt">float</span> <span class="n">t</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">t</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  <span class="kt">float</span> <span class="n">n</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">n</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">  <span class="kt">float</span> <span class="n">f</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">f</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  
</span></span><span class="line"><span class="ln">10</span><span class="cl">  <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.0f</span><span class="o">/</span><span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">l</span><span class="p">);</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>     <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>     <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="n">l</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">l</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">11</span><span class="cl">  <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>     <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.0f</span><span class="o">/</span><span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="n">b</span><span class="p">);</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>     <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">t</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="n">b</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">12</span><span class="cl">  <span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>     <span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>     <span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.0f</span><span class="o">/</span><span class="p">(</span><span class="n">f</span> <span class="o">-</span> <span class="n">n</span><span class="p">);</span> <span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">f</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">f</span> <span class="o">-</span> <span class="n">n</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">13</span><span class="cl">  <span class="n">m</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>     <span class="n">m</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>     <span class="n">m</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>     <span class="n">m</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>I&rsquo;ve added the above function to the Matrix4f class in order to initialize the orthographic projection matrix. This function is called from Pipeline::GetWVOrthoPTrans().</p>
<p>(tutorial47.cpp:163)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="nf">ShadowMapPass</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  <span class="n">m_shadowMapFBO</span><span class="p">.</span><span class="n">BindForWriting</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  <span class="n">glClear</span><span class="p">(</span><span class="n">GL_DEPTH_BUFFER_BIT</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">  <span class="n">m_ShadowMapEffect</span><span class="p">.</span><span class="n">Enable</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">  <span class="n">Pipeline</span> <span class="n">p</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  <span class="n">p</span><span class="p">.</span><span class="n">SetCamera</span><span class="p">(</span><span class="n">Vector3f</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">),</span> <span class="n">m_dirLight</span><span class="p">.</span><span class="n">Direction</span><span class="p">,</span> <span class="n">Vector3f</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">  <span class="n">p</span><span class="p">.</span><span class="n">SetOrthographicProj</span><span class="p">(</span><span class="n">m_shadowOrthoProjInfo</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">  
</span></span><span class="line"><span class="ln">12</span><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_MESHES</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>    
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="n">p</span><span class="p">.</span><span class="n">Orient</span><span class="p">(</span><span class="n">m_meshOrientation</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>    
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="n">m_ShadowMapEffect</span><span class="p">.</span><span class="n">SetWVP</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">GetWVOrthoPTrans</span><span class="p">());</span>   
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="n">m_mesh</span><span class="p">.</span><span class="n">Render</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln">16</span><span class="cl">  <span class="p">}</span>  
</span></span><span class="line"><span class="ln">17</span><span class="cl">  
</span></span><span class="line"><span class="ln">18</span><span class="cl">  <span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">
</span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="kt">void</span> <span class="nf">RenderPass</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln">23</span><span class="cl">  <span class="n">glClear</span><span class="p">(</span><span class="n">GL_COLOR_BUFFER_BIT</span> <span class="o">|</span> <span class="n">GL_DEPTH_BUFFER_BIT</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">24</span><span class="cl">  
</span></span><span class="line"><span class="ln">25</span><span class="cl">  <span class="n">m_LightingTech</span><span class="p">.</span><span class="n">Enable</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln">26</span><span class="cl">  
</span></span><span class="line"><span class="ln">27</span><span class="cl">  <span class="n">m_LightingTech</span><span class="p">.</span><span class="n">SetEyeWorldPos</span><span class="p">(</span><span class="n">m_pGameCamera</span><span class="o">-&gt;</span><span class="n">GetPos</span><span class="p">());</span>  
</span></span><span class="line"><span class="ln">28</span><span class="cl">  
</span></span><span class="line"><span class="ln">29</span><span class="cl">  <span class="n">m_shadowMapFBO</span><span class="p">.</span><span class="n">BindForReading</span><span class="p">(</span><span class="n">SHADOW_TEXTURE_UNIT</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">30</span><span class="cl">  
</span></span><span class="line"><span class="ln">31</span><span class="cl">  <span class="n">Pipeline</span> <span class="n">p</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">32</span><span class="cl">  <span class="n">p</span><span class="p">.</span><span class="n">SetOrthographicProj</span><span class="p">(</span><span class="n">m_shadowOrthoProjInfo</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">33</span><span class="cl">  <span class="n">p</span><span class="p">.</span><span class="n">Orient</span><span class="p">(</span><span class="n">m_quad</span><span class="p">.</span><span class="n">GetOrientation</span><span class="p">());</span>
</span></span><span class="line"><span class="ln">34</span><span class="cl">  <span class="n">p</span><span class="p">.</span><span class="n">SetCamera</span><span class="p">(</span><span class="n">Vector3f</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">),</span> <span class="n">m_dirLight</span><span class="p">.</span><span class="n">Direction</span><span class="p">,</span> <span class="n">Vector3f</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">35</span><span class="cl">  <span class="n">m_LightingTech</span><span class="p">.</span><span class="n">SetLightWVP</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">GetWVOrthoPTrans</span><span class="p">());</span>
</span></span><span class="line"><span class="ln">36</span><span class="cl">  <span class="n">p</span><span class="p">.</span><span class="n">SetPerspectiveProj</span><span class="p">(</span><span class="n">m_persProjInfo</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">37</span><span class="cl">  <span class="n">p</span><span class="p">.</span><span class="n">SetCamera</span><span class="p">(</span><span class="n">m_pGameCamera</span><span class="o">-&gt;</span><span class="n">GetPos</span><span class="p">(),</span> <span class="n">m_pGameCamera</span><span class="o">-&gt;</span><span class="n">GetTarget</span><span class="p">(),</span> <span class="n">m_pGameCamera</span><span class="o">-&gt;</span><span class="n">GetUp</span><span class="p">());</span>  
</span></span><span class="line"><span class="ln">38</span><span class="cl">  <span class="n">m_LightingTech</span><span class="p">.</span><span class="n">SetWVP</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">GetWVPTrans</span><span class="p">());</span>  
</span></span><span class="line"><span class="ln">39</span><span class="cl">  <span class="n">m_LightingTech</span><span class="p">.</span><span class="n">SetWorldMatrix</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">GetWorldTrans</span><span class="p">());</span>  
</span></span><span class="line"><span class="ln">40</span><span class="cl">  <span class="n">m_pGroundTex</span><span class="o">-&gt;</span><span class="n">Bind</span><span class="p">(</span><span class="n">COLOR_TEXTURE_UNIT</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">41</span><span class="cl">  <span class="n">m_quad</span><span class="p">.</span><span class="n">Render</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln">42</span><span class="cl">  
</span></span><span class="line"><span class="ln">43</span><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_MESHES</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>    
</span></span><span class="line"><span class="ln">44</span><span class="cl">    <span class="n">p</span><span class="p">.</span><span class="n">Orient</span><span class="p">(</span><span class="n">m_meshOrientation</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>    
</span></span><span class="line"><span class="ln">45</span><span class="cl">    <span class="n">m_LightingTech</span><span class="p">.</span><span class="n">SetWVP</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">GetWVPTrans</span><span class="p">());</span>    
</span></span><span class="line"><span class="ln">46</span><span class="cl">    <span class="n">m_LightingTech</span><span class="p">.</span><span class="n">SetWorldMatrix</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">GetWorldTrans</span><span class="p">());</span>    
</span></span><span class="line"><span class="ln">47</span><span class="cl">    <span class="n">m_mesh</span><span class="p">.</span><span class="n">Render</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln">48</span><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="ln">49</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>These are the complete shadow and render passes and they are practically the same as for spot lights so we don&rsquo;t have to review them fully. Just a couple of differences that must be noted here. First is that I&rsquo;ve added a member called m_shadowOrthoProjInfo in order to keep the orthographic projection variables separate from the existing perspective projection variables that are used for rendering. m_shadowOrthoProjInfo is used to configure the WVP for the light point of view and it is initialized with the values of -100,+100,-100,+100,-10,+100 for left, right, bottom, top, near, far, respectively.</p>
<p>The second change is that when we configure the camera for that light WVP matrix we use the origin as the location of the light. Since a directional light only has a direction and no position we don&rsquo;t care about that variable in the view matrix. We just need to rotate the world so that the light points toward the positive Z-axis.</p>
<p>(lighting.fs:96)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">vec4</span> <span class="nf">CalcDirectionalLight</span><span class="p">(</span><span class="n">vec3</span> <span class="n">Normal</span><span class="p">,</span> <span class="n">vec4</span> <span class="n">LightSpacePos</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  <span class="kt">float</span> <span class="n">ShadowFactor</span> <span class="o">=</span> <span class="n">CalcShadowFactor</span><span class="p">(</span><span class="n">LightSpacePos</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  <span class="k">return</span> <span class="n">CalcLightInternal</span><span class="p">(</span><span class="n">gDirectionalLight</span><span class="p">.</span><span class="n">Base</span><span class="p">,</span> <span class="n">gDirectionalLight</span><span class="p">.</span><span class="n">Direction</span><span class="p">,</span> <span class="n">Normal</span><span class="p">,</span> <span class="n">ShadowFactor</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="p">...</span> 
</span></span><span class="line"><span class="ln">10</span><span class="cl">  <span class="n">vec4</span> <span class="n">TotalLight</span> <span class="o">=</span> <span class="n">CalcDirectionalLight</span><span class="p">(</span><span class="n">Normal</span><span class="p">,</span> <span class="n">LightSpacePos</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>The shaders are almost exactly the same - we just need to calculate a shadow factor for the directional light as well.</p>

            <footer class="footline">
            </footer>
          </article>

        </div>
      </main>
    </div>
    <script src="../../../../../js/clipboard.min.js?1708235103" defer></script>
    <script src="../../../../../js/perfect-scrollbar.min.js?1708235103" defer></script>
    <script src="../../../../../js/theme.js?1708235103" defer></script>
  </body>
</html>
