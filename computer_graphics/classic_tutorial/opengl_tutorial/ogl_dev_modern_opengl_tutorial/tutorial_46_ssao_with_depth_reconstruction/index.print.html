<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.122.0">
    <meta name="generator" content="Relearn 5.23.2+tip">
    <meta name="description" content="啊啊啊啊">
    <meta name="author" content="Sören Weber">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="https://example.com/images/hero.png">
    <meta name="twitter:title" content="Tutorial 46:SSAO With Depth Reconstruction :: Hugo Relearn Theme">
    <meta name="twitter:description" content="Background In the previous tutorial we studied the Screen Space Ambient Occlusion algorithm. We used a geometry buffer which contained the view space position of all the pixels as a first step in our calculations. In this tutorial we are going to challenge ourselves by calculating the view space position directly from the depth buffer. The advantage of this approach is that much less memory is required because we will only need one floating point value per pixel instead of three.">
    <meta property="og:title" content="Tutorial 46:SSAO With Depth Reconstruction :: Hugo Relearn Theme">
    <meta property="og:description" content="Background In the previous tutorial we studied the Screen Space Ambient Occlusion algorithm. We used a geometry buffer which contained the view space position of all the pixels as a first step in our calculations. In this tutorial we are going to challenge ourselves by calculating the view space position directly from the depth buffer. The advantage of this approach is that much less memory is required because we will only need one floating point value per pixel instead of three.">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://example.com/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_46_ssao_with_depth_reconstruction/index.html">
    <meta property="og:image" content="https://example.com/images/hero.png">
    <meta property="article:section" content="OGL dev 教程 :: Hugo Relearn Theme">
    <meta property="og:site_name" content="Hugo Relearn Theme">
    <title>Tutorial 46:SSAO With Depth Reconstruction :: Hugo Relearn Theme</title>
    <link href="https://example.com/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_46_ssao_with_depth_reconstruction/index.html" rel="canonical" type="text/html" title="Tutorial 46:SSAO With Depth Reconstruction :: Hugo Relearn Theme">
    <link href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_46_ssao_with_depth_reconstruction/index.xml" rel="alternate" type="application/rss+xml" title="Tutorial 46:SSAO With Depth Reconstruction :: Hugo Relearn Theme"><link rel="icon" href="../../../../../images/favicon.ico">
    <!-- https://github.com/filamentgroup/loadCSS/blob/master/README.md#how-to-use -->
    <link href="../../../../../css/fontawesome-all.min.css?1708235002" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../../../../../css/fontawesome-all.min.css?1708235002" rel="stylesheet"></noscript>
    <link href="../../../../../css/nucleus.css?1708235002" rel="stylesheet">
    <link href="../../../../../css/auto-complete.css?1708235002" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../../../../../css/auto-complete.css?1708235002" rel="stylesheet"></noscript>
    <link href="../../../../../css/perfect-scrollbar.min.css?1708235002" rel="stylesheet">
    <link href="../../../../../css/fonts.css?1708235002" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../../../../../css/fonts.css?1708235002" rel="stylesheet"></noscript>
    <link href="../../../../../css/theme.css?1708235002" rel="stylesheet">
    <link href="../../../../../css/theme-auto.css?1708235002" rel="stylesheet" id="R-variant-style">
    <link href="../../../../../css/variant.css?1708235002" rel="stylesheet">
    <link href="../../../../../css/print.css?1708235002" rel="stylesheet" media="print">
    <link href="../../../../../css/format-print.css?1708235002" rel="stylesheet">
    <link href="../../../../../css/ie.css?1708235002" rel="stylesheet">
    <script src="../../../../../js/url.js?1708235002"></script>
    <script src="../../../../../js/variant.js?1708235002"></script>
    <script>
      // hack to let hugo tell us how to get to the root when using relativeURLs, it needs to be called *url= for it to do its magic:
      // https://github.com/gohugoio/hugo/blob/145b3fcce35fbac25c7033c91c1b7ae6d1179da8/transform/urlreplacers/absurlreplacer.go#L72
      window.index_js_url="../../../../../index.search.js";
      var root_url="../../../../../";
      var baseUri=root_url.replace(/\/$/, '');
      window.relearn = window.relearn || {};
      window.relearn.baseUriFull='https:\/\/example.com/';
      // variant stuff
      window.variants && variants.init( [ 'auto', 'relearn-light', 'relearn-dark', 'zen-light', 'zen-dark', 'neon', 'learn', 'blue', 'green', 'red' ] );
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
    </script>
    <style>
      #R-body img.bg-white {
        background-color: white;
      }
    </style>
  </head>
  <body class="mobile-support print" data-url="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_46_ssao_with_depth_reconstruction/index.html">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide">
              <button class="topbar-control" onclick="toggleNav()" type="button" title="Menu (CTRL&#43;ALT&#43;n)">
                <i class="fa-fw fas fa-bars"></i>
              </button>
            </div>
          </div>
          <ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype="http://schema.org/BreadcrumbList"><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../index.html"><span itemprop="name">主页</span></a><meta itemprop="position" content="1">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../computer_graphics/index.html"><span itemprop="name">计算机图形学</span></a><meta itemprop="position" content="2">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../computer_graphics/classic_tutorial/index.html"><span itemprop="name">经典教程</span></a><meta itemprop="position" content="3">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/index.html"><span itemprop="name">OpenGL教程</span></a><meta itemprop="position" content="4">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/index.html"><span itemprop="name">OGL dev 教程</span></a><meta itemprop="position" content="5">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><span itemprop="name">Tutorial 46:SSAO With Depth Reconstruction</span><meta itemprop="position" content="6"></li>
          </ol>
          <div class="topbar-area topbar-area-end" data-area="end">
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable default" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="default">
            <header class="headline">
            </header>
<h1 id="tutorial-46ssao-with-depth-reconstruction">Tutorial 46:SSAO With Depth Reconstruction</h1>

<h3 id="background">Background</h3>
<p>In the <a href="https://ogldev.org/www/tutorial45/tutorial45.html" target="_blank">previous tutorial</a> we studied the Screen Space Ambient Occlusion algorithm. We used a geometry buffer which contained the view space position of all the pixels as a first step in our calculations. In this tutorial we are going to challenge ourselves by calculating the view space position directly from the depth buffer. The advantage of this approach is that much less memory is required because we will only need one floating point value per pixel instead of three. This tutorial relies heavily on the previous tutorial so make sure you fully understand it before going on. The code here will be presented only as required changes over the original algorithm.</p>
<p>In the SSAO algorithm we scan the entire window pixel by pixel, generate random points around each pixel in view space, project them on the near clipping plane and compare their Z value with the actual pixel at that location. The view space position is generated in a geometry pass at the start of the render loop. In order to populate correctly the geometry buffer with the view space position we also need a depth buffer (else pixels will be updated based on draw order rather than depth). We can use that depth buffer alone to reconstruct the entire view space position vector, thus reducing the space required for it (though some more per-pixel math will be required).</p>
<p>Let&rsquo;s do a short recap on the stages required to populate the depth buffer (if you need a more in-depth review please see <a href="https://ogldev.org/www/tutorial12/tutorial12.html" target="_blank">tutorial 12</a>). We begin with the object space position of a vertex and multiply it with the WVP matrix which is a combined transformations of local-to-world, world-to-view and projection from view on the near clipping plane. The result is a 4D vector with the view space Z value in the fourth component. We say that this vector is in clip space at this point. The clip space vector goes into the gl_Position output vector from the vertex shader and the GPU clips its first three components between -W and W (W is the fourth component with the view space Z value). Next the GPU performs perspective divide which means that the vector is divided by W. Now the first three components are between -1 and 1 and the last component is simply 1. We say that at this point the vector is in NDC space (Normalized Device Coordinates).</p>
<p>Usually the vertex is just one out of three vertices comprising a triangle so the GPU interpolates between the three NDC vectors across the triangle face and executes the fragment shader on each pixel. On the way out of the fragment shader the GPU updates the depth buffer with the Z component of the NDC vector (based on several state nobs that must be configured correctly such as depth testing, depth write, etc). An important point to remember is that before writing the Z value to the depth buffer the GPU transforms it from (-1,1) to (0,1). We must handle this correctly or else we will get visual anomalies.</p>
<p>So this is basically all the math relevant to the Z buffer handling. Now let&rsquo;s say that we have a Z value that we sampled for the pixel and we want to reconstruct the entire view space vector from it. Everything we need in order to retrace our steps is in the above description but before we dive any further let&rsquo;s see that math again only this time with numbers and matrices rather than words. Since we are only interested in the view space position we can look at the projection matrix rather than the combined WVP (because projection works on the view space position):</p>
<p><a href="#R-image-bf3152b838a17b139ba3b43fa5d8a0eb" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_46_ssao_with_depth_reconstruction/../assets/diagram11.jpeg" alt="img" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-bf3152b838a17b139ba3b43fa5d8a0eb"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_46_ssao_with_depth_reconstruction/../assets/diagram11.jpeg" alt="img" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>What we see above is the projection of the view space vector to clip space (the result on the right). Few notations:</p>
<ul>
<li>ar = Aspect Ratio (width/height)</li>
<li>FOV = Field of View</li>
<li>n = near clipping plane</li>
<li>f = far clipping plane</li>
</ul>
<p>In order to simplify the next steps let&rsquo;s call the value in location (3,3) of the projection matrix &lsquo;S&rsquo; and the value in location (3,4) &lsquo;T&rsquo;. This means that the value of the Z in NDC is (remember perspective divide):</p>
<p><a href="#R-image-517b956e7b2af48243a25cf1b9bd4cb0" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_46_ssao_with_depth_reconstruction/../assets/diagram2.jpeg" alt="img" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-517b956e7b2af48243a25cf1b9bd4cb0"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_46_ssao_with_depth_reconstruction/../assets/diagram2.jpeg" alt="img" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>And since we need to transform the NDC value from (-1,1) to (0,1) the actual value written to the depth buffer is:</p>
<p><a href="#R-image-d0299e8f69c2eee3df786a2d2fbd2cd4" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_46_ssao_with_depth_reconstruction/../assets/diagram3.jpeg" alt="img" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d0299e8f69c2eee3df786a2d2fbd2cd4"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_46_ssao_with_depth_reconstruction/../assets/diagram3.jpeg" alt="img" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>It is now easy to see that we can extract the view space Z from the above formula. I haven&rsquo;t specified all the intermediate steps because you should be able to do them yourself. The final result is:</p>
<p><a href="#R-image-c98294c1efafbfe5c4b466a7452ba93c" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_46_ssao_with_depth_reconstruction/../assets/diagram4.jpeg" alt="img" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c98294c1efafbfe5c4b466a7452ba93c"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_46_ssao_with_depth_reconstruction/../assets/diagram4.jpeg" alt="img" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>So we have the view space Z. Let&rsquo;s see how we can recover X and Y. Remember that after transforming X and Y to clip space we perform clipping to (-W,W) and divide by W (which is actually Z in view space). X and Y are now in the (-1,1) range and so are all the X and Y values of the to-be-interpolated pixels of the triangle. In fact, -1 and 1 mapped to the left, right, top and bottom of the screen. This means that for every pixel on the screen the following equation applies (showing for X only; same applies to Y just without &lsquo;ar&rsquo;):</p>
<p><a href="#R-image-32059587d1a9fb580c2912655aa90529" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_46_ssao_with_depth_reconstruction/../assets/diagram5.jpeg" alt="img" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-32059587d1a9fb580c2912655aa90529"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_46_ssao_with_depth_reconstruction/../assets/diagram5.jpeg" alt="img" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>We can write the same as:</p>
<p><a href="#R-image-8bc4f8372389a6c5f580e40d00fced35" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_46_ssao_with_depth_reconstruction/../assets/diagram6.jpeg" alt="img" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-8bc4f8372389a6c5f580e40d00fced35"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_46_ssao_with_depth_reconstruction/../assets/diagram6.jpeg" alt="img" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Note that the left and right hand side of the inequality are basically constants and can be calculated by the application before the draw call. This means that we can draw a full screen quad and prepare a 2D vector with those values for X and Y and have the GPU interpolate them all over the screen. When we get to the pixel we can use the interpolated value along with Z in order to calculate both X and Y.</p>
<h3 id="source-walkthru">Source walkthru</h3>
<p>(tutorial46.cpp:101)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">float</span> <span class="n">AspectRatio</span> <span class="o">=</span> <span class="n">m_persProjInfo</span><span class="p">.</span><span class="n">Width</span> <span class="o">/</span> <span class="n">m_persProjInfo</span><span class="p">.</span><span class="n">Height</span><span class="p">;</span><span class="n">m_SSAOTech</span><span class="p">.</span><span class="n">SetAspectRatio</span><span class="p">(</span><span class="n">AspectRatio</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="kt">float</span> <span class="n">TanHalfFOV</span> <span class="o">=</span> <span class="n">tanf</span><span class="p">(</span><span class="n">ToRadian</span><span class="p">(</span><span class="n">m_persProjInfo</span><span class="p">.</span><span class="n">FOV</span> <span class="o">/</span> <span class="mf">2.0f</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">m_SSAOTech</span><span class="p">.</span><span class="n">SetTanHalfFOV</span><span class="p">(</span><span class="n">TanHalfFOV</span><span class="p">);</span></span></span></code></pre></div><p>As I said earlier, we are only going to review the specific code changes to the previous tutorial in order to implement depth reconstruction. The first change that we need to make is to provide the aspect ratio and the tangent of half the field of view angle to the SSAO technique. We see above how to calculate them.</p>
<p>(tutorial46.cpp:134)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">m_depthBuffer</span><span class="p">.</span><span class="n">Init</span><span class="p">(</span><span class="n">WINDOW_WIDTH</span><span class="p">,</span> <span class="n">WINDOW_HEIGHT</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="n">GL_NONE</span><span class="p">))</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln">2</span><span class="cl">  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>Next we need to initialize the geometry buffer (whose class attribute was renamed from m_gBuffer to m_depthBuffer) with GL_NONE as the internal format type. This will cause only the depth buffer to be created. Review io_buffer.cpp in the Common project for further details on the internal workings of the IOBuffer class.</p>
<p>(tutorial46.cpp:181)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="nf">GeometryPass</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  <span class="n">m_geomPassTech</span><span class="p">.</span><span class="n">Enable</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  <span class="n">m_depthBuffer</span><span class="p">.</span><span class="n">BindForWriting</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  <span class="n">glClear</span><span class="p">(</span><span class="n">GL_DEPTH_BUFFER_BIT</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  <span class="n">m_pipeline</span><span class="p">.</span><span class="n">Orient</span><span class="p">(</span><span class="n">m_mesh</span><span class="p">.</span><span class="n">GetOrientation</span><span class="p">());</span>  
</span></span><span class="line"><span class="ln">10</span><span class="cl">  <span class="n">m_geomPassTech</span><span class="p">.</span><span class="n">SetWVP</span><span class="p">(</span><span class="n">m_pipeline</span><span class="p">.</span><span class="n">GetWVPTrans</span><span class="p">());</span>  
</span></span><span class="line"><span class="ln">11</span><span class="cl">  <span class="n">m_mesh</span><span class="p">.</span><span class="n">Render</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="kt">void</span> <span class="nf">SSAOPass</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln">16</span><span class="cl">  <span class="n">m_SSAOTech</span><span class="p">.</span><span class="n">Enable</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln">17</span><span class="cl">  <span class="n">m_SSAOTech</span><span class="p">.</span><span class="n">BindDepthBuffer</span><span class="p">(</span><span class="n">m_depthBuffer</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">  
</span></span><span class="line"><span class="ln">19</span><span class="cl">  <span class="n">m_aoBuffer</span><span class="p">.</span><span class="n">BindForWriting</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln">20</span><span class="cl">  
</span></span><span class="line"><span class="ln">21</span><span class="cl">  <span class="n">glClear</span><span class="p">(</span><span class="n">GL_COLOR_BUFFER_BIT</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">22</span><span class="cl">  
</span></span><span class="line"><span class="ln">23</span><span class="cl">  <span class="n">m_quad</span><span class="p">.</span><span class="n">Render</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>We can see the change from m_gBuffer to m_depthBuffer in the geometry and SSAO passses. Also, we no longer need to call glClear with the color buffer bit because m_depthBuffer does not contain a color buffer. This completes the changes in the main application code and you can see that they are fairly minimal. Most of the juice is in the shaders. Let&rsquo;s review them.</p>
<p>(geometry_pass.vs/fs)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">Position</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">uniform</span> <span class="n">mat4</span> <span class="n">gWVP</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="c1">// uniform mat4 gWV;
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="c1">// out vec3 ViewPos;
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln">12</span><span class="cl">  <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">gWVP</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">Position</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">13</span><span class="cl">  <span class="c1">// ViewPos = (gWV \* vec4(Position, 1.0)).xyz;
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">
</span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="cp">#version 330
</span></span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="c1">// in vec3 ViewPos;
</span></span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="c1">// layout (location = 0) out vec3 PosOut;
</span></span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="ln">22</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln">24</span><span class="cl">  <span class="c1">// PosOut = ViewPos;
</span></span></span><span class="line"><span class="ln">25</span><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></div><p>Above we see the revised geometry pass vertex and fragment shaders with the stuff that we no longer need commented out. Since we are only writing out the depth everything related to view space position was thrown out. In fact, the fragment shader is now empty.</p>
<p>(ssao.vs)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">Position</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">uniform</span> <span class="kt">float</span> <span class="n">gAspectRatio</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">uniform</span> <span class="kt">float</span> <span class="n">gTanHalfFOV</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="n">out</span> <span class="n">vec2</span> <span class="n">TexCoord</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="n">out</span> <span class="n">vec2</span> <span class="n">ViewRay</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln">13</span><span class="cl">  <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">Position</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">14</span><span class="cl">  <span class="n">TexCoord</span> <span class="o">=</span> <span class="p">(</span><span class="n">Position</span><span class="p">.</span><span class="n">xy</span> <span class="o">+</span> <span class="n">vec2</span><span class="p">(</span><span class="mf">1.0</span><span class="p">))</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">15</span><span class="cl">  <span class="n">ViewRay</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">Position</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">gAspectRatio</span> <span class="o">*</span> <span class="n">gTanHalfFOV</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">  <span class="n">ViewRay</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">Position</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">gTanHalfFOV</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>Based on the math reviewed above (see the very end of the background section) we need to generate something that we call a view ray in the vertex shader of the SSAO technique. Combined with the view space Z calculated in the fragment shader it will help us extract the view space X and Y. Note how we use the fact that the incoming geometry is a full screen quad that goes from -1 to 1 on the X and Y axis in order to generate the end points of &lsquo;-1/+1 * ar * tan(FOV/2)&rsquo; for X and &lsquo;-1/+1 * tan(FOV/2)&rsquo; and &rsquo;tan(FOV/2)&rsquo; for Y.</p>
<p>(ssao.fs)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">in</span> <span class="n">vec2</span> <span class="n">TexCoord</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">in</span> <span class="n">vec2</span> <span class="n">ViewRay</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">out</span> <span class="n">vec4</span> <span class="n">FragColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">gDepthMap</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="n">uniform</span> <span class="kt">float</span> <span class="n">gSampleRad</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="n">uniform</span> <span class="n">mat4</span> <span class="n">gProj</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">MAX_KERNEL_SIZE</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="n">uniform</span> <span class="n">vec3</span> <span class="n">gKernel</span><span class="p">[</span><span class="n">MAX_KERNEL_SIZE</span><span class="p">];</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="kt">float</span> <span class="nf">CalcViewZ</span><span class="p">(</span><span class="n">vec2</span> <span class="n">Coords</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">  <span class="kt">float</span> <span class="n">Depth</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">gDepthMap</span><span class="p">,</span> <span class="n">Coords</span><span class="p">).</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">  <span class="kt">float</span> <span class="n">ViewZ</span> <span class="o">=</span> <span class="n">gProj</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">Depth</span> <span class="o">-</span><span class="mi">1</span> <span class="o">-</span> <span class="n">gProj</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]);</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">  <span class="k">return</span> <span class="n">ViewZ</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">
</span></span><span class="line"><span class="ln">22</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln">24</span><span class="cl">  <span class="kt">float</span> <span class="n">ViewZ</span> <span class="o">=</span> <span class="n">CalcViewZ</span><span class="p">(</span><span class="n">TexCoord</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl">
</span></span><span class="line"><span class="ln">26</span><span class="cl">  <span class="kt">float</span> <span class="n">ViewX</span> <span class="o">=</span> <span class="n">ViewRay</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">ViewZ</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl">  <span class="kt">float</span> <span class="n">ViewY</span> <span class="o">=</span> <span class="n">ViewRay</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">ViewZ</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">28</span><span class="cl">
</span></span><span class="line"><span class="ln">29</span><span class="cl">  <span class="n">vec3</span> <span class="n">Pos</span> <span class="o">=</span> <span class="n">vec3</span><span class="p">(</span><span class="n">ViewX</span><span class="p">,</span> <span class="n">ViewY</span><span class="p">,</span> <span class="n">ViewZ</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">30</span><span class="cl">  
</span></span><span class="line"><span class="ln">31</span><span class="cl">  <span class="kt">float</span> <span class="n">AO</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">32</span><span class="cl">  
</span></span><span class="line"><span class="ln">33</span><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_KERNEL_SIZE</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>    
</span></span><span class="line"><span class="ln">34</span><span class="cl">    <span class="n">vec3</span> <span class="n">samplePos</span> <span class="o">=</span> <span class="n">Pos</span> <span class="o">+</span> <span class="n">gKernel</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>    
</span></span><span class="line"><span class="ln">35</span><span class="cl">    <span class="n">vec4</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">samplePos</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>    
</span></span><span class="line"><span class="ln">36</span><span class="cl">    <span class="n">offset</span> <span class="o">=</span> <span class="n">gProj</span> <span class="o">*</span> <span class="n">offset</span><span class="p">;</span>    
</span></span><span class="line"><span class="ln">37</span><span class="cl">    <span class="n">offset</span><span class="p">.</span><span class="n">xy</span> <span class="o">/=</span> <span class="n">offset</span><span class="p">.</span><span class="n">w</span><span class="p">;</span>    
</span></span><span class="line"><span class="ln">38</span><span class="cl">    <span class="n">offset</span><span class="p">.</span><span class="n">xy</span> <span class="o">=</span> <span class="n">offset</span><span class="p">.</span><span class="n">xy</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="n">vec2</span><span class="p">(</span><span class="mf">0.5</span><span class="p">);</span>    
</span></span><span class="line"><span class="ln">39</span><span class="cl">    
</span></span><span class="line"><span class="ln">40</span><span class="cl">    <span class="kt">float</span> <span class="n">sampleDepth</span> <span class="o">=</span> <span class="n">CalcViewZ</span><span class="p">(</span><span class="n">offset</span><span class="p">.</span><span class="n">xy</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">41</span><span class="cl">    
</span></span><span class="line"><span class="ln">42</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">Pos</span><span class="p">.</span><span class="n">z</span> <span class="o">-</span> <span class="n">sampleDepth</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">gSampleRad</span><span class="p">)</span> <span class="p">{</span>      
</span></span><span class="line"><span class="ln">43</span><span class="cl">      <span class="n">AO</span> <span class="o">+=</span> <span class="n">step</span><span class="p">(</span><span class="n">sampleDepth</span><span class="p">,</span><span class="n">samplePos</span><span class="p">.</span><span class="n">z</span><span class="p">);</span>    
</span></span><span class="line"><span class="ln">44</span><span class="cl">    <span class="p">}</span>  
</span></span><span class="line"><span class="ln">45</span><span class="cl">  <span class="p">}</span>  
</span></span><span class="line"><span class="ln">46</span><span class="cl">  
</span></span><span class="line"><span class="ln">47</span><span class="cl">  <span class="n">AO</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">AO</span><span class="o">/</span><span class="mf">64.0</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">48</span><span class="cl">  
</span></span><span class="line"><span class="ln">49</span><span class="cl">  <span class="n">FragColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">pow</span><span class="p">(</span><span class="n">AO</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">50</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>The first thing we do in the fragment shader is to calculate the view space Z. We do this with the exact same formula we saw in the background section. The projection matrix was already here in the previous tutorial and we just need to be careful when accessing the &lsquo;S&rsquo; and &lsquo;T&rsquo; items in the (3,3) and (3,4) locations. Remember that the index goes from 0 to 3 (vs. 1 to 4 in standard matrix semantics) and that the matrix is transposed so we we need to reverse the column/row for the &lsquo;T&rsquo;.</p>
<p>Once the Z is ready we multiply it by the view ray in order to retrieve the X and Y. We continue as usual by generating the random points and projecting them on the screen. We use the same trick to calculate the depth of the projected point.</p>
<p>If you have done everything correctly you should end up with pretty much the same results as in the previous tutorial&hellip; ;-)</p>

            <footer class="footline">
            </footer>
          </article>

        </div>
      </main>
    </div>
    <script src="../../../../../js/clipboard.min.js?1708235002" defer></script>
    <script src="../../../../../js/perfect-scrollbar.min.js?1708235002" defer></script>
    <script src="../../../../../js/theme.js?1708235002" defer></script>
  </body>
</html>
