<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.122.0">
    <meta name="generator" content="Relearn 5.23.2+tip">
    <meta name="description" content="啊啊啊啊">
    <meta name="author" content="Sören Weber">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="https://example.com/images/hero.png">
    <meta name="twitter:title" content="Tutorial 42:Percentage Closer Filtering :: Hugo Relearn Theme">
    <meta name="twitter:description" content="Background In tutorial 24 we saw how to implement shadows using a technique called Shadow Mapping. The shadows that result from Shadow Mapping aren&rsquo;t that great and there is quite a lot of aliasing there, as you can see in the following picture:
This tutorial describes a method (one of many) to reduce that problem. It is called Percentage Closer Filtering, or PCF. The idea is to sample from the shadow map around the current pixel and compare its depth to all the samples.">
    <meta property="og:title" content="Tutorial 42:Percentage Closer Filtering :: Hugo Relearn Theme">
    <meta property="og:description" content="Background In tutorial 24 we saw how to implement shadows using a technique called Shadow Mapping. The shadows that result from Shadow Mapping aren&rsquo;t that great and there is quite a lot of aliasing there, as you can see in the following picture:
This tutorial describes a method (one of many) to reduce that problem. It is called Percentage Closer Filtering, or PCF. The idea is to sample from the shadow map around the current pixel and compare its depth to all the samples.">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://example.com/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_42_percentage_closer_filtering/index.html">
    <meta property="og:image" content="https://example.com/images/hero.png">
    <meta property="article:section" content="OGL dev 教程 :: Hugo Relearn Theme">
    <meta property="og:site_name" content="Hugo Relearn Theme">
    <title>Tutorial 42:Percentage Closer Filtering :: Hugo Relearn Theme</title>
    <link href="https://example.com/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_42_percentage_closer_filtering/index.html" rel="canonical" type="text/html" title="Tutorial 42:Percentage Closer Filtering :: Hugo Relearn Theme">
    <link href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_42_percentage_closer_filtering/index.xml" rel="alternate" type="application/rss+xml" title="Tutorial 42:Percentage Closer Filtering :: Hugo Relearn Theme"><link rel="icon" href="../../../../../images/favicon.ico">
    <!-- https://github.com/filamentgroup/loadCSS/blob/master/README.md#how-to-use -->
    <link href="../../../../../css/fontawesome-all.min.css?1708235103" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../../../../../css/fontawesome-all.min.css?1708235103" rel="stylesheet"></noscript>
    <link href="../../../../../css/nucleus.css?1708235103" rel="stylesheet">
    <link href="../../../../../css/auto-complete.css?1708235103" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../../../../../css/auto-complete.css?1708235103" rel="stylesheet"></noscript>
    <link href="../../../../../css/perfect-scrollbar.min.css?1708235103" rel="stylesheet">
    <link href="../../../../../css/fonts.css?1708235103" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../../../../../css/fonts.css?1708235103" rel="stylesheet"></noscript>
    <link href="../../../../../css/theme.css?1708235103" rel="stylesheet">
    <link href="../../../../../css/theme-auto.css?1708235103" rel="stylesheet" id="R-variant-style">
    <link href="../../../../../css/variant.css?1708235103" rel="stylesheet">
    <link href="../../../../../css/print.css?1708235103" rel="stylesheet" media="print">
    <link href="../../../../../css/format-print.css?1708235103" rel="stylesheet">
    <link href="../../../../../css/ie.css?1708235103" rel="stylesheet">
    <script src="../../../../../js/url.js?1708235103"></script>
    <script src="../../../../../js/variant.js?1708235103"></script>
    <script>
      // hack to let hugo tell us how to get to the root when using relativeURLs, it needs to be called *url= for it to do its magic:
      // https://github.com/gohugoio/hugo/blob/145b3fcce35fbac25c7033c91c1b7ae6d1179da8/transform/urlreplacers/absurlreplacer.go#L72
      window.index_js_url="../../../../../index.search.js";
      var root_url="../../../../../";
      var baseUri=root_url.replace(/\/$/, '');
      window.relearn = window.relearn || {};
      window.relearn.baseUriFull='https:\/\/example.com/';
      // variant stuff
      window.variants && variants.init( [ 'auto', 'relearn-light', 'relearn-dark', 'zen-light', 'zen-dark', 'neon', 'learn', 'blue', 'green', 'red' ] );
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
    </script>
    <style>
      #R-body img.bg-white {
        background-color: white;
      }
    </style>
  </head>
  <body class="mobile-support print" data-url="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_42_percentage_closer_filtering/index.html">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide">
              <button class="topbar-control" onclick="toggleNav()" type="button" title="Menu (CTRL&#43;ALT&#43;n)">
                <i class="fa-fw fas fa-bars"></i>
              </button>
            </div>
          </div>
          <ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype="http://schema.org/BreadcrumbList"><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../index.html"><span itemprop="name">主页</span></a><meta itemprop="position" content="1">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../computer_graphics/index.html"><span itemprop="name">计算机图形学</span></a><meta itemprop="position" content="2">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../computer_graphics/classic_tutorial/index.html"><span itemprop="name">经典教程</span></a><meta itemprop="position" content="3">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/index.html"><span itemprop="name">OpenGL教程</span></a><meta itemprop="position" content="4">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/index.html"><span itemprop="name">OGL dev 教程</span></a><meta itemprop="position" content="5">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><span itemprop="name">Tutorial 42:Percentage Closer Filtering</span><meta itemprop="position" content="6"></li>
          </ol>
          <div class="topbar-area topbar-area-end" data-area="end">
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable default" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="default">
            <header class="headline">
            </header>
<h1 id="tutorial-42percentage-closer-filtering">Tutorial 42:Percentage Closer Filtering</h1>

<h3 id="background">Background</h3>
<p>In <a href="https://ogldev.org/www/tutorial24/tutorial24.html" target="_blank">tutorial 24</a> we saw how to implement shadows using a technique called Shadow Mapping. The shadows that result from Shadow Mapping aren&rsquo;t that great and there is quite a lot of aliasing there, as you can see in the following picture:</p>
<p><a href="#R-image-2d455e22e24e5c789c61862f31741033" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_42_percentage_closer_filtering/../assets/no_pcf.png" alt="img" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-2d455e22e24e5c789c61862f31741033"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_42_percentage_closer_filtering/../assets/no_pcf.png" alt="img" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>This tutorial describes a method (one of many) to reduce that problem. It is called <em>Percentage Closer Filtering</em>, or PCF. The idea is to sample from the shadow map around the current pixel and compare its depth to all the samples. By averaging out the results we get a smoother line between light and shadow. For example, take a look at the following shadow map:</p>
<p><a href="#R-image-53638e0302db4fca4fb395006c99043e" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_42_percentage_closer_filtering/../assets/shadow_map.png" alt="img" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-53638e0302db4fca4fb395006c99043e"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_42_percentage_closer_filtering/../assets/shadow_map.png" alt="img" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Each cell contains the depth value for each pixel (when viewed from the light source). To make life simple, let&rsquo;s say that the depth of all the pixels above is 0.5 (when viewed from the camera point of view). According to the method from tutorial 24 all the pixels whose shadow map value is small than 0.5 will be in shadow while the ones whose shadow map value is greater than or equal to 0.5 will be in light. This will create a hard aliased line between light and shadow.</p>
<p>Now consider the following - the pixels that are nearest the border between light and shadow are surrounded by pixels who shadow map value is smaller than 0.5 as well as pixels whose shadow map value is greater than or equal to 0.5. If we sample these neighboring pixels and average out the results we will get a factor level that can help us smooth out the border between light and shadow. Ofcourse we don&rsquo;t know in advance what pixels are closest to that border so we simply do this sampling work for each pixel. This is basically the entire system. In this tutorial we will sample 9 pixels in a 3 by 3 kernel around each pixel and average out the result. This will be our shadow factor instead of the 0.5 or 1.0 which we have used as a factor in tutorial 24.</p>
<p>Let us now review the source code that implements PCF. We will do this by going over the changes made to the implementation of tutorial 24. You may want to do a short refresh on that tutorial to make things clearer here.</p>
<h3 id="source-walkthru">Source walkthru</h3>
<p>(lighting.fs:64)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">uniform</span> <span class="n">sampler2DShadow</span> <span class="n">gShadowMap</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="cp">#define EPSILON 0.00001
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="kt">float</span> <span class="nf">CalcShadowFactor</span><span class="p">(</span><span class="n">vec4</span> <span class="n">LightSpacePos</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  <span class="n">vec3</span> <span class="n">ProjCoords</span> <span class="o">=</span> <span class="n">LightSpacePos</span><span class="p">.</span><span class="n">xyz</span> <span class="o">/</span> <span class="n">LightSpacePos</span><span class="p">.</span><span class="n">w</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">  <span class="n">vec2</span> <span class="n">UVCoords</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  <span class="n">UVCoords</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">ProjCoords</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">10</span><span class="cl">  <span class="n">UVCoords</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">ProjCoords</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">11</span><span class="cl">  <span class="kt">float</span> <span class="n">z</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">ProjCoords</span><span class="p">.</span><span class="n">z</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">12</span><span class="cl">  
</span></span><span class="line"><span class="ln">13</span><span class="cl">  <span class="kt">float</span> <span class="n">xOffset</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">gMapSize</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">  <span class="kt">float</span> <span class="n">yOffset</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">gMapSize</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">
</span></span><span class="line"><span class="ln">16</span><span class="cl">  <span class="kt">float</span> <span class="n">Factor</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">
</span></span><span class="line"><span class="ln">18</span><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="p">;</span> <span class="n">y</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="p">;</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">      <span class="n">vec2</span> <span class="n">Offsets</span> <span class="o">=</span> <span class="n">vec2</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">xOffset</span><span class="p">,</span> <span class="n">y</span> <span class="o">*</span> <span class="n">yOffset</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">      <span class="n">vec3</span> <span class="n">UVC</span> <span class="o">=</span> <span class="n">vec3</span><span class="p">(</span><span class="n">UVCoords</span> <span class="o">+</span> <span class="n">Offsets</span><span class="p">,</span> <span class="n">z</span> <span class="o">+</span> <span class="n">EPSILON</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">      <span class="n">Factor</span> <span class="o">+=</span> <span class="n">texture</span><span class="p">(</span><span class="n">gShadowMap</span><span class="p">,</span> <span class="n">UVC</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl">
</span></span><span class="line"><span class="ln">26</span><span class="cl">  <span class="k">return</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">+</span> <span class="p">(</span><span class="n">Factor</span> <span class="o">/</span> <span class="mf">18.0</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>This is the updated shadow factor calculation function. It starts out the same where we manually perform perspective divide on clip space coordinates from the light source point of view, followed by a transformation from the (-1,+1) range to (0,1). We now have coordinates that we can use to sample from the shadow map and a Z value to compare against the sample result. From here on things are going to roll a bit differently. We are going to sample a 3 by 3 kernel so we need 9 texture coordinates altogether. The coordinates must result in sampling texels that are on one texel intervals on the X and/or Y axis. Since UV texture coordinates run from 0 to 1 and map into the texel ranges (0, Width-1) and (0, Height-1), respectively, we divide 1 by the width and height of the texture. These values are stored in the gMapSize uniform vector (see sources for more details). This gives us the offset in the texture coordinates space between two neighboring texels.</p>
<p>Next we perform a nested for loop and calculate the offset vector for each of the 9 texels we are going to sample. The last couple of lines inside the loop may seem a bit odd. We sample from the shadow map using a vector with 3 components (UVC) instead of just 2. The last component contains the value which we used in tutorial 24 to manually compare against the value from the shadow map (the light source Z plus a small epsilon to avoid Z-fighting). The change here is that we are using a sampler2DShadow as the type of &lsquo;gShadowMap&rsquo; instead of a sampler2D. When sampling from a shadow typed sampler (sampler1DShadow, sampler2DShadow, etc) the GPU performs a comparison between the texel value and a value that we supply as the last component of the texture coordinate vector (the second component for 1D, the third component for 2D, etc). We get a zero result if the comparison fails and one if the comparison succeeds. The type of comparison is configured using a GL API and not through GLSL. We will see this change later on. For now, just assume that we get a zero result for shadow and one for light. We accumulate the 9 results and divide them by 18. Thus we get a value between 0 and 0.5. We add it to a base of 0.5 and this is our shadow factor.</p>
<p>(shadow_map_fbo.cpp:39)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">bool</span> <span class="n">ShadowMapFBO</span><span class="o">::</span><span class="n">Init</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">WindowWidth</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">WindowHeight</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  <span class="c1">// Create the FBO  
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1"></span>  <span class="n">glGenFramebuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m_fbo</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">  <span class="c1">// Create the depth buffer  
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1"></span>  <span class="n">glGenTextures</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m_shadowMap</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">  <span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">m_shadowMap</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  <span class="n">glTexImage2D</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_DEPTH_COMPONENT32</span><span class="p">,</span> <span class="n">WindowWidth</span><span class="p">,</span> <span class="n">WindowHeight</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_DEPTH_COMPONENT</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">10</span><span class="cl">  <span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MIN_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">11</span><span class="cl">  <span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MAG_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">12</span><span class="cl">  <span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_COMPARE_MODE</span><span class="p">,</span> <span class="n">GL_COMPARE_REF_TO_TEXTURE</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">  <span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_COMPARE_FUNC</span><span class="p">,</span> <span class="n">GL_LEQUAL</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">	<span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_S</span><span class="p">,</span> <span class="n">GL_CLAMP_TO_EDGE</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">15</span><span class="cl">  <span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_T</span><span class="p">,</span> <span class="n">GL_CLAMP_TO_EDGE</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">16</span><span class="cl">  
</span></span><span class="line"><span class="ln">17</span><span class="cl">  <span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">m_fbo</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">18</span><span class="cl">  <span class="n">glFramebufferTexture2D</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">GL_DEPTH_ATTACHMENT</span><span class="p">,</span> <span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">m_shadowMap</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">19</span><span class="cl">  
</span></span><span class="line"><span class="ln">20</span><span class="cl">  <span class="c1">// Disable writes to the color buffer  
</span></span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="c1"></span>  <span class="n">glDrawBuffer</span><span class="p">(</span><span class="n">GL_NONE</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">22</span><span class="cl">  
</span></span><span class="line"><span class="ln">23</span><span class="cl">  <span class="c1">// Disable reads from the color buffer  
</span></span></span><span class="line"><span class="ln">24</span><span class="cl"><span class="c1"></span>  <span class="n">glReadBuffer</span><span class="p">(</span><span class="n">GL_NONE</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">25</span><span class="cl">  
</span></span><span class="line"><span class="ln">26</span><span class="cl">  <span class="n">GLenum</span> <span class="n">Status</span> <span class="o">=</span> <span class="n">glCheckFramebufferStatus</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">27</span><span class="cl">  
</span></span><span class="line"><span class="ln">28</span><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">Status</span> <span class="o">!=</span> <span class="n">GL_FRAMEBUFFER_COMPLETE</span><span class="p">)</span> <span class="p">{</span>    
</span></span><span class="line"><span class="ln">29</span><span class="cl">    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;FB error, status: 0x%x</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">Status</span><span class="p">);</span>    
</span></span><span class="line"><span class="ln">30</span><span class="cl">    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">31</span><span class="cl">  <span class="p">}</span>  
</span></span><span class="line"><span class="ln">32</span><span class="cl">  
</span></span><span class="line"><span class="ln">33</span><span class="cl">  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">34</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>This is how we configure our shadow map texture to work with the shadow sampler in the shader instead of the regular sampler. There are two new lines here and they are marked in bold face. First we set the texture compare mode to &lsquo;compare ref to texture&rsquo;. The only other possible value for the third parameter here is GL_NONE which is the default and makes the sampler behave in the regular, non-shadow, form. The second call to glTexParameteri sets the comparison function to &rsquo;less than or equal&rsquo;. This means that the result of the sample operation will be 1.0 if the reference value is less than or equal to the value in the texture and zero otherwise. You can also use GL_GEQUAL, GL_LESS, GL_GREATER, GL_EQUAL, GL_NOTEQUAL for similar types of comparisons. You get the idea. There are also GL_ALWAYS which always return 1.0 and GL_NEVER which always return 0.0.</p>
<p>(tutorial42.cpp:174)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="nf">ShadowMapPass</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  <span class="n">glCullFace</span><span class="p">(</span><span class="n">GL_FRONT</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="kt">void</span> <span class="nf">RenderPass</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  <span class="n">glCullFace</span><span class="p">(</span><span class="n">GL_BACK</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">10</span><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>The last point that I want to discuss is a minor change intended to avoid self shadowing. Self shadowing is a big problem when dealing with almost any shadowing technique and the reason is that the precision of the depth buffer is quite limited (even at 32 bits). The problem is specific to the polygons that are facing the light and are not in shadow. In the shadow map pass we render their depth into the shadow map and in the render pass we compare their depth against the value stored in the shadow map. Due to the depth precision problem we often get Z fighting which leads to some pixels being in shadow while others are in light. To reduce this problem we reverse culling so that we cull front facing polygons in the shadow map pass (and render only the back facing polygons into the shadow map). In the render pass we are back to the usual culling. Since real world occluders are generally closed volumes it is ok to use the back facing polygons for depth comparison and not the front facing ones. You should try to disable the code above and see the results for yourself.</p>
<p>After applying all the changes that we discussed the shadow looks like this:</p>
<p><a href="#R-image-20a92ce4491d105e51d1a4a53aefc8fb" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_42_percentage_closer_filtering/../assets/pcf.png" alt="img" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-20a92ce4491d105e51d1a4a53aefc8fb"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_42_percentage_closer_filtering/../assets/pcf.png" alt="img" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>

            <footer class="footline">
            </footer>
          </article>

        </div>
      </main>
    </div>
    <script src="../../../../../js/clipboard.min.js?1708235103" defer></script>
    <script src="../../../../../js/perfect-scrollbar.min.js?1708235103" defer></script>
    <script src="../../../../../js/theme.js?1708235103" defer></script>
  </body>
</html>
