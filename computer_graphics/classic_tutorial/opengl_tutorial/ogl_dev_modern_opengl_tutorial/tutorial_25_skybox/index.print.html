<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.122.0">
    <meta name="generator" content="Relearn 5.23.2+tip">
    <meta name="description" content="啊啊啊啊">
    <meta name="author" content="Sören Weber">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="https://example.com/images/hero.png">
    <meta name="twitter:title" content="Tutorial 25:SkyBox :: Hugo Relearn Theme">
    <meta name="twitter:description" content="Background A skybox is a technique that makes the scene looks bigger and more impressive by wrapping the viewer with a texture that goes around the camera 360 degrees. The texture is often a combination between the sky and a terrain type such as mountains, skyscapers, etc. As the player explores his surroundings he keeps seeing a part of the skybox hovering above the real models and filling up all those empty pixels.">
    <meta property="og:title" content="Tutorial 25:SkyBox :: Hugo Relearn Theme">
    <meta property="og:description" content="Background A skybox is a technique that makes the scene looks bigger and more impressive by wrapping the viewer with a texture that goes around the camera 360 degrees. The texture is often a combination between the sky and a terrain type such as mountains, skyscapers, etc. As the player explores his surroundings he keeps seeing a part of the skybox hovering above the real models and filling up all those empty pixels.">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://example.com/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_25_skybox/index.html">
    <meta property="og:image" content="https://example.com/images/hero.png">
    <meta property="article:section" content="OGL dev 教程 :: Hugo Relearn Theme">
    <meta property="og:site_name" content="Hugo Relearn Theme">
    <title>Tutorial 25:SkyBox :: Hugo Relearn Theme</title>
    <link href="https://example.com/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_25_skybox/index.html" rel="canonical" type="text/html" title="Tutorial 25:SkyBox :: Hugo Relearn Theme">
    <link href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_25_skybox/index.xml" rel="alternate" type="application/rss+xml" title="Tutorial 25:SkyBox :: Hugo Relearn Theme"><link rel="icon" href="../../../../../images/favicon.ico">
    <!-- https://github.com/filamentgroup/loadCSS/blob/master/README.md#how-to-use -->
    <link href="../../../../../css/fontawesome-all.min.css?1708235103" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../../../../../css/fontawesome-all.min.css?1708235103" rel="stylesheet"></noscript>
    <link href="../../../../../css/nucleus.css?1708235103" rel="stylesheet">
    <link href="../../../../../css/auto-complete.css?1708235103" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../../../../../css/auto-complete.css?1708235103" rel="stylesheet"></noscript>
    <link href="../../../../../css/perfect-scrollbar.min.css?1708235103" rel="stylesheet">
    <link href="../../../../../css/fonts.css?1708235103" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../../../../../css/fonts.css?1708235103" rel="stylesheet"></noscript>
    <link href="../../../../../css/theme.css?1708235103" rel="stylesheet">
    <link href="../../../../../css/theme-auto.css?1708235103" rel="stylesheet" id="R-variant-style">
    <link href="../../../../../css/variant.css?1708235103" rel="stylesheet">
    <link href="../../../../../css/print.css?1708235103" rel="stylesheet" media="print">
    <link href="../../../../../css/format-print.css?1708235103" rel="stylesheet">
    <link href="../../../../../css/ie.css?1708235103" rel="stylesheet">
    <script src="../../../../../js/url.js?1708235103"></script>
    <script src="../../../../../js/variant.js?1708235103"></script>
    <script>
      // hack to let hugo tell us how to get to the root when using relativeURLs, it needs to be called *url= for it to do its magic:
      // https://github.com/gohugoio/hugo/blob/145b3fcce35fbac25c7033c91c1b7ae6d1179da8/transform/urlreplacers/absurlreplacer.go#L72
      window.index_js_url="../../../../../index.search.js";
      var root_url="../../../../../";
      var baseUri=root_url.replace(/\/$/, '');
      window.relearn = window.relearn || {};
      window.relearn.baseUriFull='https:\/\/example.com/';
      // variant stuff
      window.variants && variants.init( [ 'auto', 'relearn-light', 'relearn-dark', 'zen-light', 'zen-dark', 'neon', 'learn', 'blue', 'green', 'red' ] );
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
    </script>
    <style>
      #R-body img.bg-white {
        background-color: white;
      }
    </style>
  </head>
  <body class="mobile-support print" data-url="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_25_skybox/index.html">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide">
              <button class="topbar-control" onclick="toggleNav()" type="button" title="Menu (CTRL&#43;ALT&#43;n)">
                <i class="fa-fw fas fa-bars"></i>
              </button>
            </div>
          </div>
          <ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype="http://schema.org/BreadcrumbList"><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../index.html"><span itemprop="name">主页</span></a><meta itemprop="position" content="1">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../computer_graphics/index.html"><span itemprop="name">计算机图形学</span></a><meta itemprop="position" content="2">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../computer_graphics/classic_tutorial/index.html"><span itemprop="name">经典教程</span></a><meta itemprop="position" content="3">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/index.html"><span itemprop="name">OpenGL教程</span></a><meta itemprop="position" content="4">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/index.html"><span itemprop="name">OGL dev 教程</span></a><meta itemprop="position" content="5">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><span itemprop="name">Tutorial 25:SkyBox</span><meta itemprop="position" content="6"></li>
          </ol>
          <div class="topbar-area topbar-area-end" data-area="end">
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable default" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="default">
            <header class="headline">
            </header>
<h1 id="tutorial-25skybox">Tutorial 25:SkyBox</h1>

<h3 id="background">Background</h3>
<p>A skybox is a technique that makes the scene looks bigger and more impressive by wrapping the viewer with a texture that goes around the camera 360 degrees. The texture is often a combination between the sky and a terrain type such as mountains, skyscapers, etc. As the player explores his surroundings he keeps seeing a part of the skybox hovering above the real models and filling up all those empty pixels. Here&rsquo;s an example of a skybox from the game Half-Life:</p>
<p><a href="#R-image-30e7f27a959fecf73e13376d6dbfe739" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_25_skybox/../assets/Halflife_skybox.jpeg" alt="img" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-30e7f27a959fecf73e13376d6dbfe739"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_25_skybox/../assets/Halflife_skybox.jpeg" alt="img" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>The idea behind the skybox is to render a big cube and place the viewer at its center. As the camera moves the cube follows it so that the viewer can never reach the &ldquo;horizon&rdquo; of the scene. This is similar to real life where we see the sky &ldquo;touch&rdquo; the earth on the horizon but when we move toward the horizon it remains at the same distance from us (pending on land type, etc).</p>
<p>A special type of texture is mapped on the cube. This texture is created in such a way that if it is cut and folded properly it creates a box where the contents along the edges of the internal faces are perfectly aligned with one another and create a sense of continuity for someone who is located inside the box. For example, see the following texture:</p>
<p><a href="#R-image-4c9f95ddb154d9e6f7233b25759e65e0" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_25_skybox/../assets/skybox.jpeg" alt="img" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-4c9f95ddb154d9e6f7233b25759e65e0"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_25_skybox/../assets/skybox.jpeg" alt="img" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>If we cut away the white margins of the texture above and fold the remaining parts along the white lines we will get a box with the required properties. OpenGL calls such a texture a <em>Cubemap</em>.</p>
<p>In order to sample from the cubemap we will use a 3D texture coordinate instead of the 2D coordinate that we have been using thus far. The texture sampler will use this 3D coordinate as a vector and will first find out which of the six faces of the cubemap contains the required texel and then fetch it from within that face. This process can be seen in the following picture which is taken from above (looking down at the box):</p>
<p><a href="#R-image-dc3bb588073e9545c082efb88237f192" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_25_skybox/../assets/texel_fetch.png" alt="img" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-dc3bb588073e9545c082efb88237f192"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_25_skybox/../assets/texel_fetch.png" alt="img" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>The proper face is selected based on the highest magnitude component of the texture coordinate. In the above example we see that Z has the largest magnitude (Y cannot be seen but let&rsquo;s assume it is smaller than Z). Since Z has a positive sign the texture sampler will use the face entitled &lsquo;PosZ&rsquo; and will fetch the texel from there (the remaining faces are &lsquo;NegZ&rsquo;, &lsquo;PosX&rsquo;, &lsquo;NegX&rsquo;, &lsquo;PosY&rsquo; and &lsquo;NegY&rsquo;).</p>
<p>The skybox technique can actually be implemented using a sphere as well as a box. The only difference is that the length of all possible direction vectors in a sphere is equal (since they represent the radius of the sphere) while in a box there are different lengths. The mechanism for texel fetching remains the same. A skybox which uses a sphere is sometimes called a <em>skydome</em>. This is what we will use for the demo of this tutorial. You should play with both options and see what works best for you.</p>
<h3 id="source-walkthru">Source walkthru</h3>
<p>(ogldev_cubemap_texture.h:28)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">class</span> <span class="nc">CubemapTexture</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="k">public</span><span class="o">:</span>  
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  <span class="n">CubemapTexture</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">Directory</span><span class="p">,</span>    
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">                 <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">PosXFilename</span><span class="p">,</span>    
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">                 <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">NegXFilename</span><span class="p">,</span>    
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">                 <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">PosYFilename</span><span class="p">,</span>    
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">                 <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">NegYFilename</span><span class="p">,</span>    
</span></span><span class="line"><span class="ln">10</span><span class="cl">                 <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">PosZFilename</span><span class="p">,</span>    
</span></span><span class="line"><span class="ln">11</span><span class="cl">                 <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">NegZFilename</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">12</span><span class="cl">  
</span></span><span class="line"><span class="ln">13</span><span class="cl">  <span class="o">~</span><span class="n">CubemapTexture</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln">14</span><span class="cl">  
</span></span><span class="line"><span class="ln">15</span><span class="cl">  <span class="kt">bool</span> <span class="nf">Load</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln">16</span><span class="cl">  
</span></span><span class="line"><span class="ln">17</span><span class="cl">  <span class="kt">void</span> <span class="nf">Bind</span><span class="p">(</span><span class="n">GLenum</span> <span class="n">TextureUnit</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">  
</span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="k">private</span><span class="o">:</span>  
</span></span><span class="line"><span class="ln">20</span><span class="cl">  
</span></span><span class="line"><span class="ln">21</span><span class="cl">  <span class="n">string</span> <span class="n">m_fileNames</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>  
</span></span><span class="line"><span class="ln">22</span><span class="cl">  <span class="n">GLuint</span> <span class="n">m_textureObj</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl"><span class="p">};</span></span></span></code></pre></div><p>This class wraps the OpenGL implementation of the cubemap texture and provides a simple interface to load and use the cubemap. The constructor takes a directory and six filenames of image files that contain the cubemap faces. For simplicity we assume that all files exist in the same directory. We need to call the function Load() once during startup in order to load the image files and create the OpenGL texture object. The attributes of the class are the image filenames (stored with the full path this time) and the OpenGL texture object handle. This single handle provides access to all six faces of the cubemap. During runtime Bind() must be called with the proper texture unit in order to make the cubemap available to the shader.</p>
<p>(cubemap_texture.cpp:60)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">bool</span> <span class="n">CubemapTexture</span><span class="o">::</span><span class="n">Load</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  <span class="n">glGenTextures</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m_textureObj</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  <span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_CUBE_MAP</span><span class="p">,</span> <span class="n">m_textureObj</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">  <span class="n">Magick</span><span class="o">::</span><span class="n">Image</span><span class="o">*</span> <span class="n">pImage</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  <span class="n">Magick</span><span class="o">::</span><span class="n">Blob</span> <span class="n">blob</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE_IN_ELEMENTS</span><span class="p">(</span><span class="n">types</span><span class="p">)</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>    
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="n">pImage</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Magick</span><span class="o">::</span><span class="n">Image</span><span class="p">(</span><span class="n">m_fileNames</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>    
</span></span><span class="line"><span class="ln">11</span><span class="cl">    
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="k">try</span> <span class="p">{</span>      
</span></span><span class="line"><span class="ln">13</span><span class="cl">      <span class="n">pImage</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">blob</span><span class="p">,</span> <span class="s">&#34;RGBA&#34;</span><span class="p">);</span>    
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="p">}</span>    
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="k">catch</span> <span class="p">(</span><span class="n">Magick</span><span class="o">::</span><span class="n">Error</span><span class="o">&amp;</span> <span class="n">Error</span><span class="p">)</span> <span class="p">{</span>      
</span></span><span class="line"><span class="ln">16</span><span class="cl">      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Error loading texture &#39;&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">m_fileNames</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;&#39;: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">Error</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>      
</span></span><span class="line"><span class="ln">17</span><span class="cl">      <span class="k">delete</span> <span class="n">pImage</span><span class="p">;</span>      
</span></span><span class="line"><span class="ln">18</span><span class="cl">      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>    
</span></span><span class="line"><span class="ln">19</span><span class="cl">    <span class="p">}</span>    
</span></span><span class="line"><span class="ln">20</span><span class="cl">    
</span></span><span class="line"><span class="ln">21</span><span class="cl">    <span class="n">glTexImage2D</span><span class="p">(</span><span class="n">types</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGB</span><span class="p">,</span> <span class="n">pImage</span><span class="o">-&gt;</span><span class="n">columns</span><span class="p">(),</span> <span class="n">pImage</span><span class="o">-&gt;</span><span class="n">rows</span><span class="p">(),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGBA</span><span class="p">,</span>      <span class="n">GL_UNSIGNED_BYTE</span><span class="p">,</span> <span class="n">blob</span><span class="p">.</span><span class="n">data</span><span class="p">());</span>  
</span></span><span class="line"><span class="ln">22</span><span class="cl">    <span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_CUBE_MAP</span><span class="p">,</span> <span class="n">GL_TEXTURE_MAG_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">23</span><span class="cl">    <span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_CUBE_MAP</span><span class="p">,</span> <span class="n">GL_TEXTURE_MIN_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">24</span><span class="cl">    <span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_CUBE_MAP</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_S</span><span class="p">,</span> <span class="n">GL_CLAMP_TO_EDGE</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">25</span><span class="cl">    <span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_CUBE_MAP</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_T</span><span class="p">,</span> <span class="n">GL_CLAMP_TO_EDGE</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">26</span><span class="cl">    <span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_CUBE_MAP</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_R</span><span class="p">,</span> <span class="n">GL_CLAMP_TO_EDGE</span><span class="p">);</span>    
</span></span><span class="line"><span class="ln">27</span><span class="cl">    
</span></span><span class="line"><span class="ln">28</span><span class="cl">    <span class="k">delete</span> <span class="n">pImage</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">29</span><span class="cl">  <span class="p">}</span>  
</span></span><span class="line"><span class="ln">30</span><span class="cl">  
</span></span><span class="line"><span class="ln">31</span><span class="cl">  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">32</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>The function that loads the cubemap texture starts by generating a texture object. This object is bound to the special GL_TEXTURE_CUBE_MAP target. After that we loop over the &rsquo;types&rsquo; array which contains the GL enums that represent the cubemap faces (GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, etc). These enums match the attribute string vector &rsquo;m_fileNames&rsquo; which simplifies the loop. The image files are loaded one by one by ImageMagick and then specified to OpenGL using glTexImage2D(). Note that each call to this function is done using the proper GL enum for that face (which is why the &rsquo;types&rsquo; array and &rsquo;m_fileNames&rsquo; must match). After the cubemap is loaded and populated we setup some configuration flags. You should be familiar with all these flags except GL_TEXTURE_WRAP_R. This enum simply refers to the third dimension of the texture coordinate. We set it to the same clamping mode as the other dimensions.</p>
<p>(cubemap_texture.cpp:95)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">void</span> <span class="n">CubemapTexture</span><span class="o">::</span><span class="n">Bind</span><span class="p">(</span><span class="n">GLenum</span> <span class="n">TextureUnit</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln">3</span><span class="cl">  <span class="n">glActiveTexture</span><span class="p">(</span><span class="n">TextureUnit</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">4</span><span class="cl">  <span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_CUBE_MAP</span><span class="p">,</span> <span class="n">m_textureObj</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>This function must be called before the texture can be used for drawing the skybox. The target for the bind function is GL_TEXTURE_CUBE_MAP which is the same enum we used in the Load() function.</p>
<p>(skybox_technique.h:25)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">class</span> <span class="nc">SkyboxTechnique</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Technique</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="k">public</span><span class="o">:</span>  
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  <span class="n">SkyboxTechnique</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">Init</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  <span class="kt">void</span> <span class="nf">SetWVP</span><span class="p">(</span><span class="k">const</span> <span class="n">Matrix4f</span><span class="o">&amp;</span> <span class="n">WVP</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">10</span><span class="cl">  <span class="kt">void</span> <span class="nf">SetTextureUnit</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">TextureUnit</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">  
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="k">private</span><span class="o">:</span>  
</span></span><span class="line"><span class="ln">13</span><span class="cl">  <span class="n">GLuint</span> <span class="n">m_WVPLocation</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">14</span><span class="cl">  <span class="n">GLuint</span> <span class="n">m_textureLocation</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="p">};</span></span></span></code></pre></div><p>The skybox is rendered using its own special technique. This technique has only a couple of attributes that the caller must specify - a WVP matrix to transform the box or the sphere and a texture to map on it. Let&rsquo;s see the internals of this class.</p>
<p>(skybox.vs)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">Position</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">uniform</span> <span class="n">mat4</span> <span class="n">gWVP</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="n">out</span> <span class="n">vec3</span> <span class="n">TexCoord0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln">11</span><span class="cl">  <span class="n">vec4</span> <span class="n">WVP_Pos</span> <span class="o">=</span> <span class="n">gWVP</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">Position</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">12</span><span class="cl">  <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">WVP_Pos</span><span class="p">.</span><span class="n">xyww</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">13</span><span class="cl">  <span class="n">TexCoord0</span> <span class="o">=</span> <span class="n">Position</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>This is the vertex shader of the skybox technique. It&rsquo;s actually quite simple but you must be aware of a couple of tricks. The first trick is that we transform the incoming position vector using the WVP matrix as always, but in the vector that goes to the fragment shader we override the Z component with the W component. What happens here is that after the vertex shader is complete the rasterizer takes gl_Position vector and performs perspective divide (division by W) in order to complete the projection. When we set Z to W we guarantee that the final Z value of the position will be 1.0. This Z value is always mapped to the far Z. This means that the skybox will always fail the depth test against the other models in the scene. That way the skybox will only take up the background left between the models and everything else will be infront of it, which is exactly what we expect from it.</p>
<p>The second trick here is that we use the original position in object space as the 3D texture coordinate. This makes sense because the way sampling from the cubemap works is by shooting a vector from the origin through a point in the box or sphere. So the position of the point actually becomes the texture coordinate. The vertex shader passes the object space coordinate of each vertex as the texture coordinate (8 vertices in the case of a cube and probably much more for a sphere) and it gets interpolated by the rasterizer for each pixel. This gives us the position of the pixel which we can use for sampling.</p>
<p>(skybox.fs)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">in</span> <span class="n">vec3</span> <span class="n">TexCoord0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">out</span> <span class="n">vec4</span> <span class="n">FragColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="n">uniform</span> <span class="n">samplerCube</span> <span class="n">gCubemapTexture</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln">11</span><span class="cl">  <span class="n">FragColor</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">gCubemapTexture</span><span class="p">,</span> <span class="n">TexCoord0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>The fragment shader is extremely simple. The only thing worth noting here is that we use a &lsquo;samplerCube&rsquo; rather than a &lsquo;sampler2D&rsquo; in order to access the cubemap.</p>
<p>(skybox.h:27)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">class</span> <span class="nc">SkyBox</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="k">public</span><span class="o">:</span>  
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  <span class="n">SkyBox</span><span class="p">(</span><span class="k">const</span> <span class="n">Camera</span><span class="o">*</span> <span class="n">pCamera</span><span class="p">,</span> <span class="k">const</span> <span class="n">PersProjInfo</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">  <span class="o">~</span><span class="n">SkyBox</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">  <span class="kt">bool</span> <span class="nf">Init</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">Directory</span><span class="p">,</span>    
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">            <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">PosXFilename</span><span class="p">,</span>    
</span></span><span class="line"><span class="ln">10</span><span class="cl">            <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">NegXFilename</span><span class="p">,</span>    
</span></span><span class="line"><span class="ln">11</span><span class="cl">            <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">PosYFilename</span><span class="p">,</span>    
</span></span><span class="line"><span class="ln">12</span><span class="cl">            <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">NegYFilename</span><span class="p">,</span>    
</span></span><span class="line"><span class="ln">13</span><span class="cl">            <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">PosZFilename</span><span class="p">,</span>    
</span></span><span class="line"><span class="ln">14</span><span class="cl">            <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">NegZFilename</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">15</span><span class="cl">  
</span></span><span class="line"><span class="ln">16</span><span class="cl">  <span class="kt">void</span> <span class="nf">Render</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">  
</span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="k">private</span><span class="o">:</span>  
</span></span><span class="line"><span class="ln">19</span><span class="cl">  <span class="n">SkyboxTechnique</span><span class="o">*</span> <span class="n">m_pSkyboxTechnique</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">20</span><span class="cl">  <span class="k">const</span> <span class="n">Camera</span><span class="o">*</span> <span class="n">m_pCamera</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">21</span><span class="cl">  <span class="n">CubemapTexture</span><span class="o">*</span> <span class="n">m_pCubemapTex</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">22</span><span class="cl">  <span class="n">Mesh</span><span class="o">*</span> <span class="n">m_pMesh</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">23</span><span class="cl">  <span class="n">PersProjInfo</span> <span class="n">m_persProjInfo</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl"><span class="p">};</span></span></span></code></pre></div><p>Rendering of the skybox involves several components - a technique, a cubemap texture and a box or sphere model. To simplify its usage this class is suggested as a solution that brings all these components under the same roof. It is initialized once during startup with the directory and filenames of the cubemap texture and then used during runtime by calling Render(). A single function call takes care of everything. Note that in addition to the above components the class also have access to the camera and the perspective projection values (FOV, Z and screen dimensions). This is so that it can populate the Pipeline class properly.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="n">SkyBox</span><span class="o">::</span><span class="n">Render</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  <span class="n">m_pSkyboxTechnique</span><span class="o">-&gt;</span><span class="n">Enable</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  <span class="n">GLint</span> <span class="n">OldCullFaceMode</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">  <span class="n">glGetIntegerv</span><span class="p">(</span><span class="n">GL_CULL_FACE_MODE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">OldCullFaceMode</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  <span class="n">GLint</span> <span class="n">OldDepthFuncMode</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">  <span class="n">glGetIntegerv</span><span class="p">(</span><span class="n">GL_DEPTH_FUNC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">OldDepthFuncMode</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  
</span></span><span class="line"><span class="ln">10</span><span class="cl">  <span class="n">glCullFace</span><span class="p">(</span><span class="n">GL_FRONT</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">11</span><span class="cl">  <span class="n">glDepthFunc</span><span class="p">(</span><span class="n">GL_LEQUAL</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">12</span><span class="cl">  
</span></span><span class="line"><span class="ln">13</span><span class="cl">  <span class="n">Pipeline</span> <span class="n">p</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">14</span><span class="cl">  <span class="n">p</span><span class="p">.</span><span class="n">Scale</span><span class="p">(</span><span class="mf">20.0f</span><span class="p">,</span> <span class="mf">20.0f</span><span class="p">,</span> <span class="mf">20.0f</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">15</span><span class="cl">  <span class="n">p</span><span class="p">.</span><span class="n">Rotate</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">16</span><span class="cl">  <span class="n">p</span><span class="p">.</span><span class="n">WorldPos</span><span class="p">(</span><span class="n">m_pCamera</span><span class="o">-&gt;</span><span class="n">GetPos</span><span class="p">().</span><span class="n">x</span><span class="p">,</span> <span class="n">m_pCamera</span><span class="o">-&gt;</span><span class="n">GetPos</span><span class="p">().</span><span class="n">y</span><span class="p">,</span> <span class="n">m_pCamera</span><span class="o">-&gt;</span><span class="n">GetPos</span><span class="p">().</span><span class="n">z</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">17</span><span class="cl">  <span class="n">p</span><span class="p">.</span><span class="n">SetCamera</span><span class="p">(</span><span class="n">m_pCamera</span><span class="o">-&gt;</span><span class="n">GetPos</span><span class="p">(),</span> <span class="n">m_pCamera</span><span class="o">-&gt;</span><span class="n">GetTarget</span><span class="p">(),</span> <span class="n">m_pCamera</span><span class="o">-&gt;</span><span class="n">GetUp</span><span class="p">());</span>  
</span></span><span class="line"><span class="ln">18</span><span class="cl">  <span class="n">p</span><span class="p">.</span><span class="n">SetPerspectiveProj</span><span class="p">(</span><span class="n">m_persProjInfo</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">19</span><span class="cl">  <span class="n">m_pSkyboxTechnique</span><span class="o">-&gt;</span><span class="n">SetWVP</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">GetWVPTrans</span><span class="p">());</span>  
</span></span><span class="line"><span class="ln">20</span><span class="cl">  <span class="n">m_pCubemapTex</span><span class="o">-&gt;</span><span class="n">Bind</span><span class="p">(</span><span class="n">GL_TEXTURE0</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">21</span><span class="cl">  <span class="n">m_pMesh</span><span class="o">-&gt;</span><span class="n">Render</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln">22</span><span class="cl">  
</span></span><span class="line"><span class="ln">23</span><span class="cl">  <span class="n">glCullFace</span><span class="p">(</span><span class="n">OldCullFaceMode</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">24</span><span class="cl">  <span class="n">glDepthFunc</span><span class="p">(</span><span class="n">OldDepthFuncMode</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>This function takes care of rendering the skybox. We start by enabling the skybox technique. Then a new OpenGL API is introduced - glGetIntegerv(). This function returns the state of OpenGL for the enum specified as the first parameter. The second parameter is the address of an array of integers that receives the state (in our case only a single integer is enough). We must use the proper Get* function according to the type of the state - glGetIntegerv(), glGetBooleanv(), glGetInteger64v(), glGetFloatv() and glGetDoublev(). The reason why glGetIntegerv() is used here is because we are going to change a couple of common state values that are usually set in glut_backend.cpp in all of the tutorials. We want to do that in a way which is transparent to the other parts of the code and one solution is to retrieve the current status, make the proper changes and finally restore the original state. That way the rest of the system doesn&rsquo;t need to know that something was changed.</p>
<p>The first thing that we change is the culling mode. Usually, we want to cull the triangles that are facing away from the camera. However, in the case of a skybox the camera is placed inside of a box so we want to see their front, rather than their back. The problem is that in the generic sphere model which is used here the external triangles are considered front facing while the internal are backfacing (this is a dependency on the order of the vertices). We can either change the model or reverse the culling state of OpenGL. The later solution is preferable so that the same sphere model can remain generic and usable for other cases. Therefore, we tell OpenGL to cull front facing triangles.</p>
<p>The second thing that we change is the depth test function. By default, we tell OpenGL that an incoming fragment wins the depth test if its Z value is less than the stored one. However, in the case of a skybox the Z value is always the far Z (see above). The far Z is clipped when the depth test function is set to &ldquo;less than&rdquo;. To make it part of the scene we change the depth function to &ldquo;less than or equal&rdquo;.</p>
<p>The next thing this function does is to calculate the WVP matrix. Note that the world position of the skybox is set at the camera. This will keep the camera at its center the whole time. After that the cubemap texture is bound to texture unit 0 (this texture unit was also configured in SkyboxTechnique when it was created in SkyBox::Init()). Then the sphere mesh is rendered. Finally, the original cull mode and depth function are restored.</p>
<p>An interesting performance tip is to always render the skybox last (after all the other models). The reason is that we know that it will always be behind the other objects in the scene. Some GPUs have optimization mechanisms that allow them to do an early depth test and discard a fragment if it fails the test without executing the fragment shader. This is especially helpful in the case of the skybox because then the fragment shader will only run for the pixel encompasing the &ldquo;background&rdquo; of the scene and not the ones that are covered by the other models. But to make it happen we must get the depth buffer populated with all the Z values so that by the time the skybox is rendered all the information is already there.</p>

            <footer class="footline">
            </footer>
          </article>

        </div>
      </main>
    </div>
    <script src="../../../../../js/clipboard.min.js?1708235103" defer></script>
    <script src="../../../../../js/perfect-scrollbar.min.js?1708235103" defer></script>
    <script src="../../../../../js/theme.js?1708235103" defer></script>
  </body>
</html>
