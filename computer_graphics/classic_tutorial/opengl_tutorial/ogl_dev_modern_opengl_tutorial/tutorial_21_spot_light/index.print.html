<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.122.0">
    <meta name="generator" content="Relearn 5.23.2+tip">
    <meta name="description" content="啊啊啊啊">
    <meta name="author" content="Sören Weber">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="https://example.com/images/hero.png">
    <meta name="twitter:title" content="Tutorial 21:Spot Light :: Hugo Relearn Theme">
    <meta name="twitter:description" content="Background The spot light is the third and final light type that we will review (at least for a little while&hellip;). It is more complex than directional light and point light and essentially borrows stuff from both. The spot light has an origin position and is under the effect of attenuation as distance from target grows (as point light) and its light is pointed at a specific direction (as directional light).">
    <meta property="og:title" content="Tutorial 21:Spot Light :: Hugo Relearn Theme">
    <meta property="og:description" content="Background The spot light is the third and final light type that we will review (at least for a little while&hellip;). It is more complex than directional light and point light and essentially borrows stuff from both. The spot light has an origin position and is under the effect of attenuation as distance from target grows (as point light) and its light is pointed at a specific direction (as directional light).">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://example.com/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_21_spot_light/index.html">
    <meta property="og:image" content="https://example.com/images/hero.png">
    <meta property="article:section" content="OGL dev 教程 :: Hugo Relearn Theme">
    <meta property="og:site_name" content="Hugo Relearn Theme">
    <title>Tutorial 21:Spot Light :: Hugo Relearn Theme</title>
    <link href="https://example.com/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_21_spot_light/index.html" rel="canonical" type="text/html" title="Tutorial 21:Spot Light :: Hugo Relearn Theme">
    <link href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_21_spot_light/index.xml" rel="alternate" type="application/rss+xml" title="Tutorial 21:Spot Light :: Hugo Relearn Theme"><link rel="icon" href="../../../../../images/favicon.ico">
    <!-- https://github.com/filamentgroup/loadCSS/blob/master/README.md#how-to-use -->
    <link href="../../../../../css/fontawesome-all.min.css?1708235103" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../../../../../css/fontawesome-all.min.css?1708235103" rel="stylesheet"></noscript>
    <link href="../../../../../css/nucleus.css?1708235103" rel="stylesheet">
    <link href="../../../../../css/auto-complete.css?1708235103" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../../../../../css/auto-complete.css?1708235103" rel="stylesheet"></noscript>
    <link href="../../../../../css/perfect-scrollbar.min.css?1708235103" rel="stylesheet">
    <link href="../../../../../css/fonts.css?1708235103" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../../../../../css/fonts.css?1708235103" rel="stylesheet"></noscript>
    <link href="../../../../../css/theme.css?1708235103" rel="stylesheet">
    <link href="../../../../../css/theme-auto.css?1708235103" rel="stylesheet" id="R-variant-style">
    <link href="../../../../../css/variant.css?1708235103" rel="stylesheet">
    <link href="../../../../../css/print.css?1708235103" rel="stylesheet" media="print">
    <link href="../../../../../css/format-print.css?1708235103" rel="stylesheet">
    <link href="../../../../../css/ie.css?1708235103" rel="stylesheet">
    <script src="../../../../../js/url.js?1708235103"></script>
    <script src="../../../../../js/variant.js?1708235103"></script>
    <script>
      // hack to let hugo tell us how to get to the root when using relativeURLs, it needs to be called *url= for it to do its magic:
      // https://github.com/gohugoio/hugo/blob/145b3fcce35fbac25c7033c91c1b7ae6d1179da8/transform/urlreplacers/absurlreplacer.go#L72
      window.index_js_url="../../../../../index.search.js";
      var root_url="../../../../../";
      var baseUri=root_url.replace(/\/$/, '');
      window.relearn = window.relearn || {};
      window.relearn.baseUriFull='https:\/\/example.com/';
      // variant stuff
      window.variants && variants.init( [ 'auto', 'relearn-light', 'relearn-dark', 'zen-light', 'zen-dark', 'neon', 'learn', 'blue', 'green', 'red' ] );
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
    </script>
    <style>
      #R-body img.bg-white {
        background-color: white;
      }
    </style>
  </head>
  <body class="mobile-support print" data-url="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_21_spot_light/index.html">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide">
              <button class="topbar-control" onclick="toggleNav()" type="button" title="Menu (CTRL&#43;ALT&#43;n)">
                <i class="fa-fw fas fa-bars"></i>
              </button>
            </div>
          </div>
          <ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype="http://schema.org/BreadcrumbList"><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../index.html"><span itemprop="name">主页</span></a><meta itemprop="position" content="1">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../computer_graphics/index.html"><span itemprop="name">计算机图形学</span></a><meta itemprop="position" content="2">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../computer_graphics/classic_tutorial/index.html"><span itemprop="name">经典教程</span></a><meta itemprop="position" content="3">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/index.html"><span itemprop="name">OpenGL教程</span></a><meta itemprop="position" content="4">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/index.html"><span itemprop="name">OGL dev 教程</span></a><meta itemprop="position" content="5">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><span itemprop="name">Tutorial 21:Spot Light</span><meta itemprop="position" content="6"></li>
          </ol>
          <div class="topbar-area topbar-area-end" data-area="end">
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable default" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="default">
            <header class="headline">
            </header>
<h1 id="tutorial-21spot-light">Tutorial 21:Spot Light</h1>

<h3 id="background">Background</h3>
<p>The spot light is the third and final light type that we will review (at least for a little while&hellip;). It is more complex than directional light and point light and essentially borrows stuff from both. The spot light has an origin position and is under the effect of attenuation as distance from target grows (as point light) and its light is pointed at a specific direction (as directional light). The spot light adds the unique attribute of shedding light only within a limited cone that grows wider as light moves further away from its origin. A good example for a spot light is the flashlight. Spot lights are very useful when the character in the game you are developing is exploring an underground dungeon or escaping from prison.</p>
<p>We already know all the tools to develop the spot light. The missing piece is the cone effect of this light type. Take a look at the following picture:</p>
<p><a href="#R-image-59e27904424398f80cb7c6a9ce341ce0" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_21_spot_light/../assets/spotlight.png" alt="img" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-59e27904424398f80cb7c6a9ce341ce0"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_21_spot_light/../assets/spotlight.png" alt="img" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>The spot light direction is defined as the black arrow that points straight down. We want our light to have an effect only on the area limited within the two red lines. The dot product operation again comes to the rescue. We can define the cone of light as the angle between each of the red lines and the light direction (i.e. half the angle between the red lines). We can take the cosine &lsquo;C&rsquo; of that angle and perform a dot product between the light direction &lsquo;L&rsquo; and the vector &lsquo;V&rsquo; from the light origin to the pixel. If the result of the dot product is larger than &lsquo;C&rsquo; (remember that a cosine result grows larger as the angle grows smaller), then the angle between &lsquo;L&rsquo; and &lsquo;V&rsquo; is smaller than the angle between &lsquo;L&rsquo; and the two red lines that define the spot light cone. In that case we want the pixel to receive light. If the angle is larger the pixel does not receive any light from the spot light. In the example above a dot product between &lsquo;L&rsquo; and &lsquo;V&rsquo; will yield a result which is smaller than the dot product between &lsquo;L&rsquo; and either one of the red lines (it is quite obvious that the angle between &lsquo;L&rsquo; and &lsquo;V&rsquo; is larger than the angle between &lsquo;L&rsquo; and the red lines). Therefore, the pixel is outside the cone of light and is not illuminated by the spot light.</p>
<p>If we go with this &ldquo;receive/doesn&rsquo;t receive light&rdquo; approach we will end up with a highly artificial spot light that has a very noticeable edge between its lit and dark areas. It will look like a perfect circle within total darkness (assuming no other light sources). A more realistic looking spot light is one whose light gradually decreases towards the edges of the circle. We can use the dot product that we calculated (in order to determine whether a pixel is lit or not) as a factor. We already know that the dot product will be 1 (i.e. maximum light) when the vectors &lsquo;L&rsquo; and &lsquo;V&rsquo; are equal. But now we run into some nasty behavior of the cosine function. The spot light angle should not be too large or else the light will be too widespread and we will loose the appearance of a spot light. For example, let&rsquo;s set the angle at 20 degrees. The cosine of 20 degrees is 0.939, but the range [0.939, 1.0] is too small to serve as a factor. There is not enough room there to interpolate values that the eye will be able to notice. The range [0, 1] will provide much better results.</p>
<p>The approach that we will use is to map the smaller range defined by the spot light angle into the larger range of [0, 1]. Here&rsquo;s how we do it:</p>
<p><a href="#R-image-7f98fde724200f3e269fbbdd78d48241" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_21_spot_light/../assets/map.png" alt="img" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7f98fde724200f3e269fbbdd78d48241"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_21_spot_light/../assets/map.png" alt="img" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>The principle is very simple - calculate the ratio between the smaller range and the larger range and scale the specific range you want to map by that ratio.</p>
<h3 id="source-walkthru">Source walkthru</h3>
<p>(lighting_technique.h:68)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">struct</span> <span class="nc">SpotLight</span> <span class="o">:</span> <span class="k">public</span> <span class="n">PointLight</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  <span class="n">Vector3f</span> <span class="n">Direction</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  <span class="kt">float</span> <span class="n">Cutoff</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">  <span class="n">SpotLight</span><span class="p">()</span>  
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  <span class="p">{</span>    
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="n">Direction</span> <span class="o">=</span> <span class="n">Vector3f</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">);</span>    
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="n">Cutoff</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">10</span><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="p">};</span></span></span></code></pre></div><p>The structure that defines the spot light is derived from PointLight and adds the two attributes that differentiate it from the point light: a direction vector and cutoff value. The cutoff value represents the maximum angle between the light direction and the light to pixel vector for pixels that are under the influence of the spot light. The spot light has no effect beyond the cutoff value. We&rsquo;ve also added to the LightingTechnique class an array of locations for the shader (not quoted here). This array allows us to access the spot light array in the shader.</p>
<p>(lighting.fs:39)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">struct</span> <span class="nc">SpotLight</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  <span class="k">struct</span> <span class="nc">PointLight</span> <span class="n">Base</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  <span class="n">vec3</span> <span class="n">Direction</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  <span class="kt">float</span> <span class="n">Cutoff</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="n">uniform</span> <span class="kt">int</span> <span class="n">gNumSpotLights</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="n">uniform</span> <span class="n">SpotLight</span> <span class="n">gSpotLights</span><span class="p">[</span><span class="n">MAX_SPOT_LIGHTS</span><span class="p">];</span></span></span></code></pre></div><p>There is a similar structure for the spot light type in GLSL. Since we cannot use inheritance here as in the C++ code we use the PointLight structure as a member and add the new attributes next to it. The important difference here is that in the C++ code the cutoff value is the angle itself while in the shader it is the cosine of that angle. The shader only cares about the cosine so it is more efficient to calculate it once and not for every pixel. We also define an array of spot lights and use a counter called &lsquo;gNumSpotLights&rsquo; to allow the application to define the number of spot lights that are actually used.</p>
<p>(lighting.fs:85)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">vec4</span> <span class="nf">CalcPointLight</span><span class="p">(</span><span class="k">struct</span> <span class="nc">PointLight</span> <span class="n">l</span><span class="p">,</span> <span class="n">vec3</span> <span class="n">Normal</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  <span class="n">vec3</span> <span class="n">LightDirection</span> <span class="o">=</span> <span class="n">WorldPos0</span> <span class="o">-</span> <span class="n">l</span><span class="p">.</span><span class="n">Position</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  <span class="kt">float</span> <span class="n">Distance</span> <span class="o">=</span> <span class="n">length</span><span class="p">(</span><span class="n">LightDirection</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  <span class="n">LightDirection</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">LightDirection</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  <span class="n">vec4</span> <span class="n">Color</span> <span class="o">=</span> <span class="n">CalcLightInternal</span><span class="p">(</span><span class="n">l</span><span class="p">.</span><span class="n">Base</span><span class="p">,</span> <span class="n">LightDirection</span><span class="p">,</span> <span class="n">Normal</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">  <span class="kt">float</span> <span class="n">Attenuation</span> <span class="o">=</span> <span class="n">l</span><span class="p">.</span><span class="n">Atten</span><span class="p">.</span><span class="n">Constant</span> <span class="o">+</span>    
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="n">l</span><span class="p">.</span><span class="n">Atten</span><span class="p">.</span><span class="n">Linear</span> <span class="o">*</span> <span class="n">Distance</span> <span class="o">+</span>    
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="n">l</span><span class="p">.</span><span class="n">Atten</span><span class="p">.</span><span class="n">Exp</span> <span class="o">*</span> <span class="n">Distance</span> <span class="o">*</span> <span class="n">Distance</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">11</span><span class="cl">  
</span></span><span class="line"><span class="ln">12</span><span class="cl">  <span class="k">return</span> <span class="n">Color</span> <span class="o">/</span> <span class="n">Attenuation</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>The point light function has gone through a minor modification - it now takes a PointLight structure as a parameter, rather than access the global array directly. This makes it simpler to share it with spot lights. Other than that, there is no change here.</p>
<p>(lighting.cpp:fs)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">vec4</span> <span class="nf">CalcSpotLight</span><span class="p">(</span><span class="k">struct</span> <span class="nc">SpotLight</span> <span class="n">l</span><span class="p">,</span> <span class="n">vec3</span> <span class="n">Normal</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  <span class="n">vec3</span> <span class="n">LightToPixel</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">WorldPos0</span> <span class="o">-</span> <span class="n">l</span><span class="p">.</span><span class="n">Base</span><span class="p">.</span><span class="n">Position</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  <span class="kt">float</span> <span class="n">SpotFactor</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">LightToPixel</span><span class="p">,</span> <span class="n">l</span><span class="p">.</span><span class="n">Direction</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">SpotFactor</span> <span class="o">&gt;</span> <span class="n">l</span><span class="p">.</span><span class="n">Cutoff</span><span class="p">)</span> <span class="p">{</span>    
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="n">vec4</span> <span class="n">Color</span> <span class="o">=</span> <span class="n">CalcPointLight</span><span class="p">(</span><span class="n">l</span><span class="p">.</span><span class="n">Base</span><span class="p">,</span> <span class="n">Normal</span><span class="p">);</span>    
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="k">return</span> <span class="n">Color</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">SpotFactor</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">l</span><span class="p">.</span><span class="n">Cutoff</span><span class="p">));</span>  
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  <span class="p">}</span>  
</span></span><span class="line"><span class="ln">10</span><span class="cl">  <span class="k">else</span> <span class="p">{</span>    
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="k">return</span> <span class="n">vec4</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">12</span><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>This is where we calculate the spot light effect. We start by taking the vector from the light origin to the pixel. As is often the case, we normalize it to get it ready for the dot product ahead. We do a dot product between this vector and the light direction (which has already been normalized by the application) and get the cosine of the angle between them. We then compare it to the light&rsquo;s cutoff value. This is the cosine of the angle between the light direction and the vector that defines its circle of influence. If the cosine is smaller it means the angle between the light direction and the light to pixel vector places the pixel outside the circle of influence. In this case the contribution of this spot light is zero. This will limit the spot light to a small or large circle, depending on the cutoff value. If it is the other way around we calculate the base color as if the light is a point light. Then we take the dot product result that we&rsquo;ve just calculated (&lsquo;SpotFactor&rsquo;) and plug it into the forumla described above. This provides the factor that will linearly interpolate &lsquo;SpotFactor&rsquo; between 0 and 1. We multiply it by the point light color and receive the final spot light color.</p>
<p>(lighting.fs:122)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">gNumSpotLights</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>  
</span></span><span class="line"><span class="ln">3</span><span class="cl">  <span class="n">TotalLight</span> <span class="o">+=</span> <span class="n">CalcSpotLight</span><span class="p">(</span><span class="n">gSpotLights</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Normal</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="p">...</span></span></span></code></pre></div><p>In a similar fashion to point lights we have a loop in the main function that accumulates the contribution of all spot lights into the final pixel color.</p>
<p>(lighting_technique.cpp:367)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="n">LightingTechnique</span><span class="o">::</span><span class="n">SetSpotLights</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">NumLights</span><span class="p">,</span> <span class="k">const</span> <span class="n">SpotLight</span><span class="o">*</span> <span class="n">pLights</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  <span class="n">glUniform1i</span><span class="p">(</span><span class="n">m_numSpotLightsLocation</span><span class="p">,</span> <span class="n">NumLights</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NumLights</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>    
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="n">glUniform3f</span><span class="p">(</span><span class="n">m_spotLightsLocation</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Color</span><span class="p">,</span> <span class="n">pLights</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Color</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pLights</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Color</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">pLights</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Color</span><span class="p">.</span><span class="n">z</span><span class="p">);</span>    
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="n">glUniform1f</span><span class="p">(</span><span class="n">m_spotLightsLocation</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">AmbientIntensity</span><span class="p">,</span> <span class="n">pLights</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">AmbientIntensity</span><span class="p">);</span>    
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="n">glUniform1f</span><span class="p">(</span><span class="n">m_spotLightsLocation</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">DiffuseIntensity</span><span class="p">,</span> <span class="n">pLights</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">DiffuseIntensity</span><span class="p">);</span>    
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="n">glUniform3f</span><span class="p">(</span><span class="n">m_spotLightsLocation</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Position</span><span class="p">,</span> <span class="n">pLights</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Position</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pLights</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Position</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">pLights</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Position</span><span class="p">.</span><span class="n">z</span><span class="p">);</span>    
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="n">Vector3f</span> <span class="n">Direction</span> <span class="o">=</span> <span class="n">pLights</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Direction</span><span class="p">;</span>    
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="n">Direction</span><span class="p">.</span><span class="n">Normalize</span><span class="p">();</span>    
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="n">glUniform3f</span><span class="p">(</span><span class="n">m_spotLightsLocation</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Direction</span><span class="p">,</span> <span class="n">Direction</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">Direction</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">Direction</span><span class="p">.</span><span class="n">z</span><span class="p">);</span>    
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="n">glUniform1f</span><span class="p">(</span><span class="n">m_spotLightsLocation</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Cutoff</span><span class="p">,</span> <span class="n">cosf</span><span class="p">(</span><span class="n">ToRadian</span><span class="p">(</span><span class="n">pLights</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Cutoff</span><span class="p">)));</span>    
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="n">glUniform1f</span><span class="p">(</span><span class="n">m_spotLightsLocation</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Atten</span><span class="p">.</span><span class="n">Constant</span><span class="p">,</span> <span class="n">pLights</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Attenuation</span><span class="p">.</span><span class="n">Constant</span><span class="p">);</span>    
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="n">glUniform1f</span><span class="p">(</span><span class="n">m_spotLightsLocation</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Atten</span><span class="p">.</span><span class="n">Linear</span><span class="p">,</span> <span class="n">pLights</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Attenuation</span><span class="p">.</span><span class="n">Linear</span><span class="p">);</span>    
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="n">glUniform1f</span><span class="p">(</span><span class="n">m_spotLightsLocation</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Atten</span><span class="p">.</span><span class="n">Exp</span><span class="p">,</span> <span class="n">pLights</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Attenuation</span><span class="p">.</span><span class="n">Exp</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">17</span><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>This function updates the shader program with an array of SpotLight structures. This is the same as the correspoding function for point lights, with two additions. The light direction vector is also applied to the shader, after it has been normalized. Also, the cutoff value is supplied as an angle by the caller but is passed to the shader as the cosine of that angle (allowing the shader to compare a dot product result directly to that value). Note that the library function cosf() takes the angle in radians so we use the handy macro ToRadian in order to translate it.</p>
<p>For more information on this subject check out the following <a href="https://www.youtube.com/watch?v=tmCOMzAA4rc&amp;list=PLRtjMdoYXLf6zUMDJVRZYV-6g6n62vet8&amp;index=19" target="_blank">video tutorial by Frahaan Hussain</a>.</p>

            <footer class="footline">
            </footer>
          </article>

        </div>
      </main>
    </div>
    <script src="../../../../../js/clipboard.min.js?1708235103" defer></script>
    <script src="../../../../../js/perfect-scrollbar.min.js?1708235103" defer></script>
    <script src="../../../../../js/theme.js?1708235103" defer></script>
  </body>
</html>
