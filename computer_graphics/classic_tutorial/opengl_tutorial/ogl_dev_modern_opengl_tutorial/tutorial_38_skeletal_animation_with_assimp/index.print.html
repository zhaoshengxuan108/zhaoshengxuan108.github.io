<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.122.0">
    <meta name="generator" content="Relearn 5.23.2+tip">
    <meta name="description" content="啊啊啊啊">
    <meta name="author" content="Sören Weber">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="https://example.com/images/hero.png">
    <meta name="twitter:title" content="Tutorial 38:Skeletal Animation With Assimp :: Hugo Relearn Theme">
    <meta name="twitter:description" content="Background Finally, it is here. The tutorial that millions of my readers (I may be exaggerating here, but definitely a few ;-) ) have been asking for. Skeletal animation, also known as Skinning, using the Assimp library.
Skeletal animation is actually a two part process. The first one is executed by the artist and the second by you, the programmer (or rather, the engine that you wrote). The first part takes place inside the modeling software and is called Rigging.">
    <meta property="og:title" content="Tutorial 38:Skeletal Animation With Assimp :: Hugo Relearn Theme">
    <meta property="og:description" content="Background Finally, it is here. The tutorial that millions of my readers (I may be exaggerating here, but definitely a few ;-) ) have been asking for. Skeletal animation, also known as Skinning, using the Assimp library.
Skeletal animation is actually a two part process. The first one is executed by the artist and the second by you, the programmer (or rather, the engine that you wrote). The first part takes place inside the modeling software and is called Rigging.">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://example.com/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_38_skeletal_animation_with_assimp/index.html">
    <meta property="og:image" content="https://example.com/images/hero.png">
    <meta property="article:section" content="OGL dev 教程 :: Hugo Relearn Theme">
    <meta property="og:site_name" content="Hugo Relearn Theme">
    <title>Tutorial 38:Skeletal Animation With Assimp :: Hugo Relearn Theme</title>
    <link href="https://example.com/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_38_skeletal_animation_with_assimp/index.html" rel="canonical" type="text/html" title="Tutorial 38:Skeletal Animation With Assimp :: Hugo Relearn Theme">
    <link href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_38_skeletal_animation_with_assimp/index.xml" rel="alternate" type="application/rss+xml" title="Tutorial 38:Skeletal Animation With Assimp :: Hugo Relearn Theme"><link rel="icon" href="../../../../../images/favicon.ico">
    <!-- https://github.com/filamentgroup/loadCSS/blob/master/README.md#how-to-use -->
    <link href="../../../../../css/fontawesome-all.min.css?1708235103" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../../../../../css/fontawesome-all.min.css?1708235103" rel="stylesheet"></noscript>
    <link href="../../../../../css/nucleus.css?1708235103" rel="stylesheet">
    <link href="../../../../../css/auto-complete.css?1708235103" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../../../../../css/auto-complete.css?1708235103" rel="stylesheet"></noscript>
    <link href="../../../../../css/perfect-scrollbar.min.css?1708235103" rel="stylesheet">
    <link href="../../../../../css/fonts.css?1708235103" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../../../../../css/fonts.css?1708235103" rel="stylesheet"></noscript>
    <link href="../../../../../css/theme.css?1708235103" rel="stylesheet">
    <link href="../../../../../css/theme-auto.css?1708235103" rel="stylesheet" id="R-variant-style">
    <link href="../../../../../css/variant.css?1708235103" rel="stylesheet">
    <link href="../../../../../css/print.css?1708235103" rel="stylesheet" media="print">
    <link href="../../../../../css/format-print.css?1708235103" rel="stylesheet">
    <link href="../../../../../css/ie.css?1708235103" rel="stylesheet">
    <script src="../../../../../js/url.js?1708235103"></script>
    <script src="../../../../../js/variant.js?1708235103"></script>
    <script>
      // hack to let hugo tell us how to get to the root when using relativeURLs, it needs to be called *url= for it to do its magic:
      // https://github.com/gohugoio/hugo/blob/145b3fcce35fbac25c7033c91c1b7ae6d1179da8/transform/urlreplacers/absurlreplacer.go#L72
      window.index_js_url="../../../../../index.search.js";
      var root_url="../../../../../";
      var baseUri=root_url.replace(/\/$/, '');
      window.relearn = window.relearn || {};
      window.relearn.baseUriFull='https:\/\/example.com/';
      // variant stuff
      window.variants && variants.init( [ 'auto', 'relearn-light', 'relearn-dark', 'zen-light', 'zen-dark', 'neon', 'learn', 'blue', 'green', 'red' ] );
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
    </script>
    <style>
      #R-body img.bg-white {
        background-color: white;
      }
    </style>
  </head>
  <body class="mobile-support print" data-url="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_38_skeletal_animation_with_assimp/index.html">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide">
              <button class="topbar-control" onclick="toggleNav()" type="button" title="Menu (CTRL&#43;ALT&#43;n)">
                <i class="fa-fw fas fa-bars"></i>
              </button>
            </div>
          </div>
          <ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype="http://schema.org/BreadcrumbList"><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../index.html"><span itemprop="name">主页</span></a><meta itemprop="position" content="1">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../computer_graphics/index.html"><span itemprop="name">计算机图形学</span></a><meta itemprop="position" content="2">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../computer_graphics/classic_tutorial/index.html"><span itemprop="name">经典教程</span></a><meta itemprop="position" content="3">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/index.html"><span itemprop="name">OpenGL教程</span></a><meta itemprop="position" content="4">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/index.html"><span itemprop="name">OGL dev 教程</span></a><meta itemprop="position" content="5">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><span itemprop="name">Tutorial 38:Skeletal Animation With Assimp</span><meta itemprop="position" content="6"></li>
          </ol>
          <div class="topbar-area topbar-area-end" data-area="end">
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable default" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="default">
            <header class="headline">
            </header>
<h1 id="tutorial-38skeletal-animation-with-assimp">Tutorial 38:Skeletal Animation With Assimp</h1>

<h3 id="background">Background</h3>
<p>Finally, it is here. The tutorial that millions of my readers (I may be exaggerating here, but definitely a few ;-) ) have been asking for. <em>Skeletal animation</em>, also known as <em>Skinning</em>, using the Assimp library.</p>
<p>Skeletal animation is actually a two part process. The first one is executed by the artist and the second by you, the programmer (or rather, the engine that you wrote). The first part takes place inside the modeling software and is called <em>Rigging</em>. What happens here is that the artist defines a skeleton of bones underneath the mesh. The mesh represents the skin of the object (be it a human, monster or whatever) and the bones are used to move the mesh in a way that would mimic actual movement in the real world. This is done by assigning each vertex to one or more bones. When a vertex is assigned to a bone a weight is defined that determines the amount of influence that bone has on the vertex when it moves. The common practice is to make the sum of all weights 1 (per vertex). For example, if a vertex is located exactly between two bones we would probably want to assign each bone a weight of 0.5 because we expect the bones to be equal in their influence on the vertex. However, if a vertex is entirely within the influence of a single bone then the weight would be 1 (which means that bone autonomously controls the movement of the vertex).</p>
<p>Here&rsquo;s an example of a bone structure created in blender:</p>
<p><a href="#R-image-6fee87956f71ac8914d83eb87be15992" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_38_skeletal_animation_with_assimp/../assets/rigging.jpeg" alt="img" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-6fee87956f71ac8914d83eb87be15992"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_38_skeletal_animation_with_assimp/../assets/rigging.jpeg" alt="img" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>What we see above is actually an important part of the animation. The artist riggs together the bone structure and defines a set of key frames for each animation type (&ldquo;walk&rdquo;, &ldquo;run&rdquo;, &ldquo;die&rdquo;, etc). The key frames contain the transformations of all bones in critical points along the animation path. The graphics engine interpolates between the transformations of the keyframes and creates a smooth motion between them.</p>
<p>The bone structure used for skeletal animation is often heirarchical. This means that the bones have a child/parent relationships so a tree of bones is created. Every bone has one parent except for the root bone. In the case of the human body, for example, you may assign the back bone as the root with child bones such as arms and legs and finger bones on the next level done. When a parent bone moves it also moves all of its children, but when a child bone moves it does not move it parent (our fingers can move without moving the hand, but when the hand moves it moves all of its fingers). From a practical point of view this means that when we process the transformations of a bone we need to combine it with the transformations of all the parent bones that lead from it to the root.</p>
<p>We are not going to discuss rigging any further. It is a complex subject and outside the domain of graphics programmers. Modeling software has advanced tools to help the artist do this job and you need to be a good artist to create a good looking mesh and skeleton. Let&rsquo;s see what the graphics engine needs to do in order to make skeletal animation.</p>
<p>The first stage is to augument the vertex buffer with per vertex bone information. There are several options available but what we are going to do is pretty straightforward. For each vertex we are going to add an array of slots where each slot contains a bone ID and a weight. To make our life simpler we will use an array with four slots which means no vertex can be influenced by more than four bones. If you are going to load models with more bones you will need to adjust the array size but for the Doom 3 model that is part of this tutorial demo four bones are enough. So our new vertex structure is going to look like this:</p>
<p><a href="#R-image-cc0076054004ae2763e9cd02c126ab48" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_38_skeletal_animation_with_assimp/../assets/vertex.jpeg" alt="img" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-cc0076054004ae2763e9cd02c126ab48"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_38_skeletal_animation_with_assimp/../assets/vertex.jpeg" alt="img" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>The bone IDs are indices into an array of bone transformations. These tranformations will be applied on the position and normal before the WVP matrix (i.e. they transform the vertex from a &ldquo;bone space&rdquo; into local space). The weight will be used to combine the transformations of several bones into a single transformation and in any case the total weight must be exactly 1 (responsibility of the modeling software). Usually, we would interpolate between animation key frames and update the array of bone transformations in every frame.</p>
<p>The way the array of bone transformations is created is usually the tricky part. The transformations are set in a heirarchical structure (i.e. tree) and a common practice is to have a scaling vector, a rotation quaternion and a translation vector in every node in the tree. In fact, each node contains an array of these items. Every entry in the array must have a time stamp. The case where the application time will exactly match one of the time stamps is probably rare so our code must be able to interpolate the scaling/rotation/translation to get the correct transformation for the point in time of the application. We do the same process for each node from the current bone to the root and multiply this chain of transformations together to get the final result. We do that for each bone and then update the shader.</p>
<p>Everything that we talked about so far has been pretty generic. But this is a tutorial about skeletal animation <strong>with Assimp</strong>, so we need to dive into that library again and see how to do skinning with it. The good thing about Assimp is that it supports loading bone information from several formats. The bad thing is that you still need to do quite a bit of work on the data structures that it creates to generate the bone transformations that you need for the shaders.</p>
<p>Let&rsquo;s start at the bone information at the vertex level. Here&rsquo;s the relevant pieces in Assimp data structures:</p>
<p><a href="#R-image-dc952aa751ef6e00cb8a465bc62fb369" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_38_skeletal_animation_with_assimp/../assets/assimp1.jpeg" alt="img" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-dc952aa751ef6e00cb8a465bc62fb369"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_38_skeletal_animation_with_assimp/../assets/assimp1.jpeg" alt="img" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>As you probably recall from the tutorial on Assimp, everything is contained in the aiScene class (an object of which we get when we import the mesh file). The aiScene contains an array of aiMesh objects. An aiMesh is a part of the model and contains stuff at the vertex level such as position, normal, texture coordinates, etc. Now we see that aiMesh also contains an array of aiBone objects. Unsuprisingly, an aiBone represents one bone in the skeleton of the mesh. Each bone has a name by which it can be found in the bone hierarchy (see below), an array of vertex weights and a 4x4 offset matrix. The reason why we need this matrix is because the vertices are stored in the usual local space. This means that even without skeletal animation support our existing code base can load the model and render it correctly. But the bone transformations in the hierarchy work in a bone space (and every bone has its own space which is why we need to multiply the transformations together). So the job of the offset matrix it to move the vertex position from the local space of the mesh into the bone space of that particular bone.</p>
<p>The vertex weight array is where things start to become interesting. Each entry in this array contains an index into the array of vertices in the aiMesh (remember that the vertex is spread across several arrays with the same length) and a weight. The sum of all vertex weights must be 1 but to find them you need to walk through all the bones and accumulate the weights into a kind of list for each particular vertex.</p>
<p>After we build the bone information at the vertex level we need to process the bone transformation hierarchy and generate the final transformations that we will load into the shader. The following picture displays the relevant data structures:</p>
<p><a href="#R-image-ae1c742140eefbc72156a02edcfbfef9" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_38_skeletal_animation_with_assimp/../assets/assimp2.jpeg" alt="img" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-ae1c742140eefbc72156a02edcfbfef9"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_38_skeletal_animation_with_assimp/../assets/assimp2.jpeg" alt="img" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Again, we start at the aiScene. The aiScene object contains a pointer to an object of the aiNode class which is the root of the a node hierarchy (in other words - a tree). Each node in the tree has a pointer back to its parent and an array of pointers to its children. This allows us to conveniently traverse the tree back and forth. In addition, the node carries a transformation matrix that transforms from the node space into the space of its parent. Finally, the node may or may not have a name. If a node represents a bone in the hierarchy then the node name must match the bone name. But sometimes nodes have no name (which means there is not corresponding bone) and their job is simply to help the modeller decompose the model and place some intermediate transformation along the way.</p>
<p>The last piece of the puzzle is the aiAnimation array which is also stored in the aiScene object. A single aiAnimation object represents a sequence of animation frames such as &ldquo;walk&rdquo;, &ldquo;run&rdquo;, &ldquo;shoot&rdquo;, etc. By interpolating between the frames we get the desired visual effect which matches the name of the animation. An animation has a duration in ticks and the number of ticks per second (e.g 100 ticks and 25 ticks per second represent a 4 second animation) which help us time the progression so that the animation will look the same on every hardware. In addition, the animation has an array of aiNodeAnim objects called channels. Each channel is actually the bone with all its transformations. The channel contains a name which must match one of the nodes in the hierarchy and three transformation arrays.</p>
<p>In order to calculate the final bone transformation in a particular point in time we need to find the two entries in each of these three arrays that matches the time and interpolate between them. Then we need to combine the transformations into a single matrix. Having done that we need to find the corresponding node in the hierarchy and travel to its parent. Then we need the corresponding channel for the parent and do the same interpolation process. We multiply the two transformations together and continue until we reach the root of the hierarchy.</p>
<h3 id="source-walkthru">Source walkthru</h3>
<p>(mesh.cpp:75)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">bool</span> <span class="n">Mesh</span><span class="o">::</span><span class="n">LoadMesh</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">Filename</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  <span class="c1">// Release the previously loaded mesh (if it exists)  
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1"></span>  <span class="n">Clear</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">  <span class="c1">// Create the VAO  
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1"></span>  <span class="n">glGenVertexArrays</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m_VAO</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">  <span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">m_VAO</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  
</span></span><span class="line"><span class="ln">10</span><span class="cl">  <span class="c1">// Create the buffers for the vertices attributes  
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="c1"></span>  <span class="n">glGenBuffers</span><span class="p">(</span><span class="n">ARRAY_SIZE_IN_ELEMENTS</span><span class="p">(</span><span class="n">m_Buffers</span><span class="p">),</span> <span class="n">m_Buffers</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">12</span><span class="cl">  
</span></span><span class="line"><span class="ln">13</span><span class="cl">  <span class="kt">bool</span> <span class="n">Ret</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">14</span><span class="cl">  
</span></span><span class="line"><span class="ln">15</span><span class="cl">  <span class="n">m_pScene</span> <span class="o">=</span> <span class="n">m_Importer</span><span class="p">.</span><span class="n">ReadFile</span><span class="p">(</span><span class="n">Filename</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span> <span class="n">aiProcess_Triangulate</span> <span class="o">|</span> 
</span></span><span class="line"><span class="ln">16</span><span class="cl">                                 <span class="n">aiProcess_GenSmoothNormals</span> <span class="o">|</span>                  
</span></span><span class="line"><span class="ln">17</span><span class="cl">                                 <span class="n">aiProcess_FlipUVs</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">18</span><span class="cl">  
</span></span><span class="line"><span class="ln">19</span><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">m_pScene</span><span class="p">)</span> <span class="p">{</span>    
</span></span><span class="line"><span class="ln">20</span><span class="cl">    <span class="n">m_GlobalInverseTransform</span> <span class="o">=</span> <span class="n">m_pScene</span><span class="o">-&gt;</span><span class="n">mRootNode</span><span class="o">-&gt;</span><span class="n">mTransformation</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">    <span class="n">m_GlobalInverseTransform</span><span class="p">.</span><span class="n">Inverse</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">    <span class="n">Ret</span> <span class="o">=</span> <span class="n">InitFromScene</span><span class="p">(</span><span class="o">**</span><span class="n">m_pScene</span><span class="o">**</span><span class="p">,</span> <span class="n">Filename</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">23</span><span class="cl">  <span class="p">}</span>  
</span></span><span class="line"><span class="ln">24</span><span class="cl">  <span class="k">else</span> <span class="p">{</span>    
</span></span><span class="line"><span class="ln">25</span><span class="cl">    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Error parsing &#39;%s&#39;: &#39;%s&#39;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">Filename</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span> <span class="n">m_Importer</span><span class="p">.</span><span class="n">GetErrorString</span><span class="p">());</span>  
</span></span><span class="line"><span class="ln">26</span><span class="cl">  <span class="p">}</span>  
</span></span><span class="line"><span class="ln">27</span><span class="cl">  
</span></span><span class="line"><span class="ln">28</span><span class="cl">  <span class="c1">// Make sure the VAO is not changed from the outside  
</span></span></span><span class="line"><span class="ln">29</span><span class="cl"><span class="c1"></span>  <span class="n">glBindVertexArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">30</span><span class="cl">  
</span></span><span class="line"><span class="ln">31</span><span class="cl">  <span class="k">return</span> <span class="n">Ret</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">32</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>Here&rsquo;s the updated entry point to the Mesh class with changes marked in bold face. There are a couple of changes that we need to note. One is that the importer and aiScene object are now class members rather then stack variables. The reason is that during runtime we are going to go back to the aiScene object again and again and for that we need to extend the scope of both the importer and the scene. In a real game you may want to copy the stuff that you need and store it at a more optimized format but for educational purposes this is enough.</p>
<p>The second change is that the transformation matrix of the root of the hierarchy is extracted, inversed and stored. We are going to use that further down the road. Note that the matrix inverse code has been copied from the Assimp library into our Matrix4f class.</p>
<p>(mesh.h:69)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">struct</span> <span class="nc">VertexBoneData</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln">3</span><span class="cl">  <span class="n">uint</span> <span class="n">IDs</span><span class="p">[</span><span class="n">NUM_BONES_PER_VERTEX</span><span class="p">];</span>  
</span></span><span class="line"><span class="ln">4</span><span class="cl">  <span class="kt">float</span> <span class="n">Weights</span><span class="p">[</span><span class="n">NUM_BONES_PER_VERTEX</span><span class="p">];</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>(mesh.cpp:107)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">bool</span> <span class="n">Mesh</span><span class="o">::</span><span class="n">InitFromScene</span><span class="p">(</span><span class="k">const</span> <span class="n">aiScene</span><span class="o">*</span> <span class="n">pScene</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">Filename</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  <span class="p">...</span>  
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  <span class="n">vector</span><span class="o">&lt;</span><span class="n">VertexBoneData</span><span class="o">&gt;</span> <span class="n">Bones</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  <span class="p">...</span>  
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">  <span class="n">Bones</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">NumVertices</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  <span class="p">...</span>  
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">m_Buffers</span><span class="p">[</span><span class="n">BONE_VB</span><span class="p">]);</span>  
</span></span><span class="line"><span class="ln">10</span><span class="cl">  <span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Bones</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">Bones</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">Bones</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">GL_STATIC_DRAW</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">11</span><span class="cl">  <span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="n">BONE_ID_LOCATION</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">12</span><span class="cl">  <span class="n">glVertexAttribIPointer</span><span class="o">**</span><span class="p">(</span><span class="n">BONE_ID_LOCATION</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">GL_INT</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">VertexBoneData</span><span class="p">),</span> <span class="p">(</span><span class="k">const</span> <span class="n">GLvoid</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">13</span><span class="cl">  <span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="n">BONE_WEIGHT_LOCATION</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">14</span><span class="cl">  <span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="n">BONE_WEIGHT_LOCATION</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> 
</span></span><span class="line"><span class="ln">15</span><span class="cl">                        <span class="k">sizeof</span><span class="p">(</span><span class="n">VertexBoneData</span><span class="p">),</span> <span class="p">(</span><span class="k">const</span> <span class="n">GLvoid</span><span class="o">*</span><span class="p">)</span><span class="mi">16</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">16</span><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>The structure above contains everything we need at the vertex level. By default, we have enough storage for four bones (ID and weight per bone). VertexBoneData was structured like that to make it simple to pass it on to the shader. We already got position, texture coordinates and normal bound at locations 0, 1 and 2, respectively. Therefore, we configure our VAO to bind the bone IDs at location 3 and the weights at location 4. It is very important to note that we use glVertexAttrib<strong>I</strong>Pointer rather than glVertexAttribPointer to bind the IDs. The reason is that the IDs are integer and not floating point. Pay attention to this or you will get corrupted data in the shader.</p>
<p>(mesh.cpp:213)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="n">Mesh</span><span class="o">::</span><span class="n">LoadBones</span><span class="p">(</span><span class="n">uint</span> <span class="n">MeshIndex</span><span class="p">,</span> <span class="k">const</span> <span class="n">aiMesh</span><span class="o">*</span> <span class="n">pMesh</span><span class="p">,</span> <span class="n">vector</span><span class="o">&amp;</span> <span class="n">Bones</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="n">uint</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pMesh</span><span class="o">-&gt;</span><span class="n">mNumBones</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>    
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="n">uint</span> <span class="n">BoneIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>    
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="n">string</span> <span class="nf">BoneName</span><span class="p">(</span><span class="n">pMesh</span><span class="o">-&gt;</span><span class="n">mBones</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">mName</span><span class="p">.</span><span class="n">data</span><span class="p">);</span>    
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">m_BoneMapping</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">BoneName</span><span class="p">)</span> <span class="o">==</span> <span class="n">m_BoneMapping</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>      
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">      <span class="n">BoneIndex</span> <span class="o">=</span> <span class="n">m_NumBones</span><span class="p">;</span>      
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">      <span class="n">m_NumBones</span><span class="o">++</span><span class="p">;</span>      
</span></span><span class="line"><span class="ln">10</span><span class="cl">      <span class="n">BoneInfo</span> <span class="n">bi</span><span class="p">;</span>      
</span></span><span class="line"><span class="ln">11</span><span class="cl">      <span class="n">m_BoneInfo</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">bi</span><span class="p">);</span>    
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="p">}</span>    
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="k">else</span> <span class="p">{</span>      
</span></span><span class="line"><span class="ln">14</span><span class="cl">      <span class="n">BoneIndex</span> <span class="o">=</span> <span class="n">m_BoneMapping</span><span class="p">[</span><span class="n">BoneName</span><span class="p">];</span>    
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="p">}</span>    
</span></span><span class="line"><span class="ln">16</span><span class="cl">    
</span></span><span class="line"><span class="ln">17</span><span class="cl">    <span class="n">m_BoneMapping</span><span class="p">[</span><span class="n">BoneName</span><span class="p">]</span> <span class="o">=</span> <span class="n">BoneIndex</span><span class="p">;</span>    
</span></span><span class="line"><span class="ln">18</span><span class="cl">    <span class="n">m_BoneInfo</span><span class="p">[</span><span class="n">BoneIndex</span><span class="p">].</span><span class="n">BoneOffset</span> <span class="o">=</span> <span class="n">pMesh</span><span class="o">-&gt;</span><span class="n">mBones</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">mOffsetMatrix</span><span class="p">;</span>    
</span></span><span class="line"><span class="ln">19</span><span class="cl">    
</span></span><span class="line"><span class="ln">20</span><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">uint</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">pMesh</span><span class="o">-&gt;</span><span class="n">mBones</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">mNumWeights</span> <span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>      
</span></span><span class="line"><span class="ln">21</span><span class="cl">      <span class="n">uint</span> <span class="n">VertexID</span> <span class="o">=</span> <span class="n">m_Entries</span><span class="p">[</span><span class="n">MeshIndex</span><span class="p">].</span><span class="n">BaseVertex</span> <span class="o">+</span> <span class="n">pMesh</span><span class="o">-&gt;</span><span class="n">mBones</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">mWeights</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">mVertexId</span><span class="p">;</span>      
</span></span><span class="line"><span class="ln">22</span><span class="cl">      <span class="kt">float</span> <span class="n">Weight</span> <span class="o">=</span> <span class="n">pMesh</span><span class="o">-&gt;</span><span class="n">mBones</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">mWeights</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">mWeight</span><span class="p">;</span>      
</span></span><span class="line"><span class="ln">23</span><span class="cl">      <span class="n">Bones</span><span class="p">[</span><span class="n">VertexID</span><span class="p">].</span><span class="n">AddBoneData</span><span class="p">(</span><span class="n">BoneIndex</span><span class="p">,</span> <span class="n">Weight</span><span class="p">);</span>    
</span></span><span class="line"><span class="ln">24</span><span class="cl">    <span class="p">}</span>  
</span></span><span class="line"><span class="ln">25</span><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>The function above loads the vertex bone information for a single aiMesh object. It is called from Mesh::InitMesh(). In addition to populating the VertexBoneData structure this function also updates a map between bone names and bone IDs (a running index managed by this function) and stores the offset matrix in a vector based on the bone ID. Note how the vertex ID is calculated. Since vertex IDs are relevant to a single mesh and we store all meshes in a single vector we add the base vertex ID of the current aiMesh to vertex ID from the mWeights array to get the absolute vertex ID.</p>
<p>(mesh.cpp:29)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="n">Mesh</span><span class="o">::</span><span class="n">VertexBoneData</span><span class="o">::</span><span class="n">AddBoneData</span><span class="p">(</span><span class="n">uint</span> <span class="n">BoneID</span><span class="p">,</span> <span class="kt">float</span> <span class="n">Weight</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="n">uint</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE_IN_ELEMENTS</span><span class="p">(</span><span class="n">IDs</span><span class="p">)</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>    
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">Weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">)</span> <span class="p">{</span>      
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">      <span class="n">IDs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">BoneID</span><span class="p">;</span>      
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">      <span class="n">Weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Weight</span><span class="p">;</span>      
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">      <span class="k">return</span><span class="p">;</span>    
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="p">}</span>  
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  <span class="p">}</span>  
</span></span><span class="line"><span class="ln">10</span><span class="cl">  
</span></span><span class="line"><span class="ln">11</span><span class="cl">  <span class="c1">// should never get here - more bones than we have space for  
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="c1"></span>  <span class="n">assert</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>This utility function finds a free slot in the VertexBoneData structure and places the bone ID and weight in it. Some vertices will be influenced by less than four bones but since the weight of a non existing bone remains zero (see the constructor of VertexBoneData) it means that we can use the same weight calculation for any number of bones.</p>
<p>(mesh.cpp:473)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">Matrix4f</span> <span class="n">Mesh</span><span class="o">::</span><span class="n">BoneTransform</span><span class="p">(</span><span class="kt">float</span> <span class="n">TimeInSeconds</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">Matrix4f</span><span class="o">&gt;&amp;</span> <span class="n">Transforms</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  <span class="n">Matrix4f</span> <span class="n">Identity</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  <span class="n">Identity</span><span class="p">.</span><span class="n">InitIdentity</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">  <span class="kt">float</span> <span class="n">TicksPerSecond</span> <span class="o">=</span> <span class="n">m_pScene</span><span class="o">-&gt;</span><span class="n">mAnimations</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">mTicksPerSecond</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">?</span>              <span class="n">m_pScene</span><span class="o">-&gt;</span><span class="n">mAnimations</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="nl">mTicksPerSecond</span> <span class="p">:</span> <span class="mf">25.0f</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">  <span class="kt">float</span> <span class="n">TimeInTicks</span> <span class="o">=</span> <span class="n">TimeInSeconds</span> <span class="o">*</span> <span class="n">TicksPerSecond</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  <span class="kt">float</span> <span class="n">AnimationTime</span> <span class="o">=</span> <span class="n">fmod</span><span class="p">(</span><span class="n">TimeInTicks</span><span class="p">,</span> <span class="n">m_pScene</span><span class="o">-&gt;</span><span class="n">mAnimations</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">mDuration</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">10</span><span class="cl">  
</span></span><span class="line"><span class="ln">11</span><span class="cl">  <span class="n">ReadNodeHierarchy</span><span class="p">(</span><span class="n">AnimationTime</span><span class="p">,</span> <span class="n">m_pScene</span><span class="o">-&gt;</span><span class="n">mRootNode</span><span class="p">,</span> <span class="n">Identity</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">12</span><span class="cl">  
</span></span><span class="line"><span class="ln">13</span><span class="cl">  <span class="n">Transforms</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">m_NumBones</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">14</span><span class="cl">  
</span></span><span class="line"><span class="ln">15</span><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="n">uint</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m_NumBones</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>    
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="n">Transforms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">m_BoneInfo</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">FinalTransformation</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">17</span><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>Loading of the bone information at the vertex level that we saw earlier is done only once when the mesh is loading during startup. Now we come to the second part which is calculating the bone transformations that go into the shader every frame. The function above is the entry point to this activity. The caller reports the current time in seconds (which can be a fraction) and provides a vector of matrices which we must update. We find the relative time inside the animation cycle and process the node hierarchy. The result is an array of transformations which is returned to the caller.</p>
<p>(mesh.cpp:428)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="n">Mesh</span><span class="o">::</span><span class="n">ReadNodeHierarchy</span><span class="p">(</span><span class="kt">float</span> <span class="n">AnimationTime</span><span class="p">,</span> <span class="k">const</span> <span class="n">aiNode</span><span class="o">*</span> <span class="n">pNode</span><span class="p">,</span> <span class="k">const</span> <span class="n">Matrix4f</span><span class="o">&amp;</span> <span class="n">ParentTransform</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  <span class="n">string</span> <span class="nf">NodeName</span><span class="p">(</span><span class="n">pNode</span><span class="o">-&gt;</span><span class="n">mName</span><span class="p">.</span><span class="n">data</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  <span class="k">const</span> <span class="n">aiAnimation</span><span class="o">*</span> <span class="n">pAnimation</span> <span class="o">=</span> <span class="n">m_pScene</span><span class="o">-&gt;</span><span class="n">mAnimations</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>  
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  <span class="n">Matrix4f</span> <span class="nf">NodeTransformation</span><span class="p">(</span><span class="n">pNode</span><span class="o">-&gt;</span><span class="n">mTransformation</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  <span class="k">const</span> <span class="n">aiNodeAnim</span><span class="o">*</span> <span class="n">pNodeAnim</span> <span class="o">=</span> <span class="n">FindNodeAnim</span><span class="p">(</span><span class="n">pAnimation</span><span class="p">,</span> <span class="n">NodeName</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">10</span><span class="cl">  
</span></span><span class="line"><span class="ln">11</span><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">pNodeAnim</span><span class="p">)</span> <span class="p">{</span>    
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="c1">// Interpolate scaling and generate scaling transformation matrix    
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="c1"></span>    <span class="n">aiVector3D</span> <span class="n">Scaling</span><span class="p">;</span>    
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="n">CalcInterpolatedScaling</span><span class="p">(</span><span class="n">Scaling</span><span class="p">,</span> <span class="n">AnimationTime</span><span class="p">,</span> <span class="n">pNodeAnim</span><span class="p">);</span>    
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="n">Matrix4f</span> <span class="n">ScalingM</span><span class="p">;</span>    
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="n">ScalingM</span><span class="p">.</span><span class="n">InitScaleTransform</span><span class="p">(</span><span class="n">Scaling</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">Scaling</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">Scaling</span><span class="p">.</span><span class="n">z</span><span class="p">);</span>    
</span></span><span class="line"><span class="ln">17</span><span class="cl">    
</span></span><span class="line"><span class="ln">18</span><span class="cl">    <span class="c1">// Interpolate rotation and generate rotation transformation matrix    
</span></span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="c1"></span>    <span class="n">aiQuaternion</span> <span class="n">RotationQ</span><span class="p">;</span>    
</span></span><span class="line"><span class="ln">20</span><span class="cl">    <span class="n">CalcInterpolatedRotation</span><span class="p">(</span><span class="n">RotationQ</span><span class="p">,</span> <span class="n">AnimationTime</span><span class="p">,</span> <span class="n">pNodeAnim</span><span class="p">);</span>    
</span></span><span class="line"><span class="ln">21</span><span class="cl">    <span class="n">Matrix4f</span> <span class="n">RotationM</span> <span class="o">=</span> <span class="n">Matrix4f</span><span class="p">(</span><span class="n">RotationQ</span><span class="p">.</span><span class="n">GetMatrix</span><span class="p">());</span>    
</span></span><span class="line"><span class="ln">22</span><span class="cl">    
</span></span><span class="line"><span class="ln">23</span><span class="cl">    <span class="c1">// Interpolate translation and generate translation transformation matrix    
</span></span></span><span class="line"><span class="ln">24</span><span class="cl"><span class="c1"></span>    <span class="n">aiVector3D</span> <span class="n">Translation</span><span class="p">;</span>    
</span></span><span class="line"><span class="ln">25</span><span class="cl">    <span class="n">CalcInterpolatedPosition</span><span class="p">(</span><span class="n">Translation</span><span class="p">,</span> <span class="n">AnimationTime</span><span class="p">,</span> <span class="n">pNodeAnim</span><span class="p">);</span>    
</span></span><span class="line"><span class="ln">26</span><span class="cl">    <span class="n">Matrix4f</span> <span class="n">TranslationM</span><span class="p">;</span>    
</span></span><span class="line"><span class="ln">27</span><span class="cl">    <span class="n">TranslationM</span><span class="p">.</span><span class="n">InitTranslationTransform</span><span class="p">(</span><span class="n">Translation</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">Translation</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">Translation</span><span class="p">.</span><span class="n">z</span><span class="p">);</span>    
</span></span><span class="line"><span class="ln">28</span><span class="cl">    
</span></span><span class="line"><span class="ln">29</span><span class="cl">    <span class="c1">// Combine the above transformations    
</span></span></span><span class="line"><span class="ln">30</span><span class="cl"><span class="c1"></span>    <span class="n">NodeTransformation</span> <span class="o">=</span> <span class="n">TranslationM</span> <span class="o">*</span> <span class="n">RotationM</span> <span class="o">*</span> <span class="n">ScalingM</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">31</span><span class="cl">  <span class="p">}</span>  
</span></span><span class="line"><span class="ln">32</span><span class="cl">  
</span></span><span class="line"><span class="ln">33</span><span class="cl">  <span class="n">Matrix4f</span> <span class="n">GlobalTransformation</span> <span class="o">=</span> <span class="n">ParentTransform</span> <span class="o">*</span> <span class="n">NodeTransformation</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">34</span><span class="cl">  
</span></span><span class="line"><span class="ln">35</span><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">m_BoneMapping</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">NodeName</span><span class="p">)</span> <span class="o">!=</span> <span class="n">m_BoneMapping</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>    
</span></span><span class="line"><span class="ln">36</span><span class="cl">    <span class="n">uint</span> <span class="n">BoneIndex</span> <span class="o">=</span> <span class="n">m_BoneMapping</span><span class="p">[</span><span class="n">NodeName</span><span class="p">];</span>    
</span></span><span class="line"><span class="ln">37</span><span class="cl">    <span class="n">m_BoneInfo</span><span class="p">[</span><span class="n">BoneIndex</span><span class="p">].</span><span class="n">FinalTransformation</span> <span class="o">=</span> <span class="n">m_GlobalInverseTransform</span> <span class="o">*</span> 
</span></span><span class="line"><span class="ln">38</span><span class="cl">      <span class="n">GlobalTransformation</span> <span class="o">*</span>                          
</span></span><span class="line"><span class="ln">39</span><span class="cl">      <span class="n">m_BoneInfo</span><span class="p">[</span><span class="n">BoneIndex</span><span class="p">].</span><span class="n">BoneOffset</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">40</span><span class="cl">  <span class="p">}</span>  
</span></span><span class="line"><span class="ln">41</span><span class="cl">  
</span></span><span class="line"><span class="ln">42</span><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="n">uint</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pNode</span><span class="o">-&gt;</span><span class="n">mNumChildren</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>    
</span></span><span class="line"><span class="ln">43</span><span class="cl">    <span class="n">ReadNodeHierarchy</span><span class="p">(</span><span class="n">AnimationTime</span><span class="p">,</span> <span class="n">pNode</span><span class="o">-&gt;</span><span class="n">mChildren</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">GlobalTransformation</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">44</span><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="ln">45</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>This function traverses the node tree and generates the final transformation for each node/bone according to the specified animation time. It is limited in the sense that it assumes that the mesh has only a single animation sequence. If you want to support multiple animations you will need to tell it the animation name and search for it in the m_pScene-&gt;mAnimations[] array. The code above is good enough for the demo mesh that we use.</p>
<p>The node transformation is initialized from the mTransformation member in the node. If the node does not correspond to a bone then that is its final transformation. If it does we overwrite it with a matrix that we generate. This is done as follows: first we search for the node name in the channel array of the animation. Then we interpolate the scaling vector, rotation quaternion and translation vector based on the animation time. We combine them into a single matrix and multiply with the matrix we got as a parameter (named GlobablTransformation). This function is recursive and is called for the root node with the GlobalTransformation param being the identity matrix. Each node recursively calls this function for all of its children and passes its own transformation as GlobalTransformation. Since we start at the top and work our way down, we get the combined transformation chain at every node.</p>
<p>The m_BoneMapping array maps a node name to the index that we generate and we use that index to as an entry into the m_BoneInfo array where the final transformations are stored. The final transformation is calculated as follows: we start with the node offset matrix which brings the vertices from their local space position into their node space. We then multiple with the combined transformations of all of the nodes parents plus the specific transformation that we calculated for the node according to the animation time.</p>
<p>Note that we use Assimp code here to handle the math stuff. I saw no point in duplicating it into our own code base so I simply used Assimp.</p>
<p>(mesh.cpp:387)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="n">Mesh</span><span class="o">::</span><span class="n">CalcInterpolatedRotation</span><span class="p">(</span><span class="n">aiQuaternion</span><span class="o">&amp;</span> <span class="n">Out</span><span class="p">,</span> <span class="kt">float</span> <span class="n">AnimationTime</span><span class="p">,</span> <span class="k">const</span> <span class="n">aiNodeAnim</span><span class="o">*</span> <span class="n">pNodeAnim</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  <span class="c1">// we need at least two values to interpolate...  
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">pNodeAnim</span><span class="o">-&gt;</span><span class="n">mNumRotationKeys</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>    
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="n">Out</span> <span class="o">=</span> <span class="n">pNodeAnim</span><span class="o">-&gt;</span><span class="n">mRotationKeys</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">mValue</span><span class="p">;</span>    
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="k">return</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  <span class="p">}</span>  
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  <span class="n">uint</span> <span class="n">RotationIndex</span> <span class="o">=</span> <span class="n">FindRotation</span><span class="p">(</span><span class="n">AnimationTime</span><span class="p">,</span> <span class="n">pNodeAnim</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">10</span><span class="cl">  <span class="n">uint</span> <span class="n">NextRotationIndex</span> <span class="o">=</span> <span class="p">(</span><span class="n">RotationIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">11</span><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">NextRotationIndex</span> <span class="o">&lt;</span> <span class="n">pNodeAnim</span><span class="o">-&gt;</span><span class="n">mNumRotationKeys</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">12</span><span class="cl">  <span class="kt">float</span> <span class="n">DeltaTime</span> <span class="o">=</span> <span class="n">pNodeAnim</span><span class="o">-&gt;</span><span class="n">mRotationKeys</span><span class="p">[</span><span class="n">NextRotationIndex</span><span class="p">].</span><span class="n">mTime</span> <span class="o">-</span> <span class="n">pNodeAnim</span><span class="o">-&gt;</span><span class="n">mRotationKeys</span><span class="p">[</span><span class="n">RotationIndex</span><span class="p">].</span><span class="n">mTime</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">13</span><span class="cl">  <span class="kt">float</span> <span class="n">Factor</span> <span class="o">=</span> <span class="p">(</span><span class="n">AnimationTime</span> <span class="o">-</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">pNodeAnim</span><span class="o">-&gt;</span><span class="n">mRotationKeys</span><span class="p">[</span><span class="n">RotationIndex</span><span class="p">].</span><span class="n">mTime</span><span class="p">)</span> <span class="o">/</span> <span class="n">DeltaTime</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">14</span><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">Factor</span> <span class="o">&gt;=</span> <span class="mf">0.0f</span> <span class="o">&amp;&amp;</span> <span class="n">Factor</span> <span class="o">&lt;=</span> <span class="mf">1.0f</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">15</span><span class="cl">  <span class="k">const</span> <span class="n">aiQuaternion</span><span class="o">&amp;</span> <span class="n">StartRotationQ</span> <span class="o">=</span> <span class="n">pNodeAnim</span><span class="o">-&gt;</span><span class="n">mRotationKeys</span><span class="p">[</span><span class="n">RotationIndex</span><span class="p">].</span><span class="n">mValue</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">16</span><span class="cl">  <span class="k">const</span> <span class="n">aiQuaternion</span><span class="o">&amp;</span> <span class="n">EndRotationQ</span> <span class="o">=</span> <span class="n">pNodeAnim</span><span class="o">-&gt;</span><span class="n">mRotationKeys</span><span class="p">[</span><span class="n">NextRotationIndex</span><span class="p">].</span><span class="n">mValue</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">17</span><span class="cl">  <span class="n">aiQuaternion</span><span class="o">::</span><span class="n">Interpolate</span><span class="p">(</span><span class="n">Out</span><span class="p">,</span> <span class="n">StartRotationQ</span><span class="p">,</span> <span class="n">EndRotationQ</span><span class="p">,</span> <span class="n">Factor</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">18</span><span class="cl">  <span class="n">Out</span> <span class="o">=</span> <span class="n">Out</span><span class="p">.</span><span class="n">Normalize</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>This method interpolates the rotation quaternion of the specified channel based on the animation time (remember that the channel contains an array of key quaternions). First we find the index of the key quaternion which is just before the required animation time. We calculate the ratio between the distance from the animation time to the key before it and the distance between that key and the next. We need to interpolate between these two keys using that factor. We use an Assimp code to do the interpolation and normalize the result. The corresponding methods for position and scaling are very similar so they are not quoted here.</p>
<p>(mesh.cpp:335)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">uint</span> <span class="n">Mesh</span><span class="o">::</span><span class="n">FindRotation</span><span class="p">(</span><span class="kt">float</span> <span class="n">AnimationTime</span><span class="p">,</span> <span class="k">const</span> <span class="n">aiNodeAnim</span><span class="o">*</span> <span class="n">pNodeAnim</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">pNodeAnim</span><span class="o">-&gt;</span><span class="n">mNumRotationKeys</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="n">uint</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pNodeAnim</span><span class="o">-&gt;</span><span class="n">mNumRotationKeys</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>    
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">AnimationTime</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">pNodeAnim</span><span class="o">-&gt;</span><span class="n">mRotationKeys</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">].</span><span class="n">mTime</span><span class="p">)</span> <span class="p">{</span>      
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">      <span class="k">return</span> <span class="n">i</span><span class="p">;</span>    
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="p">}</span>  
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  <span class="p">}</span>  
</span></span><span class="line"><span class="ln">10</span><span class="cl">  
</span></span><span class="line"><span class="ln">11</span><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>This utility method finds the key rotation which is immediately before the animation time. If we have N key rotations the result can be 0 to N-2. The animation time is always contained inside the duration of the channel so the last key (N-1) can never be a valid result.</p>
<p>(skinning.vs)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">Position</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec2</span> <span class="n">TexCoord</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">Normal</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span> <span class="n">in</span> <span class="n">ivec4</span> <span class="n">BoneIDs</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">4</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec4</span> <span class="n">Weights</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="n">out</span> <span class="n">vec2</span> <span class="n">TexCoord0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="n">out</span> <span class="n">vec3</span> <span class="n">Normal0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="n">out</span> <span class="n">vec3</span> <span class="n">WorldPos0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">MAX_BONES</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="n">uniform</span> <span class="n">mat4</span> <span class="n">gWVP</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="n">uniform</span> <span class="n">mat4</span> <span class="n">gWorld</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="n">uniform</span> <span class="n">mat4</span> <span class="n">gBones</span><span class="p">[</span><span class="n">MAX_BONES</span><span class="p">];</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">
</span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln">21</span><span class="cl">  <span class="n">mat4</span> <span class="n">BoneTransform</span> <span class="o">=</span> <span class="n">gBones</span><span class="p">[</span><span class="n">BoneIDs</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="n">Weights</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">  <span class="n">BoneTransform</span> <span class="o">+=</span> <span class="n">gBones</span><span class="p">[</span><span class="n">BoneIDs</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">*</span> <span class="n">Weights</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">  <span class="n">BoneTransform</span> <span class="o">+=</span> <span class="n">gBones</span><span class="p">[</span><span class="n">BoneIDs</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">*</span> <span class="n">Weights</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">  <span class="n">BoneTransform</span> <span class="o">+=</span> <span class="n">gBones</span><span class="p">[</span><span class="n">BoneIDs</span><span class="p">[</span><span class="mi">3</span><span class="p">]]</span> <span class="o">*</span> <span class="n">Weights</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl">  
</span></span><span class="line"><span class="ln">26</span><span class="cl">  <span class="n">vec4</span> <span class="n">PosL</span> <span class="o">=</span> <span class="n">BoneTransform</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">Position</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">27</span><span class="cl">  <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">gWVP</span> <span class="o">*</span> <span class="n">PosL</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">28</span><span class="cl">  <span class="n">TexCoord0</span> <span class="o">=</span> <span class="n">TexCoord</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">29</span><span class="cl">  <span class="n">vec4</span> <span class="n">NormalL</span> <span class="o">=</span> <span class="n">BoneTransform</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">Normal</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">30</span><span class="cl">  <span class="n">Normal0</span> <span class="o">=</span> <span class="p">(</span><span class="n">gWorld</span> <span class="o">*</span> <span class="n">NormalL</span><span class="p">).</span><span class="n">xyz</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">31</span><span class="cl">  <span class="n">WorldPos0</span> <span class="o">=</span> <span class="p">(</span><span class="n">gWorld</span> <span class="o">*</span> <span class="n">PosL</span><span class="p">).</span><span class="n">xyz</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">32</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>Now that we have finished with the changes in the mesh class let&rsquo;s see what we need to do at the shader level. First, we&rsquo;ve added the bone IDs and weights array to the VSInput structure. Next, there is a new uniform array that contains the bone transformations. In the shader itself we calculate the final bone transformation as a combination of the bone transformation matrices of the vertex and their weights. This final matrix is used to transform the position and normal from their bone space into the local space. From here on everything is the same.</p>
<p>(tutorial38.cpp:140)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">float</span> <span class="n">RunningTime</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="p">)((</span><span class="kt">double</span><span class="p">)</span><span class="n">GetCurrentTimeMillis</span><span class="p">()</span> <span class="o">-</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">m_startTime</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1000.0f</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">m_mesh</span><span class="p">.</span><span class="n">BoneTransform</span><span class="p">(</span><span class="n">RunningTime</span><span class="p">,</span> <span class="n">Transforms</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="n">uint</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">Transforms</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>  
</span></span><span class="line"><span class="ln">6</span><span class="cl">  <span class="n">m_pEffect</span><span class="o">-&gt;</span><span class="n">SetBoneTransform</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">Transforms</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>The last thing we need to do is to integrate all this stuff into the application code. This is done in the above simple code. The function GetCurrentTimeMillis() returns the time in milliseconds since the application startup (note the floating point to accomodate fractions).</p>
<p>If you&rsquo;ve done everything correctly then the final result should look similar to <a href="http://www.youtube.com/watch?v=aHUTof9S8mM" target="_blank">this</a>.</p>

            <footer class="footline">
            </footer>
          </article>

        </div>
      </main>
    </div>
    <script src="../../../../../js/clipboard.min.js?1708235103" defer></script>
    <script src="../../../../../js/perfect-scrollbar.min.js?1708235103" defer></script>
    <script src="../../../../../js/theme.js?1708235103" defer></script>
  </body>
</html>
