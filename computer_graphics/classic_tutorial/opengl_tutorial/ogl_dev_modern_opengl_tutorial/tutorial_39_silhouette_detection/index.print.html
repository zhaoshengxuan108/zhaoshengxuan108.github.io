<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.122.0">
    <meta name="generator" content="Relearn 5.23.2+tip">
    <meta name="description" content="啊啊啊啊">
    <meta name="author" content="Sören Weber">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="https://example.com/images/hero.png">
    <meta name="twitter:title" content="Tutorial 39:Silhouette Detection :: Hugo Relearn Theme">
    <meta name="twitter:description" content="Background Today we are going to discuss one way in which the silhouette of an object can be detected. To make things clearer, I&rsquo;m referring to the silhouette of a 3D object which is created when light falls upon it from an arbitrary direction. Moving the light source will likely change the silhouette accordingly. This is entirely different from silhouette detection in image space that deals with finding the boundaries of an object in a 2D picture (which is usually not dependant on the location of the light source).">
    <meta property="og:title" content="Tutorial 39:Silhouette Detection :: Hugo Relearn Theme">
    <meta property="og:description" content="Background Today we are going to discuss one way in which the silhouette of an object can be detected. To make things clearer, I&rsquo;m referring to the silhouette of a 3D object which is created when light falls upon it from an arbitrary direction. Moving the light source will likely change the silhouette accordingly. This is entirely different from silhouette detection in image space that deals with finding the boundaries of an object in a 2D picture (which is usually not dependant on the location of the light source).">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://example.com/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_39_silhouette_detection/index.html">
    <meta property="og:image" content="https://example.com/images/hero.png">
    <meta property="article:section" content="OGL dev 教程 :: Hugo Relearn Theme">
    <meta property="og:site_name" content="Hugo Relearn Theme">
    <title>Tutorial 39:Silhouette Detection :: Hugo Relearn Theme</title>
    <link href="https://example.com/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_39_silhouette_detection/index.html" rel="canonical" type="text/html" title="Tutorial 39:Silhouette Detection :: Hugo Relearn Theme">
    <link href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_39_silhouette_detection/index.xml" rel="alternate" type="application/rss+xml" title="Tutorial 39:Silhouette Detection :: Hugo Relearn Theme"><link rel="icon" href="../../../../../images/favicon.ico">
    <!-- https://github.com/filamentgroup/loadCSS/blob/master/README.md#how-to-use -->
    <link href="../../../../../css/fontawesome-all.min.css?1708235103" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../../../../../css/fontawesome-all.min.css?1708235103" rel="stylesheet"></noscript>
    <link href="../../../../../css/nucleus.css?1708235103" rel="stylesheet">
    <link href="../../../../../css/auto-complete.css?1708235103" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../../../../../css/auto-complete.css?1708235103" rel="stylesheet"></noscript>
    <link href="../../../../../css/perfect-scrollbar.min.css?1708235103" rel="stylesheet">
    <link href="../../../../../css/fonts.css?1708235103" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../../../../../css/fonts.css?1708235103" rel="stylesheet"></noscript>
    <link href="../../../../../css/theme.css?1708235103" rel="stylesheet">
    <link href="../../../../../css/theme-auto.css?1708235103" rel="stylesheet" id="R-variant-style">
    <link href="../../../../../css/variant.css?1708235103" rel="stylesheet">
    <link href="../../../../../css/print.css?1708235103" rel="stylesheet" media="print">
    <link href="../../../../../css/format-print.css?1708235103" rel="stylesheet">
    <link href="../../../../../css/ie.css?1708235103" rel="stylesheet">
    <script src="../../../../../js/url.js?1708235103"></script>
    <script src="../../../../../js/variant.js?1708235103"></script>
    <script>
      // hack to let hugo tell us how to get to the root when using relativeURLs, it needs to be called *url= for it to do its magic:
      // https://github.com/gohugoio/hugo/blob/145b3fcce35fbac25c7033c91c1b7ae6d1179da8/transform/urlreplacers/absurlreplacer.go#L72
      window.index_js_url="../../../../../index.search.js";
      var root_url="../../../../../";
      var baseUri=root_url.replace(/\/$/, '');
      window.relearn = window.relearn || {};
      window.relearn.baseUriFull='https:\/\/example.com/';
      // variant stuff
      window.variants && variants.init( [ 'auto', 'relearn-light', 'relearn-dark', 'zen-light', 'zen-dark', 'neon', 'learn', 'blue', 'green', 'red' ] );
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
    </script>
    <style>
      #R-body img.bg-white {
        background-color: white;
      }
    </style>
  </head>
  <body class="mobile-support print" data-url="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_39_silhouette_detection/index.html">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide">
              <button class="topbar-control" onclick="toggleNav()" type="button" title="Menu (CTRL&#43;ALT&#43;n)">
                <i class="fa-fw fas fa-bars"></i>
              </button>
            </div>
          </div>
          <ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype="http://schema.org/BreadcrumbList"><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../index.html"><span itemprop="name">主页</span></a><meta itemprop="position" content="1">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../computer_graphics/index.html"><span itemprop="name">计算机图形学</span></a><meta itemprop="position" content="2">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../computer_graphics/classic_tutorial/index.html"><span itemprop="name">经典教程</span></a><meta itemprop="position" content="3">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/index.html"><span itemprop="name">OpenGL教程</span></a><meta itemprop="position" content="4">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/index.html"><span itemprop="name">OGL dev 教程</span></a><meta itemprop="position" content="5">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><span itemprop="name">Tutorial 39:Silhouette Detection</span><meta itemprop="position" content="6"></li>
          </ol>
          <div class="topbar-area topbar-area-end" data-area="end">
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable default" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="default">
            <header class="headline">
            </header>
<h1 id="tutorial-39silhouette-detection">Tutorial 39:Silhouette Detection</h1>

<h3 id="background">Background</h3>
<p>Today we are going to discuss one way in which the silhouette of an object can be detected. To make things clearer, I&rsquo;m referring to the silhouette of a 3D object which is created when light falls upon it from an arbitrary direction. Moving the light source will likely change the silhouette accordingly. This is entirely different from silhouette detection in image space that deals with finding the boundaries of an object in a 2D picture (which is usually not dependant on the location of the light source). While the subject of silhouette detection may be interesting by itself, for me its main goal is as a first step in the implementation of a <em>Stencil Shadow Volume</em>. This is a technique for rendering shadows which is particularly useful when dealing with point lights. We will study this technique in the next tutorial (so you may refer to this tutorial as &ldquo;Stencil Shadow Volume - Part 1&rdquo;&hellip;).</p>
<p>The following image demonstrates the silhouette that we want to detect:</p>
<p><a href="#R-image-c1aa16d68db91d09b769a7e3b0f4c015" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_39_silhouette_detection/../assets/silhouette1.jpeg" alt="img" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c1aa16d68db91d09b769a7e3b0f4c015"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_39_silhouette_detection/../assets/silhouette1.jpeg" alt="img" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>In the image above the silhouette is the ellipsis which is touched by the light rays.</p>
<p>Let us now move to a more traditional 3D language. A model is basically composed of triangles so the silhouette must be created by triangle edges. How do we decide whether an edge is part of the silhouette or not? The trick is based on the diffuse light model. According to that model the light strength is based on the dot product between the triangle normal and the light vector. If the triangle faces away from the light source the result of this dot product operation will be less than or equal to zero. In that case the light doesn&rsquo;t affect the triangle at all. In order to decide whether a triangle edge is part of the silhouette or not we need to find the adjacent triangle that shares the same edge and calculate the dot product between the light direction and the normals of both the original triangle and its neighbor. An edge is considered a silhouette edge if one triangle faces the light but its neighbor does not.</p>
<p>The following picture shows a 2D object for simplicity:</p>
<p><a href="#R-image-b0e98a4b401c77b4e63597dba7ce7999" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_39_silhouette_detection/../assets/silhouette2.jpeg" alt="img" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b0e98a4b401c77b4e63597dba7ce7999"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_39_silhouette_detection/../assets/silhouette2.jpeg" alt="img" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>The red arrow represents the light ray that hits the three edges (in 3D these would be triangles) whose normals are 1, 2 and 3 (dot product between these normals and the reverse of the light vector is obviously greater than zero). The edges whose normals are 4, 5 and 6 are facing away from the light (here the same dot product would be less than or equal to zero). The two blue circles mark the silhouette of the object and the reason is that edge 1 is facing the light but its neighbor edge 6 does not. The point between them is therefore a silhoette. Same goes for the other silhouette point. Edges (or points in this example) that face the light as well as their neighbors are not silhoette (between 1 and 2 and between 2 and 3).</p>
<p>As you can see, the algorithm for finding the silhouette is very simple. However, it does require us to have knowledge of the three neighbors of each triangle. This is known as the <em>Adjacencies</em> of the triangles. Unfortunately, Assimp does not support automatic adjacencies calculation for us so we need to implement such an algorithm ourselves. In the coding section we will review a simple algorithm that will satisfy our needs.</p>
<p>What is the best place in the pipeline for the silhouette algorithm itself? remember that we need to do a dot product between the light vector and the triangle normal as well as the normals of the three adjacent triangles. This requires us to have access to the entire primitive information. Therefore, the VS is not enough. Looks like the GS is more appropriate since it allows access to all the vertices of a primitive. But what about the adjacencies? luckily for us, the designers of OpenGL have already given it much thought and created a topology type known as &rsquo;triangle with adjacencies&rsquo;. If you provide a vertex buffer with adjacency information it will correctly load it and provide the GS with six vertices per triangle instead of three. The additional three vertices belong to the adjacent triangles and are not shared with the current triangle. The following image should make this much clearer:</p>
<p><a href="#R-image-323765c6c06f5621b3242883543e9467" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_39_silhouette_detection/../assets/adjacencies.jpeg" alt="img" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-323765c6c06f5621b3242883543e9467"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_39_silhouette_detection/../assets/adjacencies.jpeg" alt="img" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>The red vertices in the above picture belong to the original triangle and the blue ones are the adjacent vertices (ignore the edges e1-e6 for now - they are referenced later in the code section). When we supply a vertex buffer in the above format the VS is executed for every vertex (adjacent and non adjacent) and the GS (if it exists) is executed on a group of six vertices that include the triangle and its adjacent vertices. When the GS is present it is up to the developer to supply an output topology but if there is no GS the rasterizer knows how to deal with such a scheme and it rasterizes only the actual triangles (ignoring the adjacent triangles). One of the readers informed me that such a setup has produced an error on his Macbook with Intel HD 3000 so if you run into a similar problem simply use a pass thru GS, or change the topology type.</p>
<p>Note that the adjacent vertices in the vertex buffer have the same format and attributes as regular vertices. What makes them adjacent is simply their relative location within each group of six vertices. In the case of a model whose triangles are continuous the same vertices will sometimes be regular and sometimes adjacent, depending on the current triangle. This makes indexed draws even more attractive due to the saving of space in the vertex buffer.</p>
<h3 id="source-walkthru">Source walkthru</h3>
<p>(mesh.cpp:204)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="n">Mesh</span><span class="o">::</span><span class="n">FindAdjacencies</span><span class="p">(</span><span class="k">const</span> <span class="n">aiMesh</span><span class="o">*</span> <span class="n">paiMesh</span><span class="p">,</span> <span class="n">vector</span><span class="o">&amp;</span> <span class="n">Indices</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="n">uint</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">paiMesh</span><span class="o">-&gt;</span><span class="n">mNumFaces</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>    
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="k">const</span> <span class="n">aiFace</span><span class="o">&amp;</span> <span class="n">face</span> <span class="o">=</span> <span class="n">paiMesh</span><span class="o">-&gt;</span><span class="n">mFaces</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>    
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="n">Face</span> <span class="n">Unique</span><span class="p">;</span>    
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="c1">// If a position vector is duplicated in the VB we fetch the    
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1"></span>    <span class="c1">// index of the first occurrence.    
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="n">uint</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>      
</span></span><span class="line"><span class="ln">11</span><span class="cl">      <span class="n">uint</span> <span class="n">Index</span> <span class="o">=</span> <span class="n">face</span><span class="p">.</span><span class="n">mIndices</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>      
</span></span><span class="line"><span class="ln">12</span><span class="cl">      <span class="n">aiVector3D</span><span class="o">&amp;</span> <span class="n">v</span> <span class="o">=</span> <span class="n">paiMesh</span><span class="o">-&gt;</span><span class="n">mVertices</span><span class="p">[</span><span class="n">Index</span><span class="p">];</span>      
</span></span><span class="line"><span class="ln">13</span><span class="cl">      
</span></span><span class="line"><span class="ln">14</span><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">m_posMap</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="n">m_posMap</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>        
</span></span><span class="line"><span class="ln">15</span><span class="cl">        <span class="n">m_posMap</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">Index</span><span class="p">;</span>      
</span></span><span class="line"><span class="ln">16</span><span class="cl">      <span class="p">}</span>      
</span></span><span class="line"><span class="ln">17</span><span class="cl">      <span class="k">else</span> <span class="p">{</span>        
</span></span><span class="line"><span class="ln">18</span><span class="cl">        <span class="n">Index</span> <span class="o">=</span> <span class="n">m_posMap</span><span class="p">[</span><span class="n">v</span><span class="p">];</span>      
</span></span><span class="line"><span class="ln">19</span><span class="cl">      <span class="p">}</span>      
</span></span><span class="line"><span class="ln">20</span><span class="cl">      
</span></span><span class="line"><span class="ln">21</span><span class="cl">      <span class="n">Unique</span><span class="p">.</span><span class="n">Indices</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">Index</span><span class="p">;</span>    
</span></span><span class="line"><span class="ln">22</span><span class="cl">    <span class="p">}</span>    
</span></span><span class="line"><span class="ln">23</span><span class="cl">    
</span></span><span class="line"><span class="ln">24</span><span class="cl">    <span class="n">m_uniqueFaces</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Unique</span><span class="p">);</span>    
</span></span><span class="line"><span class="ln">25</span><span class="cl">    
</span></span><span class="line"><span class="ln">26</span><span class="cl">    <span class="n">Edge</span> <span class="nf">e1</span><span class="p">(</span><span class="n">Unique</span><span class="p">.</span><span class="n">Indices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Unique</span><span class="p">.</span><span class="n">Indices</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>    
</span></span><span class="line"><span class="ln">27</span><span class="cl">    <span class="n">Edge</span> <span class="nf">e2</span><span class="p">(</span><span class="n">Unique</span><span class="p">.</span><span class="n">Indices</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">Unique</span><span class="p">.</span><span class="n">Indices</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>    
</span></span><span class="line"><span class="ln">28</span><span class="cl">    <span class="n">Edge</span> <span class="nf">e3</span><span class="p">(</span><span class="n">Unique</span><span class="p">.</span><span class="n">Indices</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">Unique</span><span class="p">.</span><span class="n">Indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>    
</span></span><span class="line"><span class="ln">29</span><span class="cl">    
</span></span><span class="line"><span class="ln">30</span><span class="cl">    <span class="n">m_indexMap</span><span class="p">[</span><span class="n">e1</span><span class="p">].</span><span class="n">AddNeigbor</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>    
</span></span><span class="line"><span class="ln">31</span><span class="cl">    <span class="n">m_indexMap</span><span class="p">[</span><span class="n">e2</span><span class="p">].</span><span class="n">AddNeigbor</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>    
</span></span><span class="line"><span class="ln">32</span><span class="cl">    <span class="n">m_indexMap</span><span class="p">[</span><span class="n">e3</span><span class="p">].</span><span class="n">AddNeigbor</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">33</span><span class="cl">  <span class="p">}</span></span></span></code></pre></div><p>Most of the adjacency logic is contained in the above function and a few helper structures. The algorithm is composed of two stages. In the first stage we create a map between each edge and the two triangles that share it. This happens in the above for loop. In the first half of this loop we generate a map between each vertex position and the first index that refers to it. The reason why different indices may point to vertices that share the same position is that sometimes other attributes force Assimp to split the same vertex into two vertices. e.g. the same vertex may have different texture attributes for two neighboring triangles that share it. This creates a problem for our adjacency algorithm and we prefer to have each vertex appear only once. Therefore, we create this mapping between a position and first index and use only this index from now on.</p>
<p>(mesh.cpp:240)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="n">uint</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">paiMesh</span><span class="o">-&gt;</span><span class="n">mNumFaces</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>    
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    <span class="k">const</span> <span class="n">Face</span><span class="o">&amp;</span> <span class="n">face</span> <span class="o">=</span> <span class="n">m_uniqueFaces</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>    
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">uint</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>      
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">      <span class="n">Edge</span> <span class="nf">e</span><span class="p">(</span><span class="n">face</span><span class="p">.</span><span class="n">Indices</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">face</span><span class="p">.</span><span class="n">Indices</span><span class="p">[(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]);</span>      
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">      <span class="n">assert</span><span class="p">(</span><span class="n">m_indexMap</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">!=</span> <span class="n">m_indexMap</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>      
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">      <span class="n">Neighbors</span> <span class="n">n</span> <span class="o">=</span> <span class="n">m_indexMap</span><span class="p">[</span><span class="n">e</span><span class="p">];</span>      
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">      <span class="n">uint</span> <span class="n">OtherTri</span> <span class="o">=</span> <span class="n">n</span><span class="p">.</span><span class="n">GetOther</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>      
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">      
</span></span><span class="line"><span class="ln">10</span><span class="cl">      <span class="n">assert</span><span class="p">(</span><span class="n">OtherTri</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>      
</span></span><span class="line"><span class="ln">11</span><span class="cl">        
</span></span><span class="line"><span class="ln">12</span><span class="cl">      <span class="k">const</span> <span class="n">Face</span><span class="o">&amp;</span> <span class="n">OtherFace</span> <span class="o">=</span> <span class="n">m_uniqueFaces</span><span class="p">[</span><span class="n">OtherTri</span><span class="p">];</span>      
</span></span><span class="line"><span class="ln">13</span><span class="cl">      <span class="n">uint</span> <span class="n">OppositeIndex</span> <span class="o">=</span> <span class="n">OtherFace</span><span class="p">.</span><span class="n">GetOppositeIndex</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>      
</span></span><span class="line"><span class="ln">14</span><span class="cl">      
</span></span><span class="line"><span class="ln">15</span><span class="cl">      <span class="n">Indices</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">face</span><span class="p">.</span><span class="n">Indices</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>      
</span></span><span class="line"><span class="ln">16</span><span class="cl">      <span class="n">Indices</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">OppositeIndex</span><span class="p">);</span>    
</span></span><span class="line"><span class="ln">17</span><span class="cl">    <span class="p">}</span>  
</span></span><span class="line"><span class="ln">18</span><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>In the second stage we populate the index vector with sets of six vertices each that match the topology of the triangle list with adjacency that we saw earlier. The map that we created in the first stage helps us here because for each edge in the triangle it is very easy to find the neighboring triangle that shares it and then the vertex in that triangle which is opposite to this edge. The last two lines in the loop alternate the content of the index buffer between vertices from the current triangle and vertices from the adjacent triangles that are opposite to edges of the current triangle.</p>
<p>There are a few additional minor changes to the Mesh class. I suggest you compare it to the version from the previous tutorial to make sure you capture all differences. One of the notable changes is that we use GL_TRIANGLES_ADJACENCY instead of GL_TRIANGLES as the topology when calling glDrawElementsBaseVertex(). If you forget that the GL will feed incorrectly sized primitives into the GS.</p>
<p>(silhouette.vs)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">Position</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec2</span> <span class="n">TexCoord</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">Normal</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="n">out</span> <span class="n">vec3</span> <span class="n">WorldPos0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="n">uniform</span> <span class="n">mat4</span> <span class="n">gWVP</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="n">uniform</span> <span class="n">mat4</span> <span class="n">gWorld</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln">14</span><span class="cl">  <span class="n">vec4</span> <span class="n">PosL</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">Position</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">15</span><span class="cl">  <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">gWVP</span> <span class="o">*</span> <span class="n">PosL</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">16</span><span class="cl">  <span class="n">WorldPos0</span> <span class="o">=</span> <span class="p">(</span><span class="n">gWorld</span> <span class="o">*</span> <span class="n">PosL</span><span class="p">).</span><span class="n">xyz</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>In today&rsquo;s demo we are going to detect the silhouette of an object and mark it by a thick red line. The object itself will be drawn using our standard forward rendering lighting shader and the silhouette will be drawn using a dedicated shader. The code above belongs to the VS of that shader. There is nothing special about it. We just need to transform the position into clip space using the WVP matrix and provide the GS with the vertices in world space (since the silhouette algorithm takes place in world space).</p>
<p>(silhouette.gs)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#version 330
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">triangles_adjacency</span><span class="p">)</span> <span class="n">in</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">line_strip</span><span class="p">,</span> <span class="n">max_vertices</span> <span class="o">=</span> <span class="mi">6</span><span class="p">)</span> <span class="n">out</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">in</span> <span class="n">vec3</span> <span class="n">WorldPos0</span><span class="p">[];</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="kt">void</span> <span class="nf">EmitLine</span><span class="p">(</span><span class="kt">int</span> <span class="n">StartIndex</span><span class="p">,</span> <span class="kt">int</span> <span class="n">EndIndex</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln">10</span><span class="cl">  <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">gl_in</span><span class="p">[</span><span class="n">StartIndex</span><span class="p">].</span><span class="n">gl_Position</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">11</span><span class="cl">  <span class="n">EmitVertex</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln">12</span><span class="cl">  
</span></span><span class="line"><span class="ln">13</span><span class="cl">  <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">gl_in</span><span class="p">[</span><span class="n">EndIndex</span><span class="p">].</span><span class="n">gl_Position</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">14</span><span class="cl">  <span class="n">EmitVertex</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln">15</span><span class="cl">  
</span></span><span class="line"><span class="ln">16</span><span class="cl">  <span class="n">EndPrimitive</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">
</span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="n">uniform</span> <span class="n">vec3</span> <span class="n">gLightPos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">
</span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln">23</span><span class="cl">  <span class="n">vec3</span> <span class="n">e1</span> <span class="o">=</span> <span class="n">WorldPos0</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">WorldPos0</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>  
</span></span><span class="line"><span class="ln">24</span><span class="cl">  <span class="n">vec3</span> <span class="n">e2</span> <span class="o">=</span> <span class="n">WorldPos0</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">-</span> <span class="n">WorldPos0</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>  
</span></span><span class="line"><span class="ln">25</span><span class="cl">  <span class="n">vec3</span> <span class="n">e3</span> <span class="o">=</span> <span class="n">WorldPos0</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">WorldPos0</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>  
</span></span><span class="line"><span class="ln">26</span><span class="cl">  <span class="n">vec3</span> <span class="n">e4</span> <span class="o">=</span> <span class="n">WorldPos0</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">WorldPos0</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>  
</span></span><span class="line"><span class="ln">27</span><span class="cl">  <span class="n">vec3</span> <span class="n">e5</span> <span class="o">=</span> <span class="n">WorldPos0</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">-</span> <span class="n">WorldPos0</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>  
</span></span><span class="line"><span class="ln">28</span><span class="cl">  <span class="n">vec3</span> <span class="n">e6</span> <span class="o">=</span> <span class="n">WorldPos0</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">-</span> <span class="n">WorldPos0</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>  
</span></span><span class="line"><span class="ln">29</span><span class="cl">  
</span></span><span class="line"><span class="ln">30</span><span class="cl">  <span class="n">vec3</span> <span class="n">Normal</span> <span class="o">=</span> <span class="n">cross</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span><span class="n">e2</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">31</span><span class="cl">  <span class="n">vec3</span> <span class="n">LightDir</span> <span class="o">=</span> <span class="n">gLightPos</span> <span class="o">-</span> <span class="n">WorldPos0</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>  
</span></span><span class="line"><span class="ln">32</span><span class="cl">  
</span></span><span class="line"><span class="ln">33</span><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">Normal</span><span class="p">,</span> <span class="n">LightDir</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.00001</span><span class="p">)</span> <span class="p">{</span>    
</span></span><span class="line"><span class="ln">34</span><span class="cl">    
</span></span><span class="line"><span class="ln">35</span><span class="cl">    <span class="n">Normal</span> <span class="o">=</span> <span class="n">cross</span><span class="p">(</span><span class="n">e3</span><span class="p">,</span><span class="n">e1</span><span class="p">);</span>    
</span></span><span class="line"><span class="ln">36</span><span class="cl">    
</span></span><span class="line"><span class="ln">37</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">Normal</span><span class="p">,</span> <span class="n">LightDir</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>      
</span></span><span class="line"><span class="ln">38</span><span class="cl">      <span class="n">EmitLine</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>    
</span></span><span class="line"><span class="ln">39</span><span class="cl">    <span class="p">}</span>    
</span></span><span class="line"><span class="ln">40</span><span class="cl">    
</span></span><span class="line"><span class="ln">41</span><span class="cl">    <span class="n">Normal</span> <span class="o">=</span> <span class="n">cross</span><span class="p">(</span><span class="n">e4</span><span class="p">,</span><span class="n">e5</span><span class="p">);</span>    
</span></span><span class="line"><span class="ln">42</span><span class="cl">    <span class="n">LightDir</span> <span class="o">=</span> <span class="n">gLightPos</span> <span class="o">-</span> <span class="n">WorldPos0</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>    
</span></span><span class="line"><span class="ln">43</span><span class="cl">    
</span></span><span class="line"><span class="ln">44</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">Normal</span><span class="p">,</span> <span class="n">LightDir</span><span class="p">)</span> <span class="o">&lt;=</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>      
</span></span><span class="line"><span class="ln">45</span><span class="cl">      <span class="n">EmitLine</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>    
</span></span><span class="line"><span class="ln">46</span><span class="cl">    <span class="p">}</span>    
</span></span><span class="line"><span class="ln">47</span><span class="cl">    
</span></span><span class="line"><span class="ln">48</span><span class="cl">    <span class="n">Normal</span> <span class="o">=</span> <span class="n">cross</span><span class="p">(</span><span class="n">e2</span><span class="p">,</span><span class="n">e6</span><span class="p">);</span>    
</span></span><span class="line"><span class="ln">49</span><span class="cl">    <span class="n">LightDir</span> <span class="o">=</span> <span class="n">gLightPos</span> <span class="o">-</span> <span class="n">WorldPos0</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>    
</span></span><span class="line"><span class="ln">50</span><span class="cl">    
</span></span><span class="line"><span class="ln">51</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">Normal</span><span class="p">,</span> <span class="n">LightDir</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>      
</span></span><span class="line"><span class="ln">52</span><span class="cl">      <span class="n">EmitLine</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>    
</span></span><span class="line"><span class="ln">53</span><span class="cl">    <span class="p">}</span>  
</span></span><span class="line"><span class="ln">54</span><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="ln">55</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>All the silhouette logic is contained within the GS. When using the triangle list with adjacencies topology the GS receives an array of six vertices. We start by calculating a few selected edges that will help us calculate the normal of the current triangle as well as the three adjacent triangles. Use the picture above to understand how to map e1-e6 to actual edges. Then we check whether the triangle faces the light by calculating a dot product between its normal and the light direction (with the light vector going towards the light). If the result of the dot product is positive the answer is yes (we use a small epsilon due to floating point inaccuracies). If the triangle does not face the light then this is the end of the way for it, but if it is light facing, we do the same dot product operation between the light vector and every one of the three adjacent triangles. If we hit an adjacent triangle that doesn&rsquo;t face the light we call the EmitLine() function which (unsurprisingly) emits the shared edge between the triangle (which faces the light) and its neighbor (which does not). The FS simply draws that edge in red.</p>
<p>(tutorial39.cpp:183)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="nf">RenderScene</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  <span class="c1">// Render the object as-is  
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1"></span>  <span class="n">m_LightingTech</span><span class="p">.</span><span class="n">Enable</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">  <span class="n">Pipeline</span> <span class="n">p</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  <span class="n">p</span><span class="p">.</span><span class="n">SetPerspectiveProj</span><span class="p">(</span><span class="n">m_persProjInfo</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">  <span class="n">p</span><span class="p">.</span><span class="n">SetCamera</span><span class="p">(</span><span class="n">m_pGameCamera</span><span class="o">-&gt;</span><span class="n">GetPos</span><span class="p">(),</span> <span class="n">m_pGameCamera</span><span class="o">-&gt;</span><span class="n">GetTarget</span><span class="p">(),</span> <span class="n">m_pGameCamera</span><span class="o">-&gt;</span><span class="n">GetUp</span><span class="p">());</span>  
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  <span class="n">p</span><span class="p">.</span><span class="n">WorldPos</span><span class="p">(</span><span class="n">m_boxPos</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">10</span><span class="cl">  <span class="n">m_LightingTech</span><span class="p">.</span><span class="n">SetWorldMatrix</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">GetWorldTrans</span><span class="p">());</span>  
</span></span><span class="line"><span class="ln">11</span><span class="cl">  <span class="n">m_LightingTech</span><span class="p">.</span><span class="n">SetWVP</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">GetWVPTrans</span><span class="p">());</span>  
</span></span><span class="line"><span class="ln">12</span><span class="cl">  <span class="n">m_mesh</span><span class="p">.</span><span class="n">Render</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln">13</span><span class="cl">  
</span></span><span class="line"><span class="ln">14</span><span class="cl">  <span class="c1">// Render the object&#39;s silhouette  
</span></span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="c1"></span>  <span class="n">m_silhouetteTech</span><span class="p">.</span><span class="n">Enable</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln">16</span><span class="cl">  
</span></span><span class="line"><span class="ln">17</span><span class="cl">  <span class="n">m_silhouetteTech</span><span class="p">.</span><span class="n">SetWorldMatrix</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">GetWorldTrans</span><span class="p">());</span>  
</span></span><span class="line"><span class="ln">18</span><span class="cl">  <span class="n">m_silhouetteTech</span><span class="p">.</span><span class="n">SetWVP</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">GetWVPTrans</span><span class="p">());</span>  
</span></span><span class="line"><span class="ln">19</span><span class="cl">  <span class="n">m_silhouetteTech</span><span class="p">.</span><span class="n">SetLightPos</span><span class="p">(</span><span class="n">Vector3f</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">10.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">));</span>  
</span></span><span class="line"><span class="ln">20</span><span class="cl">  
</span></span><span class="line"><span class="ln">21</span><span class="cl">  <span class="n">glLineWidth</span><span class="p">(</span><span class="mf">5.0f</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">22</span><span class="cl">  
</span></span><span class="line"><span class="ln">23</span><span class="cl">  <span class="n">m_mesh</span><span class="p">.</span><span class="n">Render</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>This is how we use the silhouette technique. The same object is rendered twice. First with the standard lighting shader. Then with the silhouette shader. Note how the function glLightWidth() is used to make the silhouette thicker and thus more noticeable.</p>
<p>If you use the code above as-is to create the demo, you might notice a minor corruption around the silhouette lines. The reason is that the second render generates a line with roughly the same depth as the original mesh edge. This causes a phenomenon known as <em>Z fighting</em> as pixels from the silhouette and the original mesh cover each other in an inconsistent way (again, due to floating point accuracies). To fix this we call glDepthFunc(GL_LEQUAL) which relaxes the depth test a bit. It means that if a second pixel is rendered on top of a previous pixel with the same depth the last pixel always take precedence.</p>

            <footer class="footline">
            </footer>
          </article>

        </div>
      </main>
    </div>
    <script src="../../../../../js/clipboard.min.js?1708235103" defer></script>
    <script src="../../../../../js/perfect-scrollbar.min.js?1708235103" defer></script>
    <script src="../../../../../js/theme.js?1708235103" defer></script>
  </body>
</html>
