<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.122.0">
    <meta name="generator" content="Relearn 5.23.2+tip">
    <meta name="description" content="啊啊啊啊">
    <meta name="author" content="Sören Weber">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="https://example.com/images/hero.png">
    <meta name="twitter:title" content="Tutorial 26:Normal Mapping :: Hugo Relearn Theme">
    <meta name="twitter:description" content="Background Our lighting technique results are not too bad. The light is nicely interpolated over the model and conveys a sense of realism to the scene. This, however, can be improved tremendously. In fact, the same interpolation is actually an obstacle because sometimes, especially when the undelying texture represents a bumpy surface, it makes it look too flat. As an example, take a look at the following two images:
The left image definitely looks better the than the right one.">
    <meta property="og:title" content="Tutorial 26:Normal Mapping :: Hugo Relearn Theme">
    <meta property="og:description" content="Background Our lighting technique results are not too bad. The light is nicely interpolated over the model and conveys a sense of realism to the scene. This, however, can be improved tremendously. In fact, the same interpolation is actually an obstacle because sometimes, especially when the undelying texture represents a bumpy surface, it makes it look too flat. As an example, take a look at the following two images:
The left image definitely looks better the than the right one.">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://example.com/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_26_normal_mapping/index.html">
    <meta property="og:image" content="https://example.com/images/hero.png">
    <meta property="article:section" content="OGL dev 教程 :: Hugo Relearn Theme">
    <meta property="og:site_name" content="Hugo Relearn Theme">
    <title>Tutorial 26:Normal Mapping :: Hugo Relearn Theme</title>
    <link href="https://example.com/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_26_normal_mapping/index.html" rel="canonical" type="text/html" title="Tutorial 26:Normal Mapping :: Hugo Relearn Theme">
    <link href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_26_normal_mapping/index.xml" rel="alternate" type="application/rss+xml" title="Tutorial 26:Normal Mapping :: Hugo Relearn Theme"><link rel="icon" href="../../../../../images/favicon.ico">
    <!-- https://github.com/filamentgroup/loadCSS/blob/master/README.md#how-to-use -->
    <link href="../../../../../css/fontawesome-all.min.css?1708235002" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../../../../../css/fontawesome-all.min.css?1708235002" rel="stylesheet"></noscript>
    <link href="../../../../../css/nucleus.css?1708235002" rel="stylesheet">
    <link href="../../../../../css/auto-complete.css?1708235002" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../../../../../css/auto-complete.css?1708235002" rel="stylesheet"></noscript>
    <link href="../../../../../css/perfect-scrollbar.min.css?1708235002" rel="stylesheet">
    <link href="../../../../../css/fonts.css?1708235002" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../../../../../css/fonts.css?1708235002" rel="stylesheet"></noscript>
    <link href="../../../../../css/theme.css?1708235002" rel="stylesheet">
    <link href="../../../../../css/theme-auto.css?1708235002" rel="stylesheet" id="R-variant-style">
    <link href="../../../../../css/variant.css?1708235002" rel="stylesheet">
    <link href="../../../../../css/print.css?1708235002" rel="stylesheet" media="print">
    <link href="../../../../../css/format-print.css?1708235002" rel="stylesheet">
    <link href="../../../../../css/ie.css?1708235002" rel="stylesheet">
    <script src="../../../../../js/url.js?1708235002"></script>
    <script src="../../../../../js/variant.js?1708235002"></script>
    <script>
      // hack to let hugo tell us how to get to the root when using relativeURLs, it needs to be called *url= for it to do its magic:
      // https://github.com/gohugoio/hugo/blob/145b3fcce35fbac25c7033c91c1b7ae6d1179da8/transform/urlreplacers/absurlreplacer.go#L72
      window.index_js_url="../../../../../index.search.js";
      var root_url="../../../../../";
      var baseUri=root_url.replace(/\/$/, '');
      window.relearn = window.relearn || {};
      window.relearn.baseUriFull='https:\/\/example.com/';
      // variant stuff
      window.variants && variants.init( [ 'auto', 'relearn-light', 'relearn-dark', 'zen-light', 'zen-dark', 'neon', 'learn', 'blue', 'green', 'red' ] );
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
    </script>
    <style>
      #R-body img.bg-white {
        background-color: white;
      }
    </style>
  </head>
  <body class="mobile-support print" data-url="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_26_normal_mapping/index.html">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide">
              <button class="topbar-control" onclick="toggleNav()" type="button" title="Menu (CTRL&#43;ALT&#43;n)">
                <i class="fa-fw fas fa-bars"></i>
              </button>
            </div>
          </div>
          <ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype="http://schema.org/BreadcrumbList"><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../index.html"><span itemprop="name">主页</span></a><meta itemprop="position" content="1">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../computer_graphics/index.html"><span itemprop="name">计算机图形学</span></a><meta itemprop="position" content="2">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../computer_graphics/classic_tutorial/index.html"><span itemprop="name">经典教程</span></a><meta itemprop="position" content="3">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/index.html"><span itemprop="name">OpenGL教程</span></a><meta itemprop="position" content="4">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/index.html"><span itemprop="name">OGL dev 教程</span></a><meta itemprop="position" content="5">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><span itemprop="name">Tutorial 26:Normal Mapping</span><meta itemprop="position" content="6"></li>
          </ol>
          <div class="topbar-area topbar-area-end" data-area="end">
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable default" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="default">
            <header class="headline">
            </header>
<h1 id="tutorial-26normal-mapping">Tutorial 26:Normal Mapping</h1>

<h3 id="background">Background</h3>
<p>Our lighting technique results are not too bad. The light is nicely interpolated over the model and conveys a sense of realism to the scene. This, however, can be improved tremendously. In fact, the same interpolation is actually an obstacle because sometimes, especially when the undelying texture represents a bumpy surface, it makes it look too flat. As an example, take a look at the following two images:</p>
<p><a href="#R-image-c6861f6f92af584a5543c83ad350154f" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_26_normal_mapping/../assets/compare.jpeg" alt="img" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c6861f6f92af584a5543c83ad350154f"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_26_normal_mapping/../assets/compare.jpeg" alt="img" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>The left image definitely looks better the than the right one. It conveys the sense of the bumpiness of the stone much better while the right image looks too smooth for a brick texture. The left image has been rendered using a technique known as <em>Normal Mapping</em> (a.k.a Bump Mapping) and this is the subject of this tutorial.</p>
<p>The idea behind normal mapping is that instead of interpolating the vertex normals across the triangle face (which creates the smoothness we are trying to get rid off) they can simply be sampled from a texture. This represents the real world better because most surfaces (especially the ones we are interested in for gaming) are not that smooth such that light will be reflected back in accordance with the way we interpolate the normals. Instead, the bumps on the surface will make it reflect back at different directions, according to the general direction of the surface at the specific location where the light hits. For each texture these normals can be calculated and stored in a special texture which is called a <em>normal map</em>. During lighting calculations in the fragment shader the specific normal for each pixel is sampled and used as usual. The following images show the difference between the normals in regular lighting and normal mapping:</p>
<p><a href="#R-image-a9b91ecf4f02a2afe7fa7ba60ef3fe0d" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_26_normal_mapping/../assets/normals.jpeg" alt="img" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a9b91ecf4f02a2afe7fa7ba60ef3fe0d"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_26_normal_mapping/../assets/normals.jpeg" alt="img" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>We now have our normal map and the true (or at least a good approximation of) surface normals are stored in it. Can we simply go ahead and use it? no. Think for a moment on the cube with the brick texture above. The same texture is applied on all six faces and therefore, the same normal map that goes along with it. The problem is that each face is pointing at a different direction so its interaction with an arbitrary light ray is different. If we use the normal vectors from map without any modification we would get incorrect results because the same normal vector cannot be correct for six faces pointing at different directions! For example, the normals of the top face point in the general direction of (0,1,0), even on a very bumpy surface. However, the normals of the bottom face point in the general direction of (0,-1,0). The point is that the normals are defined in their own private coordinate space and some conversion must be done in order to bring them to world space where they can participate in lighting calculations. In a sense, this concept is very similar to what we did with vertex normals. They were defined in the object local space and we transformed them to world space using the world matrix.</p>
<p>Let&rsquo;s define the coordinate system in which the normal vectors exist. This coordinate system requires three orthogonal axes of unit length. Since the normal is part of a 2D texture and 2D textures have two orthogonal axis U and V (both of unit length) the common practice is to map the X component of the system to the U axis and the Y component to the V axis. Remember that U goes from left to right and V from bottom to top (the origin in that system is the bottom left corner of the texture). The Z component of the system is considered to be going straight up from the texture and is perpendicular to both X and Y:</p>
<p><a href="#R-image-9dfec236896378e56e29fea2bd49b618" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_26_normal_mapping/../assets/tangent_space.jpeg" alt="img" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-9dfec236896378e56e29fea2bd49b618"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_26_normal_mapping/../assets/tangent_space.jpeg" alt="img" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>The normal vectors can now be specified in reference to that coordinate system and stored in the RGB texels of the texture. Note that even on a bumpy surface we still expect the general direction of the normals to point out from the texture. i.e. the Z component is the dominant one while the X and Y just make the vector tilt a bit (or a lot) from side to side. Storing the XYZ vector in an RGB texel makes most normal maps rather bluish as in the following example:</p>
<p><a href="#R-image-bafc0cbdbbf73f56f30dc7e889feaa43" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_26_normal_mapping/../assets/normal_map.jpeg" alt="img" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-bafc0cbdbbf73f56f30dc7e889feaa43"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_26_normal_mapping/../assets/normal_map.jpeg" alt="img" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Here&rsquo;s the first five texels of the top row of this normal map (when going from left to right): (136,102,248), (144,122,255), (141,145,253), (102, 168, 244) and (34,130,216). The dominance of the Z here cannot be mistaken.</p>
<p>What we do next is to go over all the triangles in our model and place the normal map on each one in a way that the texture coordinates of each vertex will match their location on the map. For example, say that the texture coordinate of a given triangle are (0.5,0), (1, 0.5) and (0,1). The normal map will be placed as follows:</p>
<p><a href="#R-image-c2338e050529f93e8ec63a00bc523390" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_26_normal_mapping/../assets/tangent_space4.jpeg" alt="img" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c2338e050529f93e8ec63a00bc523390"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_26_normal_mapping/../assets/tangent_space4.jpeg" alt="img" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>In the picture above the coordinate system on the bottom left corner represents the object local space.</p>
<p>In addition to texture coordinates the three vertices also have 3D coordinates that represent their position in the object local space. When we placed the texture on top of the triangle above we&rsquo;ve essentially given a value to the U and V vectors of the texture in the object local space. If we now calculate U and V in the object local space (as well as U cross V which is the normal to the texture) we can generate a transformation matrix to move the normals from the map into the object local space. From there they can be transformed to world space as usual and take part in lighting calculation. The common practice is to call the U vector in the object local space the <em>Tangent</em> and the V vector in the object local space the <em>Bitangent</em>. The transformation matrix that we need to generate is called a TBN matrix (Tangent-Bitangent-Normal). These Tangent-Bitangent-Normal vectors define a coordinate system known as Tangent (or texture ) space. Therefore, the normals in the map are stored in tangent/texture space. We will now find out how to calculate U and V in object space.t</p>
<p>Let&rsquo;s take a look at the picture above more generically. We have triangle with three vertices at positions P0, P1 and P2 and texture coordinates (U0,V0), (U1,V1) and (U2,V2):</p>
<p><a href="#R-image-e1cc3c8bd40b46c80f6648f02877809d" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_26_normal_mapping/../assets/tangent_space5.jpeg" alt="img" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-e1cc3c8bd40b46c80f6648f02877809d"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_26_normal_mapping/../assets/tangent_space5.jpeg" alt="img" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>We want to find the vectors T (representing the tangent) and B (representing the bitangent) in object space. We can see that the two triangle edges E1 and E2 can be written as a linear combination of T and B:</p>
<p><a href="#R-image-e0fad09d85901c9fae9a1808b1dd0de1" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_26_normal_mapping/../assets/tangent_space_calc1.jpeg" alt="img" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-e0fad09d85901c9fae9a1808b1dd0de1"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_26_normal_mapping/../assets/tangent_space_calc1.jpeg" alt="img" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>This can also be written as follows:</p>
<p><a href="#R-image-afc5fe5bcfe56090856f08a69330313a" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_26_normal_mapping/../assets/tangent_space_calc2.jpeg" alt="img" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-afc5fe5bcfe56090856f08a69330313a"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_26_normal_mapping/../assets/tangent_space_calc2.jpeg" alt="img" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>It is now very easy to move to a matrix form:</p>
<p><a href="#R-image-4e308645734888a56f4774bed13fabe2" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_26_normal_mapping/../assets/tangent_space_calc3.jpeg" alt="img" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-4e308645734888a56f4774bed13fabe2"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_26_normal_mapping/../assets/tangent_space_calc3.jpeg" alt="img" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>We want to extract the matrix on the right hand side. To do that we can multiply both ends of the equation by the inverse of the matrix marked in red above:</p>
<p><a href="#R-image-f9f134937f6cf35395f7d2347152c9e8" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_26_normal_mapping/../assets/tangent_space_calc4.jpeg" alt="img" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f9f134937f6cf35395f7d2347152c9e8"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_26_normal_mapping/../assets/tangent_space_calc4.jpeg" alt="img" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Now we have the following:</p>
<p><a href="#R-image-722d507886abb9849124d724b170571d" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_26_normal_mapping/../assets/tangent_space_calc5.jpeg" alt="img" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-722d507886abb9849124d724b170571d"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_26_normal_mapping/../assets/tangent_space_calc5.jpeg" alt="img" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>After calculating the matrix inverse we get:</p>
<p><a href="#R-image-81104cf0a07e366ca69cfd3b6c1e0f84" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_26_normal_mapping/../assets/tangent_space_calc6.jpeg" alt="img" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-81104cf0a07e366ca69cfd3b6c1e0f84"><img src="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_26_normal_mapping/../assets/tangent_space_calc6.jpeg" alt="img" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>We can run this process on every triangle in the mesh and generate tangent and bitangent vectors per triangle (same vectors for the three triangle vertices). The common practice is to store a per-vertex tangent/bitangent by averaging all the tangents/bitangents of the triangles that share that vertex (same as we do for vertex normals). The reason is to smooth out the effect as we travel across the triangle face and avoid hard breaks on the edges of neighboring triangles. The third element of this coordinate system, the normal, is the cross product of the tangent and bitangent. This trio of Tangent-Bitangent-Normal can now serve as a basis for a coordinate system and be used to transform the normal from the normal map into the local object space. The next step is to transform it to world space and use it for lighting calculations. However, we can optimize it a bit by transforming the Tangent-Bitangent-Normal themselves into world space and only then transform the normal from the map. This will provide the normal in world space directly.</p>
<p>In this tutorial we will do the following:</p>
<ol>
<li>Supply the tangent vector to the vertex shader.</li>
<li>Transform the tangent vector to world space and pass it to the fragment shader.</li>
<li>Use the tangent vector and normal (both in world space) to calculate the bitangent in the fragment shader.</li>
<li>Generate a world space transformation matrix using the tangent-bitangent-normal.</li>
<li>Sample the normal from the normal map.</li>
<li>Transform the normal to world space using the above matrix.</li>
<li>Continue lighting calculations as usual.</li>
</ol>
<p>There is one peculiarity which we will need to address in our code. On the pixel level the tangent-bitangent-normal are not really an orthonormal basis (three unit length vectors that are perpendicular to one another). Two reasons contribute to that - first, we average the tangents and normal per vertex according to the triangles that share it, and second, the tangents and normals are interpolated by the rasterizer and on the pixel level we see the interpolated result. This makes the tangent-bitangnet-normal loose some of their &ldquo;orthonormal qualities&rdquo;. But to transform from tangent space into world space we will need an orthonormal basis. The solution is to use the <a href="http://en.wikipedia.org/wiki/Gram%e2%80%93Schmidt_process" target="_blank">Gram-Schmidt</a> process. This process takes a group of vectors and turns them into an orthonormal basis. In a nutshell, the process is as follows: select vector &lsquo;A&rsquo; from the group and normalize it. Then select vector &lsquo;B&rsquo; and break it into two components (the two components are vectors whose sum is &lsquo;B&rsquo;) where the first component points in the direction of &lsquo;A&rsquo; and the second component is perpendicular to it. Now replace &lsquo;B&rsquo; by the component that is perpendicular to &lsquo;A&rsquo; and normalize it. Continue this process on all vectors in the group.</p>
<p>The end result of all this is that we are not using the mathematically correct tangent-bitangent-normal vectors but we are getting the required smoothness to avoid hard breaks on triangle edges.</p>
<h3 id="source-walkthru">Source walkthru</h3>
<p>(mesh.h:33)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">struct</span> <span class="nc">Vertex</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  <span class="n">Vector3f</span> <span class="n">m_pos</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  <span class="n">Vector2f</span> <span class="n">m_tex</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  <span class="n">Vector3f</span> <span class="n">m_normal</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">  <span class="n">Vector3f</span> <span class="n">m_tangent</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">  <span class="n">Vertex</span><span class="p">()</span> <span class="p">{}</span>  
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  
</span></span><span class="line"><span class="ln">10</span><span class="cl">  <span class="n">Vertex</span><span class="p">(</span> <span class="k">const</span> <span class="n">Vector3f</span><span class="o">&amp;</span> <span class="n">pos</span><span class="p">,</span>      
</span></span><span class="line"><span class="ln">11</span><span class="cl">         <span class="k">const</span> <span class="n">Vector2f</span><span class="o">&amp;</span> <span class="n">tex</span><span class="p">,</span>      
</span></span><span class="line"><span class="ln">12</span><span class="cl">         <span class="k">const</span> <span class="n">Vector3f</span><span class="o">&amp;</span> <span class="n">normal</span><span class="p">,</span>      
</span></span><span class="line"><span class="ln">13</span><span class="cl">         <span class="k">const</span> <span class="n">Vector3f</span><span class="o">&amp;</span> <span class="n">Tangent</span><span class="p">)</span>  
</span></span><span class="line"><span class="ln">14</span><span class="cl">  <span class="p">{</span>    
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="n">m_pos</span> <span class="o">=</span> <span class="n">pos</span><span class="p">;</span>    
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="n">m_tex</span> <span class="o">=</span> <span class="n">tex</span><span class="p">;</span>    
</span></span><span class="line"><span class="ln">17</span><span class="cl">    <span class="n">m_normal</span> <span class="o">=</span> <span class="n">normal</span><span class="p">;</span>    
</span></span><span class="line"><span class="ln">18</span><span class="cl">    <span class="n">m_tangent</span> <span class="o">=</span> <span class="n">Tangent</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="p">};</span></span></span></code></pre></div><p>This is our new Vertex structure with the new addition of the tangent vector. We will calculate the bitangent in the fragment shader. Note that the normal of the tangent space is identical to the regular triangle normal (since the texture and triangle are parallel). Therefore, the vertex normals in the two coordinate system are also identical.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">Indices</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>  
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">  <span class="n">Vertex</span><span class="o">&amp;</span> <span class="n">v0</span> <span class="o">=</span> <span class="n">Vertices</span><span class="p">[</span><span class="n">Indices</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span>  
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  <span class="n">Vertex</span><span class="o">&amp;</span> <span class="n">v1</span> <span class="o">=</span> <span class="n">Vertices</span><span class="p">[</span><span class="n">Indices</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]];</span>  
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  <span class="n">Vertex</span><span class="o">&amp;</span> <span class="n">v2</span> <span class="o">=</span> <span class="n">Vertices</span><span class="p">[</span><span class="n">Indices</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">]];</span>  
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">  <span class="n">Vector3f</span> <span class="n">Edge1</span> <span class="o">=</span> <span class="n">v1</span><span class="p">.</span><span class="n">m_pos</span> <span class="o">-</span> <span class="n">v0</span><span class="p">.</span><span class="n">m_pos</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  <span class="n">Vector3f</span> <span class="n">Edge2</span> <span class="o">=</span> <span class="n">v2</span><span class="p">.</span><span class="n">m_pos</span> <span class="o">-</span> <span class="n">v0</span><span class="p">.</span><span class="n">m_pos</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  <span class="kt">float</span> <span class="n">DeltaU1</span> <span class="o">=</span> <span class="n">v1</span><span class="p">.</span><span class="n">m_tex</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">v0</span><span class="p">.</span><span class="n">m_tex</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">10</span><span class="cl">  <span class="kt">float</span> <span class="n">DeltaV1</span> <span class="o">=</span> <span class="n">v1</span><span class="p">.</span><span class="n">m_tex</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">v0</span><span class="p">.</span><span class="n">m_tex</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">11</span><span class="cl">  <span class="kt">float</span> <span class="n">DeltaU2</span> <span class="o">=</span> <span class="n">v2</span><span class="p">.</span><span class="n">m_tex</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">v0</span><span class="p">.</span><span class="n">m_tex</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">12</span><span class="cl">  <span class="kt">float</span> <span class="n">DeltaV2</span> <span class="o">=</span> <span class="n">v2</span><span class="p">.</span><span class="n">m_tex</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">v0</span><span class="p">.</span><span class="n">m_tex</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">13</span><span class="cl">  
</span></span><span class="line"><span class="ln">14</span><span class="cl">  <span class="kt">float</span> <span class="n">f</span> <span class="o">=</span> <span class="mf">1.0f</span> <span class="o">/</span> <span class="p">(</span><span class="n">DeltaU1</span> <span class="o">*</span> <span class="n">DeltaV2</span> <span class="o">-</span> <span class="n">DeltaU2</span> <span class="o">*</span> <span class="n">DeltaV1</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">15</span><span class="cl">  
</span></span><span class="line"><span class="ln">16</span><span class="cl">  <span class="n">Vector3f</span> <span class="n">Tangent</span><span class="p">,</span> <span class="n">Bitangent</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">17</span><span class="cl">  
</span></span><span class="line"><span class="ln">18</span><span class="cl">  <span class="n">Tangent</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">f</span> <span class="o">*</span> <span class="p">(</span><span class="n">DeltaV2</span> <span class="o">*</span> <span class="n">Edge1</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">DeltaV1</span> <span class="o">*</span> <span class="n">Edge2</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">19</span><span class="cl">  <span class="n">Tangent</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">f</span> <span class="o">*</span> <span class="p">(</span><span class="n">DeltaV2</span> <span class="o">*</span> <span class="n">Edge1</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">DeltaV1</span> <span class="o">*</span> <span class="n">Edge2</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">20</span><span class="cl">  <span class="n">Tangent</span><span class="p">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">f</span> <span class="o">*</span> <span class="p">(</span><span class="n">DeltaV2</span> <span class="o">*</span> <span class="n">Edge1</span><span class="p">.</span><span class="n">z</span> <span class="o">-</span> <span class="n">DeltaV1</span> <span class="o">*</span> <span class="n">Edge2</span><span class="p">.</span><span class="n">z</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">21</span><span class="cl">  
</span></span><span class="line"><span class="ln">22</span><span class="cl">  <span class="n">Bitangent</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">f</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">DeltaU2</span> <span class="o">*</span> <span class="n">Edge1</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">DeltaU1</span> <span class="o">*</span> <span class="n">Edge2</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">23</span><span class="cl">  <span class="n">Bitangent</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">f</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">DeltaU2</span> <span class="o">*</span> <span class="n">Edge1</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">DeltaU1</span> <span class="o">*</span> <span class="n">Edge2</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">24</span><span class="cl">  <span class="n">Bitangent</span><span class="p">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">f</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">DeltaU2</span> <span class="o">*</span> <span class="n">Edge1</span><span class="p">.</span><span class="n">z</span> <span class="o">+</span> <span class="n">DeltaU1</span> <span class="o">*</span> <span class="n">Edge2</span><span class="p">.</span><span class="n">z</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">25</span><span class="cl">  
</span></span><span class="line"><span class="ln">26</span><span class="cl">  <span class="n">v0</span><span class="p">.</span><span class="n">m_tangent</span> <span class="o">+=</span> <span class="n">Tangent</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">27</span><span class="cl">  <span class="n">v1</span><span class="p">.</span><span class="n">m_tangent</span> <span class="o">+=</span> <span class="n">Tangent</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">28</span><span class="cl">  <span class="n">v2</span><span class="p">.</span><span class="n">m_tangent</span> <span class="o">+=</span> <span class="n">Tangent</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">29</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">30</span><span class="cl">
</span></span><span class="line"><span class="ln">31</span><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">Vertices</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>  
</span></span><span class="line"><span class="ln">32</span><span class="cl">  <span class="n">Vertices</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">m_tangent</span><span class="p">.</span><span class="n">Normalize</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">33</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>This piece of code is an implementation of the algorithm that calculates the tangent vectors (described in the background section). The Indices array is traversed and the triangle vectors are retrieved from the Vertices array by their indices. We calculale the two edges by substracting the first vertex from the second and the third vertices. We do a similar thing with the texture coordinates and calculate the deltas along the U and V axes of the two edges. &lsquo;f&rsquo; represents the fraction that appears on the right hand side of the final equation in the background section. Once &lsquo;f&rsquo; is known both the tangent and bitangent can be calculated by multiplying it by the product of the two matrices. Note that the calculation of the bitangent appears for the sake of completeness. The only thing that we really need is the tangent which we accumulate into the three vertices. The last thing that we do is scan the Vertices array and normalize the tangents.</p>
<p>Now that you fully understand both the theory and imlementation I can tell you that we won&rsquo;t be using this code in the tutorial. The Open Asset Import Library has a handy post processing flag called &lsquo;aiProcess_CalcTangentSpace&rsquo; which does exactly that and calculates the tangent vectors for us (it&rsquo;s good to know the implementation anyway in case you need to do it yourself in a future project). We only need to specify it when loading the model and then we can access the &lsquo;mTangents&rsquo; array in the aiMesh class and fetch the tangents from there. Check the code for more details.</p>
<p>(mesh.cpp:195)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="n">Mesh</span><span class="o">::</span><span class="n">Render</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  <span class="p">...</span>  
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  <span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m_Entries</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>    
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="p">...</span>    
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Vertex</span><span class="p">),</span> <span class="p">(</span><span class="k">const</span> <span class="n">GLvoid</span><span class="o">*</span><span class="p">)</span><span class="mi">32</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  <span class="p">}</span>  
</span></span><span class="line"><span class="ln">10</span><span class="cl">  <span class="p">...</span>  
</span></span><span class="line"><span class="ln">11</span><span class="cl">  <span class="n">glDisableVertexAttribArray</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>Since the Vertex structure has grown we need to make a few modification to the render function of the Mesh class. The fourth vertex attribute is enabled and we specify the location of the tangent in byte 32 (just after the normal) from the start of the vertex. Finally, the fourth attribute is disabled.</p>
<p>(lighting.vs)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">Position</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec2</span> <span class="n">TexCoord</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">Normal</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">Tangent</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">uniform</span> <span class="n">mat4</span> <span class="n">gWVP</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="n">uniform</span> <span class="n">mat4</span> <span class="n">gLightWVP</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="n">uniform</span> <span class="n">mat4</span> <span class="n">gWorld</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="n">out</span> <span class="n">vec4</span> <span class="n">LightSpacePos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="n">out</span> <span class="n">vec2</span> <span class="n">TexCoord0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="n">out</span> <span class="n">vec3</span> <span class="n">Normal0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="n">out</span> <span class="n">vec3</span> <span class="n">WorldPos0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="n">out</span> <span class="n">vec3</span> <span class="n">Tangent0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">
</span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln">18</span><span class="cl">  <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">gWVP</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">Position</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">19</span><span class="cl">  <span class="n">LightSpacePos</span> <span class="o">=</span> <span class="n">gLightWVP</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">Position</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">20</span><span class="cl">  <span class="n">TexCoord0</span> <span class="o">=</span> <span class="n">TexCoord</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">21</span><span class="cl">  <span class="n">Normal0</span> <span class="o">=</span> <span class="p">(</span><span class="n">gWorld</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">Normal</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)).</span><span class="n">xyz</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">22</span><span class="cl">  <span class="n">Tangent0</span> <span class="o">=</span> <span class="p">(</span><span class="n">gWorld</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">Tangent</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)).</span><span class="n">xyz</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">23</span><span class="cl">  <span class="n">WorldPos0</span> <span class="o">=</span> <span class="p">(</span><span class="n">gWorld</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">Position</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)).</span><span class="n">xyz</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>This is the updated vertex shader. There isn&rsquo;t a lot of new stuff here as most of the changes are in the fragment shader. The new addition is the tangent which is passed as an input, transformed to world space and passed on as an output.</p>
<p>(lighting.fs:132)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">vec3</span> <span class="nf">CalcBumpedNormal</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  <span class="n">vec3</span> <span class="n">Normal</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">Normal0</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  <span class="n">vec3</span> <span class="n">Tangent</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">Tangent0</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  <span class="n">Tangent</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">Tangent</span> <span class="o">-</span> <span class="n">dot</span><span class="p">(</span><span class="n">Tangent</span><span class="p">,</span> <span class="n">Normal</span><span class="p">)</span> <span class="o">*</span> <span class="n">Normal</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">  <span class="n">vec3</span> <span class="n">Bitangent</span> <span class="o">=</span> <span class="n">cross</span><span class="p">(</span><span class="n">Tangent</span><span class="p">,</span> <span class="n">Normal</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  <span class="n">vec3</span> <span class="n">BumpMapNormal</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">gNormalMap</span><span class="p">,</span> <span class="n">TexCoord0</span><span class="p">).</span><span class="n">xyz</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">  <span class="n">BumpMapNormal</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">BumpMapNormal</span> <span class="o">-</span> <span class="n">vec3</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  <span class="n">vec3</span> <span class="n">NewNormal</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">10</span><span class="cl">  <span class="n">mat3</span> <span class="n">TBN</span> <span class="o">=</span> <span class="n">mat3</span><span class="p">(</span><span class="n">Tangent</span><span class="p">,</span> <span class="n">Bitangent</span><span class="p">,</span> <span class="n">Normal</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">11</span><span class="cl">  <span class="n">NewNormal</span> <span class="o">=</span> <span class="n">TBN</span> <span class="o">*</span> <span class="n">BumpMapNormal</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">12</span><span class="cl">  <span class="n">NewNormal</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">NewNormal</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">13</span><span class="cl">  <span class="k">return</span> <span class="n">NewNormal</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">
</span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln">18</span><span class="cl">  <span class="n">vec3</span> <span class="n">Normal</span> <span class="o">=</span> <span class="n">CalcBumpedNormal</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln">19</span><span class="cl">  <span class="p">...</span></span></span></code></pre></div><p>The code above contains most of the changes in the fragment shader. All handling of the normal is encapsulated in the CalcBumpedNormal() function. We start by normalizing both the normal and the tangent vectors. The third line is the Gramm-Schmidt process. dot(Tangent, Normal) gives us the length of the projection of the tangent along the normal vector. The product of this length by the normal itself is the component of the tangent along the normal. Substract that from the tangent and we get a new vector which is perpendicular to the normal. This is our new tangent (just remember to normalize it as well&hellip;). A cross product between the tangent and the normal gives us the bitangent. Next, we sample the normal map and get the normal for this pixel (in tangent space). &lsquo;gNormalMap&rsquo; is a new uniform of the sampler2D type to which we must bind the normal map before the draw. The normal is stored as a color so its components are in the range [0-1]. We transform it back to its original format using the function &lsquo;f(x) = 2 * x - 1&rsquo;. This function maps 0 to -1 and 1 to 1 and is simply the reverse of what happened when the normal map was generated.</p>
<p>We now need to transform the normal from tangent space into world space. We create a 3x3 matrix called TBN using one of the constructors of the &lsquo;mat3&rsquo; type. This constructor takes three vectors as parameters and generates a matrix by placing the first parameter in the top row, the second in the middle and the third in the bottom row. If you wonder why this order and not another simply remember that the tangent is mapped to the X axis, the bitangent to the Y and the normal to the Z (see picture above). In the standard 3x3 identity matrix the top row contains the X axis, the middle the Y axis and the bottom the Z axis. We simply match this order. The tangent space normal is multiplied by the TBN matrix and the result is normalized before it is returned to the caller. This is the final pixel normal.</p>
<p>The sample that accompanies this tutorial comes with three JPEG files:</p>
<ol>
<li>&lsquo;bricks.jpg&rsquo; is the color texture.</li>
<li>&rsquo;normal_map.jpg&rsquo; is the normal map that was generated from &lsquo;bricks.jpg&rsquo;.</li>
<li>&rsquo;normal_up.jpg&rsquo; is a trivial normal map where all normals point straight upwards. When this normal map is used the effect is as if no normal mapping takes place. It is simpler to bind this texture when we want to disable normal mapping then to use two different techniques (albeit less efficient). You can use the &lsquo;b&rsquo; key to toggle between normal-mapping and no-normal-mapping and see the effect.</li>
</ol>
<p>The normal map is bound to texture unit 2 which is now the standard texture unit for that purpose (0 is the color and 1 is the shadow map).</p>
<p><strong>Note on normal map generation:</strong></p>
<p>There are many ways to generate a normal map. For this tutorial I used <a href="http://www.gimp.org/" target="_blank">gimp</a> which is free and open source and its <a href="http://code.google.com/p/gimp-normalmap/" target="_blank">normal map plugin</a>. Once you have the plugin installed simply load the texture that you plan to use for the model, go to Filters-&gt;Map-&gt;Normalmap. You will be able to change many aspects of the normal map and configure it in different ways. When satisfied click &lsquo;OK&rsquo;. The normal map will replace the original texture in the main view of gimp. Save it under a new filename and use it in your samples.</p>

            <footer class="footline">
            </footer>
          </article>

        </div>
      </main>
    </div>
    <script src="../../../../../js/clipboard.min.js?1708235002" defer></script>
    <script src="../../../../../js/perfect-scrollbar.min.js?1708235002" defer></script>
    <script src="../../../../../js/theme.js?1708235002" defer></script>
  </body>
</html>
