<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.122.0">
    <meta name="generator" content="Relearn 5.23.2+tip">
    <meta name="description" content="啊啊啊啊">
    <meta name="author" content="Sören Weber">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="https://example.com/images/hero.png">
    <meta name="twitter:title" content="Tutorial 22:Loading models using the Open Asset Import Library :: Hugo Relearn Theme">
    <meta name="twitter:description" content="Background We have made it thus far using manually generated models. As you can imagine, the process of specifying the position and other attributes for each and every vertex in an object does not scale well. A box, pyramid and a simple tiled surface are OK, but what about something like a human face? In the real world of games and commercial applications the process of mesh creation is handled by artists that use modeling programs such as Blender, Maya and 3ds Max.">
    <meta property="og:title" content="Tutorial 22:Loading models using the Open Asset Import Library :: Hugo Relearn Theme">
    <meta property="og:description" content="Background We have made it thus far using manually generated models. As you can imagine, the process of specifying the position and other attributes for each and every vertex in an object does not scale well. A box, pyramid and a simple tiled surface are OK, but what about something like a human face? In the real world of games and commercial applications the process of mesh creation is handled by artists that use modeling programs such as Blender, Maya and 3ds Max.">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://example.com/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_22_loading_models_using_the_open_asset_import_library/index.html">
    <meta property="og:image" content="https://example.com/images/hero.png">
    <meta property="article:section" content="OGL dev 教程 :: Hugo Relearn Theme">
    <meta property="og:site_name" content="Hugo Relearn Theme">
    <title>Tutorial 22:Loading models using the Open Asset Import Library :: Hugo Relearn Theme</title>
    <link href="https://example.com/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_22_loading_models_using_the_open_asset_import_library/index.html" rel="canonical" type="text/html" title="Tutorial 22:Loading models using the Open Asset Import Library :: Hugo Relearn Theme">
    <link href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_22_loading_models_using_the_open_asset_import_library/index.xml" rel="alternate" type="application/rss+xml" title="Tutorial 22:Loading models using the Open Asset Import Library :: Hugo Relearn Theme"><link rel="icon" href="../../../../../images/favicon.ico">
    <!-- https://github.com/filamentgroup/loadCSS/blob/master/README.md#how-to-use -->
    <link href="../../../../../css/fontawesome-all.min.css?1708235002" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../../../../../css/fontawesome-all.min.css?1708235002" rel="stylesheet"></noscript>
    <link href="../../../../../css/nucleus.css?1708235002" rel="stylesheet">
    <link href="../../../../../css/auto-complete.css?1708235002" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../../../../../css/auto-complete.css?1708235002" rel="stylesheet"></noscript>
    <link href="../../../../../css/perfect-scrollbar.min.css?1708235002" rel="stylesheet">
    <link href="../../../../../css/fonts.css?1708235002" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../../../../../css/fonts.css?1708235002" rel="stylesheet"></noscript>
    <link href="../../../../../css/theme.css?1708235002" rel="stylesheet">
    <link href="../../../../../css/theme-auto.css?1708235002" rel="stylesheet" id="R-variant-style">
    <link href="../../../../../css/variant.css?1708235002" rel="stylesheet">
    <link href="../../../../../css/print.css?1708235002" rel="stylesheet" media="print">
    <link href="../../../../../css/format-print.css?1708235002" rel="stylesheet">
    <link href="../../../../../css/ie.css?1708235002" rel="stylesheet">
    <script src="../../../../../js/url.js?1708235002"></script>
    <script src="../../../../../js/variant.js?1708235002"></script>
    <script>
      // hack to let hugo tell us how to get to the root when using relativeURLs, it needs to be called *url= for it to do its magic:
      // https://github.com/gohugoio/hugo/blob/145b3fcce35fbac25c7033c91c1b7ae6d1179da8/transform/urlreplacers/absurlreplacer.go#L72
      window.index_js_url="../../../../../index.search.js";
      var root_url="../../../../../";
      var baseUri=root_url.replace(/\/$/, '');
      window.relearn = window.relearn || {};
      window.relearn.baseUriFull='https:\/\/example.com/';
      // variant stuff
      window.variants && variants.init( [ 'auto', 'relearn-light', 'relearn-dark', 'zen-light', 'zen-dark', 'neon', 'learn', 'blue', 'green', 'red' ] );
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
    </script>
    <style>
      #R-body img.bg-white {
        background-color: white;
      }
    </style>
  </head>
  <body class="mobile-support print" data-url="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_22_loading_models_using_the_open_asset_import_library/index.html">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide">
              <button class="topbar-control" onclick="toggleNav()" type="button" title="Menu (CTRL&#43;ALT&#43;n)">
                <i class="fa-fw fas fa-bars"></i>
              </button>
            </div>
          </div>
          <ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype="http://schema.org/BreadcrumbList"><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../index.html"><span itemprop="name">主页</span></a><meta itemprop="position" content="1">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../computer_graphics/index.html"><span itemprop="name">计算机图形学</span></a><meta itemprop="position" content="2">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../computer_graphics/classic_tutorial/index.html"><span itemprop="name">经典教程</span></a><meta itemprop="position" content="3">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/index.html"><span itemprop="name">OpenGL教程</span></a><meta itemprop="position" content="4">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/index.html"><span itemprop="name">OGL dev 教程</span></a><meta itemprop="position" content="5">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><span itemprop="name">Tutorial 22:Loading models using the Open Asset Import Library</span><meta itemprop="position" content="6"></li>
          </ol>
          <div class="topbar-area topbar-area-end" data-area="end">
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable default" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="default">
            <header class="headline">
            </header>
<h1 id="tutorial-22loading-models-using-the-open-asset-import-library">Tutorial 22:Loading models using the Open Asset Import Library</h1>

<h3 id="background">Background</h3>
<p>We have made it thus far using manually generated models. As you can imagine, the process of specifying the position and other attributes for each and every vertex in an object does not scale well. A box, pyramid and a simple tiled surface are OK, but what about something like a human face? In the real world of games and commercial applications the process of mesh creation is handled by artists that use modeling programs such as <a href="http://www.blender.org/" target="_blank">Blender</a>, <a href="http://usa.autodesk.com/maya/" target="_blank">Maya</a> and <a href="http://usa.autodesk.com/3ds-max/" target="_blank">3ds Max</a>. These applications provide advanced tools that help the artist create extremely sophisticated models. When the model is complete it is saved to a file in one of the many available formats. The file contains the entire geometry definition of the model. It can now be loaded into a game engine (provided the engine supports the particular format) and its contents can be used to populate vertex and index buffers for rendering. Knowing how to parse the geometry definition file format and load professional models is crucial in order to take your 3D programming to the next level.</p>
<p>Developing the parser on your own can consume quite a lot of your time. If you want to be able to load models from different sources, you will need to study each format and develop a specific parser for it. Some of the formats are simple but some are very complex and you might end up spending too much time on something which is not exactly core 3D programming. Therefore, the approach persued by this tutorial is to use an external library to take care of parsing and loading the models from files.</p>
<p>The <a href="http://www.assimp.org/" target="_blank">Open Asset Import Library</a>, or Assimp, is an open source library that can handle many 3D formats, including the most popular ones. It is portable and available for both Linux and Windows. It is very easy to use and integrate into programs written in C/C++.</p>
<p>There is not much theory in this tutorial. Let&rsquo;s dive right in and see how we can integrate Assimp into our 3D programs.
(before you start, make sure you install Assimp from the link above).</p>
<h3 id="source-walkthru">Source walkthru</h3>
<p>(mesh.h:50)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">class</span> <span class="nc">Mesh</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="k">public</span><span class="o">:</span>  
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  <span class="n">Mesh</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">  <span class="o">~</span><span class="n">Mesh</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">  <span class="kt">bool</span> <span class="nf">LoadMesh</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">Filename</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  
</span></span><span class="line"><span class="ln">10</span><span class="cl">  <span class="kt">void</span> <span class="nf">Render</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">  
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="k">private</span><span class="o">:</span>  
</span></span><span class="line"><span class="ln">13</span><span class="cl">  <span class="kt">bool</span> <span class="n">InitFromScene</span><span class="p">(</span><span class="k">const</span> <span class="n">aiScene</span><span class="o">*</span> <span class="n">pScene</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">Filename</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">14</span><span class="cl">  <span class="kt">void</span> <span class="nf">InitMesh</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">Index</span><span class="p">,</span> <span class="k">const</span> <span class="n">aiMesh</span><span class="o">*</span> <span class="n">paiMesh</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">15</span><span class="cl">  <span class="kt">bool</span> <span class="nf">InitMaterials</span><span class="p">(</span><span class="k">const</span> <span class="n">aiScene</span><span class="o">*</span> <span class="n">pScene</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">Filename</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">16</span><span class="cl">  <span class="kt">void</span> <span class="nf">Clear</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">  
</span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="cp">#define INVALID_MATERIAL 0xFFFFFFFF  
</span></span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="cp"></span>  
</span></span><span class="line"><span class="ln">20</span><span class="cl">  <span class="k">struct</span> <span class="nc">MeshEntry</span> <span class="p">{</span>    
</span></span><span class="line"><span class="ln">21</span><span class="cl">    <span class="n">MeshEntry</span><span class="p">();</span>    
</span></span><span class="line"><span class="ln">22</span><span class="cl">    
</span></span><span class="line"><span class="ln">23</span><span class="cl">    <span class="o">~</span><span class="n">MeshEntry</span><span class="p">();</span>    
</span></span><span class="line"><span class="ln">24</span><span class="cl">    
</span></span><span class="line"><span class="ln">25</span><span class="cl">    <span class="kt">bool</span> <span class="nf">Init</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&amp;</span> <span class="n">Vertices</span><span class="p">,</span>    
</span></span><span class="line"><span class="ln">26</span><span class="cl">              <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&amp;</span> <span class="n">Indices</span><span class="p">);</span>    
</span></span><span class="line"><span class="ln">27</span><span class="cl">    
</span></span><span class="line"><span class="ln">28</span><span class="cl">    <span class="n">GLuint</span> <span class="n">VB</span><span class="p">;</span>    
</span></span><span class="line"><span class="ln">29</span><span class="cl">    <span class="n">GLuint</span> <span class="n">IB</span><span class="p">;</span>    
</span></span><span class="line"><span class="ln">30</span><span class="cl">    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">NumIndices</span><span class="p">;</span>    
</span></span><span class="line"><span class="ln">31</span><span class="cl">    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">MaterialIndex</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">32</span><span class="cl">  <span class="p">};</span>  
</span></span><span class="line"><span class="ln">33</span><span class="cl">  
</span></span><span class="line"><span class="ln">34</span><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span> <span class="n">m_Entries</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">35</span><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span> <span class="n">m_Textures</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">36</span><span class="cl"><span class="p">};</span></span></span></code></pre></div><p>The Mesh class represents the interface between Assimp and our OpenGL program. An object of this class takes a file name as a parameter to the LoadMesh() function, uses Assimp to load the model and then creates vertex buffers, index bufferss and Texture objects that contain the data of the model in the form that our program understands. In order to render the mesh we use the function Render(). The internal structure of the Mesh class matches the way that Assimp loads models. Assimp uses an aiScene object to represent the loaded mesh. The aiScene object contains mesh structures that encapsulate parts of the model. There must be at least one mesh structure in the aiScene object. Complex models can contain multiple mesh structures. The m_Entries member of the Mesh class is a vector of the MeshEntry struct where each structure corresponds to one mesh structure in the aiScene object. That structure contains the vertex buffer, index buffer and the index of the material. For now, a material is simply a texture and since mesh entries can share materials we have a separate vector for them (m_Textures). MeshEntry::MaterialIndex points into one of the textures in m_Textures.</p>
<p>(mesh.cpp:77)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">bool</span> <span class="n">Mesh</span><span class="o">::</span><span class="n">LoadMesh</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">Filename</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  <span class="c1">// Release the previously loaded mesh (if it exists)  
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1"></span>  <span class="n">Clear</span><span class="p">();</span>  
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">  <span class="kt">bool</span> <span class="n">Ret</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  <span class="n">Assimp</span><span class="o">::</span><span class="n">Importer</span> <span class="n">Importer</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  <span class="k">const</span> <span class="n">aiScene</span><span class="o">*</span> <span class="n">pScene</span> <span class="o">=</span> <span class="n">Importer</span><span class="p">.</span><span class="n">ReadFile</span><span class="p">(</span><span class="n">Filename</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span> <span class="n">aiProcess_Triangulate</span> <span class="o">|</span> <span class="n">aiProcess_GenSmoothNormals</span> <span class="o">|</span> <span class="n">aiProcess_FlipUVs</span> <span class="o">|</span> <span class="n">aiProcess_JoinIdenticalVertices</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">10</span><span class="cl">  
</span></span><span class="line"><span class="ln">11</span><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">pScene</span><span class="p">)</span> <span class="p">{</span>    
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="n">Ret</span> <span class="o">=</span> <span class="n">InitFromScene</span><span class="p">(</span><span class="n">pScene</span><span class="p">,</span> <span class="n">Filename</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">13</span><span class="cl">  <span class="p">}</span>  
</span></span><span class="line"><span class="ln">14</span><span class="cl">  <span class="k">else</span> <span class="p">{</span>    
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Error parsing &#39;%s&#39;: &#39;%s&#39;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">Filename</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span> <span class="n">Importer</span><span class="p">.</span><span class="n">GetErrorString</span><span class="p">());</span>  
</span></span><span class="line"><span class="ln">16</span><span class="cl">  <span class="p">}</span>  
</span></span><span class="line"><span class="ln">17</span><span class="cl">  
</span></span><span class="line"><span class="ln">18</span><span class="cl">  <span class="k">return</span> <span class="n">Ret</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>This function is the starting point of loading the mesh. We create an instance of the Assimp::Importer class on the stack and call its ReadFile function. This function takes two parameters: the full path of the model file and a mask of post processing options. Assimp is capable of performing many useful processing actions on the loaded models. For example, it can generate normals for models that lack them, optimize the structure of the model to improve performance, etc. The full list of options is availabe <a href="http://www.assimp.org/lib_html/ai_post_process_8h.html" target="_blank">here</a>. In this tutorial we use the following options:</p>
<ul>
<li>aiProcess_Triangulate - translate models that are made from non triangle polygons into triangle based meshes. For example, a quad mesh can be translated into a triangle mesh by creating two triangles out of each quad.</li>
<li>aiProcess_GenSmoothNormals - generates vertex normals in the case that the original model does not already contain them.</li>
<li>aiProcess_FlipUVsv - flip the texture coordinates along the Y axis. This was required in order to render the Quake model that was used for the demo correctly.</li>
<li>aiProcess_JoinIdenticalVertices - use a single copy for each vertex and reference it from multiple indices, if required. Helps save up memory.</li>
</ul>
<p>Note that the post processing options are basically non overlapping bitmasks so you can combine multiple options by simply ORing their values. You will need to tailor the options that you use according to the input data. If the mesh was loaded successfully, we get a pointer to an <a href="http://www.assimp.org/lib_html/structai_scene.html" target="_blank">aiScene</a> object. This object contains the entire model contents, divided into <a href="http://www.assimp.org/lib_html/structai_mesh.html" target="_blank">aiMesh</a> structures. Next we call the InitFromScene() function to initialize the Mesh object.</p>
<p>(mesh.cpp:97)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">bool</span> <span class="n">Mesh</span><span class="o">::</span><span class="n">InitFromScene</span><span class="p">(</span><span class="k">const</span> <span class="n">aiScene</span><span class="o">*</span> <span class="n">pScene</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">Filename</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  <span class="n">m_Entries</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">pScene</span><span class="o">-&gt;</span><span class="n">mNumMeshes</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  <span class="n">m_Textures</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">pScene</span><span class="o">-&gt;</span><span class="n">mNumMaterials</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">  <span class="c1">// Initialize the meshes in the scene one by one  
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1"></span>  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m_Entries</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>    
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="k">const</span> <span class="n">aiMesh</span><span class="o">*</span> <span class="n">paiMesh</span> <span class="o">=</span> <span class="n">pScene</span><span class="o">-&gt;</span><span class="n">mMeshes</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>    
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="n">InitMesh</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">paiMesh</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">10</span><span class="cl">  <span class="p">}</span>  
</span></span><span class="line"><span class="ln">11</span><span class="cl">  
</span></span><span class="line"><span class="ln">12</span><span class="cl">  <span class="k">return</span> <span class="nf">InitMaterials</span><span class="p">(</span><span class="n">pScene</span><span class="p">,</span> <span class="n">Filename</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>We start the initialization of the Mesh object by setting up space in the mesh entries and texture vectors for all the meshes and materials we will need. The numbers are available in the aiScene object members mNumMeshes and mNumMaterials, respectively. Next we scan the mMeshes array in the aiScene object and initialize the mesh entries one by one. Finally, the materials are initialized.</p>
<p>(mesh.cpp:111)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">void</span> <span class="n">Mesh</span><span class="o">::</span><span class="n">InitMesh</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">Index</span><span class="p">,</span> <span class="k">const</span> <span class="n">aiMesh</span><span class="o">*</span> <span class="n">paiMesh</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln">3</span><span class="cl">  <span class="n">m_Entries</span><span class="p">[</span><span class="n">Index</span><span class="p">].</span><span class="n">MaterialIndex</span> <span class="o">=</span> <span class="n">paiMesh</span><span class="o">-&gt;</span><span class="n">mMaterialIndex</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">4</span><span class="cl">  
</span></span><span class="line"><span class="ln">5</span><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span> <span class="n">Vertices</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">6</span><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span> <span class="n">Indices</span><span class="p">;</span>  
</span></span><span class="line"><span class="ln">7</span><span class="cl">  <span class="p">...</span></span></span></code></pre></div><p>We start the initialization of the mesh by storing its material index. This will be used during rendering to bind the proper texture. Next we create two STL vectors to store the contents of the vertex and index buffers. A STL vector has a nice property of storing its contents in a continuous buffer. This makes it easy to load the data into the OpenGL buffer (using the glBufferData() function).</p>
<p>(mesh.cpp:118)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">const</span> <span class="n">aiVector3D</span> <span class="nf">Zero3D</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">paiMesh</span><span class="o">-&gt;</span><span class="n">mNumVertices</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>    
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  <span class="k">const</span> <span class="n">aiVector3D</span><span class="o">*</span> <span class="n">pPos</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">paiMesh</span><span class="o">-&gt;</span><span class="n">mVertices</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>    
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  <span class="k">const</span> <span class="n">aiVector3D</span><span class="o">*</span> <span class="n">pNormal</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">paiMesh</span><span class="o">-&gt;</span><span class="n">mNormals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">:</span> <span class="o">&amp;</span><span class="n">Zero3D</span><span class="p">;</span>    
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">  <span class="k">const</span> <span class="n">aiVector3D</span><span class="o">*</span> <span class="n">pTexCoord</span> <span class="o">=</span> <span class="n">paiMesh</span><span class="o">-&gt;</span><span class="n">HasTextureCoords</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">paiMesh</span><span class="o">-&gt;</span><span class="n">mTextureCoords</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">])</span> <span class="o">:</span> <span class="o">&amp;</span><span class="n">Zero3D</span><span class="p">;</span>    
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">  <span class="n">Vertex</span> <span class="nf">v</span><span class="p">(</span><span class="n">Vector3f</span><span class="p">(</span><span class="n">pPos</span><span class="o">-&gt;</span><span class="n">x</span><span class="p">,</span> <span class="n">pPos</span><span class="o">-&gt;</span><span class="n">y</span><span class="p">,</span> <span class="n">pPos</span><span class="o">-&gt;</span><span class="n">z</span><span class="p">),</span>        
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">           <span class="n">Vector2f</span><span class="p">(</span><span class="n">pTexCoord</span><span class="o">-&gt;</span><span class="n">x</span><span class="p">,</span> <span class="n">pTexCoord</span><span class="o">-&gt;</span><span class="n">y</span><span class="p">),</span>        
</span></span><span class="line"><span class="ln">10</span><span class="cl">           <span class="n">Vector3f</span><span class="p">(</span><span class="n">pNormal</span><span class="o">-&gt;</span><span class="n">x</span><span class="p">,</span> <span class="n">pNormal</span><span class="o">-&gt;</span><span class="n">y</span><span class="p">,</span> <span class="n">pNormal</span><span class="o">-&gt;</span><span class="n">z</span><span class="p">));</span>    
</span></span><span class="line"><span class="ln">11</span><span class="cl">  
</span></span><span class="line"><span class="ln">12</span><span class="cl">  <span class="n">Vertices</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="p">}</span>  
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="p">...</span></span></span></code></pre></div><p>Here we prepare the contents of the vertex buffer by populating the Vertices vector. We use the following attributes of the aiMesh class:</p>
<ol>
<li>mNumVertices - the number of vertices.</li>
<li>mVertices - an array of mNumVertices vectors that contain the position.</li>
<li>mNormals - an array of mNumVertices vectors that contain the vertex normals.</li>
<li>mTextureCoords - an array of mNumVertices vectors that contain the texture coordinates. This is actualy a two dimensional array because each vertex can hold several texture coordinates.</li>
</ol>
<p>So basically we have three separate arrays that contain everything we need for the vertices and we need to pick out each attribute from its corresponding array in order to build the final Vertex structure. This structure is pushed back to the vertex vector (maintaining the same index as in the three aiMesh arrays). Note that some models do not have texture coordinates so before accessing the mTextureCoords array (and possibly causing a segmentation fault) we check whether texture coordinates exist by calling HasTextureCoords(). In addition, a mesh can contain multiple texture coordinates per vertex. In this tutorial we take the simple way of using only the first texture coordinate. So the mTextureCoords array (which is 2 dimensional) is always accessed on its first row. Therefore, the HasTextureCoords() function is always called for the first row. If a texture coordinate does not exist the Vertex structure will be initialized with the zero vector.</p>
<p>(mesh.cpp:132)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">paiMesh</span><span class="o">-&gt;</span><span class="n">mNumFaces</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>    
</span></span><span class="line"><span class="ln">2</span><span class="cl">    <span class="k">const</span> <span class="n">aiFace</span><span class="o">&amp;</span> <span class="n">Face</span> <span class="o">=</span> <span class="n">paiMesh</span><span class="o">-&gt;</span><span class="n">mFaces</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>    
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="n">assert</span><span class="p">(</span><span class="n">Face</span><span class="p">.</span><span class="n">mNumIndices</span> <span class="o">==</span> <span class="mi">3</span><span class="p">);</span>    
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="n">Indices</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Face</span><span class="p">.</span><span class="n">mIndices</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>    
</span></span><span class="line"><span class="ln">5</span><span class="cl">    <span class="n">Indices</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Face</span><span class="p">.</span><span class="n">mIndices</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>    
</span></span><span class="line"><span class="ln">6</span><span class="cl">    <span class="n">Indices</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Face</span><span class="p">.</span><span class="n">mIndices</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>  
</span></span><span class="line"><span class="ln">7</span><span class="cl">  <span class="p">}</span>  
</span></span><span class="line"><span class="ln">8</span><span class="cl">  <span class="p">...</span></span></span></code></pre></div><p>Next we create the index buffer. The mNumFaces member in the aiMesh class tells us how many polygons exist and the array mFaces contains their data (which is indices of the vertices). First we verify that the number of indices in the polygon is indeed 3 (when loading the model we requested that it will get triangulated but it is always good to check this). Then we extract the indices from the mIndices array and push them into the Indices vector.</p>
<p>(mesh.cpp:140)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl">  <span class="n">m_Entries</span><span class="p">[</span><span class="n">Index</span><span class="p">].</span><span class="n">Init</span><span class="p">(</span><span class="n">Vertices</span><span class="p">,</span> <span class="n">Indices</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>Finally, the MeshEntry structure is initialized using the vertex and index vectors. There is nothing new in the MeshEntry::Init() function so it is not quoted here. It uses glGenBuffer(), glBindBuffer() and glBufferData() to create and populate the vertex and index buffers. See the source file for more details.</p>
<p>(mesh.cpp:143)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">bool</span> <span class="n">Mesh</span><span class="o">::</span><span class="n">InitMaterials</span><span class="p">(</span><span class="k">const</span> <span class="n">aiScene</span><span class="o">*</span> <span class="n">pScene</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">Filename</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln">3</span><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pScene</span><span class="o">-&gt;</span><span class="n">mNumMaterials</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>    
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="k">const</span> <span class="n">aiMaterial</span><span class="o">*</span> <span class="n">pMaterial</span> <span class="o">=</span> <span class="n">pScene</span><span class="o">-&gt;</span><span class="n">mMaterials</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>    
</span></span><span class="line"><span class="ln">5</span><span class="cl">    <span class="p">...</span></span></span></code></pre></div><p>This function loads all the textures that are used by the model. The mNumMaterials attribute in the aiScene object holds the number of materials and mMaterials is an array of pointers to <a href="http://www.assimp.org/lib_html/structai_material.html" target="_blank">aiMaterials</a> structures (by that size). The aiMaterial structure is a complex beast, but it hides its complexity behind a small number of API calls. In general the material is organized as a stack of textures and between consecutive textures the configured blend and strength function must be applied. For example, the blend function can tell us to add the color from the two textures and the strength function can tell us to multiply the result by half. The blend and strength functions are part of the aiMaterial structure and can be retrieved. To make our life simpler and to match the way our lighting shader currently works we ignore the blend and strength function and simply use the texture as is.</p>
<p>(mesh.cpp:165)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">m_Textures</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>    
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">pMaterial</span><span class="o">-&gt;</span><span class="n">GetTextureCount</span><span class="p">(</span><span class="n">aiTextureType_DIFFUSE</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>      
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  <span class="n">aiString</span> <span class="n">Path</span><span class="p">;</span>      
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">pMaterial</span><span class="o">-&gt;</span><span class="n">GetTexture</span><span class="p">(</span><span class="n">aiTextureType_DIFFUSE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Path</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">==</span> <span class="n">AI_SUCCESS</span><span class="p">)</span> <span class="p">{</span>        
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">FullPath</span> <span class="o">=</span> <span class="n">Dir</span> <span class="o">+</span> <span class="s">&#34;/&#34;</span> <span class="o">+</span> <span class="n">Path</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>        
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="n">m_Textures</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Texture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">FullPath</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>        
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">m_Textures</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">Load</span><span class="p">())</span> <span class="p">{</span>          
</span></span><span class="line"><span class="ln">10</span><span class="cl">      <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Error loading texture &#39;%s&#39;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">FullPath</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>          
</span></span><span class="line"><span class="ln">11</span><span class="cl">      <span class="k">delete</span> <span class="n">m_Textures</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>          
</span></span><span class="line"><span class="ln">12</span><span class="cl">      <span class="n">m_Textures</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>          
</span></span><span class="line"><span class="ln">13</span><span class="cl">      <span class="n">Ret</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>        
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="p">}</span>      
</span></span><span class="line"><span class="ln">15</span><span class="cl">  <span class="p">}</span>    
</span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="p">}</span>    
</span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="p">...</span></span></span></code></pre></div><p>A material can contain multiple textures, and not all of them have to contain colors. For example, a texture can be a height map, normal map, displacement map, etc. Since our lighting shader currently uses a single texture for all the light types we are interested only in the diffuse texture. Therefore, we check how many diffuse textures exist using the aiMaterial::GetTextureCount() function. This function takes the type of the texture as a parameter and returns the number of textures of that specific type. If at least one diffuse texture is available we fetch it using the aiMaterial::GetTexture() function. The first parameter to that function is the type. Next comes the index and we always use 0. After that we need to specify the address of a string where the texture file name will go. Finally, there are five address parameters that allow us to fetch various configurations of the texture such as the blend factor, map mode, texture operation, etc. These are optional and we ignore them for now so we just pass NULL. We are interested only in the texture file name and we concatenate it to the directory where the model is located. The directory was retrieved at the start of the function (not quoted here) and the assumption is that the model and the texture are in the same subdirectory. If the directory structure is more complex you may need to search for the texture elsewhere. We create our texture object as usual and load it.</p>
<p>(mesh.cpp:187)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">m_Textures</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>      
</span></span><span class="line"><span class="ln">2</span><span class="cl">      <span class="n">m_Textures</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Texture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="s">&#34;../Content/white.png&#34;</span><span class="p">);</span>      
</span></span><span class="line"><span class="ln">3</span><span class="cl">      <span class="n">Ret</span> <span class="o">=</span> <span class="n">m_Textures</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">Load</span><span class="p">();</span>    
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="p">}</span>  
</span></span><span class="line"><span class="ln">5</span><span class="cl">  <span class="p">}</span>  
</span></span><span class="line"><span class="ln">6</span><span class="cl">
</span></span><span class="line"><span class="ln">7</span><span class="cl">  <span class="k">return</span> <span class="n">Ret</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">8</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>The above piece of code is a small workaround to a problem you may encounter if you start loading models you find on the net. Sometimes a model does not include a texture and in cases like that you will not see anything because the color that will be sampled from a non existing texture is by default black. One way to deal with it is to detect this case and treat it with a special case in the shader or a dedicated shader. This tutorial takes a simpler approach of loading a texture that contains a single white texel (you will find this texture in the attached sources). This will make the basic color of all pixels white. It will probably not look great but at least you will see something. This texture takes very little space and allows us to use the same shader for both cases.</p>
<p>(mesh.cpp:197)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="n">Mesh</span><span class="o">::</span><span class="n">Render</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  <span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  <span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  <span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">  
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m_Entries</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>    
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">m_Entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">VB</span><span class="p">);</span>    
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Vertex</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>    
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Vertex</span><span class="p">),</span> <span class="p">(</span><span class="k">const</span> <span class="n">GLvoid</span><span class="o">*</span><span class="p">)</span><span class="mi">12</span><span class="p">);</span>    
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Vertex</span><span class="p">),</span> <span class="p">(</span><span class="k">const</span> <span class="n">GLvoid</span><span class="o">*</span><span class="p">)</span><span class="mi">20</span><span class="p">);</span>    
</span></span><span class="line"><span class="ln">12</span><span class="cl">    
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ELEMENT_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">m_Entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">IB</span><span class="p">);</span>    
</span></span><span class="line"><span class="ln">14</span><span class="cl">    
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">MaterialIndex</span> <span class="o">=</span> <span class="n">m_Entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">MaterialIndex</span><span class="p">;</span>    
</span></span><span class="line"><span class="ln">16</span><span class="cl">    
</span></span><span class="line"><span class="ln">17</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">MaterialIndex</span> <span class="o">&lt;</span> <span class="n">m_Textures</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">m_Textures</span><span class="p">[</span><span class="n">MaterialIndex</span><span class="p">])</span> <span class="p">{</span>      
</span></span><span class="line"><span class="ln">18</span><span class="cl">      <span class="n">m_Textures</span><span class="p">[</span><span class="n">MaterialIndex</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">Bind</span><span class="p">(</span><span class="n">GL_TEXTURE0</span><span class="p">);</span>    
</span></span><span class="line"><span class="ln">19</span><span class="cl">    <span class="p">}</span>    
</span></span><span class="line"><span class="ln">20</span><span class="cl">    
</span></span><span class="line"><span class="ln">21</span><span class="cl">    <span class="n">glDrawElements</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">,</span> <span class="n">m_Entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">NumIndices</span><span class="p">,</span> <span class="n">GL_UNSIGNED_INT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">22</span><span class="cl">  <span class="p">}</span>  
</span></span><span class="line"><span class="ln">23</span><span class="cl">  
</span></span><span class="line"><span class="ln">24</span><span class="cl">  <span class="n">glDisableVertexAttribArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">25</span><span class="cl">  <span class="n">glDisableVertexAttribArray</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>  
</span></span><span class="line"><span class="ln">26</span><span class="cl">  <span class="n">glDisableVertexAttribArray</span><span class="p">(</span><span class="mi">2</span><span class="p">);}</span></span></span></code></pre></div><p>This function encapsulates the rendering of a mesh and separates it from the main application (in previous tutorials it was part of the application code itself). The m_Entries array is scanned and the vertex buffer and index buffer in each node are bound. The material index of the node is used to fetch the texture object from the m_Texture array and the texture is also bound. Finally, the draw command is executed. Now you can have multiple mesh objects that have been loaded from files and render them one by one by calling the Mesh::Render() function.</p>
<p>(glut_backend.cpp:112)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glEnable</span><span class="p">(</span><span class="n">GL_DEPTH_TEST</span><span class="p">);</span></span></span></code></pre></div><p>The last thing we need to study is something that was left out in previous tutorials. If you go ahead and load models using the code above you will probably encounter visual anomalies with your scene. The reason is that triangles that are further from the camera are drawn on top of the closer ones. In order to fix this we need to enable the famous depth test (a.k.a Z-test). When the depth test is enabled the rasterizer compares the depth of each pixel prior to rendering with the existing pixel on the same location on the screen. The pixel whose color is eventually used is the one who &ldquo;wins&rdquo; the depth test (i.e. closer to the camera). The depth test is not enabled by default and the code above takes care of that (part of the OpenGL initialization code in the function GLUTBackendRun()). This is just one of three pieces of code that are required for the depth test (see below).</p>
<p>(glut_backend.cpp:73)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glutInitDisplayMode</span><span class="p">(</span><span class="n">GLUT_DOUBLE</span><span class="o">|</span><span class="n">GLUT_RGBA</span><span class="o">|</span><span class="n">GLUT_DEPTH</span><span class="p">);</span></span></span></code></pre></div><p>The second piece is the initialization of the depth buffer. In order to compare depth between two pixels the depth of the &ldquo;old&rdquo; pixel must be stored somewhere (the depth of the &ldquo;new&rdquo; pixel is available because it was passed from the vertex shader). For this purpose we have a special buffer known as the depth buffer (or Z buffer). It has the same proporations as the screen so that each pixel in the color buffer has a corresponding slot in the depth buffer. That slot always stores the depth of the closest pixel and it is used in the depth test for the comparison.</p>
<p>(tutorial22.cpp:101)</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">glClear</span><span class="p">(</span><span class="n">GL_COLOR_BUFFER_BIT</span> <span class="o">|</span> <span class="n">GL_DEPTH_BUFFER_BIT</span><span class="p">);</span></span></span></code></pre></div><p>The last thing we need to do is to clear the depth buffer at the start of a new frame. If we don&rsquo;t do that the buffer will contain old values from the previous frame and the depth of the pixels from the new frame will be compared against the depth of the pixels from the previous frame. As you can imagine, this will cause serious corruptions (try!). The glClear() function takes a bitmask of the buffers it needs to operate on. Up until now we&rsquo;ve only cleared the color buffer. Now it&rsquo;s time to clear the depth buffer as well.</p>
<p>For more information on this subject check out the following <a href="https://www.youtube.com/watch?v=ZbnEMM7vwmU&amp;list=PLRtjMdoYXLf6zUMDJVRZYV-6g6n62vet8&amp;index=21" target="_blank">video tutorial by Frahaan Hussain</a> and also <a href="https://www.youtube.com/watch?v=yQx_pMsYqzU&amp;list=PLRtjMdoYXLf6zUMDJVRZYV-6g6n62vet8&amp;index=22" target="_blank">this one</a>.</p>

            <footer class="footline">
            </footer>
          </article>

        </div>
      </main>
    </div>
    <script src="../../../../../js/clipboard.min.js?1708235002" defer></script>
    <script src="../../../../../js/perfect-scrollbar.min.js?1708235002" defer></script>
    <script src="../../../../../js/theme.js?1708235002" defer></script>
  </body>
</html>
