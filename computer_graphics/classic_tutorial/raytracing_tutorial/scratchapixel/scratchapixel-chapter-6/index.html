<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.122.0">
    <meta name="generator" content="Relearn 5.23.2+tip">
    <meta name="description" content="啊啊啊啊">
    <meta name="author" content="Sören Weber">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="https://example.com/images/hero.png">
    <meta name="twitter:title" content="Rasterization: a Practical Implementation :: Hugo Relearn Theme">
    <meta name="twitter:description" content="An Overview of the Rasterization Algorithm Everything You Wanted to Know About the Rasterization Algorithm (But Were Afraid to Ask!) The rasterization rendering technique is surely the most commonly used technique to render images of 3D scenes, and yet, that is probably the least understood and the least properly documented technique of all (especially compared to ray-tracing).
Why this is so, depends on different factors. First, it&rsquo;s a technique from the past.">
    <meta property="og:title" content="Rasterization: a Practical Implementation :: Hugo Relearn Theme">
    <meta property="og:description" content="An Overview of the Rasterization Algorithm Everything You Wanted to Know About the Rasterization Algorithm (But Were Afraid to Ask!) The rasterization rendering technique is surely the most commonly used technique to render images of 3D scenes, and yet, that is probably the least understood and the least properly documented technique of all (especially compared to ray-tracing).
Why this is so, depends on different factors. First, it&rsquo;s a technique from the past.">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://example.com/computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/index.html">
    <meta property="og:image" content="https://example.com/images/hero.png">
    <meta property="article:section" content="Scratchapixe 系列短文 :: Hugo Relearn Theme">
    <meta property="og:site_name" content="Hugo Relearn Theme">
    <title>Rasterization: a Practical Implementation :: Hugo Relearn Theme</title>
    <link href="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/index.xml" rel="alternate" type="application/rss+xml" title="Rasterization: a Practical Implementation :: Hugo Relearn Theme">
    <link href="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/index.print.html" rel="alternate" type="text/html" title="Rasterization: a Practical Implementation :: Hugo Relearn Theme"><link rel="icon" href="../../../../../images/favicon.ico">
    <!-- https://github.com/filamentgroup/loadCSS/blob/master/README.md#how-to-use -->
    <link href="../../../../../css/fontawesome-all.min.css?1708235101" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../../../../../css/fontawesome-all.min.css?1708235101" rel="stylesheet"></noscript>
    <link href="../../../../../css/nucleus.css?1708235101" rel="stylesheet">
    <link href="../../../../../css/auto-complete.css?1708235101" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../../../../../css/auto-complete.css?1708235101" rel="stylesheet"></noscript>
    <link href="../../../../../css/perfect-scrollbar.min.css?1708235101" rel="stylesheet">
    <link href="../../../../../css/fonts.css?1708235101" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../../../../../css/fonts.css?1708235101" rel="stylesheet"></noscript>
    <link href="../../../../../css/theme.css?1708235101" rel="stylesheet">
    <link href="../../../../../css/theme-auto.css?1708235101" rel="stylesheet" id="R-variant-style">
    <link href="../../../../../css/variant.css?1708235101" rel="stylesheet">
    <link href="../../../../../css/print.css?1708235101" rel="stylesheet" media="print">
    <link href="../../../../../css/ie.css?1708235101" rel="stylesheet">
    <script src="../../../../../js/url.js?1708235101"></script>
    <script src="../../../../../js/variant.js?1708235101"></script>
    <script>
      // hack to let hugo tell us how to get to the root when using relativeURLs, it needs to be called *url= for it to do its magic:
      // https://github.com/gohugoio/hugo/blob/145b3fcce35fbac25c7033c91c1b7ae6d1179da8/transform/urlreplacers/absurlreplacer.go#L72
      window.index_js_url="../../../../../index.search.js";
      var root_url="../../../../../";
      var baseUri=root_url.replace(/\/$/, '');
      window.relearn = window.relearn || {};
      window.relearn.baseUriFull='https:\/\/example.com/';
      // variant stuff
      window.variants && variants.init( [ 'auto', 'relearn-light', 'relearn-dark', 'zen-light', 'zen-dark', 'neon', 'learn', 'blue', 'green', 'red' ] );
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
    </script>
    <style>
      #R-body img.bg-white {
        background-color: white;
      }
    </style>
  </head>
  <body class="mobile-support html" data-url="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/index.html">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide">
              <button class="topbar-control" onclick="toggleNav()" type="button" title="Menu (CTRL&#43;ALT&#43;n)">
                <i class="fa-fw fas fa-bars"></i>
              </button>
            </div>
            <div class="topbar-button topbar-button-toc" data-content-empty="hide" data-width-s="show" data-width-m="show" data-width-l="show">
              <button class="topbar-control" onclick="toggleTopbarFlyout(this)" type="button" title="Table of Contents (CTRL&#43;ALT&#43;t)">
                <i class="fa-fw fas fa-list-alt"></i>
              </button>
              <div class="topbar-content">
                <div class="topbar-content-wrapper">
<nav class="TableOfContents">
  <ul>
    <li><a href="#an-overview-of-the-rasterization-algorithm">An Overview of the Rasterization Algorithm</a>
      <ul>
        <li><a href="#everything-you-wanted-to-know-about-the-rasterization-algorithm-but-were-afraid-to-ask">Everything You Wanted to Know About the Rasterization Algorithm (But Were Afraid to Ask!)</a></li>
        <li><a href="#introduction">Introduction</a></li>
        <li><a href="#the-rasterization-algorithm">The Rasterization Algorithm</a></li>
        <li><a href="#optimizing-2d-triangles-bounding-box">Optimizing: 2D Triangles Bounding Box</a></li>
        <li><a href="#the-image-or-frame-buffer">The Image or Frame-Buffer</a></li>
        <li><a href="#when-two-triangles-overlap-the-same-pixel-the-depth-buffer-or-z-buffer">When Two Triangles Overlap the Same Pixel: The Depth Buffer (or Z-Buffer)</a></li>
        <li><a href="#whats-next">What&rsquo;s Next?</a></li>
      </ul>
    </li>
    <li><a href="#the-projection-stage">The Projection Stage</a>
      <ul>
        <li><a href="#quick-review">Quick Review</a></li>
        <li><a href="#projection-what-are-we-trying-to-solve">Projection: What Are We Trying to Solve?</a></li>
        <li><a href="#projecting-vertices-mind-the-z-coordinate">Projecting Vertices: Mind the Z-Coordinate!</a></li>
        <li><a href="#screen-space-is-also-three-dimensional">Screen Space is Also Three-Dimensional</a></li>
        <li><a href="#remapping-screen-space-coordinates-to-ndc-space">Remapping Screen Space Coordinates to NDC Space</a></li>
        <li><a href="#putting-things-together">Putting Things Together</a></li>
        <li><a href="#whats-next-1">What&rsquo;s Next?</a></li>
      </ul>
    </li>
    <li><a href="#the-rasterization-stage">The Rasterization Stage</a>
      <ul>
        <li><a href="#rasterization-what-are-we-trying-to-solve">Rasterization: What Are We Trying to Solve?</a></li>
        <li><a href="#the-edge-function">The Edge Function</a></li>
        <li><a href="#alternative-to-the-edge-function">Alternative to the Edge Function</a></li>
        <li><a href="#be-careful-winding-order-matters">Be Careful! Winding Order Matters</a></li>
        <li><a href="#barycentric-coordinates">Barycentric Coordinates</a></li>
        <li><a href="#interpolate-vs-extrapolate">Interpolate vs. Extrapolate</a></li>
        <li><a href="#rasterization-rules">Rasterization Rules</a></li>
        <li><a href="#putting-things-together-finding-if-a-pixel-overlaps-a-triangle">Putting Things Together: Finding if a Pixel Overlaps a Triangle</a></li>
        <li><a href="#conclusion-and-whats-next">Conclusion and What&rsquo;s Next?</a></li>
      </ul>
    </li>
    <li><a href="#the-visibility-problem-the-depth-buffer-algorithm-and-depth-interpolation">The Visibility Problem, the Depth Buffer Algorithm and Depth Interpolation</a>
      <ul>
        <li><a href="#the-depth-buffer-or-z-buffer-algorithm-and-hidden-surface-removal">The Depth-Buffer or Z-Buffer Algorithm and Hidden Surface Removal</a></li>
        <li><a href="#finding-z-by-interpolation">Finding Z by Interpolation</a></li>
        <li><a href="#other-visible-surface-algorithms">Other Visible Surface Algorithms</a></li>
      </ul>
    </li>
  </ul>
</nav>
                </div>
              </div>
            </div>
          </div>
          <ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype="http://schema.org/BreadcrumbList"><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../index.html"><span itemprop="name">主页</span></a><meta itemprop="position" content="1">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../computer_graphics/index.html"><span itemprop="name">计算机图形学</span></a><meta itemprop="position" content="2">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../computer_graphics/classic_tutorial/index.html"><span itemprop="name">经典教程</span></a><meta itemprop="position" content="3">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/index.html"><span itemprop="name">光线追踪</span></a><meta itemprop="position" content="4">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/index.html"><span itemprop="name">Scratchapixe 系列短文</span></a><meta itemprop="position" content="5">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><span itemprop="name">Rasterization: a Practical Implementation</span><meta itemprop="position" content="6"></li>
          </ol>
          <div class="topbar-area topbar-area-end" data-area="end">
            <div class="topbar-button topbar-button-print" data-content-empty="disable" data-width-s="area-more" data-width-m="show" data-width-l="show">
              <a class="topbar-control" href="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/index.print.html" title="Print whole chapter (CTRL&#43;ALT&#43;p)">
                <i class="fa-fw fas fa-print"></i>
              </a>
            </div>
            <div class="topbar-button topbar-button-prev" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show">
              <a class="topbar-control" href="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/index.html" title="3D Viewing: the Pinhole Camera Model (🡐)">
                <i class="fa-fw fas fa-chevron-left"></i>
              </a>
            </div>
            <div class="topbar-button topbar-button-next" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show">
              <a class="topbar-control" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/index.html" title="OpenGL教程 (🡒)">
                <i class="fa-fw fas fa-chevron-right"></i>
              </a>
            </div>
            <div class="topbar-button topbar-button-more" data-content-empty="hide" data-width-s="show" data-width-m="show" data-width-l="show">
              <button class="topbar-control" onclick="toggleTopbarFlyout(this)" type="button" title="More">
                <i class="fa-fw fas fa-ellipsis-v"></i>
              </button>
              <div class="topbar-content">
                <div class="topbar-content-wrapper">
                  <div class="topbar-area topbar-area-more" data-area="more">
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable default" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="default">
            <header class="headline">
            </header>
<h1 id="rasterization-a-practical-implementation">Rasterization: a Practical Implementation</h1>

<h2 id="an-overview-of-the-rasterization-algorithm">An Overview of the Rasterization Algorithm</h2>
<h3 id="everything-you-wanted-to-know-about-the-rasterization-algorithm-but-were-afraid-to-ask">Everything You Wanted to Know About the Rasterization Algorithm (But Were Afraid to Ask!)</h3>
<p>The <strong>rasterization rendering technique</strong> is surely the most commonly used technique to render images of 3D scenes, and yet, that is probably the least understood and the least <strong>properly</strong> documented technique of all (especially compared to ray-tracing).</p>
<p>Why this is so, depends on different factors. First, it&rsquo;s a technique from the past. We don&rsquo;t mean to say the technique is obsolete, quite the contrary, but that most of the techniques that are used to produce an image with this algorithm, were developed somewhere between the 1960s and the early 1980s. In the world of computer graphics, this is middle-ages and the knowledge about the papers in which these techniques were developed tends to be lost. Rasterization is also the technique used by GPUs to produce 3D graphics. Hardware technology changed a lot since GPUs were first invented, but the fondamental techniques they implement to produce images haven&rsquo;t changed much since the early 1980s (the hardware changed, but the underlying pipeline by which an image is formed hasn&rsquo;t). In fact, these techniques are so fundamental and consequently so deeply integrated within the hardware architecture, that no one pays attention to them anymore (only people designing GPUs can tell what they do, and this is far from being a trivial task, but designing a GPU and understanding the principle of the rasterization algorithm are two different things; thus explaining the latter should not be that hard!).</p>
<p>Regardless, we thought it was urgent and important to correct this situation. With this lesson, we believe it to be the first resource that provides a clear and complete picture of the algorithm as well as a full practical implementation of the technique. If you found in this lesson the answers you have been desperately looking for anywhere else, please consider donating! This work is provided to you for free and requires many hours of hard work.</p>
<h3 id="introduction">Introduction</h3>
<p>Rasterization and ray tracing try to solve the visibility or hidden surface problem but in a different order (the visibility problem was introduced in the lesson <a href="../../../../../lessons/3d-basic-rendering/rendering-3d-scene-overview/visibility-problem">Rendering an Image of a 3D Scene, an Overview</a>). Both algorithms have in common that they essentially use techniques from geometry to solve that problem. In this lesson, we will describe briefly how the rasterization (you can write rasterization if you prefer UK English to US English) algorithm works. Understanding the principle is quite simple but implementing it requires to use of a series of techniques notably from the field of geometry, that you will also find explained in this lesson.</p>
<p>The program we will develop in this lesson to demonstrate how rasterization works in practice is important, because we will use it again in the next lessons to implement the ray-tracing algorithm as well. Having both algorithms implemented in the same program will allow us to more easily compare the output produced by the two rendering techniques (they should both produce the same result at least before shading is applied) and performances. It will be a great way to better understand the pros and cons of both algorithms.</p>
<h3 id="the-rasterization-algorithm">The Rasterization Algorithm</h3>
<p>There are not one but multiple rasterization algorithms, but to go straight to the point, let&rsquo;s say that all these different algorithms though are based upon the same overall principle. In other words, all these algorithms are just variants of the same idea. It is this idea or principle, we will refer to when we speak of rasterization in this lesson.</p>
<p>What is that idea? In the previous lessons, we already talked about the difference between rasterization and ray-tracing. We also suggested that the rendering process can essentially be decomposed into two main tasks: visibility and shading. Rasterization to say things quickly is essentially a method to solve the <strong>visibility problem</strong>. Visibility consists of being able to tell which parts of 3D objects are visible to the camera. Some parts of these objects can be bidden because they are either outside the camera&rsquo;s visible area or hidden by other objects.</p>
<p><a href="#R-image-0d0a5f0f8411a66a70884ab61a57911a" class="lightbox-link"><img src="../assets/raytracing-raster.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-0d0a5f0f8411a66a70884ab61a57911a"><img src="../assets/raytracing-raster.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 1:</strong> <em>in ray tracing, we trace a ray passing through the center of each pixel in the image and then test if this ray intersects any geometry in the scene. If it an intersection is found, we set the pixel color with the color of the object the ray intersected. Because a ray may intersect several objects, we need to keep track of the closest intersection distance.</em></p>
<p>Solving this problem can be done in essentially two ways. You can either trace a ray through every pixel in the image to find out the distance between the camera and any object this ray intersects (if any). The object visible through that pixel is the object with the smallest intersection distance (generally denoted t). This is the technique used in ray tracing. Note that in this particular case, you create an image by looping over all pixels in the image, tracing a ray for each one of these pixels, and then finding out if these rays intersect any of the objects in the scene. In other words, the algorithm requires two main loops. The outer loop iterates over the pixel in the image, and the inner loop iterates over the objects in the scene:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="n">each</span> <span class="n">pixel</span> <span class="n">in</span> <span class="n">the</span> <span class="n">image</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    <span class="n">Ray</span> <span class="n">R</span> <span class="o">=</span> <span class="n">computeRayPassingThroughPixel</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="kt">float</span> <span class="n">tclosest</span> <span class="o">=</span> <span class="n">INFINITY</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="n">Triangle</span> <span class="n">triangleClosest</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">each</span> <span class="n">triangle</span> <span class="n">in</span> <span class="n">the</span> <span class="n">scene</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">        <span class="kt">float</span> <span class="n">thit</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">intersect</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">object</span><span class="p">,</span> <span class="n">thit</span><span class="p">))</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">             <span class="k">if</span> <span class="p">(</span><span class="n">thit</span> <span class="o">&lt;</span> <span class="n">closest</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">                 <span class="n">triangleClosest</span> <span class="o">=</span> <span class="n">triangle</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">10</span><span class="cl">             <span class="p">}</span> 
</span></span><span class="line"><span class="ln">11</span><span class="cl">        <span class="p">}</span> 
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">triangleClosest</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln">14</span><span class="cl">        <span class="n">imageAtPixel</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="n">triangleColorAtHitPoint</span><span class="p">(</span><span class="n">triangle</span><span class="p">,</span> <span class="n">tclosest</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="p">}</span> 
</span></span></code></pre></div><p>Note that in this example, the objects are considered to be made of triangles (and triangles only). Rather than iterating other objects, we just consider the objects as a pool of triangles and iterate other triangles instead. For reasons we have already explained in the previous lessons, the triangle is often used as the basic rendering primitive both in ray tracing and in rasterization (GPUs require the geometry to be triangulated).</p>
<p>Ray tracing is the first possible approach to solve the visibility problem. We say the technique is <strong>image-centric</strong> because we shoot rays from the camera into the scene (we start from the image) as opposed to the other way around, which is the approach we will be using in rasterization.</p>
<p><a href="#R-image-a796599639df42583357f3fc66709199" class="lightbox-link"><img src="../assets/raytracing-raster2.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a796599639df42583357f3fc66709199"><img src="../assets/raytracing-raster2.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 2:</strong> <em>rasterization can be roughly decomposed in two steps. We first project the 3D vertices making up triangles onto the screen using perspective projection. Then, we loop over all pixels in the image and test whether they lie within the resulting 2D triangles. If they do, we fill the pixel with the triangle&rsquo;s color.</em></p>
<p>Rasterization takes the opposite approach. To solve for visibility, it actually &ldquo;projects&rdquo; triangles onto the screen, in other words, we go from a 3D representation to a 2D representation of that triangle, using perspective projection. This can easily be done by projecting the vertices making up the triangle onto the screen (using perspective projection as we just explained). The next step in the algorithm is to use some technique to fill up all the pixels of the image that are covered by that 2D triangle. These two steps are illustrated in Figure 2. From a technical point of view, they are very simple to perform. The projection steps only require a perspective divide and a remapping of the resulting coordinates from image space to raster space, a process we already covered in the previous lessons. Finding out which pixels in the image the resulting triangles cover, is also very simple and will be described later.</p>
<p>What does the algorithm look like compared to the ray tracing approach? First, note that rather than iterating over all the pixels in the image first, in rasterization, in the outer loop, we need to iterate over all the triangles in the scene. Then, in the inner loop, we iterate over all pixels in the image and find out if the current pixel is &ldquo;contained&rdquo; within the &ldquo;projected image&rdquo; of the current triangle (figure 2). In other words, the inner and outer loops of the two algorithms are swapped.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="c1">// rasterization algorithm
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="n">each</span> <span class="n">triangle</span> <span class="n">in</span> <span class="n">scene</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="c1">// STEP 1: project vertices of the triangle using perspective projection
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1"></span>    <span class="n">Vec2f</span> <span class="n">v0</span> <span class="o">=</span> <span class="n">perspectiveProject</span><span class="p">(</span><span class="n">triangle</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">v0</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="n">Vec2f</span> <span class="n">v1</span> <span class="o">=</span> <span class="n">perspectiveProject</span><span class="p">(</span><span class="n">triangle</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">v1</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="n">Vec2f</span> <span class="n">v2</span> <span class="o">=</span> <span class="n">perspectiveProject</span><span class="p">(</span><span class="n">triangle</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">v2</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">each</span> <span class="n">pixel</span> <span class="n">in</span> <span class="n">image</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        <span class="c1">// STEP 2: is this pixel contained in the projected image of the triangle?
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">pixelContainedIn2DTriangle</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln">10</span><span class="cl">            <span class="n">image</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="n">triangle</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">color</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">11</span><span class="cl">        <span class="p">}</span> 
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>This algorithm is <strong>object-centric</strong> because we actually start from the geometry and walk our way back to the image as opposed to the approach used in ray tracing where we started from the image and walked our way back into the scene.</p>
<p>Both algorithms are simple in their principle, but they differ slightly in their complexity when it comes to implementing them and finding solutions to the different problems they require to solve. In ray tracing, generating the rays is simple but finding the intersection of the ray with the geometry can reveal itself to be difficult (depending on the type of geometry you deal with) and is also potentially computationally expensive. But let&rsquo;s ignore ray tracing for now. In the rasterization algorithm, we need to project vertices onto the screen which is simple and fast, and we will see that the second step which requires finding out if a pixel is contained within the 2D representation of a triangle has an equally simple geometric solution. In other words, computing an image using the rasterization approach relies on two very simple and fast techniques (the perspective process and finding out if a pixel lies within a 2D triangle). Rasterization is a good example of an &ldquo;elegant&rdquo; algorithm. The techniques it relies on have simple solutions; they are also easy to implement and produce predictable results. For all these reasons, the algorithm is very well suited for the GPU and is the rendering technique applied by GPUs to generate images of 3D objects (it can also easily be run in parallel).</p>
<p>In summary:</p>
<ul>
<li>Converting geometry to triangles makes the process simpler. If all primitives are converted to the triangle primitive, we can write fast and efficient functions to project triangles onto the screen and check if pixels lie within these 2D triangles</li>
<li>Rasterization is <strong>object-centric</strong>. We project geometry onto the screen and determine their visibility by looping over all pixels in the image.</li>
<li>It relies on mostly two techniques: projecting vertices onto the screen and finding out if a given pixel lies within a 2D triangle.</li>
<li>The rendering pipeline run on GPUs is based on the rasterization algorithm.</li>
</ul>
<blockquote>
<p>The fast rendering of 3D Z-buffered linearly interpolated polygons is a problem that is fundamental to state-of-the-art workstations. In general, the problem consists of two parts: 1) the 3D transformation, projection, and light calculation of the vertices, and 2) the rasterization of the polygon into a frame buffer. (A Parallel Algorithm for Polygon Rasterization, Juan Pineda - 1988)</p>
</blockquote>
<p>The term <strong>rasterization</strong> comes from the fact that polygons (triangles in this case) are decomposed in a way, into pixels, and as we know an image made of pixels is called a raster image. Technically this process is referred to as the <strong>rasterization of the triangles into an image of frame buffer</strong>.</p>
<blockquote>
<p>Rasterization is the process of determining which pixels are inside a triangle, and nothing more. (Michael Abrash in Rasterization on Larrabee)</p>
</blockquote>
<p>Hopefully, at this point of the lesson, you have understood the way the image of a 3D scene (made of triangles) is generated using the rasterization approach. Of course, what we described so far is the simplest form of the algorithm. First, it can be optimized greatly but furthermore, we haven&rsquo;t explained yet what happens when two triangles projected onto the screen overlap the same pixels in the image. When that happens, how do we define which one of these two (or more) triangles is visible to the camera? We will now answer these two questions.</p>
<blockquote>
<details>
What happens if my geometry is not made of triangles? Can I still use the rasterization algorithm? The easiest solution to this problem is to triangulate the geometry. Modern GPUs only render triangles (as well as lines and points) thus you are required to triangulate the geometry anyway. Rendering 3D geometry raises a series of problems that can be more easily resolved with triangles. You will understand why as we progress in the lesson.
</details>
</blockquote>
<h3 id="optimizing-2d-triangles-bounding-box">Optimizing: 2D Triangles Bounding Box</h3>
<p><a href="#R-image-4155824ebd240cfc0ca93ff4a5dc896f" class="lightbox-link"><img src="../assets/raytracing-raster3.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-4155824ebd240cfc0ca93ff4a5dc896f"><img src="../assets/raytracing-raster3.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 3:</strong> <em>to avoid iterating over all pixels in the image, we can iterate over all pixels contained in the bounding box of the 2D triangle instead.</em></p>
<p>The problem with the naive implementation of the rasterization algorithm we gave so far, is that it requires in the inner loop to iterate over all pixels in the image, even though only a small number of these pixels may be contained within the triangle (as shown in figure 3). Of course, this depends on the size of the triangle on the screen. But considering we are not interested in rendering one triangle but an object made up of potentially from a few hundred to a few million triangles, it is unlikely that in a typical production example, these triangles will be very large in the image.</p>
<p><a href="#R-image-e4602ff03a86362b946eec1f59c431f8" class="lightbox-link"><img src="../assets/raytracing-raster4.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-e4602ff03a86362b946eec1f59c431f8"><img src="../assets/raytracing-raster4.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 4:</strong> once the bounding box around the triangle is computed, we can loop over all pixels contained in the bounding box and test if they overlap the 2D triangle.</p>
<p>There are different ways of minimizing the number of tested pixels, but the most common one consists of computing the 2D bounding box of the projected triangle and iterating over the pixels contained in that 2D bounding box rather than the pixels of the entire image. While some of these pixels might still lie outside the triangle, at least on average, it can already considerably improve the performance of the algorithm. This idea is illustrated in figure 3.</p>
<p>Computing the 2D bounding box of a triangle is very simple. We just need to find the minimum and maximum x- and y-coordinates of the three vertices making up the triangle in raster space. This is illustrated in the following pseudo code:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="c1">// convert the vertices of the current triangle to raster space
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1"></span><span class="n">Vec2f</span> <span class="n">bbmin</span> <span class="o">=</span> <span class="n">INFINITY</span><span class="p">,</span> <span class="n">bbmax</span> <span class="o">=</span> <span class="o">-</span><span class="n">INFINITY</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">Vec2f</span> <span class="n">vproj</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span> 
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="n">vproj</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">projectAndConvertToNDC</span><span class="p">(</span><span class="n">triangle</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> 
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="c1">// coordinates are in raster space but still floats not integers
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1"></span>    <span class="n">vproj</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">x</span> <span class="o">*=</span> <span class="n">imageWidth</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="n">vproj</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">y</span> <span class="o">*=</span> <span class="n">imageHeight</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">vproj</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">bbmin</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="n">bbmin</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">vproj</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">x</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">vproj</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">bbmin</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="n">bbmin</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">vproj</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">y</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">vproj</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">bbmax</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="n">bbmax</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">vproj</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">x</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">vproj</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">y</span> <span class="o">&gt;</span> <span class="n">bbmax</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="n">bbmax</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">vproj</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">y</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="p">}</span> 
</span></span></code></pre></div><p>Once we calculated the 2D bounding box of the triangle (in raster space), we just need to loop over the pixel defined by that box. But you need to be very careful about the way you convert the raster coordinates, which in our code are defined as floats rather than integers. First, note that one or two vertices may be projected outside the boundaries of the canvas. Thus, their raster coordinates may be lower than 0 or greater than the image size. We solve this problem by clamping the pixel coordinates to the range [0, Image Width - 1] for the x coordinate, and [0, Image Height - 1] for the y coordinate. Furthermore, we will need to round off the minimum and maximum coordinates of the bounding box to the nearest integer value (note that this works fine when we iterate over the pixels in the loop because we initialize the variable to <code>xmim</code> or <code>ymin</code> and break from the loop when the variable x or y is lower or equal to <code>xmax</code> or <code>ymax</code>). All these tests need to be applied before using the final fixed point (or integer) bounding box coordinates in the loop. Here is the pseudo-code:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="p">...</span> 
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="n">uint</span> <span class="n">xmin</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nl">std</span><span class="p">:</span><span class="n">min</span><span class="p">(</span><span class="n">imageWidth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">floor</span><span class="p">(</span><span class="n">min</span><span class="p">.</span><span class="n">x</span><span class="p">)));</span> 
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">uint</span> <span class="n">ymin</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nl">std</span><span class="p">:</span><span class="n">min</span><span class="p">(</span><span class="n">imageHeight</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">floor</span><span class="p">(</span><span class="n">min</span><span class="p">.</span><span class="n">y</span><span class="p">)));</span> 
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">uint</span> <span class="n">xmax</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nl">std</span><span class="p">:</span><span class="n">min</span><span class="p">(</span><span class="n">imageWidth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">floor</span><span class="p">(</span><span class="n">max</span><span class="p">.</span><span class="n">x</span><span class="p">)));</span> 
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">uint</span> <span class="n">ymax</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nl">std</span><span class="p">:</span><span class="n">min</span><span class="p">(</span><span class="n">imageHeight</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">floor</span><span class="p">(</span><span class="n">max</span><span class="p">.</span><span class="n">y</span><span class="p">)));</span> 
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="n">y</span> <span class="o">=</span> <span class="n">ymin</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;=</span> <span class="n">ymin</span><span class="p">;</span> <span class="o">++</span><span class="n">y</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="n">xmin</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">xmax</span><span class="p">;</span> <span class="o">++</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        <span class="c1">// check of if current pixel lies in triangle
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">pixelContainedIn2DTriangle</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln">10</span><span class="cl">            <span class="n">image</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="n">triangle</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">color</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">11</span><span class="cl">        <span class="p">}</span> 
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="p">}</span> 
</span></span></code></pre></div><blockquote>
<details>
Note that production rasterizers use more efficient methods than looping over the pixels contained in the bounding box of the triangle. As mentioned, many of the pixels do not overlap the triangle, and testing if these pixel samples overlap the triangle is a waste. We won't study these more optimized methods in this lesson.
</details>
</blockquote>
<blockquote>
<details>
If you already studied this algorithm or studied how GPUs render images, you may have heard or read that the coordinates of projected vertices are sometimes converted from floating point to **fixed point numbers** (in other words integers). The reason behind this conversion is that basic operations such as multiplication, division, addition, etc. on fixed point numbers can be done very quickly (compared to the time it takes to do the same operations with floating point numbers). This used to be the case in the past and GPUs are still designed to work with integers at the rasterization stage of the rendering pipeline. However modern CPUs generally have FPUs (floating-point units) so if your program runs on the CPU, there is probably little to no advantage to using fixed point numbers (it actually might even run slower).
</details>
</blockquote>
<h3 id="the-image-or-frame-buffer">The Image or Frame-Buffer</h3>
<p>Our goal is to produce an image of the scene. We have two ways of visualizing the result of the program, either by displaying the rendered image directly on the screen or saving the image to disk, and using a program such as Photoshop to preview the image later on. But in both cases though, we somehow need to store the image that is being rendered while it&rsquo;s being rendered and for that purpose, we use what we call in CG an image or <strong>frame-buffer</strong>. It is nothing else than a two-dimensional array of colors that has the size of the image. Before the rendering process starts, the frame-buffer is created and the pixels are all set to black. At render time, when the triangles are rasterized, if a given pixel overlaps a given triangle, then we store the color of that triangle in the frame-buffer at that pixel location. When all triangles have been rasterized, the frame-buffer will contain the image of the scene. All that is left to do then is either display the content of the buffer on the screen or save its content to a file. In this lesson, we will choose the latter option.</p>
<blockquote>
<details>
In programming, there is no solution to display images on the screen that is cross-platform (which is a shame). For this reason, it is better to store the content of the image in a file and use a cross-platform application such as Photoshop or another image editing tool to view the image. Of course, the software you will be using to view the image needs to support the image format the image will be saved in. In this lesson, we will use the very simple PPM image file format.
</details>
</blockquote>
<h3 id="when-two-triangles-overlap-the-same-pixel-the-depth-buffer-or-z-buffer">When Two Triangles Overlap the Same Pixel: The Depth Buffer (or Z-Buffer)</h3>
<p>Keep in mind that the goal of the rasterization algorithm is to solve the visibility problem. To display 3D objects, it is necessary to determine which surfaces are visible. In the early days of computer graphics, two methods were used to solve the &ldquo;hidden surface&rdquo; problem (the other name for the visibility problem): the <strong>Newell algorithm</strong> and the <strong>z-buffer</strong>. We only mention the Newell algorithm for historical reasons but we won&rsquo;t study it in this lesson because it is not used anymore. We will only study the z-buffer method which is used by GPUs.</p>
<p><a href="#R-image-92a75cbc24bb8b3fdfb58b5511716c2d" class="lightbox-link"><img src="../assets/raytracing-raster5.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-92a75cbc24bb8b3fdfb58b5511716c2d"><img src="../assets/raytracing-raster5.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 5:</strong> <em>when a pixel overlaps two triangles, we set the pixel color to the color of the triangle with the smallest distance to the camera.</em></p>
<p>There is one last thing though that we need to do to get a basic rasterizer working. We need to account for the fact that more than one triangle may overlap the same pixel in the image (as shown in figure 5). When this happens, how do we decide which triangle is visible? The solution to this problem is very simple. We will use what we call a <strong>z-buffer</strong> which is also called a <strong>depth buffer</strong>, two terms that you may have heard or read about already quite often. A z-buffer is nothing more than another two-dimensional array that has the same dimension as the image, however rather than being an array of colors, it is simply an array of floating numbers. Before we start rendering the image, we initialize each pixel in this array to a very large number. When a pixel overlaps a triangle, we also read the value stored in the z-buffer at that pixel location. As you maybe guessed, this array is used to store the distance from the camera to the nearest triangle that any pixel in the image overlaps. Since this value is initially set to infinity (or any very large number), then, of course, the first time we find that a given pixel X overlaps a triangle T1, the distance from the camera to that triangle is necessarily lower than the value stored in the z-buffer. What we do then, is replace the value stored for that pixel with the distance to T1. Next, when the same pixel X is tested and we find that it overlaps another triangle T2, we then compare the distance of the camera to this new triangle to the distance stored in the z-buffer (which at this point, stores to the distance to the first triangle T1). If this distance to the second triangle is lower than the distance to the first triangle, then T2 is visible and T1 is hidden by T2. Otherwise, T1 is hidden by T2, and T2 is visible. In the first case, we update the value in the z-buffer with the distance to T2 and in the second case, the z-buffer doesn&rsquo;t need to be updated since the first triangle T1 is still the closest triangle we found for that pixel so far. As you can see <strong>the z-buffer is used to store the distance of each pixel to the nearest object in the scene</strong> (we don&rsquo;t really use the distance, but we will give the details further in the lesson). In figure 5, we can see that the red triangle is behind the green triangle in 3D space. If we were to render the red triangle first, and the green triangle second, for a pixel that would overlap both triangles, we would have to store in the z-buffer at that pixel location, first a very large number (that happens when the z-buffer is initialized), then the distance to the red triangle and then finally the distance to the green triangle.</p>
<p>You may wonder how we find the distance from the camera to the triangle. Let&rsquo;s first look at an implementation of this algorithm in pseudo-code and we will come back to this point later (for now let&rsquo;s just assume the function pixelContainedIn2DTriangle computes that distance for us):</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="c1">// A z-buffer is just an 2D array of floats
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1"></span><span class="kt">float</span> <span class="n">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">float</span> <span class="p">[</span><span class="n">imageWidth</span> <span class="o">*</span> <span class="n">imageHeight</span><span class="p">];</span> 
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="c1">// initialize the distance for each pixel to a very large number
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">imageWidth</span> <span class="o">*</span> <span class="n">imageHeight</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> 
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="n">buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">INFINITY</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"> 
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="n">each</span> <span class="n">triangle</span> <span class="n">in</span> <span class="n">scene</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="c1">// project vertices
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1"></span>    <span class="p">...</span> 
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="c1">// compute bbox of the projected triangle
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="c1"></span>    <span class="p">...</span> 
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">y</span> <span class="o">=</span> <span class="n">ymin</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;=</span> <span class="n">ymin</span><span class="p">;</span> <span class="o">++</span><span class="n">y</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln">13</span><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="n">xmin</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">xmax</span><span class="p">;</span> <span class="o">++</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln">14</span><span class="cl">            <span class="c1">// check of if current pixel lies in triangle
</span></span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="c1"></span>            <span class="kt">float</span> <span class="n">z</span><span class="p">;</span>  <span class="c1">//distance from the camera to the triangle 
</span></span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">pixelContainedIn2DTriangle</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">))</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln">17</span><span class="cl">                <span class="c1">// If the distance to that triangle is lower than the distance stored in the
</span></span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="c1"></span>                <span class="c1">// z-buffer, update the z-buffer and update the image at pixel location (x,y)
</span></span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="c1"></span>                <span class="c1">// with the color of that triangle
</span></span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="c1"></span>                <span class="k">if</span> <span class="p">(</span><span class="n">z</span> <span class="o">&lt;</span> <span class="n">zbuffer</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">))</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln">21</span><span class="cl">                    <span class="n">zbuffer</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="n">z</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">22</span><span class="cl">                    <span class="n">image</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="n">triangle</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">color</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">23</span><span class="cl">                <span class="p">}</span> 
</span></span><span class="line"><span class="ln">24</span><span class="cl">            <span class="p">}</span> 
</span></span><span class="line"><span class="ln">25</span><span class="cl">        <span class="p">}</span> 
</span></span><span class="line"><span class="ln">26</span><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="ln">27</span><span class="cl"><span class="p">}</span> 
</span></span></code></pre></div><h3 id="whats-next">What&rsquo;s Next?</h3>
<p>This is only a very high-level description of the algorithm (figure 6) but this should hopefully already give you an idea of what we will need in the program to produce an image. We will need:</p>
<ul>
<li>An image-buffer (a 2D array of colors),</li>
<li>A depth-buffer (a 2D array of floats),</li>
<li>Triangles (the geometry making up the scene),</li>
<li>A function to project vertices of the triangles onto the canvas,</li>
<li>A function to rasterize the projected triangles,</li>
<li>Some code to save the content of the image buffer to disk.</li>
</ul>
<p><a href="#R-image-06515b24991afbb24c997f408b14a629" class="lightbox-link"><img src="../assets/rasterization-schema.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-06515b24991afbb24c997f408b14a629"><img src="../assets/rasterization-schema.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 6:</strong> <em>schematic view of the rasterization algorithm.</em></p>
<p>In the next chapter, we will see how are coordinates converted from camera to raster space. The method is of course identical to the one we studied and presented in the previous lesson, however, we will present a few more tricks along the way. In chapter three, we will learn how to rasterize triangles. In chapter four, we will study in detail how the z-buffer algorithm works. As usual, we will conclude this lesson with a practical example.</p>
<h2 id="the-projection-stage">The Projection Stage</h2>
<h3 id="quick-review">Quick Review</h3>
<p>In the previous chapter, we gave a high-level overview of the rasterization rendering technique. It can be decomposed into two main stages: first, the projection of the triangle&rsquo;s vertices onto the canvas, then the rasterization of the triangle itself. Rasterization means in this case, <strong>&ldquo;breaking apart&rdquo; the triangle&rsquo;s shape into pixels</strong> or <strong>raster element squares</strong>; this is what pixels used to be called in the past. In this chapter, we will review the first step. We have already described this method in the two previous lessons, thus we won&rsquo;t explain it here again. If you have any doubts about the principles behind perspective projection, check these lessons again. However, in this chapter, we will study a couple of new tricks related to projection that are going to be useful when we will get to the lesson on the perspective projection matrix. We will learn about a new method to remap the coordinates of the projected vertices from screen space to NDC space. We will also learn more about the role of the z-coordinate in the rasterization algorithm and how it should be handled at the projection stage.</p>
<p>Keep in mind as already mentioned in the previous chapter, that the goal of the rasterization rendering technique is to solve the visibility or hidden surface problem, which is to determine with parts of a 3D object are visible and which parts are hidden.</p>
<h3 id="projection-what-are-we-trying-to-solve">Projection: What Are We Trying to Solve?</h3>
<p>What are we trying to solve here at that stage of the rasterization algorithm? As explained in the previous chapter, the principle of rasterization is to find if pixels in the image overlap triangles. To do so, we first need to project triangles onto the canvas and then convert their coordinates from screen space to raster space. Pixels and triangles are then defined in the same space, which means that it becomes possible to compare their respective coordinates (we can check the coordinates of a given pixel against the raster-space coordinates of a triangle&rsquo;s vertices).</p>
<p>The goal of this stage is thus to convert the vertices making up triangles from camera space to raster space.</p>
<h3 id="projecting-vertices-mind-the-z-coordinate">Projecting Vertices: Mind the Z-Coordinate!</h3>
<p>In the previous two lessons, we mentioned that when we compute the raster coordinates of a 3D point what we need in the end are its x- and y-coordinates (the position of the 3D point in the image). As a quick reminder, recall that these 2D coordinates are obtained by dividing the x and y coordinates of the 3D point in camera space, by the point&rsquo;s respective z-coordinate (what we called the perspective divide), and then remapping the resulting 2D coordinates from screen space to NDC space and then NDC space to raster space. Keep in mind that because the image plane is positioned at the near-clipping plane, we also need to multiply the x- and y-coordinate by the near-clipping plane. Again, we explained this process in great detail in the previous two lessons.</p>

<span class="math align-center">$$
\begin{array}{l}
Pscreen.x = \dfrac{ near * Pcamera.x }{ -Pcamera.z }\\
Pscreen.y = \dfrac{ near * Pcamera.y }{ -Pcamera.z }\\
\end{array}
$$</span><p>Note that so far, we have been considering points in screen space as essentially 2D points (we didn&rsquo;t need to use the points&rsquo; z-coordinate after the perspective divide). From now on though, we will declare points in screen-space, as 3D points and set their z-coordinate to the camera-space points&rsquo; z-coordinate as follow:</p>

<span class="math align-center">$$
\begin{array}{l}
Pscreen.x = \dfrac{ near * Pcamera.x }{ -Pcamera.z }\\
Pscreen.y = \dfrac{ near * Pcamera.y }{ -Pcamera.z }\\
Pscreen.z = { -Pcamera.z }\\
\end{array}
$$</span><p>It is best at this point to set the projected point z-coordinate to the inverse of the original point z-coordinate, which as you know by now, is negative. Dealing with positive z-coordinates will make everything simpler later on (but this is not mandatory).</p>
<p><a href="#R-image-f38d95edc05c4495c5ffe075bc0b84bb" class="lightbox-link"><img src="../assets/rasterizer-z.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f38d95edc05c4495c5ffe075bc0b84bb"><img src="../assets/rasterizer-z.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 1:</strong> <em>when two vertices in camera space have the same 2D raster coordinates, we can use the original vertices z-coordinate to find out which one is in front of the other (and thus which one is visible).</em></p>
<p><strong>Keeping track of the vertex z-coordinate in camera space is needed to solve the visibility problem</strong>. Understanding why is easier if you look at Figure 1. Imagine two vertices v1 and v2 which when projected onto the canvas, have the same raster coordinates (as shown in Figure 1). If we project v1 before v2 then v2 will be visible in the image when it should be v1 (v1 is clearly in front of v2). However, if we store the z-coordinate of the vertices along with their 2D raster coordinates, we can use these coordinates to define which point is closest to the camera independently of the order in which the vertices are projected (as shown in the code fragment below).</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="c1">// project v2
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1"></span><span class="n">Vec3f</span> <span class="n">v2screen</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">v2screen</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">near</span> <span class="o">*</span> <span class="n">v2camera</span><span class="p">.</span><span class="n">x</span> <span class="o">/</span> <span class="o">-</span><span class="n">v2camera</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">v2screen</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">near</span> <span class="o">*</span> <span class="n">v2camera</span><span class="p">.</span><span class="n">y</span> <span class="o">/</span> <span class="o">-</span><span class="n">v2camera</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">v2screen</span><span class="p">.</span><span class="n">z</span> <span class="o">=</span> <span class="o">-</span><span class="n">v2cam</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="n">Vec3f</span> <span class="n">v1screen</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="n">v1screen</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">near</span> <span class="o">*</span> <span class="n">v1camera</span><span class="p">.</span><span class="n">x</span> <span class="o">/</span> <span class="o">-</span><span class="n">v1camera</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="n">v1screen</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">near</span> <span class="o">*</span> <span class="n">v1camera</span><span class="p">.</span><span class="n">y</span> <span class="o">/</span> <span class="o">-</span><span class="n">v1camera</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="n">v1screen</span><span class="p">.</span><span class="n">z</span> <span class="o">=</span> <span class="o">-</span><span class="n">v1camera</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="c1">// If the two vertices have the same coordinates in the image then compare their z-coordinate
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="n">v1screen</span><span class="p">.</span><span class="n">x</span> <span class="o">==</span> <span class="n">v2screen</span><span class="p">.</span><span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">v1screen</span><span class="p">.</span><span class="n">y</span> <span class="o">==</span> <span class="n">v2screen</span><span class="p">.</span><span class="n">y</span> <span class="o">&amp;&amp;</span> <span class="n">v1screen</span><span class="p">.</span><span class="n">z</span> <span class="o">&lt;</span> <span class="n">v2screen</span><span class="p">.</span><span class="n">z</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="c1">// if v1.z &lt; v2.z then store v1 in frame-buffer
</span></span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="c1"></span>    <span class="p">....</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p><a href="#R-image-be41dc6987263685b3eb2bc0736c6e2e" class="lightbox-link"><img src="../assets/rasterizer-z2.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-be41dc6987263685b3eb2bc0736c6e2e"><img src="../assets/rasterizer-z2.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 2:</strong> <em>the points on the surface of triangles that a pixel overlaps can be computed by interpolating the vertices making up these triangles. See chapter 4 for more details.</em></p>
<p>What we want to render though are triangles, not vertices. So the question is, how does the method we just learned about apply to triangles? In short, we will use the triangle vertices coordinates to find the position of the point on the triangle that the pixel overlaps (and thus it&rsquo;s z-coordinate). This idea is illustrated in Figure 2. If a pixel overlaps two or more triangles, we should be able to compute the position of the points on the triangles that the pixel overlap, and use the z-coordinates of these points as we did with the vertices, to know which triangle is the closest to the camera. This method will be described in detail in <a href="../../../../../lessons/3d-basic-rendering/rasterization-practical-implementation/visibility-problem-depth-buffer-depth-interpolation">chapter 4 (The Depth Buffer. Finding the Depth Value of a Sample by Interpolation)</a>.</p>
<h3 id="screen-space-is-also-three-dimensional">Screen Space is Also Three-Dimensional</h3>
<p><a href="#R-image-35a23897e6179da8e4ef35150a5ddab3" class="lightbox-link"><img src="../assets/screen-space-3D.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-35a23897e6179da8e4ef35150a5ddab3"><img src="../assets/screen-space-3D.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 3:</strong> <em>screen space is three-dimensional (middle image).</em></p>
<p>To summarize, to go from camera space to screen space (which is the process during which the perspective divide is happening), we need to:</p>
<ul>
<li>
<p>Perform the perspective divide: that is dividing the point in camera space x- and y-coordinate by the point z-coordinate.</p>

<span class="math align-center">$$
\begin{array}{l}
Pscreen.x = \dfrac{ near * Pcamera.x }{ -Pcamera.z }\\
Pscreen.y = \dfrac{ near * Pcamera.y }{ -Pcamera.z }\\
\end{array}
$$</span></li>
<li>
<p>But also set the projected point z-coordinate to the original point z-coordinate (the point in camera space).</p>

<span class="math align-center">$$
Pscreen.z = { -Pcamera.z }
$$</span></li>
</ul>
<p>Practically, this means that our projected point is not a 2D point anymore, but a 3D point. Or to say it differently, that screen space is not two- by three-dimensional. In his thesis <a href="http://en.wikipedia.org/wiki/Edwin_Catmull" target="_blank">Ed-Catmull</a> writes:</p>
<p>Screen-space is also three-dimensional, but the objects have undergone a perspective distortion so that an orthogonal projection of the object onto the x-y plane, would result in the expected perspective image (Ed-Catmull&rsquo;s Thesis, 1974).</p>
<p><a href="#R-image-59cc475a748f4b334efc0d0c3262b414" class="lightbox-link"><img src="../assets/screen-space-3D2.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-59cc475a748f4b334efc0d0c3262b414"><img src="../assets/screen-space-3D2.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 4:</strong> <em>we can form an image of an object in screen space by projecting lines orthogonal (or perpendicular if you prefer) to the x-y image plane.</em></p>
<p>You should now be able to understand this quote. The process is also illustrated in Figure 3. First, the geometry vertices are defined in camera space (top image). Then, each vertex undergoes a perspective divide. That is, the vertex x- and y-coordinates are divided by their z-coordinate, but as mentioned before, we also set the resulting projected point z-coordinate to the inverse of the original vertex z-coordinate. This, by the way, infers a change of direction in the z-axis of the screen space coordinate system. As you can see, the z-axis is now pointing inward rather than outward (middle image in Figure 3). But the most important thing to notice is that the resulting object is a deformed version of the original object but a three-dimensional object. Furthermore what Ed-Catmull means when he writes &ldquo;an orthogonal projection of the object onto the x-y plane, would result in the expected perspective image&rdquo;, is that once the object is in screen space, if we trace lines perpendicular to the x-y image plane from the object to the canvas, then we get a perspective representation of that object (as shown in Figure 4). This is an interesting observation because it means that the image creation process can be seen as <strong>a perspective projection followed by an orthographic projection</strong>. Don&rsquo;t worry if you don&rsquo;t understand clearly the difference between perspective and orthographic projection. It is the topic of the next lesson. However, try to remember this observation, as it will become handy later.</p>
<h3 id="remapping-screen-space-coordinates-to-ndc-space">Remapping Screen Space Coordinates to NDC Space</h3>
<p>In the previous two lessons, we explained that once in screen space, the x- and y-coordinates of the projected points need to be remapped to NDC space. In the previous lessons, we also explained that in NDC space, points on the canvas had their x- and y-coordinates contained in the range [0,1]. In the GPU world though, coordinates in NDC space are contained in the range [-1,1]. Sadly, this is one of these conventions again, that we need to deal with. We could have kept the convention [0,1] but because GPUs are the reference when it comes to rasterization, it is best to stick to the way the term is defined in the GPU world.</p>
<p>You may wonder why we didn&rsquo;t use the [-1,1] convention in the first place then. For several reasons. Once because in our opinion the term &ldquo;normalize&rdquo; should always suggest that the value that is being normalized is in the range [0,1]. Also because it is good to be aware that several rendering systems use different conventions with respect to the concept of NDC space. The RenderMan specifications for example define NDC space as a space defined over the range [0,1].</p>
<p>Thus once the points have been converted from camera space to screen space, the next step is to remap them from the range [l,r] and [b,t] for the x- and y-coordinate respectively, to the range [-1,1]. The term l, r, b, and t relate to the left, right, bottom, and top coordinates of the canvas. By re-arranging the terms, we can easily find an equation that performs the remapping we want:</p>

<span class="math align-center">$$l < x < r$$</span><p>Where x here is the x-coordinate of a 3D point in screen space (remember that from now on, we will assume that points in screen space are three-dimensional as explained above). If we remove the term l from the equation we get:</p>

<span class="math align-center">$$0 < x - l < r - l$$</span><p>By dividing all terms by (r-l) we get:</p>

<span class="math align-center">$$
\begin{array}{l}
0 < \dfrac {(x - l)}{(r - l)} < \dfrac {(r - l)}{(r - l)} \\
0 < \dfrac {(x - l)}{(r  -l)} < 1 \\
\end{array}
$$</span><p>We can now develop the term in the middle of the equation:</p>

<span class="math align-center">$$0 < \dfrac {x}{(r  -l)} - \dfrac {l}{(r  -l)}< 1$$</span><p>We can now multiply all terms by 2:</p>

<span class="math align-center">$$0 < 2 * \dfrac {x}{(r  -l)} - 2 * \dfrac {l}{(r  -l)}< 2$$</span><p>We now remove 1 from all terms:</p>

<span class="math align-center">$$-1 < 2 * \dfrac {x}{(r  -l)} - 2 * \dfrac {l}{(r-l)} - 1 < 1$$</span><p>If we develop the terms and regroup them, we finally get:</p>

<span class="math align-center">$$
\begin{array}{l}
-1 < 2 * \dfrac {x}{(r  -l)} - 2 * \dfrac {l}{(r-l)} - \dfrac{(r-l)}{(r-l)}< 1 \\
-1 < 2 * \dfrac {x}{(r  -l)} + \dfrac {-2*l+l-r}{(r-l)} < 1 \\
-1 < 2 * \dfrac {x}{(r  -l)} + \dfrac {-l-r}{(r-l)} < 1 \\
-1 < \color{red}{\dfrac {2x}{(r  -l)}} \color{green}{- \dfrac {r + l}{(r-l)}} < 1\\
\end{array}
$$</span><p>This is a very important equation because the red and green terms of the equation in the middle of the formula will become the coefficients of the perspective projection matrix. We will study this matrix in the next lesson. But for now, we will just apply this equation <strong>to remap the x-coordinate of a point in screen space to NDC space</strong> (any point that lies on the canvas has its coordinates contained in the range [-1.1] when defined in NDC space). If we apply the same reasoning to the y-coordinate we get:</p>

<span class="math align-center">$$-1 < \color{red}{\dfrac {2y}{(t  - b)}} \color{green}{- \dfrac {t + b}{(t-b)}} < 1$$</span><h3 id="putting-things-together">Putting Things Together</h3>
<p>At the end of this lesson, we now can perform the first stage of the rasterization algorithm which you can decompose into two steps:</p>
<ul>
<li>
<p>Convert a point in camera space to screen space. It essentially projects a point onto the canvas, but keep in mind that we also need to store the original point z-coordinate. The point in screen-space is tree-dimensional and the z-coordinate will be useful to solve the visibility problem later on.</p>

<span class="math align-center">$$
\begin{array}{l}
Pscreen.x = \dfrac{ near * Pcamera.x }{ -Pcamera.z }\\
Pscreen.y = \dfrac{ near * Pcamera.y }{ -Pcamera.z }\\
Pscreen.z = { -Pcamera.z }\\
\end{array}
$$</span></li>
<li>
<p>We then convert the x- and y-coordinates of these points in screen space to NDC space using the following formulas:</p>

<span class="math align-center">$$
\begin{array}{l}
-1 < \color{}{\dfrac {2x}{(r  -l)}} \color{}{- \dfrac {r + l}{(r-l)}} < 1\\
-1 < \color{}{\dfrac {2y}{(t  - b)}} \color{}{- \dfrac {t + b}{(t-b)}} < 1
\end{array}
$$</span><p>Where l, r, b, t denote the left, right, bottom, and top coordinates of the canvas.</p>
</li>
</ul>
<p>From there, it is extremely simple to convert the coordinates to raster space. We just need to remap the x- and y-coordinates in NDC space to the range [0,1] and multiply the resulting number by the image width and height respectively (don&rsquo;t forget that in raster space the y-axis goes down while in NDC space it goes up. Thus we need to change y&rsquo;s direction during this remapping process). In code we get:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">float</span> <span class="n">nearClippingPlane</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1">// point in camera space
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="c1"></span><span class="n">Vec3f</span> <span class="n">pCamera</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">worldToCamera</span><span class="p">.</span><span class="n">multVecMatrix</span><span class="p">(</span><span class="n">pWorld</span><span class="p">,</span> <span class="n">pCamera</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="c1">// convert to screen space
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="c1"></span><span class="n">Vec2f</span> <span class="n">pScreen</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="n">pScreen</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">nearClippingPlane</span> <span class="o">*</span> <span class="n">pCamera</span><span class="p">.</span><span class="n">x</span> <span class="o">/</span> <span class="o">-</span><span class="n">pCamera</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="n">pScreen</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">nearClippingPlane</span> <span class="o">*</span> <span class="n">pCamera</span><span class="p">.</span><span class="n">y</span> <span class="o">/</span> <span class="o">-</span><span class="n">pCamera</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1">// now convert point from screen space to NDC space (in range [-1,1])
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1"></span><span class="n">Vec2f</span> <span class="n">pNDC</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="n">pNDC</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pScreen</span><span class="p">.</span><span class="n">x</span> <span class="o">/</span> <span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">l</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="n">l</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">l</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="n">pNDC</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pScreen</span><span class="p">.</span><span class="n">y</span> <span class="o">/</span> <span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">t</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="c1">// convert to raster space and set point z-coordinate to -pCamera.z
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="c1"></span><span class="n">Vec3f</span> <span class="n">pRaster</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="n">pRaster</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">pNDC</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">imageWidth</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="c1">// in raster space y is down so invert direction
</span></span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="c1"></span><span class="n">pRaster</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">pNDC</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">imageHeight</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="c1">// store the point camera space z-coordinate (as a positive value)
</span></span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="c1"></span><span class="n">pRaster</span><span class="p">.</span><span class="n">z</span> <span class="o">=</span> <span class="o">-</span><span class="n">pCamera</span><span class="p">.</span><span class="n">z</span><span class="p">;</span></span></span></code></pre></div><p>Note that the coordinates of points or vertices in raster space are still defined as floating point numbers here and not integers (which is the case for pixel coordinates).</p>
<h3 id="whats-next-1">What&rsquo;s Next?</h3>
<p>We now have projected the triangle onto the canvas and converted these projected vertices to raster space. Both the vertices of the triangle and the pixel live in the same coordinate system. We are now ready to loop over all pixels in the image and use a technique to find if they overlap a triangle. This is the topic of the next chapter.</p>
<h2 id="the-rasterization-stage">The Rasterization Stage</h2>
<h3 id="rasterization-what-are-we-trying-to-solve">Rasterization: What Are We Trying to Solve?</h3>
<p>Rasterization is the process by which a primitive is converted to a two-dimensional image. Each point of this image contains such information as color and depth. Thus, rasterizing a primitive consists of two parts. The first is to determine which squares of an integer grid in window coordinates are occupied by the primitive. The second is assigning a color and a depth value to each such square. (OpenGL Specifications)</p>
<p><a href="#R-image-41c4c5cad9e767b4090749cd92faa25c" class="lightbox-link"><img src="../assets/rasterization-triangle1.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-41c4c5cad9e767b4090749cd92faa25c"><img src="../assets/rasterization-triangle1.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 1:</strong> <em>by testing, if pixels in the image overlap the triangle, we can draw an image of that triangle. This is the principle of the rasterization algorithm.</em></p>
<p>In the previous chapter, we learned how to perform the first step of the rasterization algorithm in a way, which is to project the triangle from 3D space onto the canvas. This definition is not entirely accurate in fact, since what we did was to transform the triangle from camera space to screen space, which as mentioned in the previous chapter, is also a three-dimensional space. However the x- and y-coordinates of the vertices in screen-space correspond to the position of the triangle vertices on the canvas, and by converting them from screen-space to NDC space and then finally from NDC-space to raster-space, what we get in the end are the vertices 2D coordinates in raster space. Finally, we also know that the z-coordinates of the vertices in screen-space hold the original z-coordinate of the vertices in camera space (inverted so that we deal with positive numbers rather than negative ones).</p>
<p>What we need to do next, is to loop over the pixel in the image and find out if any of these pixels overlap the &ldquo;projected image of the triangle&rdquo; (figure 1). In graphics APIs specifications, this test is sometimes called the <strong>inside-outside test</strong> or the <strong>coverage test</strong>. If they do, we then set the pixel in the image to the triangle&rsquo;s color. The idea is simple but of course, we now need to come up with a method to find if a given pixel overlaps a triangle. This is essentially what we will study in this chapter. We will learn about the method that is typically used in rasterization to solve this problem. It uses a technique known as the <strong>edge function</strong> which we are now going to describe and study. This edge function is also going to provide valuable information about the position of the pixel within the projected image of the triangle known as <strong>barycentric coordinates</strong>. Barycentric coordinates play an essential role in computing the actual depth (or the z-coordinate) of the point on the surface of the triangle that the pixel overlaps. We will also explain what barycentric coordinates are in this chapter and how they are computed.</p>
<p>At the end of this chapter, you will be able to produce a very basic rasterizer. In the next chapter, we will look into the possible issues with this very naive implementation of the rasterization algorithm. We will list what these issues are as well as study how they are typically addressed.</p>
<p>A lot of research has been done to optimize the algorithm. The goal of this lesson is not to teach you how to write or develop an optimized and efficient renderer based on the rasterization algorithm. The goal of this lesson is to teach the basic principles of the rendering technique. Don&rsquo;t think though that the techniques we present in these chapters are not used. They are used to some extent, but how they are implemented either on the GPU or in a CPU version of a production renderer, is just likely to be a highly optimized version of the same idea. What is truly important is to understand the principle and how it works in general. From there, you can study on your own the different techniques which are used to speed up the algorithm. But the techniques presented in this lesson are generic and make up the foundations of any rasterizer.</p>
<p>Keep in mind that drawing a triangle (since the triangle is a primitive we will use it in this case), is a two steps problem:</p>
<ul>
<li>We first need to find which pixels overlap the triangle.</li>
<li>We then need to define which colors should the pixels overlapping the triangle be set to, a process that is called <strong>shading</strong></li>
</ul>
<p>The rasterization stage deals essentially with the first step. The reason we say essentially rather than exclusively is that at the rasterization stage, we will also compute something called <strong>barycentric coordinates</strong> which to some extent, are used in the second step.</p>
<h3 id="the-edge-function">The Edge Function</h3>
<p>As mentioned above, they are several possible methods to find if a pixel overlaps a triangle. It would be good to document older techniques, but in this lesson, will only present the method that is generally used today. This method was presented by Juan Pineda in 1988 and a paper called &ldquo;<strong>A Parallel Algorithm for Polygon Rasterization</strong>&rdquo; (see references in the last chapter).</p>
<p><a href="#R-image-2625ac3717db8d4036213d9ac81afd18" class="lightbox-link"><img src="../assets/rasterization-triangle2.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-2625ac3717db8d4036213d9ac81afd18"><img src="../assets/rasterization-triangle2.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 2:</strong> <em>the principle of Pineda&rsquo;s method is to find a function, so that when we test on which side of this line a given point is, the function returns a positive number when it is to the left of the line, a negative number when it is to the right of this line, and zero when the point is exactly on the line.</em></p>
<p><a href="#R-image-494d3a7a2ab963d3015b64c485a10ffd" class="lightbox-link"><img src="../assets/rasterization-triangle3.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-494d3a7a2ab963d3015b64c485a10ffd"><img src="../assets/rasterization-triangle3.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 3:</strong> <em>points contained within the white area are all located to the right of all three edges of the triangle.</em></p>
<p>Before we look into Pineda&rsquo;s technique itself, we will first describe the principle of his method. Let&rsquo;s say that the edge of a triangle can be seen as a line splitting the 2D plane (the plane of the image) in two (as shown in figure 2). The principle of Pineda&rsquo;s method is to find a function which he called the <strong>edge function</strong>, so that when we test on which side of this line a given point is (the point P in figure 2), the function returns a negative number when it is to the left of the line, a positive number when it is to the right of this line, and zero when the point is exactly on the line.</p>
<p>In figure 2, we applied this method to the first edge of the triangle (defined by the vertices v0-v1. Be careful the order is important). If we now apply the same method to the two other edges (v1-v2 and v2-v0), we then can see that there is an area (the white triangle) within which all points are positive (figure 3). If we take a point within this area, then we will find that this point is to the right of all three edges of the triangle. If P is a point in the center of a pixel, we can then use this method to find if the pixel overlaps the triangle. If for this point, we find that the edge function returns a positive number for all three edges, then the pixel is contained in the triangle (or may lie on one of its edges). The function Pinada uses also happens to be linear which means that it can be computed incrementally but we will come back to this point later.</p>
<p>Now that we understand the principle, let&rsquo;s find out what that function is. The edge function is defined as (for the edge defined by vertices V0 and V1):</p>

<span class="math align-center">$$E_{01}(P) = (P.x - v0.x) * (V1.y - V0.y) - (P.y - V0.y) * (V1.x - V0.x).$$</span><p>As the paper mentions, this function has the useful property that its value is related to the position of the point (x,y) relative to the edge defined by the points V0 and V1:</p>
<ul>
<li>E(P) &gt; 0 if P is to the &ldquo;right&rdquo; side</li>
<li>E(P) = 0 if P is exactly on the line</li>
<li>E(P) &lt; 0 if P is to the &ldquo;left &quot; side</li>
</ul>
<p>This function is equivalent in mathematics to the magnitude of the cross products between the vector (v1-v0) and (P-v0). We can also write these vectors in a matrix form (presenting this as a matrix has no other interest than just neatly presenting the two vectors):</p>

<span class="math align-center">$$
\begin{vmatrix}
(P.x - V0.x) & (P.y - V0.y) \\
(V1.x - V0.x) & (V1.y - V0.y)
\end{vmatrix}
$$</span><p>If we write that 
<span class="math align-center">$A = (P-V0)$</span> and 
<span class="math align-center">$B = (V1 - V0)$</span>, then we can also write the vectors A and B as a 2x2 matrix:</p>

<span class="math align-center">$$
\begin{vmatrix}
 A.x & A.y \\ 
 B.x & B.y
\end{vmatrix}
$$</span><p>The <a href="http://en.wikipedia.org/wiki/Determinant#2.C2.A0.C3.97.C2.A02_matrices" target="_blank"><strong>determinant</strong></a> of this matrix can be computed as:</p>

<span class="math align-center">$$A.x * B.y - A.y * B.x.$$</span><p>If you now replace the vectors A and B with the vectors (P-V0) and (V1-V0) back again, you get:</p>

<span class="math align-center">$$(P.x - V0.x) * (V1.y - V0.y) - (P.y - V0.y) * (V1.x - V0.x).$$</span><p>Which as you can see, is similar to the edge function we have defined above. In other words, the edge function can either be seen as the determinant of the 2x2 matrix defined by the components of the 2D vectors (P-v0) and (v1-v0) or also as the magnitude of the cross product of the vectors (P-V0) and (V1-V0). Both the determinant and the magnitude of the cross-product of two vectors have the same geometric interpretation. Let&rsquo;s explain.</p>
<p><a href="#R-image-18ada556672e666f83eda985fa5f3c0c" class="lightbox-link"><img src="../assets/cross-product-anim.gif" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-18ada556672e666f83eda985fa5f3c0c"><img src="../assets/cross-product-anim.gif" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 4:</strong> <em>the cross-product of vector B (blue) and A (red) gives a vector C (green) perpendicular to the plane defined by A and B (assuming the right-hand rule convention). The magnitude of vector C depends on the angle between A and B. It can either be positive or negative.</em></p>
<p><a href="#R-image-bba80d4091bf3c8ada8a507233144d98" class="lightbox-link"><img src="../assets/cross-product.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-bba80d4091bf3c8ada8a507233144d98"><img src="../assets/cross-product.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 5:</strong> <em>the area of the parallelogram is the absolute value of the determinant of the matrix formed by the vectors A and B (or the magnitude of the cross-product of the two vectors B and A (assuming the right-hand rule convention).</em></p>
<p><a href="#R-image-f84a0d6c7fb02d1bc4f12e690df67c6d" class="lightbox-link"><img src="../assets/cross-product1.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f84a0d6c7fb02d1bc4f12e690df67c6d"><img src="../assets/cross-product1.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 6:</strong> <em>the area of the parallelogram is the absolute value of the determinant of the matrix formed by the vectors A and B. If the angle</em> � <em>is lower than</em> � <em>then the &ldquo;signed&rdquo; area is positive. If the angle is greater than</em> � <em>then the &ldquo;signed&rdquo; area is negative. The angle is computed with respect to the Cartesian coordinates defined by the vectors A and D. They can be seen to separate the plane in two halves.</em></p>
<p><a href="#R-image-245c2002c7df290fbaef328895679ee6" class="lightbox-link"><img src="../assets/cross-product2.gif" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-245c2002c7df290fbaef328895679ee6"><img src="../assets/cross-product2.gif" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 7:</strong> <em>P is contained in the triangle if the edge function returns a positive number for the three indicated pairs of vectors.</em></p>
<p>Understanding what&rsquo;s happening is easier when we look at the result of a cross-product between two 3D vectors (Figure 4). In 3D, the cross-product returns another 3D vector that is perpendicular (or orthonormal) to the two original vectors. But as you can see in Figure 4, the magnitude of that orthonormal vector also changes with the orientation of the two vectors with respect to each other. In Figure 4, we assume a right-hand coordinate system. When the two vectors A (red) and B (blue) are either pointing exactly in the same direction or opposite directions, the magnitude of the third vector C (in green) is zero. Vector A has coordinates (1,0,0) and is fixed. When vector B has coordinates (0,0,-1), then the green vector, vector C has coordinates (0,-1,0). If we were to find its &ldquo;signed&rdquo; magnitude, we would find that it is equal to -1. On the other hand, when vector B has coordinates (0,0,1), then C has coordinates (0,1,0) and its signed magnitude is equal to 1. In one case the &ldquo;signed&rdquo; magnitude is negative, and in the second case, the signed magnitude is positive. In fact, in 3D, the magnitude of a vector can be interpreted as the area of the parallelogram having A and B as sides as shown in Figure 5 (read the Wikipedia article on the <a href="http://en.wikipedia.org/wiki/Cross_product#Geometric_meaning" target="_blank">cross product</a> to get more details on this interpretation):</p>

<span class="math align-center">$$Area = || A \times B || = ||A|| ||B|| \sin(\theta).$$</span><p>An area should always be positive, though the sign of the above equation provides an indication of the orientation of the vectors A and B with respect to each other. When with respect to A, B is within the half-plane defined by vector A and a vector orthogonal to A (let&rsquo;s call this vector D; note that A and D form a 2D Cartesian coordinate system), then the result of the equation is positive. When B is within the opposite half plane, the result of the equation is negative (Figure 6). Another way of explaining this result is that the result is positive when the angle (\theta) is in the range (]0,\pi[) and negative when (\theta) is in the range (]\pi, 2\pi[). Note that when (\theta) is exactly equal to 0 or (\pi) then the cross-product or the edge function returns 0.</p>
<p>To find if a point is inside a triangle, all we care about really is the sign of the function we used to compute the area of the parallelogram. However, the area itself also plays an important role in the rasterization algorithm; it is used to compute the barycentric coordinates of the point in the triangle, a technique we will study next. The cross-product in 3D and 2D has the same geometric interpretation, thus the cross-product between two 2D vectors also returns the &ldquo;signed&rdquo; area of the parallelogram defined by the two vectors. The only difference is that in 3D, to compute the area of the parallelogram you need to use this equation:</p>

<span class="math align-center">$$Area = || A \\times B || = ||A|| ||B|| \\sin(\\theta),$$</span><p>while in 2D, this area is given by the cross-product itself (which as mentioned before can also be interpreted as the determinant of a 2x2 matrix):</p>

<span class="math align-center">$$Area = A.x * B.y - A.y * B.x.$$</span><p>From a practical point of view, all we need to do now is test the sign of the edge function computed for each edge of the triangle and another vector defined by a point and the first vertex of the edge (Figure 7).</p>

<span class="math align-center">$$
\begin{array}{l}
E_{01}(P) = (P.x - V0.x) * (V1.y - V0.y) - (P.y - V0.y) * (V1.x - V0.x),\\
E_{12}(P) = (P.x - V1.x) * (V2.y - V1.y) - (P.y - V1.y) * (V2.x - V1.x),\\
E_{20}(P) = (P.x - V2.x) * (V0.y - V2.y) - (P.y - V2.y) * (V0.x - V2.x).
\end{array}
$$</span><p>If all three tests are positive or equal to 0, then the point is inside the triangle (or lying on one of the edges of the triangle). If any one of the tests is negative, then the point is outside the triangle. In code we get:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">bool</span> <span class="nf">edgeFunction</span><span class="p">(</span><span class="k">const</span> <span class="n">Vec2f</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Vec3f</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">,</span> <span class="k">const</span> <span class="n">Vec2f</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="k">return</span> <span class="p">((</span><span class="n">c</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">a</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">a</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">a</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">a</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">gt</span><span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="kt">bool</span> <span class="n">inside</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="n">inside</span> <span class="o">&amp;=</span> <span class="n">edgeFunction</span><span class="p">(</span><span class="n">V0</span><span class="p">,</span> <span class="n">V1</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="n">inside</span> <span class="o">&amp;=</span> <span class="n">edgeFunction</span><span class="p">(</span><span class="n">V1</span><span class="p">,</span> <span class="n">V2</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="n">inside</span> <span class="o">&amp;=</span> <span class="n">edgeFunction</span><span class="p">(</span><span class="n">V2</span><span class="p">,</span> <span class="n">V0</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">inside</span> <span class="o">==</span> <span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="c1">// point p is inside triangles defined by vertices v0, v1, v2
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="c1"></span>    <span class="p">...</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><blockquote>
<details>
The edge function has the property of being linear. We refer you to the original paper if you wish to learn more about this property and how it can be used to optimize the algorithm. In short though, let's say that because of this property, the edge function can be run in parallel (several pixels can be tested at once). This makes the method ideal for hardware implementation. This explains partially why pixels on the GPU are generally rendered as a block of 2x2 pixels (pixels can be tested in a single cycle). Hint: you can also use SSE instructions and multi-threading to optimize the algorithm on the CPU.
</details>
</blockquote>
<h3 id="alternative-to-the-edge-function">Alternative to the Edge Function</h3>
<p>There are other ways than the edge function method to find if pixels overlap triangles, however as mentioned in the introduction of this chapter, we won&rsquo;t study them in this lesson. Just for reference though, the other common technique is called scanline rasterization. It is based on the Brenseham algorithm that is generally used to draw lines. GPUs use the edge method mostly because it is more generic than the scanline approach which is also more difficult to run in parallel than the edge method, but we won&rsquo;t provide more information on this topic in this lesson.</p>
<h3 id="be-careful-winding-order-matters">Be Careful! Winding Order Matters</h3>
<p><a href="#R-image-891be71d3cb89c0ba817bf39f79f30f5" class="lightbox-link"><img src="../assets/winding.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-891be71d3cb89c0ba817bf39f79f30f5"><img src="../assets/winding.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 8:</strong> <em>clockwise and counter-clockwise winding.</em></p>
<p>One of the things we have been talking about yet, but which has great importance in CG, is the order in which you declare the vertices making up the triangles. They are two possible conventions which you can see illustrated in Figure 8: <strong>clockwise</strong> or <strong>counter-clockwise ordering</strong> or <strong>winding</strong>. Winding is important because it essentially defines one important property of the triangle which is the orientation of its normal. Remember that the normal of the triangle can be computed from the cross product of the two vectors A=(V2-V0) and B=(V1-V0). Let&rsquo;s say that V0={0,0,0}, V1={1,0,0} and V2={0,-1,0} then (V1-V0)={1,0,0} and (V2-V0)={0,-1,0}. Let&rsquo;s now compute the cross-product of these two vectors:</p>

<span class="math align-center">$$
\begin{array}{l}
N = (V1-V0) \times (V2-V0)\\
N.x = a.y*b.z - a.z * b.y = 0*0 - 0*-1\\
N.y = a.z*b.x - a.x * b.z = 0*0 - 1*0\\
N.z = a.x*b.y - a.y * b.x = 1*-1 - 0*0 = -1\\
N=\{0,0,-1\}
\end{array}
$$</span><p>However if you declare the vertices in counter-clockwise order, then V0={0,0,0}, V1={0,-1,0} and V2={1,0,0}, (V1-V0)={0,-1,0} and (V2-V0)={1,0,0}. Let&rsquo;s compute the cross-product of these two vectors again:</p>

<span class="math align-center">$$
\begin{array}{l}
N = (V1-V0) \times (V2-V0)\\
N.x = a.y*b.z - a.z * b.y = 0*0 - 0*-1\\
N.y = a.z*b.x - a.x * b.z = 0*0 - 1*0\\
N.z = a.x*b.y - a.y * b.x = 0*0 - -1*1 = 1\\
N=\{0,0,1\}
\end{array}
$$</span><p><a href="#R-image-3abad1a1066a9af2ca1ab1710df07700" class="lightbox-link"><img src="../assets/winding1.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-3abad1a1066a9af2ca1ab1710df07700"><img src="../assets/winding1.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 9:</strong> <em>the ordering defines the orientation of the normal.</em></p>
<p><a href="#R-image-0f40ec82aafef43b0d4e960628addc93" class="lightbox-link"><img src="../assets/rasterization-triangle4.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-0f40ec82aafef43b0d4e960628addc93"><img src="../assets/rasterization-triangle4.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 10:</strong> <em>the ordering defines if points inside the triangle are positive or negative.</em></p>
<p>As expected, the two normals are pointing in opposite directions. The orientation of the normal has great importance for lots of different reasons, but one of the most important ones is called <strong>face culling</strong>. Most rasterizers and even ray-tracer for that matter may not render triangles whose normal is facing away from the camera. This is called <a href="http://en.wikipedia.org/wiki/Back-face_culling" target="_blank">back-face culling</a>. Most rendering APIs such as OpenGL or DirectX give the option to turn back-face culling off, however, you should still be aware that vertex ordering plays a role in what&rsquo;s rendered, among many other things. And not surprisingly, the edge function is one of these other things. Before we get to explain why it matters in our particular case, let&rsquo;s say that there is no particular rule when it comes to choosing the order. In reality, so many details in a renderer implementation may change the orientation of the normal that you can&rsquo;t assume that by declaring vertices in a certain order, you will get the guarantee that the normal will be oriented a certain way. For instance, rather than using the vectors (V1-V0) and (V2-V0) in the cross-product, you could as have used (V0-V1) and (V2-V1) instead. It would have produced the same normal but flipped. Even if you use the vectors (V1-V0) and (V2-V0), <a href="../../../../../lessons/mathematics-physics-for-computer-graphics/geometry/math-operations-on-points-and-vectors">remember</a> that the order of the vectors in the cross-product changes the sign of the normal: 
<span class="math align-center">$A \times B=-B \times A$</span>. So the direction of your normal also depends on the order of the vectors in the cross-product. For all these reasons, don&rsquo;t try to assume that declaring vertices in one order rather than the other will give you one result or the other. What&rsquo;s important though, is that once you stick to the convention you have chosen. Generally, graphics APIs such as OpenGL and DirectX expect triangles to be declared in counter-clockwise order. We will also use counter-clockwise winding. Now let&rsquo;s see how ordering impacts the edge function.</p>
<p>Why does winding matter when it comes to the edge function? You may have noticed that since the beginning of this chapter, in all figures we have drawn the triangle vertices in clockwise order. We have also defined the edge function as:</p>

<span class="math align-center">$$
\begin{array}{l}
E_{AB}(P) &=& (P.x - A.x) * (B.y - A.y) - \\
&& (P.y - A.y) * (B.x - A.x)
\end{array}
$$</span><p>If we respect this convention, then points to the right of the line defined by the vertices A and B will be positive. For example, a point to, the right of V0V1, V1V2, or V2V0 would be positive. However, if we were to declare the vertices in counter-clockwise order, points to the right of an edge defined by vertices A and B would still be positive, but then they would be outside the triangle. In other words, points overlapping the triangle would not be positive but negative (Figure 10). You can potentially still get the code working with positive numbers with a small change to the edge function:</p>

<span class="math align-center">$$E_{AB}(P) = (A.x - B.x) * (P.y - A.y) - (A.y - B.y) * (P.x - A.x).$$</span><p>In conclusion, depending on the ordering convention you use, you may need to use one version of the edge function or the other.</p>
<h3 id="barycentric-coordinates">Barycentric Coordinates</h3>
<p><a href="#R-image-c70f41e936469a6a7773ec989936215f" class="lightbox-link"><img src="../assets/barycentric1.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c70f41e936469a6a7773ec989936215f"><img src="../assets/barycentric1.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 11:</strong> <em>the area of a parallelogram is twice the area of a triangle.</em></p>
<p>Computing barycentric coordinates are not necessary to get the rasterization algorithm working. For a naive implementation of the rendering technique, all you need is to project the vertices and use a technique like an edge function that we described above, to find if pixels are inside triangles. These are the only two necessary steps to produce an image. However, the result of the edge function which as we explained above, can be interpreted as the area of the parallelogram defined by vectors A and B can directly be used to compute these barycentric coordinates. Thus, it makes sense to study the edge function and the barycentric coordinates at the same time.</p>
<p>Before we get any further though, let&rsquo;s explain what these barycentric coordinates are. First, they come in a set of <b>three floating point numbers</b> which in this lesson, we will denote 
<span class="math align-center">$\lambda_0$</span>, 
<span class="math align-center">$\lambda_1$</span> and 
<span class="math align-center">$\lambda_2$</span>. Many different conventions exist but Wikipedia uses the greek letter lambda as well ((\lambda)) which is also used by other authors (the greek letter omega (\omega) is also sometimes used). This doesn&rsquo;t matter, you can call them the way you want. In short, the coordinates can be used to define any point on the triangle in the following manner:</p>

<span class="math align-center">$$P = \lambda_0 * V0 + \lambda_1 * V1 + \lambda_2 * V2.$$ </span><p>Where as usual, V0, V1, and V2 are the vertices of a triangle. These coordinates can take on any value, but for points that are inside the triangle (or lying on one of its edges) they can only be in the range [0,1] and the sum of the three coordinates is equal to 1. In other words:</p>

<span class="math align-center">$$\lambda_0 + \lambda_1 + \lambda_2 = 1, \text{ for } P \in \triangle{V0, V1, V2}.$$</span><p><a href="#R-image-bd8d68f5eb483a1d62c0857df13bf149" class="lightbox-link"><img src="../assets/barycentric2.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-bd8d68f5eb483a1d62c0857df13bf149"><img src="../assets/barycentric2.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 12:</strong> <em>how do we find the color of P?</em></p>
<p>This is a form of interpolation if you want. They are also sometimes defined as <strong>weights</strong> for the triangle&rsquo;s vertices (which is why in the code we will denote them with the letter w). A point overlapping the triangle can be defined as &ldquo;a little bit of V0 plus a little bit of V1 plus a little bit of V2&rdquo;. Note that when any of the coordinates is 1 (which means that the others in this case are necessarily 0) then the point P is equal to one of the triangle&rsquo;s vertices. For instance if 
<span class="math align-center">$\lambda_2 = 1$</span> then P is equal to V2. Interpolating the triangle&rsquo;s vertices to find the position of a point inside the triangle is not that useful. But the method can also be used to interpolate across the surface of the triangle any quantity or variable that has been defined at the triangle&rsquo;s vertices. Imagine for instance that you have defined a color at each vertex of the triangle. Say V0 is red, V1 is green and V2 is blue (Figure 12). What you want to do, is find how these three colors interpolated across the surface of the triangle. If you know the barycentric coordinates of a point P on the triangle, then its color 
<span class="math align-center">$C_P$</span> (which is a combination of the triangle vertices&rsquo; colors) is defined as:</p>

<span class="math align-center">$$C_P = \lambda_0 * C_{V0} + \lambda_1 * C_{V1} + \lambda_2 * C_{V2}.$$ </span><p>This is a very handy technique that is going to be useful to shade triangles. Data associated with the vertices of triangles is called <strong>vertex attribute</strong>. This is a very common and very important technique in CG. <strong>The most common vertex attributes are colors, normals, and texture coordinates</strong>. What this means in practice, is that generally when you define a triangle you don&rsquo;t only pass on to the renderer the triangle vertices but also its associated vertex attributes. For example, if you want to shade the triangle you may need color and normal vertex attribute, which means that each triangle will be defined by 3 points (the triangle vertex positions), 3 colors (the color of the triangle vertices), and 3 normals (the normal of the triangle vertices). Normals too can be interpolated across the surface of the triangle. Interpolated normals are used in a technique called <a href="http://en.wikipedia.org/wiki/Gouraud_shading" target="_blank"><strong>smooth shading</strong></a> which was first introduced by Henri Gouraud. We will explain this technique later when we get to shading.</p>
<p>How do we find these barycentric coordinates? It turns out to be simple. As mentioned above when we presented the edge function, the result of the edge function can be interpreted as the area of the parallelogram defined by the vectors A and B. If you look at Figure 8, you can easily see that the area of the triangle defined by the vertices V0, V1, and V2, is just half of the area of the parallelogram defined by the vectors A and B. The area of the triangle is thus half the area of the parallelogram which we know can be computed by the cross-product of the two 2D vectors A and B:</p>

<span class="math align-center">$$Area_{\triangle{V0V1V2}}= {1 \over 2} {A \times B} = {1 \over 2}(A.x * B.y - A.y * B.x).$$</span><p><a href="#R-image-be3406a4cd4a76cf8243377df9617f65" class="lightbox-link"><img src="../assets/barycentric3.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-be3406a4cd4a76cf8243377df9617f65"><img src="../assets/barycentric3.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 13:</strong> connecting P to each vertex of the triangle forms three sub-triangles.</p>
<p>If the point P is inside the triangle, then you can see by looking at Figure 3, that we can draw three sub-triangles: V0-V1-P (green), V1-V2-P (magenta), and V2-V0-P (cyan). It is quite obvious that the sum of these three sub-triangle areas, is equal to the area of the triangle V0-V1-V2:</p>

<span class="math align-center">$$
\begin{array}{l}
Area_{\triangle{V0V1V2}} =&Area_{\triangle{V0V1P}} + \\& Area_{\triangle{V1V2P}} + \\& Area_{\triangle{V2V0P}}.
\end{array}
$$</span><p><a href="#R-image-277f1cdd30b8009a6453867532008dc5" class="lightbox-link"><img src="../assets/barycentric4.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-277f1cdd30b8009a6453867532008dc5"><img src="../assets/barycentric4.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 14:</strong> <em>the values for</em> �0*,* �1 <em>and</em> �2 <em>depends on the position of P on the triangle.</em></p>
<p>Let&rsquo;s first try to intuitively get a sense of how they work. This will be easier hopefully if you look at Figure 14. Each image in the series shows what happens to the sub-triangle as a point P which is originally on the edge defined by the vertices V1-V2, moves towards V0. In the beginning, P lies exactly on the edge V1-V2. In a way, this is similar to a basic linear interpolation between two points. In other words, we could write:</p>

<span class="math align-center">$$P = \lambda_1 * V1 + \lambda_2 * V2$$</span><p>With 
<span class="math align-center">$\lambda_1 + \lambda_2 = 1$</span> thus 
<span class="math align-center">$\lambda_2 = 1 - \lambda_1$</span>. What&rsquo;s more interesting in this particular case is that if the generic equation for computing the position of P using barycentric coordinates is:</p>

<span class="math align-center">$$P = \lambda_0 * V0 + \lambda_1 * V1 + \lambda_2 * V2.$$ </span><p>Thus, it clearly shows that in this particular case, (\lambda_0) is equal to 0.</p>

<span class="math align-center">$$
\begin{array}{l}
P = \lambda_0 * V0 + \lambda_1 * V1 + \lambda_2 * V2,\\
P = 0 * V0 + \lambda_1 * V1 + \lambda_2 * V2,\\
P = \lambda_1 * V1 + \lambda_2 * V2.
\end{array}
$$</span><p>This is pretty simple. Note also that in the first image, the red triangle is not visible. Note also that P is closer to V1 than it is to V2. Thus, somehow, 
<span class="math align-center">$\lambda_1$</span> is necessarily greater than 
<span class="math align-center">$\lambda_2$</span>. Note also that in the first image, the green triangle is bigger than the blue triangle. So if we summarize: when the red triangle is not visible, 
<span class="math align-center">$\lambda_0$</span> is equal to 0. 
<span class="math align-center">$\lambda_1$</span> is greater than 
<span class="math align-center">$\lambda_2$</span> and the green triangle is bigger than the blue triangle. Thus somehow, there seems to be a relationship between the area of the triangles and the barycentric coordinates. Furthermore, the red triangle seems associated with 
<span class="math align-center">$\lambda_0$</span> the green triangle with 
<span class="math align-center">$\lambda_1$</span>, and the blue triangle with 
<span class="math align-center">$\lambda_2$</span>.</p>
<ul>
<li>
<span class="math align-center">$\lambda_0$</span> is proportional to the area of the red triangle,</li>
<li>
<span class="math align-center">$\lambda_1$</span> is proportional to the area of the green triangle,</li>
<li>
<span class="math align-center">$\lambda_2$</span> is proportional to the area of the blue triangle.</li>
</ul>
<p>Now, let&rsquo;s jump directly to the last image. In this case, P is equal to V0. This is only possible if 
<span class="math align-center">$\lambda_0$</span> is equal to 1 and the two other coordinates are equal to 0:</p>

<span class="math align-center">$$
\begin{array}{l}
P = \lambda_0 * V0 + \lambda_1 * V1 + \lambda_2 * V2,\\
P = 1 * V0 + 0 * V1 + 0 * V2,\\
P = V0.
\end{array}
$$</span><p><a href="#R-image-54304f391ec472388bd82554a81ae33f" class="lightbox-link"><img src="../assets/barycentric5.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-54304f391ec472388bd82554a81ae33f"><img src="../assets/barycentric5.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 15:</strong> <em>to compute one of the barycentric coordinates, use the area of the triangle defined by P and the edge opposite to the vertex for which the barycentric coordinate needs to be computed.</em></p>
<p>Note also that in this particular case, the blue and green triangles have disappeared and that the area of the triangle V0-V1-V2 is the same as the area of the red triangle. This confirms our intuition that there is a relationship between the area of the sub-triangles and the barycentric coordinates. Finally, from the above observation we can also say that each barycentric coordinate is somehow related to the area of the sub-triangle defined by the edge directly opposite to the vertex the barycentric coordinate is associated with, and the point P. In other words (Figure 15):</p>
<ul>
<li>
<span class="math align-center">$\color{red}{\lambda_0}$</span> is associated with V0. The edge opposite V0 is V1-V2. V1-V2-P defines the red triangle.</li>
<li>
<span class="math align-center">$\color{green}{\lambda_1}$</span> is associated with V1. The edge opposite V1 is V2-V0. V2-V0-P defines the green triangle.</li>
<li>
<span class="math align-center">$\color{blue}{\lambda_2}$</span> is associated with V2. The edge opposite V2 is V0-V1. V0-V1-P defines the blue triangle.</li>
</ul>
<p>If you haven&rsquo;t noticed yet, the area of the red, green, and blue triangles are given by the respective edge functions that we have been using before to find if P is inside the triangle, divided by 2 (remember that the edge function itself gives the &ldquo;signed&rdquo; area of the parallelogram defined by the two vectors A and B, where A and B can be any of the three edges of the triangle):</p>

<span class="math align-center">$$
\begin{array}{l}
\color{red}{Area_{tri}(V1,V2,P)}=&{1\over2}E_{12}(P),\\
\color{green}{Area_{tri}(V2,V0,P)}=&{1\over2}E_{20}(P),\\
\color{blue}{Area_{tri}(V0,V1,P)}=&{1\over2}E_{01}(P).\\
\end{array}
$$</span><p>The barycentric coordinates can be computed as the ratio between the area of the sub-triangles and the area of the triangle V0V1V2:</p>

<span class="math align-center">$$\begin{array}{l}
\color{red}{\lambda_0 = \dfrac{Area(V1,V2,P) } {Area(V0,V1,V2)}},\\
\color{green}{\lambda_1 = \dfrac{Area(V2,V0,P)}{Area(V0,V1,V2)}},\\
\color{blue}{\lambda_2 = \dfrac{Area(V0,V1,P)}{Area(V0,V1,V2)}}.\\
\end{array}
$$</span><p>What the division by the triangle area does, essentially normalizes the coordinates. For example, when P has the same position as V0, then the area of the triangle V2V1P (the red triangle) is the same as the area of the triangle V0V1V2. Thus dividing one by the over gives 1, which is the value of the coordinate (\lambda_0). Since in this case, the green and blue triangles have area 0, (\lambda_1) and (\lambda_2) are equal to 0 and we get:</p>

<span class="math align-center">$$P = 1 * V0 + 0 * V1 + 0 * V2 = V0.$$</span><p>Which is what we expect.</p>
<p>To compute the area of a triangle we can use the edge function as mentioned before. This works for the sub-triangles as well as the main triangle V0V1V2. However the edge function returns the area of the parallelogram instead of the area of the triangle (Figure 8) but since the barycentric coordinates are computed as the ratio between the sub-triangle area and the main triangle area, we can ignore the division by 2 (this division which is in the numerator and the denominator cancel out):</p>

<span class="math align-center">$$\lambda_0 = \dfrac{Area_{tri}(V1,V2,P)}{Area_{tri}(V0,V1,V2)} = \dfrac{1/2 E_{12}(P)}{1/2E_{12}(V0)} =  \dfrac{E_{12}(P)}{E_{12}(V0)}.$$</span><p>Note that: ( E_{01}(V2) = E_{12}(V0) = E_{20}(V1) = 2 * Area_{tri}(V0,V1,V2)).</p>
<p>Let&rsquo;s see how it looks in the code. We were already computing the edge functions before to test if points were inside triangles. Only, in our previous implementation, we were just returning true or false depending on whether the result of the function was either positive or negative. To compute the barycentric coordinates, we need the actual result of the edge function. We can also use the edge function to compute the area (multiplied by 2) of the triangle. Here is a version of an implementation that tests if a point P is inside a triangle and if so, computes its barycentric coordinates:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">float</span> <span class="nf">edgeFunction</span><span class="p">(</span><span class="k">const</span> <span class="n">Vec2f</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Vec3f</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">,</span> <span class="k">const</span> <span class="n">Vec2f</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">a</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">a</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">a</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">a</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="kt">float</span> <span class="n">area</span> <span class="o">=</span> <span class="n">edgeFunction</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">);</span> <span class="c1">// area of the triangle multiplied by 2
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1"></span><span class="kt">float</span> <span class="n">w0</span> <span class="o">=</span> <span class="n">edgeFunction</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span> <span class="c1">// signed area of the triangle v1v2p multiplied by 2
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="c1"></span><span class="kt">float</span> <span class="n">w1</span> <span class="o">=</span> <span class="n">edgeFunction</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="n">v0</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span> <span class="c1">// signed area of the triangle v2v0p multiplied by 2
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1"></span><span class="kt">float</span> <span class="n">w2</span> <span class="o">=</span> <span class="n">edgeFunction</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span> <span class="c1">// signed area of the triangle v0v1p multiplied by 2
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="c1">// if point p is inside triangles defined by vertices v0, v1, v2
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="n">w0</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">w1</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">w2</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="c1">// barycentric coordinates are the areas of the sub-triangles divided by the area of the main triangle
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="c1"></span>    <span class="n">w0</span> <span class="o">/=</span> <span class="n">area</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="n">w1</span> <span class="o">/=</span> <span class="n">area</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="n">w2</span> <span class="o">/=</span> <span class="n">area</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>Let&rsquo;s try this code to produce an actual image.</p>
<blockquote>
<details>
We know that:

<span class="math align-center">$$\lambda_0 + \lambda_1 + \lambda_2 = 1.$$</span><p>We also know that we can compute any value across the surface of the triangle using the following equation:</p>

<span class="math align-center">$$Z = \lambda_0 * Z0 + \lambda_1 * Z1 + \lambda_0 * Z2.$$</span><p>The value that we interpolate in this case is Z which can be anything we want or as the name suggests, the z-coordinate of the triangle&rsquo;s vertices in camera space. We can re-write the first equation:</p>

<span class="math align-center">$$\lambda_0 = 1 - \lambda_1 - \lambda_2.$$</span><p>If we plug this equation in the equation to compute Z and simplify, we get:</p>

<span class="math align-center">$$Z = Z0 + \lambda_1(Z1 - Z0) + \lambda_2(Z2 - Z0).$$</span><p>(Z1 - Z0) and (Z2 - Z0) can generally be precomputed which simplifies the computation of Z to two additions and two multiplications. We mention this optimization because GPUs use it and people may mention it for this reason essentially.</p>
</details>
</blockquote>
<h3 id="interpolate-vs-extrapolate">Interpolate vs. Extrapolate</h3>
<p><a href="#R-image-38c27af005fa962d8a6ab5a313cb1e2b" class="lightbox-link"><img src="../assets/extrapolate.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-38c27af005fa962d8a6ab5a313cb1e2b"><img src="../assets/extrapolate.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 16:</strong> <em>interpolation vs. extrapolation.</em></p>
<p>One thing worth noticing is that the computation of barycentric coordinates works independently from its position with respect to the triangle. In other words, the coordinates are valid if the point is inside our outside the triangle. When the point is inside, using the barycentric coordinates to evaluate the value of a vertex attribute is called interpolation, and when the point is outside, we speak of extrapolation. This is an important detail because in some cases, we will have to evaluate the value of a given vertex attribute for points that potentially don&rsquo;t overlap triangles. To be more specific, this will be needed to compute the derivatives of the triangle texture coordinates for example. These derivatives are used to filter textures properly. If you are interested in learning more about this particular topic we invite you to read the lesson on Texture Mapping. In the meantime, all you need to remember is that barycentric coordinates are valid even when the point doesn&rsquo;t cover the triangle. You also need to know about the difference between vertex attribute extrapolation and interpolation.</p>
<h3 id="rasterization-rules">Rasterization Rules</h3>
<p><a href="#R-image-16e8654df2034d8db9324fed942933b2" class="lightbox-link"><img src="../assets/top-left.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-16e8654df2034d8db9324fed942933b2"><img src="../assets/top-left.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 17:</strong> <em>pixels may cover an edge shared by two triangles.</em></p>
<p><a href="#R-image-6921bf7bf85e11942694250972be9eae" class="lightbox-link"><img src="../assets/top-left2.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-6921bf7bf85e11942694250972be9eae"><img src="../assets/top-left2.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 18:</strong> if the geometry is semi-transparent, a dark edge may appear where pixels overlap the two triangles.</p>
<p><a href="#R-image-6830523cf6b7a87945eb5650a4419ade" class="lightbox-link"><img src="../assets/top-left3.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-6830523cf6b7a87945eb5650a4419ade"><img src="../assets/top-left3.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 19:</strong> <em>top and left edges.</em></p>
<p>In some special cases, a pixel may overlap more than one triangle. This happens when a pixel lies exactly on an edge shared by two triangles as shown in Figure 17. Such a pixel would pass the coverage test for both triangles. If they are semi-transparent, a dark edge may appear where the pixels overlap the two triangles as a result of the way semi-transparent objects are combined (imagine two super-imposed semi-transparent sheets of plastic. The surface is more opaque and looks darker than the individual sheets). You would get something similar to what you can see in Figure 18, which is a darker line where the two triangles share an edge.</p>
<p>The solution to this problem is to come up with some sort of rule that guarantees that a pixel can never overlap twice two triangles sharing an edge. How do we do that? Most graphics APIs such as OpenGL and DirectX define something which they call the <strong>top-left rule</strong>. We already know the coverage test returns true if a point is either inside the triangle or if it lies on any of the triangle edges. What the top-left rule says though, is that the pixel or point is considered to overlap a triangle if it is either inside the triangle or lies on either a triangle&rsquo;s top edge or any edge that is considered to be a left edge. What is a top and theft edge? If you look at Figure 19, you can easily see what we mean by the top and left edges.</p>
<ul>
<li>A top edge is an edge that is perfectly horizontal and whose defining vertices are above the third one. Technically this means that the y-coordinates of the vector V[(X+1)%3]-V[X] are equal to 0 and that its x-coordinates are positive (greater than 0).</li>
<li>A left edge is essentially an edge that is going up. Keep in mind that in our case, vertices are defined in clockwise order. An edge is considered to go up if its respective vector V[(X+1)%3]-V[X] (where X can either be 0, 1, 2) has a positive y-coordinate.</li>
</ul>
<blockquote>
<details>
Of course, if you are using a counter-clockwise order, a top edge is an edge that is horizontal and whose x-coordinate is negative, and a left edge is an edge whose y-coordinate is negative.
</details>
</blockquote>
<p>In pseudo-code we have:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="c1">// Does it pass the top-left rule?
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1"></span><span class="n">Vec2f</span> <span class="n">v0</span> <span class="o">=</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">Vec2f</span> <span class="n">v1</span> <span class="o">=</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">Vec2f</span> <span class="n">v2</span> <span class="o">=</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="kt">float</span> <span class="n">w0</span> <span class="o">=</span> <span class="n">edgeFunction</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="kt">float</span> <span class="n">w1</span> <span class="o">=</span> <span class="n">edgeFunction</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="n">v0</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="kt">float</span> <span class="n">w2</span> <span class="o">=</span> <span class="n">edgeFunction</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="n">Vec2f</span> <span class="n">edge0</span> <span class="o">=</span> <span class="n">v2</span> <span class="o">-</span> <span class="n">v1</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="n">Vec2f</span> <span class="n">edge1</span> <span class="o">=</span> <span class="n">v0</span> <span class="o">-</span> <span class="n">v2</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="n">Vec2f</span> <span class="n">edge2</span> <span class="o">=</span> <span class="n">v1</span> <span class="o">-</span> <span class="n">v0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="kt">bool</span> <span class="n">overlaps</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">
</span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="c1">// If the point is on the edge, test if it is a top or left edge, 
</span></span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="c1">// otherwise test if  the edge function is positive
</span></span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="c1"></span><span class="n">overlaps</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">w0</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="p">((</span><span class="n">edge0</span><span class="p">.</span><span class="n">y</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">edge0</span><span class="p">.</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>  <span class="n">edge0</span><span class="p">.</span><span class="n">y</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="n">w0</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="n">overlaps</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">w1</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="p">((</span><span class="n">edge1</span><span class="p">.</span><span class="n">y</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">edge1</span><span class="p">.</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>  <span class="n">edge1</span><span class="p">.</span><span class="n">y</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="n">w1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="n">overlaps</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">w1</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="p">((</span><span class="n">edge2</span><span class="p">.</span><span class="n">y</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">edge2</span><span class="p">.</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>  <span class="n">edge2</span><span class="p">.</span><span class="n">y</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="n">w2</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">
</span></span><span class="line"><span class="ln">22</span><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">overlaps</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">    <span class="c1">// pixel overlap the triangle
</span></span></span><span class="line"><span class="ln">24</span><span class="cl"><span class="c1"></span>    <span class="p">...</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>This version is valid as a proof of concept but highly unoptimized. The key idea is to first check whether any of the values return by returned function is equal to 0 which means that the point lies on the edge. In this case, we test if the edge in question is a top-left edge. If it is, it returns true. If the value returned by the edge function is not equal to 0, we then return true if the value is greater than 0. We won&rsquo;t implement the top-left rule in the program provided with this lesson.</p>
<h3 id="putting-things-together-finding-if-a-pixel-overlaps-a-triangle">Putting Things Together: Finding if a Pixel Overlaps a Triangle</h3>
<p><a href="#R-image-80f6ff50e07a51895fb197432b93fbe1" class="lightbox-link"><img src="../assets/raster2d.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-80f6ff50e07a51895fb197432b93fbe1"><img src="../assets/raster2d.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 20:</strong> <em>Example of vertex attribute linear interpolation using barycentric coordinates.</em></p>
<p>Let&rsquo;s test the different techniques we learned about in this chapter, in a program that produces an actual image. We will just assume that we have projected the triangle already (check the last chapter of this lesson for a complete implementation of the rasterization algorithm). We will also assign a color to each vertex of the triangle. Here is how the image is formed. We will loop over all the pixels in the image and test if they overlap the triangle using the edge function method. All three edges of the triangle are tested against the current position of the pixel, and if the edge function returns a positive number for all the edges then the pixel overlaps the triangle. We can then compute the pixel&rsquo;s barycentric coordinates and use these coordinates to shade the pixel by interpolating the color defined at each vertex of the triangle. The result of the frame-buffer is saved to a PPM file (that you can read with Photoshop). The output of the program is shown in Figure 20.</p>
<p>Note that one possible optimization for this program would be to loop over the pixels contained in the bounding box of the triangle. We haven&rsquo;t made this optimization in this version of the program but you can make it yourself if you wish (using the code from the previous chapters). You can also check the source code of this lesson (available in the last chapter).</p>
<p>Note also that in this version of the program, we move point P to the center of each pixel. You could as well use the pixel integer coordinates. You will find more details on this topic in the next chapter.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="c1">// c++ -o raster2d raster2d.cpp
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1">// (c) www.scratchapixel.com
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="cp">#include &amp;ltcstdio&amp;gt
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="cp">#include &amp;ltcstdlib&amp;gt
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="cp">#include &amp;ltfstream&amp;gt
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="k">typedef</span> <span class="kt">float</span> <span class="n">Vec2</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="k">typedef</span> <span class="kt">float</span> <span class="n">Vec3</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">Rgb</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="kr">inline</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="kt">float</span> <span class="nf">edgeFunction</span><span class="p">(</span><span class="k">const</span> <span class="n">Vec2</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Vec2</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">,</span> <span class="k">const</span> <span class="n">Vec2</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="p">}</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">
</span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">    <span class="n">Vec2</span> <span class="n">v0</span> <span class="o">=</span> <span class="p">{</span><span class="mf">491.407</span><span class="p">,</span> <span class="mf">411.407</span><span class="p">};</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">    <span class="n">Vec2</span> <span class="n">v1</span> <span class="o">=</span> <span class="p">{</span><span class="mf">148.593</span><span class="p">,</span> <span class="mf">68.5928</span><span class="p">};</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">    <span class="n">Vec2</span> <span class="n">v2</span> <span class="o">=</span> <span class="p">{</span><span class="mf">148.593</span><span class="p">,</span> <span class="mf">411.407</span><span class="p">};</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">    <span class="n">Vec3</span> <span class="n">c0</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">    <span class="n">Vec3</span> <span class="n">c1</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">    <span class="n">Vec3</span> <span class="n">c2</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">    
</span></span><span class="line"><span class="ln">25</span><span class="cl">    <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">w</span> <span class="o">=</span> <span class="mi">512</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl">    <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">512</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl">    
</span></span><span class="line"><span class="ln">28</span><span class="cl">    <span class="n">Rgb</span> <span class="o">*</span><span class="n">framebuffer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Rgb</span><span class="p">[</span><span class="n">w</span> <span class="o">*</span> <span class="n">h</span><span class="p">];</span>
</span></span><span class="line"><span class="ln">29</span><span class="cl">    <span class="n">memset</span><span class="p">(</span><span class="n">framebuffer</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">,</span> <span class="n">w</span> <span class="o">*</span> <span class="n">h</span> <span class="o">*</span> <span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">30</span><span class="cl">    
</span></span><span class="line"><span class="ln">31</span><span class="cl">    <span class="kt">float</span> <span class="n">area</span> <span class="o">=</span> <span class="n">edgeFunction</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">32</span><span class="cl">    
</span></span><span class="line"><span class="ln">33</span><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&amp;</span><span class="n">lt</span> <span class="n">h</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">34</span><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span> <span class="n">w</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">35</span><span class="cl">            <span class="n">Vec2</span> <span class="n">p</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span> <span class="o">+</span> <span class="mf">0.5f</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mf">0.5f</span><span class="p">};</span>
</span></span><span class="line"><span class="ln">36</span><span class="cl">            <span class="kt">float</span> <span class="n">w0</span> <span class="o">=</span> <span class="n">edgeFunction</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">37</span><span class="cl">            <span class="kt">float</span> <span class="n">w1</span> <span class="o">=</span> <span class="n">edgeFunction</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="n">v0</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">38</span><span class="cl">            <span class="kt">float</span> <span class="n">w2</span> <span class="o">=</span> <span class="n">edgeFunction</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">39</span><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">w0</span> <span class="o">&amp;</span><span class="n">gt</span><span class="o">=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">w1</span> <span class="o">&amp;</span><span class="n">gt</span><span class="o">=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">w2</span> <span class="o">&amp;</span><span class="n">gt</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">40</span><span class="cl">                <span class="n">w0</span> <span class="o">/=</span> <span class="n">area</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">41</span><span class="cl">                <span class="n">w1</span> <span class="o">/=</span> <span class="n">area</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">42</span><span class="cl">                <span class="n">w2</span> <span class="o">/=</span> <span class="n">area</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">43</span><span class="cl">                <span class="kt">float</span> <span class="n">r</span> <span class="o">=</span> <span class="n">w0</span> <span class="o">*</span> <span class="n">c0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">w1</span> <span class="o">*</span> <span class="n">c1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">w2</span> <span class="o">*</span> <span class="n">c2</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="ln">44</span><span class="cl">                <span class="kt">float</span> <span class="n">g</span> <span class="o">=</span> <span class="n">w0</span> <span class="o">*</span> <span class="n">c0</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">w1</span> <span class="o">*</span> <span class="n">c1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">w2</span> <span class="o">*</span> <span class="n">c2</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="ln">45</span><span class="cl">                <span class="kt">float</span> <span class="n">b</span> <span class="o">=</span> <span class="n">w0</span> <span class="o">*</span> <span class="n">c0</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">w1</span> <span class="o">*</span> <span class="n">c1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">w2</span> <span class="o">*</span> <span class="n">c2</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span></span><span class="line"><span class="ln">46</span><span class="cl">                <span class="n">framebuffer</span><span class="p">[</span><span class="n">j</span> <span class="o">*</span> <span class="n">w</span> <span class="o">+</span> <span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)(</span><span class="n">r</span> <span class="o">*</span> <span class="mi">255</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">47</span><span class="cl">                <span class="n">framebuffer</span><span class="p">[</span><span class="n">j</span> <span class="o">*</span> <span class="n">w</span> <span class="o">+</span> <span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)(</span><span class="n">g</span> <span class="o">*</span> <span class="mi">255</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">48</span><span class="cl">                <span class="n">framebuffer</span><span class="p">[</span><span class="n">j</span> <span class="o">*</span> <span class="n">w</span> <span class="o">+</span> <span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)(</span><span class="n">b</span> <span class="o">*</span> <span class="mi">255</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">49</span><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="ln">50</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln">51</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">52</span><span class="cl">    
</span></span><span class="line"><span class="ln">53</span><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span> <span class="n">ofs</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">54</span><span class="cl">    <span class="n">ofs</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="s">&#34;./raster2d.ppm&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">55</span><span class="cl">    <span class="n">ofs</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;P6</span><span class="se">\n</span><span class="s">&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">w</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">h</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">255</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">56</span><span class="cl">    <span class="n">ofs</span><span class="p">.</span><span class="n">write</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">framebuffer</span><span class="p">,</span> <span class="n">w</span> <span class="o">*</span> <span class="n">h</span> <span class="o">*</span> <span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">57</span><span class="cl">    <span class="n">ofs</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">58</span><span class="cl">    
</span></span><span class="line"><span class="ln">59</span><span class="cl">    <span class="k">delete</span> <span class="p">[]</span> <span class="n">framebuffer</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">60</span><span class="cl">    
</span></span><span class="line"><span class="ln">61</span><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">62</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>As you can see and in conclusion, we can say that the rasterization algorithm is in itself quite simple (and the basic implementation of this technique is quite easy as well).</p>
<h3 id="conclusion-and-whats-next">Conclusion and What&rsquo;s Next?</h3>
<p><a href="#R-image-02b389e2dc3aa81e86e145793a962bcc" class="lightbox-link"><img src="../assets/barycentric6.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-02b389e2dc3aa81e86e145793a962bcc"><img src="../assets/barycentric6.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 21:</strong> <em>barycentric coordinates are constant along lines parallel to an edge.</em></p>
<p>There are many interesting techniques and trivia related to the topic of barycentric coordinates but this lesson is just an introduction to the rasterization algorithm thus we won&rsquo;t go any further. One trivia that is interesting to know though, is that barycentric coordinates are constant along lines parallel to an edge (as shown in Figure 21).</p>
<p>In this lesson, we learned two important methods and various concepts.</p>
<ul>
<li>First, we learned about the edge function and how it can be used to find if a point P overlaps a triangle. The edge function is computed for each edge of the triangle, and a second vector is defined by the edge first vertex and another point P. If for all three edges, the function is positive, then point P overlaps the triangle.</li>
<li>Furthermore, we also learned that the result of the edge function can also be used to compute the barycentric coordinates of point P. These coordinates can be used to interpolate vertex data or vertex attributes across the surface of the triangle. They can be interpreted as weights for the various vertices. The most common vertex attribute is color, normal, and texture coordinates.</li>
</ul>
<h2 id="the-visibility-problem-the-depth-buffer-algorithm-and-depth-interpolation">The Visibility Problem, the Depth Buffer Algorithm and Depth Interpolation</h2>
<p>In the second chapter of this lesson, we learned that in the third coordinate of the projected point (the point in screen space) we store the original vertex z-coordinate (the z-coordinate of the point in camera space):</p>

<span class="math align-center">$$
\begin{array}{l}
P_{screen}.x = \dfrac{ near * P_{camera}.x }{ -P_{camera}.z}\\
P_{screen}.y = \dfrac{ near * P_{camera}.z }{ -P_{camera}.z}\\
P_{screen}.z = -P_{camera}.z\\
\end{array}
$$</span><p>Finding the z-coordinate of a point on the surface of the triangle is useful when a pixel overlaps more than one triangle. And the way we find that z-coordinate is by interpolating the original vertices z-coordinates using the barycentric coordinates that we learned about in the previous chapter. In other words, we can treat the z-coordinates of the triangle vertices as any other vertex attribute, and interpolate them the same way we interpolated colors in the previous chapter. Before we look into the details of how this z-coordinate is computed, let&rsquo;s start to explain why we need to do so.</p>
<h3 id="the-depth-buffer-or-z-buffer-algorithm-and-hidden-surface-removal">The Depth-Buffer or Z-Buffer Algorithm and Hidden Surface Removal</h3>
<p><a href="#R-image-c48c22a5fdad18cc169d1ddcdb4899cc" class="lightbox-link"><img src="./assets/depth-buffer2.png?" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c48c22a5fdad18cc169d1ddcdb4899cc"><img src="./assets/depth-buffer2.png?" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 1:</strong> <em>when a pixel overlaps a triangle, this pixel corresponds to a point on the surface of the triangle (noted P in this figure).</em></p>
<p><a href="#R-image-e29d3ba4586cd302fb27f49e8352edef" class="lightbox-link"><img src="./assets/depth-buffer1.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-e29d3ba4586cd302fb27f49e8352edef"><img src="./assets/depth-buffer1.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 2:</strong> <em>when a pixel overlaps several triangles, we can use the points on the triangle&rsquo;s z-coordinate to find which one of these triangles is the closest to the camera.</em></p>
<p>When a pixel overlaps a point, what we see through that pixel is a small area on the surface of a triangle, which for simplification we will reduce to a single point (denoted P in figure 1). Thus each pixel covering a triangle corresponds to a point on the surface of that triangle. Of course, if a pixel covers more than one triangle, we then have several of these points. The problem when this happens is to find which one of these points is visible. We have illustrated this concept in 2D in figure 2. We could test triangles from back to front (this technique would require sorting triangles by decreasing depth first) but this doesn&rsquo;t always work when triangle intersects each other (figure 2, bottom). The only reliable solution is to compute the depth of each triangle a pixel overlaps, and then compare these depth values to find out which one is the closest to the camera. If you look at figure 2, you can see that a pixel in the image overlaps two triangles in P1 and P2. However, the P1 z-coordinate (Z1) is lower than the P2 z-coordinate (Z2) thus we can deduce that P1 is in front of P2. Note that this technique is needed because triangles are tested in a &ldquo;random&rdquo; order. As mentioned before we could sort out triangles in decreasing depth order but this is not good enough. Generally, they are just tested in the order they are specified in the program, and for this reason, a triangle T1 that is closer to the camera can be tested before a triangle T2 that is further away. If we were not comparing these triangles&rsquo; depth, then we would end up in this case seeing the triangle which was tested last (T2) when in fact we should be seeing T1. As mentioned many times before, this is called the <strong>visibility problem</strong> or <strong>hidden surface problem</strong>. Algorithms for ordering objects so that they are drawn correctly are called visible surface algorithms or hidden surface removal algorithms. The depth-buffer or z-buffer algorithm that we are going to study next belongs to this category of algorithms.</p>
<p>One solution to the visibility problem is to use a <strong>depth-buffer</strong> or <strong>z-buffer</strong>. A depth-buffer is nothing more than a two-dimensional array of floats that has the same dimension as the frame-buffer and that is used to store the depth of the object as the triangles are being rasterized. When this array is created, we initialize each pixel in the array with a very large number. If we find that a pixel overlaps the current triangle, we do as follows:</p>
<ul>
<li>We first compute the z-coordinate or depth of the point on the triangle that the pixel overlaps.</li>
<li>We then compare that current triangle depth with the value stored in the depth buffer for that pixel.</li>
<li>If we find that the value stored in the depth-buffer is greater than the depth of the point on the triangle, then the new point is closer to the observer or the camera than the point stored in the depth buffer at that pixel location. The value stored in the depth-buffer is then replaced with the new depth, and the frame-buffer is updated with the current triangle color. On the other hand, if the value stored in the depth-buffer is smaller than the current depth sample, then the triangle that the pixel overlaps is hidden by the object whose depth is currently stored in the depth-buffer.</li>
</ul>
<p>Note that once all triangles have been processed, the depth-buffer contains &ldquo;some sort&rdquo; of image, that represents the &ldquo;distance&rdquo; between the visible parts of the objects in the scene and the camera (this is not a distance but the z-coordinate of each point visible through the camera). The depth buffer is essentially useful to solve the visibility problem, however, it can also be used in post-processing to do things such as 2D depth of field, adding fog, etc. All these effects are better done in 3D but applying them in 2D is often faster but the result is not always as accurate as what you can get in 3D.</p>
<p>Here is an implementation of the depth-buffer algorithm in pseudo-code:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">float</span> <span class="o">*</span><span class="n">depthBuffer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">float</span> <span class="p">[</span><span class="n">imageWidth</span> <span class="o">*</span> <span class="n">imageHeight</span><span class="p">];</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1">// Initialize depth-buffer with a very large number
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&amp;</span><span class="n">lt</span> <span class="n">imageHeight</span><span class="p">;</span> <span class="o">++</span><span class="n">y</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&amp;</span><span class="n">lt</span> <span class="n">imageWidth</span><span class="p">;</span> <span class="o">++</span><span class="n">x</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">        <span class="n">depthBuffer</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">INFINITY</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="n">each</span> <span class="n">triangle</span> <span class="n">in</span> <span class="n">the</span> <span class="n">scene</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="c1">// Project triangle vertices
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1"></span>    <span class="p">...</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="c1">// Compute 2D triangle bounding-box
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="c1"></span>    <span class="p">...</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">y</span> <span class="o">=</span> <span class="n">bbox</span><span class="p">.</span><span class="n">min</span><span class="p">.</span><span class="n">y</span><span class="p">;</span> <span class="n">y</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">=</span> <span class="n">bbox</span><span class="p">.</span><span class="n">max</span><span class="p">.</span><span class="n">y</span><span class="p">;</span> <span class="o">++</span><span class="n">y</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">x</span> <span class="o">=</span> <span class="n">bbox</span><span class="p">.</span><span class="n">min</span><span class="p">.</span><span class="n">x</span><span class="p">;</span> <span class="n">x</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">=</span> <span class="n">bbox</span><span class="p">.</span><span class="n">max</span><span class="p">.</span><span class="n">x</span><span class="p">;</span> <span class="o">++</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">           <span class="k">if</span> <span class="p">(</span><span class="n">pixelOverlapsTriangle</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">                <span class="c1">// Compute the z-coordinate of the point on the triangle surface
</span></span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="c1"></span>                <span class="kt">float</span> <span class="n">z</span> <span class="o">=</span> <span class="n">computeDepth</span><span class="p">(...);</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">                <span class="c1">// Current point is closest than object stored in depth/frame-buffer
</span></span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="c1"></span>                <span class="k">if</span> <span class="p">(</span><span class="n">z</span> <span class="o">&amp;</span><span class="n">lt</span> <span class="n">depthBuffer</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">                     <span class="c1">// Update depth-buffer with that depth
</span></span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="c1"></span>                     <span class="n">depthBuffer</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">z</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">                     <span class="n">frameBuffer</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">triangleColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">        <span class="p">}</span> 
</span></span><span class="line"><span class="ln">25</span><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="ln">26</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><h3 id="finding-z-by-interpolation">Finding Z by Interpolation</h3>
<p><a href="#R-image-f6a2b7cbbf6e5c819530542b9674a96c" class="lightbox-link"><img src="./assets/interpolate-depth.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f6a2b7cbbf6e5c819530542b9674a96c"><img src="./assets/interpolate-depth.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 3:</strong> <em>can we find the depth of P by interpolating the z coordinates of the triangles vertices z-coordinates using barycentric coordinates?</em></p>
<p><a href="#R-image-553825bfe245afb1e5d779a8d58b1fef" class="lightbox-link"><img src="./assets/depth-interpolation1.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-553825bfe245afb1e5d779a8d58b1fef"><img src="./assets/depth-interpolation1.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 4:</strong> <em>finding the y-coordinate of a point by linear interpolation.</em></p>
<p>Hopefully, the principle of the depth-buffer is simple and easy to understand. All we need to do now is explained how depth values are computed. First, let&rsquo;s repeat one more time what that depth value is. When a pixel overlaps a triangle, it overlaps a small surface on the surface of the triangle, which as mentioned in the introduction we will reduce to a point for simplification (point P in figure 1). What we want to find here, is this point z-coordinate. As also mentioned earlier in this chapter, if we know the triangle vertices&rsquo; z-coordinate (which we do, they are stored in the projected point z-coordinate), all we need to do is interpolate these coordinates using P&rsquo;s barycentric coordinates (figure 4):</p>

<span class="math align-center">$$P.z = \lambda_0 * V0.z + \lambda_1 * V1.z + \lambda_2 * V2.z.$$</span><p>Technically this sounds reasonable, though unfortunately, it doesn&rsquo;t work. Let&rsquo;s see why. The problem is not in the formula itself which is perfectly fine. The problem is that once the vertices of a triangle are projected onto the canvas (once we have performed the perspective divide), then z, the value we want to interpolate, doesn&rsquo;t vary linearly anymore across the surface of the 2D triangle. This is easier to demonstrate with a 2D example.</p>
<p>The secret lies in figure 4. Imagine that we want to find the &ldquo;image&rdquo; of a line defined in 2D space by two vertices V0 and V1. The canvas is represented by the horizontal green line. This line is one unit away (along the z-axis) from the coordinate system origin. If we trace lines from V0 and V1 to the origin, then we intersect the green lines in two points (denoted V0&rsquo; and V1&rsquo; in the figure). The z-coordinate of this point is 1 since they lie on the canvas which is 1 unit away from the origin. The x-coordinate of the points can easily be computed using perspective projection. We just need to divide the original vertex x-coordinates by their z-coordinate. We get:</p>

<span class="math align-center">$$
\begin{array}{l}
V0'.x = \dfrac{V0.x}{V0.z} = \dfrac{-4}{2} = -2,\\
V1'.x = \dfrac{V1.x}{V1.z} = \dfrac{2}{5} = 0.4.
\end{array}
$$</span><p>The goal of the exercise is to find the z-coordinate of P, a point on the line defined by V0 and V1. In this example, all we know about P is the position of its projection P&rsquo;, on the green line. The coordinates of P&rsquo; are {0,1}. The problem is similar to trying to find the z-coordinate of a point on the triangle that a pixel overlaps. In our example, P&rsquo; would be the pixel and P would be the point on the triangle that the pixel overlaps. What we need to do now, is compute the &ldquo;barycentric coordinate&rdquo; of P&rsquo; with respect to V0&rsquo; and V1&rsquo;. Let&rsquo;s call the resulting value 
<span class="math align-center">$\lambda$</span>. Like our triangle barycentric coordinates, 
<span class="math align-center">$\lambda$</span> is also in the range [0,1]. To find 
<span class="math align-center">$\lambda$</span>, we just need to take the distance between V0&rsquo; and P&rsquo; (along the x-axis), and divide this number by the distance between V0&rsquo; and V1&rsquo;. If linearly interpolating the z-coordinates of the original vertices V0 and V1 using 
<span class="math align-center">$\lambda$</span> to find the depth of P works, then we should get the number 4 (we can easily see by just looking at the illustration that the coordinates of P are {0,4}). Let&rsquo;s first compute 
<span class="math align-center">$\lambda$</span>:</p>

<span class="math align-center">$$\lambda=\dfrac{P'x - V0'.x}{V1'.x - V0'.x} = \dfrac{0--2}{0.4--2}= \dfrac{2}{2.4} = 0.833.$$</span><p>If we now linearly interpolate V0 and V1 z-coordinate to find the P z-coordinate we get:</p>

<span class="math align-center">$$P.z = V0.z * (1-\lambda) + V1.z * \lambda\ = 2 * 1.666 + 5 * 0.833 = 4.5.$$</span><p>This is not the value we expect! Interpolating the original vertices z-coordinates, using P&rsquo;s &ldquo;barycentric coordinates&rdquo; or (\lambda) in this example, to find P z-coordinate doesn&rsquo;t work. Why? The reason is simple. <b>Perspective projection preserves lines but does not preserve distances</b>. It&rsquo;s quite easy to see in figure 4, that the ratio of the distance between V0 and P over the distance between V0 and V1 (0.666) is not the same as the ratio of the distance between V0&rsquo; and P&rsquo; over the distance between V0&rsquo; and V1&rsquo; (0.833). If (\lambda) was equal to 0.666 it would work fine, but here is the problem, it&rsquo;s equal to 0.833 instead! So, how do we find the z-coordinate of P?</p>
<p>The solution to the problem is to compute the inverse of the P z-coordinate by interpolating the inverse of the vertices V0 and V1 z-coordinates using \(\lambda\). In other words, the solution is:</p>

<span class="math align-center">$$\dfrac{1}{P.z} = \color{purple}{\dfrac{1}{V0.z} * (1-\lambda) + \dfrac{1}{V1.z} * \lambda}.$$</span><p>Let&rsquo;s check that it works:</p>

<span class="math align-center">$$\dfrac{1}{P.z} = \dfrac{1}{V0.z} * (1-\lambda) + \dfrac{1}{V1.z} * \lambda = \dfrac{1}{2} * (1-2/2.4)+ \dfrac{1}{5} * (2/2.4) = 0.25.$$</span><p>If now take the inverse of this result, we get for P z-coordinate the value 4. Which is the correct result! As mentioned before, the solution is to linearly interpolate the vertex&rsquo;s z-coordinates using barycentric coordinates, and invert the resulting number to find the depth of P (its z-coordinate). In the case of our triangle, the formula is:</p>

<span class="math align-center">$$\dfrac{1}{P.z} = \dfrac{1}{V0.z} * \lambda_0 + \dfrac{1}{V1.z} * \lambda_1 + \dfrac{1}{V2.z} * \lambda_2.$$</span><p><a href="#R-image-592edcc8c8ccc31dbb085d245a3272ca" class="lightbox-link"><img src="./assets/perspective-correct.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-592edcc8c8ccc31dbb085d245a3272ca"><img src="./assets/perspective-correct.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 5:</strong> <em>perspective projection preserves lines but not distances.</em></p>
<p>Let&rsquo;s now look into this problem more formally. Why do we need to interpolate the vertex&rsquo;s inverse z-coordinates? The formal explanation is a bit complicated and you can skip it if you want. Let&rsquo;s consider a line in camera space defined by two vertices whose coordinates are denoted 
<span class="math align-center">$(X_0,Z_0)
$</span> and 
<span class="math align-center">$(X_1,Z_1)$</span>. The projection of these vertices on the screen is denoted 
<span class="math align-center">$S_0$</span> and 
<span class="math align-center">$S_1$</span> respectively (in our example, we will assume that the distance between the camera origin and the canvas is 1 as shown in figure 5). Let&rsquo;s call S a point on the line defined by (S_0) and (S_1). S has a corresponding point P on the 2D line whose coordinates are (X,Z = 1) (we assume in this example that the screen or the vertical line on which the points are projected is 1 unit away from the coordinate system origin). Finally, the parameters (t) and (q) are defined such that:</p>

<span class="math align-center">$$
\begin{array}{l}
P = P_0 * (1-t) + P_1 * t,\\
S = S_0 * (1-q) + S_1 * q.\\
\end{array}
$$</span><p>Which we can also write as:</p>

<span class="math align-center">$$
\begin{array}{l}
P = P_0 + t * (P_1 - P_0),\\
S = S_0 + q * (S_1 - S_0).\\
\end{array}
$$</span><p>The (X,Z) coordinates of point P can thus be computed by interpolation (equation 1):</p>

<span class="math align-center">$$(X,Z) = (X_0 + t * (X_1 - X_0), Z_0 + t * (Z_1 - Z_0)).$$</span><p>Similarly (equation 2):</p>

<span class="math align-center">$$S = S_0 + q * (S_1 - S_0).$$</span><p>S is a 1D point (it has been projected on the screen) thus it has no z-coordinate. S can also be computed as:</p>

<span class="math align-center">$$S = \dfrac{X}{Z}.$$</span><p>Therefore:</p>

<span class="math align-center">$$Z = \dfrac{X}{S}.$$</span><p>If we replace the numerator with equation 1 and the denominator with equation 2, then we get (equation 3):</p>

<span class="math align-center">$$Z = \dfrac{\color{red}{X_0} + t * (\color{green}{X_1} - \color{red}{X_0})}{S_0 + q * (S_1 - S_0)}$$</span><p>We also have:</p>

<span class="math align-center">$$\begin{array}{l}
S_0 = \dfrac{X_0}{Z_0},\\
S_1 = \dfrac{X_1}{Z_1}.
\end{array}$$</span><p>Therefore (equation 4):</p>

<span class="math align-center">$$\begin{array}{l}
\color{red}{X_0 = S_0 * Z_0},\\
\color{green}{X_1 = S_1 * Z_1}.
\end{array}
$$</span><p>If now replace 
<span class="math align-center">$X_0$</span> and 
<span class="math align-center">$X_1$</span> in equation 3 with equation 4, we get (equation 5):</p>

<span class="math align-center">$$Z = \dfrac{\color{red}{S_0 * Z_0} + t * (\color{green}{S_1 * Z_1} - \color{red}{S_0 * Z_0})}{S_0 + q * (S_1 - S_0)}$$</span><p>Remember from equation 1 that (equation 6):</p>

<span class="math align-center">$$Z = Z_0 + t * (Z_1 - Z_0).$$</span><p>If we combine equations 5 and 6 we get:</p>

<span class="math align-center">$$Z_0 + t * (Z_1 - Z_0) = \dfrac{\color{red}{S_0 * Z_0} + t * (\color{green}{S_1 * Z_1} - \color{red}{S_0 * Z_0})}{S_0 + q * (S_1 - S_0)}.$$</span><p>Which can be simplified to:</p>

<span class="math align-center">$$
\begin{array}{l}
(Z_0 + t (Z_1 - Z_0))(S_0 + q(S_1 - S_0))=S_0Z_0 + t(S_1Z_1 - S_0Z_0),\\
Z_0S_0 + Z_0q(S_1 - S_0)+t(Z_1 - Z_0)S_0+t (Z_1 - Z_0)q(S_1 - S_0)=S_0Z_0 + t (S_1Z_1 - S_0Z_0),\\
t[(Z_1 - Z_0)S_0 + (Z_1 - Z_0)q(S_1 - S_0) -(S_1Z_1 - S_0Z_0)] =-qZ_0(S_1 - S_0),\\
t[Z_1S_0 - Z_0S_0 + (Z_1 - Z_0)q(S_1 - S_0) - S_1Z_1 + S_0Z_0] =-qZ_0(S_1 - S_0),\\
t(S_1 - S_0)[Z_1 - q(Z_1 - Z_0)]=qZ_0(S_1 - S_0),\\
t[qZ_0 +(1-q)Z_1]=qZ_0.
\end{array}
$$</span><p>We can now express the parameter 
<span class="math align-center">$t$</span> in terms of 
<span class="math align-center">$q$</span>:</p>

<span class="math align-center">$$t=\dfrac{qZ_0}{qZ_0 +(1-q)Z_1}.$$</span><p>If we substitute for t in equation 6, we get:</p>

<span class="math align-center">$$
\begin{array}{l}
Z &= Z_0 + t * (Z_1 - Z_0) = Z_0 + \dfrac{qZ_0(Z_1 - Z_0)}{qZ_0 +(1-q)Z_1},\\
&= \dfrac{qZ_0^2 + (1-q)Z_0Z_1 + qZ_0Z_1 - qZ_0^2}{qZ_0 +(1-q)Z_1},\\
&= \dfrac{Z_0Z_1}{qZ_0 +(1-q)Z_1},\\
&= \dfrac{1}{\dfrac{q}{Z_1} + \dfrac{(1-q)}{Z_0}},\\
&= \dfrac{1}{\dfrac{1}{Z_0} +q (\dfrac{1}{Z1} - \dfrac{1}{Z_0})}.\\
\end{array}
$$</span><p>And from there you can write:</p>

<span class="math align-center">$$\begin{array}{l}
\dfrac{1}{Z} &= \dfrac{1}{Z_0} +q (\dfrac{1}{Z1} - \dfrac{1}{Z_0}) = \color{purple}{\dfrac{1}{Z_0}(1-q) + \dfrac{1}{Z_1}q}.
\end{array}
$$</span><p>Which is the formula we wanted to end up with.</p>
<blockquote>
<details>
You can use a different approach to explain the depth interpolation issue (but we prefer the one above). You can see the triangle (in 3D or camera space) lying on a plane. The plane equation is (equation 1):

<span class="math align-center">$$AX + BY + CZ = D.$$</span><p>We know that:</p>

<span class="math align-center">$$
\begin{array}{l}
X_{screen} = \dfrac{X_{camera}}{Z_{camera}},\\
Y_{screen} = \dfrac{Y_{camera}}{Z_{camera}}.\\
\end{array}
$$</span><p>Thus:</p>

<span class="math align-center">$$
\begin{array}{l}
X_{camera} = X_{screen}Z_{camera},\\
Y_{camera} = Y_{screen}Z_{camera}.
\end{array}
$$</span><p>If we substitute these two equations in equation 1 and solve for (Z_{camera}), we get:</p>

<span class="math align-center">$$
\begin{array}{l}
AX_{screen}Z_{camera} + BY_{screen}Z_{camera} + CZ_{camera} = D,\\
Z_{camera}(AX_{screen} + BY_{screen} + C) = D,\\
\dfrac{D}{Z_{camera}} = AX_{screen} + BY_{screen} + C,\\
\dfrac{1}{Z_{camera}} = \dfrac{A}{D}X_{screen} + \dfrac{B}{D}Y_{screen} + \dfrac{C}{D},\\
\dfrac{1}{Z_{camera}} = {A'}X_{screen} + {B'}Y_{screen} + {C'},\\
\end{array}
$$</span><p>With: 
<span class="math align-center">$A'=\dfrac{A}{D}$</span>, 
<span class="math align-center">$B'=\dfrac{B}{D}$</span>, 
<span class="math align-center">$C'=\dfrac{C}{D}$</span>.</p>
<p>What this equation shows is that (1/Z_{camera}) is an affine function of (X_{camera}) and (Y_{camera}) which can be interpolated linearly across the surface of the projected triangle (the triangle in screen, NDC or raster space).</p>
</details>
</blockquote>
<h3 id="other-visible-surface-algorithms">Other Visible Surface Algorithms</h3>
<p>As mentioned in the introduction, the z-buffer algorithm belongs to the family of hidden surface removal or visible surface algorithms. These algorithms can be divided into two categories: the <strong>object space</strong> and <strong>image space algorithms</strong>. The <a href="http://en.wikipedia.org/wiki/Painter%27s_algorithm" target="_blank">&ldquo;painter&rsquo;s&rdquo; algorithm</a> which we haven&rsquo;t talked about in this lesson belongs to the former, while the z-buffer algorithm belongs to the latter type. The concept behind the painter&rsquo;s algorithm is roughly to paint or draw objects from back to front. This technique requires objects to be sorted in depth. As explained earlier in this chapter, first objects are passed down to the renderer in arbitrary order, and then when two triangles intersect each other, it becomes difficult to figure out which one is in front of the other (thus deciding which one should be drawn first). This algorithm is not used anymore but the z-buffer is very common (GPUs use it).</p>

            <footer class="footline">
            </footer>
          </article>
        </div>
      </main>
    </div>
    <aside id="R-sidebar" class="default-animation">
      <div id="R-header-topbar" class="default-animation"></div>
      <div id="R-header-wrapper" class="default-animation">
        <div id="R-header" class="default-animation">
          
<span style="font-size:26px">晟世清风</span>
        </div>
        <form action="../../../../../search.html" method="get"><div class="searchbox default-animation">
          <button class="search-detail" type="submit" title="Search (CTRL+ALT+f)"><i class="fas fa-search"></i></button>
          <label class="a11y-only" for="R-search-by">Search</label>
          <input data-search-input id="R-search-by" name="search-by" class="search-by" type="search" placeholder="Search...">
          <button class="search-clear" type="button" data-search-clear="" title="Clear search"><i class="fas fa-times" title="Clear search"></i></button>
        </div></form>
        <script>
          var contentLangs=['en'];
        </script>
        <script src="../../../../../js/auto-complete.js?1708235102" defer></script>
        <script src="../../../../../js/lunr/lunr.min.js?1708235102" defer></script>
        <script src="../../../../../js/lunr/lunr.stemmer.support.min.js?1708235102" defer></script>
        <script src="../../../../../js/lunr/lunr.multi.min.js?1708235102" defer></script>
        <script src="../../../../../js/lunr/lunr.en.min.js?1708235102" defer></script>
        <script src="../../../../../js/search.js?1708235102" defer></script>
      </div>
      <div id="R-homelinks" class="default-animation homelinks">
        <ul>
          <li><a class="padding" href="../../../../../index.html"><i class='fas fa-home'></i> Home</a></li>
        </ul>
        <hr class="padding">
      </div>
      <div id="R-content-wrapper" class="highlightable">
        <div id="R-topics">
          <ul class="enlarge morespace collapsible-menu">
          <li data-nav-id="/programming/index.html" class=""><input type="checkbox" id="R-section-d205f2b94e06f539e77f2bc392064cb6" aria-controls="R-subsections-d205f2b94e06f539e77f2bc392064cb6"><label for="R-section-d205f2b94e06f539e77f2bc392064cb6"><i class="fas fa-chevron-down"></i><i class="fas fa-chevron-right"></i><span class="a11y-only">Submenu 程序设计与开发</span></label><a class="padding" href="../../../../../programming/index.html">程序设计与开发</a><ul id="R-subsections-d205f2b94e06f539e77f2bc392064cb6" class="morespace collapsible-menu">
          <li data-nav-id="/programming/java/index.html" class="alwaysopen"><input type="checkbox" id="R-section-1a585580994f9dab2d4547c8eaf11987" aria-controls="R-subsections-1a585580994f9dab2d4547c8eaf11987" checked><label for="R-section-1a585580994f9dab2d4547c8eaf11987"><i class="fas fa-chevron-down"></i><i class="fas fa-chevron-right"></i><span class="a11y-only">Submenu Java 语言</span></label><a class="padding" href="../../../../../programming/java/index.html">Java 语言</a><ul id="R-subsections-1a585580994f9dab2d4547c8eaf11987" class="morespace collapsible-menu">
          <li data-nav-id="/programming/java/java_basics/index.html" class=""><a class="padding" href="../../../../../programming/java/java_basics/index.html">Java 基础知识</a></li>
          <li data-nav-id="/programming/java/java_collection_framework/index.html" class=""><a class="padding" href="../../../../../programming/java/java_collection_framework/index.html">Java 集合框架</a></li>
          <li data-nav-id="/programming/java/java_concurrency/index.html" class=""><a class="padding" href="../../../../../programming/java/java_concurrency/index.html">Java 并发编程</a></li>
          <li data-nav-id="/programming/java/java_memory_model/index.html" class=""><a class="padding" href="../../../../../programming/java/java_memory_model/index.html">Java 内存模型</a></li>
          <li data-nav-id="/programming/java/java_annotation/index.html" class=""><a class="padding" href="../../../../../programming/java/java_annotation/index.html">Java 注解相关</a></li></ul></li></ul></li>
          <li data-nav-id="/test/index.html" class=""><input type="checkbox" id="R-section-40aaf63da4d8c6f43df4cc726b56321f" aria-controls="R-subsections-40aaf63da4d8c6f43df4cc726b56321f"><label for="R-section-40aaf63da4d8c6f43df4cc726b56321f"><i class="fas fa-chevron-down"></i><i class="fas fa-chevron-right"></i><span class="a11y-only">Submenu Test</span></label><a class="padding" href="../../../../../test/index.html">Test</a><ul id="R-subsections-40aaf63da4d8c6f43df4cc726b56321f" class="morespace collapsible-menu">
          <li data-nav-id="/test/demo/index.html" class=""><a class="padding" href="../../../../../test/demo/index.html">Test</a></li></ul></li>
          <li data-nav-id="/algorithms_and_data_structures/index.html" class=""><a class="padding" href="../../../../../algorithms_and_data_structures/index.html">数据结构与算法</a></li>
          <li data-nav-id="/computer_graphics/index.html" class="parent "><input type="checkbox" id="R-section-17dabdd0438dc68716ce11b90ee5aa30" aria-controls="R-subsections-17dabdd0438dc68716ce11b90ee5aa30" checked><label for="R-section-17dabdd0438dc68716ce11b90ee5aa30"><i class="fas fa-chevron-down"></i><i class="fas fa-chevron-right"></i><span class="a11y-only">Submenu 计算机图形学</span></label><a class="padding" href="../../../../../computer_graphics/index.html">计算机图形学</a><ul id="R-subsections-17dabdd0438dc68716ce11b90ee5aa30" class="morespace collapsible-menu">
          <li data-nav-id="/computer_graphics/classic_tutorial/index.html" class="parent "><input type="checkbox" id="R-section-0e0951862a264269c87df7fac4f297fb" aria-controls="R-subsections-0e0951862a264269c87df7fac4f297fb" checked><label for="R-section-0e0951862a264269c87df7fac4f297fb"><i class="fas fa-chevron-down"></i><i class="fas fa-chevron-right"></i><span class="a11y-only">Submenu 经典教程</span></label><a class="padding" href="../../../../../computer_graphics/classic_tutorial/index.html">经典教程</a><ul id="R-subsections-0e0951862a264269c87df7fac4f297fb" class="morespace collapsible-menu">
          <li data-nav-id="/computer_graphics/classic_tutorial/basics_tutorial/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/basics_tutorial/index.html">基础教程</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/shader_tutorial/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/shader_tutorial/index.html">着色教程</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/raytracing_tutorial/index.html" class="parent "><input type="checkbox" id="R-section-06ac295778bd74c824886a3ab22c212c" aria-controls="R-subsections-06ac295778bd74c824886a3ab22c212c" checked><label for="R-section-06ac295778bd74c824886a3ab22c212c"><i class="fas fa-chevron-down"></i><i class="fas fa-chevron-right"></i><span class="a11y-only">Submenu 光线追踪</span></label><a class="padding" href="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/index.html">光线追踪</a><ul id="R-subsections-06ac295778bd74c824886a3ab22c212c" class="morespace collapsible-menu">
          <li data-nav-id="/computer_graphics/classic_tutorial/raytracing_tutorial/ray_tracing_in_one_weekend/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/ray_tracing_in_one_weekend/index.html">Ray Tracing in One Weekend</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/raytracing_tutorial/ray_tracing_the_next_week/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/ray_tracing_the_next_week/index.html">Ray Tracing The Next Week</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/raytracing_tutorial/ray_tracing_the_rest_of_your_life/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/ray_tracing_the_rest_of_your_life/index.html">Ray Tracing The Rest of Your Life</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/index.html" class="parent "><input type="checkbox" id="R-section-c33da7e0886830ccf91b260ac3fff456" aria-controls="R-subsections-c33da7e0886830ccf91b260ac3fff456" checked><label for="R-section-c33da7e0886830ccf91b260ac3fff456"><i class="fas fa-chevron-down"></i><i class="fas fa-chevron-right"></i><span class="a11y-only">Submenu Scratchapixe 系列短文</span></label><a class="padding" href="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/index.html">Scratchapixe 系列短文</a><ul id="R-subsections-c33da7e0886830ccf91b260ac3fff456" class="morespace collapsible-menu">
          <li data-nav-id="/computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/index.html">Chapter - 1</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-2/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-2/index.html">Chapter - 2</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/index.html">Chapter - 3</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/index.html">Chapter - 4</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/index.html">Chapter - 5</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/index.html" class="active"><a class="padding" href="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/index.html">Chapter - 6</a></li></ul></li></ul></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/index.html" class=""><input type="checkbox" id="R-section-23d956a7f1e516a9e3d46517dfb799dd" aria-controls="R-subsections-23d956a7f1e516a9e3d46517dfb799dd"><label for="R-section-23d956a7f1e516a9e3d46517dfb799dd"><i class="fas fa-chevron-down"></i><i class="fas fa-chevron-right"></i><span class="a11y-only">Submenu OpenGL教程</span></label><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/index.html">OpenGL教程</a><ul id="R-subsections-23d956a7f1e516a9e3d46517dfb799dd" class="morespace collapsible-menu">
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/learn_opengl/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/learn_opengl/index.html">Learn OpenGL</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/index.html" class=""><input type="checkbox" id="R-section-ae6b71edd18a266dbd92162060f7614e" aria-controls="R-subsections-ae6b71edd18a266dbd92162060f7614e"><label for="R-section-ae6b71edd18a266dbd92162060f7614e"><i class="fas fa-chevron-down"></i><i class="fas fa-chevron-right"></i><span class="a11y-only">Submenu OGL dev 教程</span></label><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/index.html">OGL dev 教程</a><ul id="R-subsections-ae6b71edd18a266dbd92162060f7614e" class="morespace collapsible-menu">
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_1_open_a_window/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_1_open_a_window/index.html">Chapter - 1</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_2_hello_dot/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_2_hello_dot/index.html">Chapter - 2</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_3_first_triangle/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_3_first_triangle/index.html">Chapter - 3</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_4_shaders/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_4_shaders/index.html">Chapter - 4</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_5_uniform_variables/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_5_uniform_variables/index.html">Chapter - 5</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_6_translation_transformation/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_6_translation_transformation/index.html">Chapter - 6</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_7_rotation_transformation/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_7_rotation_transformation/index.html">Chapter - 7</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_8_scaling_transformation/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_8_scaling_transformation/index.html">Chapter - 8</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_9_interpolation/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_9_interpolation/index.html">Chapter - 9</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_10_indexed_draws/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_10_indexed_draws/index.html">Chapter - 10</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_11_concatenating_transformations/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_11_concatenating_transformations/index.html">Chapter - 11</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_12_perspective_projection/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_12_perspective_projection/index.html">Chapter - 12</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_13_camera_space/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_13_camera_space/index.html">Chapter - 13</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_14_camera_control_-_part_1/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_14_camera_control_-_part_1/index.html">Chapter - 14</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_15_camera_control_-_part_2/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_15_camera_control_-_part_2/index.html">Chapter - 15</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_16_basic_texture_mapping/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_16_basic_texture_mapping/index.html">Chapter - 16</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_17_ambient_lighting/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_17_ambient_lighting/index.html">Chapter - 17</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_18_diffuse_lighting/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_18_diffuse_lighting/index.html">Chapter - 18</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_19_specular_lighting/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_19_specular_lighting/index.html">Chapter - 19</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_20_point_light/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_20_point_light/index.html">Chapter - 20</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_21_spot_light/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_21_spot_light/index.html">Chapter - 21</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_22_loading_models_using_the_open_asset_import_library/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_22_loading_models_using_the_open_asset_import_library/index.html">Chapter - 22</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_23_shadow_mapping_-_part_1/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_23_shadow_mapping_-_part_1/index.html">Chapter - 23</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_24_shadow_mapping_-_part_2/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_24_shadow_mapping_-_part_2/index.html">Chapter - 24</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_25_skybox/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_25_skybox/index.html">Chapter - 25</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_26_normal_mapping/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_26_normal_mapping/index.html">Chapter - 26</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_27_billboarding_and_the_geometry_shader/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_27_billboarding_and_the_geometry_shader/index.html">Chapter - 27</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_28_particle_system_using_transform_feedback/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_28_particle_system_using_transform_feedback/index.html">Chapter - 28</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_29_3d_picking/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_29_3d_picking/index.html">Chapter - 29</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_30_basic_tessellation/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_30_basic_tessellation/index.html">Chapter - 30</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_31_pn_triangles_tessellation/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_31_pn_triangles_tessellation/index.html">Chapter - 31</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_32_vertex_array_objects/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_32_vertex_array_objects/index.html">Chapter - 32</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_33_instanced_rendering/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_33_instanced_rendering/index.html">Chapter - 33</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_34_glfx_-_an_opengl_effect_library/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_34_glfx_-_an_opengl_effect_library/index.html">Chapter - 34</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_35_deferred_shading_-_part_1/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_35_deferred_shading_-_part_1/index.html">Chapter - 35</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_36_deferred_shading_-_part_2/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_36_deferred_shading_-_part_2/index.html">Chapter - 36</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_37_deferred_shading_-_part_3/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_37_deferred_shading_-_part_3/index.html">Chapter - 37</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_38_skeletal_animation_with_assimp/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_38_skeletal_animation_with_assimp/index.html">Chapter - 38</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_39_silhouette_detection/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_39_silhouette_detection/index.html">Chapter - 39</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_40_stencil_shadow_volume/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_40_stencil_shadow_volume/index.html">Chapter - 40</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_41_object_motion_blur/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_41_object_motion_blur/index.html">Chapter - 41</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_42_percentage_closer_filtering/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_42_percentage_closer_filtering/index.html">Chapter - 42</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_43_multipass_shadow_mapping_with_point_lights/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_43_multipass_shadow_mapping_with_point_lights/index.html">Chapter - 43</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_44_glfw/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_44_glfw/index.html">Chapter - 44</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_45_screen_space_ambient_occlusion/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_45_screen_space_ambient_occlusion/index.html">Chapter - 45</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_46_ssao_with_depth_reconstruction/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_46_ssao_with_depth_reconstruction/index.html">Chapter - 46</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_47_shadow_mapping_with_directional_lights/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_47_shadow_mapping_with_directional_lights/index.html">Chapter - 47</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_48_user_interface_with_ant_tweak_bar/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_48_user_interface_with_ant_tweak_bar/index.html">Chapter - 48</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_49_cascaded_shadow_mapping/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_49_cascaded_shadow_mapping/index.html">Chapter - 49</a></li></ul></li></ul></li></ul></li>
          <li data-nav-id="/computer_graphics/book_recommend/index.html" class=""><a class="padding" href="../../../../../computer_graphics/book_recommend/index.html">书籍推荐</a></li>
          <li data-nav-id="/computer_graphics/blog_article/index.html" class=""><a class="padding" href="../../../../../computer_graphics/blog_article/index.html">博客文章</a></li>
          <li data-nav-id="/computer_graphics/reference/index.html" class=""><a class="padding" href="../../../../../computer_graphics/reference/index.html">参考资料</a></li></ul></li>
          <li data-nav-id="/computer_science/index.html" class=""><input type="checkbox" id="R-section-7d71eaebfb32275fa70e6b3397a5fe7c" aria-controls="R-subsections-7d71eaebfb32275fa70e6b3397a5fe7c"><label for="R-section-7d71eaebfb32275fa70e6b3397a5fe7c"><i class="fas fa-chevron-down"></i><i class="fas fa-chevron-right"></i><span class="a11y-only">Submenu 计算机科学</span></label><a class="padding" href="../../../../../computer_science/index.html">计算机科学</a><ul id="R-subsections-7d71eaebfb32275fa70e6b3397a5fe7c" class="morespace collapsible-menu">
          <li data-nav-id="/computer_science/blog_article/index.html" class=""><a class="padding" href="../../../../../computer_science/blog_article/index.html">博客文章</a></li>
          <li data-nav-id="/computer_science/operating_system/index.html" class=""><a class="padding" href="../../../../../computer_science/operating_system/index.html">操作系统</a></li></ul></li>
          <li data-nav-id="/computer_networks/index.html" class=""><a class="padding" href="../../../../../computer_networks/index.html">计算机网络</a></li>
          <li data-nav-id="/game_programming/index.html" class=""><a class="padding" href="../../../../../game_programming/index.html">游戏编程</a></li>
          <li data-nav-id="/database/index.html" class=""><a class="padding" href="../../../../../database/index.html">数据库</a></li>
          </ul>
        </div>
        <div id="R-shortcuts">
          <div class="nav-title padding">More</div>
          <ul class="space">
            <li><a class="padding" href="https://github.com/McShelby/hugo-theme-relearn"><i class='fab fa-fw fa-github'></i> GitHub repo</a></li>
            <li><a class="padding" href="../../../../../tags/index.html"><i class='fas fa-fw fa-tags'></i> Tags</a></li>
            <li><a class="padding" href="../../../../../categories/index.html"><i class='fas fa-fw fa-layer-group'></i> Categories</a></li>
          </ul>
        </div>
        <div class="padding footermargin footerLangSwitch footerVariantSwitch footerVisitedLinks footerFooter showVariantSwitch showFooter"></div>
        <div id="R-menu-footer">
          <hr class="padding default-animation footerLangSwitch footerVariantSwitch footerVisitedLinks footerFooter showVariantSwitch showFooter">
          <div id="R-prefooter" class="footerLangSwitch footerVariantSwitch footerVisitedLinks showVariantSwitch">
            <ul>
              <li id="R-select-language-container" class="footerLangSwitch">
                <div class="padding menu-control">
                  <i class="fas fa-language fa-fw"></i>
                  <span>&nbsp;</span>
                  <div class="control-style">
                    <label class="a11y-only" for="R-select-language">Language</label>
                    <select id="R-select-language" onchange="location = baseUri + this.value;">
                    </select>
                  </div>
                  <div class="clear"></div>
                </div>
              </li>
              <li id="R-select-variant-container" class="footerVariantSwitch showVariantSwitch">
                <div class="padding menu-control">
                  <i class="fas fa-paint-brush fa-fw"></i>
                  <span>&nbsp;</span>
                  <div class="control-style">
                    <label class="a11y-only" for="R-select-variant">Theme</label>
                    <select id="R-select-variant" onchange="window.variants && variants.changeVariant( this.value );">
                      <option id="R-auto" value="auto" selected>Auto</option>
                      <option id="R-relearn-light" value="relearn-light">Relearn Light</option>
                      <option id="R-relearn-dark" value="relearn-dark">Relearn Dark</option>
                      <option id="R-zen-light" value="zen-light">Zen Light</option>
                      <option id="R-zen-dark" value="zen-dark">Zen Dark</option>
                      <option id="R-neon" value="neon">Neon</option>
                      <option id="R-learn" value="learn">Learn</option>
                      <option id="R-blue" value="blue">Blue</option>
                      <option id="R-green" value="green">Green</option>
                      <option id="R-red" value="red">Red</option>
                    </select>
                  </div>
                  <div class="clear"></div>
                </div>
                <script>window.variants && variants.markSelectedVariant();</script>
              </li>
              <li class="footerVisitedLinks">
                <div class="padding menu-control">
                  <i class="fas fa-history fa-fw"></i>
                  <span>&nbsp;</span>
                  <div class="control-style">
                    <button onclick="clearHistory();">Clear History</button>
                  </div>
                  <div class="clear"></div>
                </div>
              </li>
            </ul>
          </div>
          <div id="R-footer" class="footerFooter showFooter">
          <span class="github-buttons"></span>
          <p>Built with <a href="https://github.com/McShelby/hugo-theme-relearn" title="love"><i class="fas fa-heart"></i></a> by <a href="https://gohugo.io/">Hugo</a></p>
          <script>
            function githubButtonsScheme(){
              var scheme = 'light';
              var colorPropertyValue = window.getComputedStyle( document.querySelector( '#R-sidebar' ) ).getPropertyValue( 'background-color' );
              var colorValues = colorPropertyValue.match( /\d+/g ).map( function( e ){ return parseInt(e,10); });
              if( colorValues.length === 3 && ((0.2126 * colorValues[0]) + (0.7152 * colorValues[1]) + (0.0722 * colorValues[2]) < 165) ){
                
                scheme = 'dark';
              }
              return scheme;
            }
            function githubButtonsInit(){
              if( !window.githubButtons ){
                
                setTimeout( githubButtonsInit, 50 );
                return;
              }
              var scheme = githubButtonsScheme();
              var githubButtonsHTML = `
                <a class="github-button" href="https://github.com/McShelby/hugo-theme-relearn/archive/main.zip" data-color-scheme="${scheme}" data-icon="octicon-cloud-download" aria-label="Download McShelby/hugo-theme-relearn on GitHub">Download</a>
                <a class="github-button" href="https://github.com/McShelby/hugo-theme-relearn" data-color-scheme="${scheme}" data-icon="octicon-star" data-show-count="true" aria-label="Star McShelby/hugo-theme-relearn on GitHub">Star</a>
                <a class="github-button" href="https://github.com/McShelby/hugo-theme-relearn/fork" data-color-scheme="${scheme}" data-icon="octicon-repo-forked" data-show-count="true" aria-label="Fork McShelby/hugo-theme-relearn on GitHub">Fork</a>
               `;
              document.querySelector( '.github-buttons' ).innerHTML = githubButtonsHTML;
              document.querySelectorAll( '.github-button' ).forEach( function( anchor ){
                anchor.dataset.colorScheme = scheme;
                window.githubButtons.render( anchor, function( el ){
                  anchor.parentNode.replaceChild( el, anchor );
                });
              });
            }
            document.addEventListener( 'themeVariantLoaded', function( e ){
              
              setTimeout( githubButtonsInit, 400 );
            });
          </script>
          <script async src="../../../../../js/github-buttons.js?1708235102"></script>
          </div>
        </div>
      </div>
    </aside>
    <script src="../../../../../js/clipboard.min.js?1708235102" defer></script>
    <script src="../../../../../js/perfect-scrollbar.min.js?1708235102" defer></script>
    <script>
      function useMathJax( config ){
        if( !Object.assign ){
          
          return;
        }
        window.MathJax = Object.assign( window.MathJax || {}, {
          loader: {
            load: ['[tex]/mhchem']
          },
          startup: {
            elements: [
              '.math'
            ]
          },
          tex: {
            inlineMath: [
              ['$', '$'], 
              ['\\(', '\\)']
            ]
          },
          options: {
            enableMenu: false 
          }
        }, config );
      }
      useMathJax( JSON.parse("{}") );
    </script>
    <script id="MathJax-script" async src="../../../../../js/mathjax/tex-mml-chtml.js?1708235102"></script>
    <script src="../../../../../js/theme.js?1708235102" defer></script>
  </body>
</html>
