<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.122.0">
    <meta name="generator" content="Relearn 5.23.2+tip">
    <meta name="description" content="啊啊啊啊">
    <meta name="author" content="Sören Weber">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="https://example.com/images/hero.png">
    <meta name="twitter:title" content="3D Viewing: the Pinhole Camera Model :: Hugo Relearn Theme">
    <meta name="twitter:description" content="How a pinhole camera works (part 1) What Will You Learn in this Lesson? In the previous lesson, we learned about some key concepts involved in the process of generating images, however, we didn&rsquo;t speak specifically about cameras. 3D rendering is not only about producing realistic images by the mean of perspective projection. It is also about being able to deliver images similar to that of real-world cameras. Why? Because when CG images are combined with live-action footage, images delivered by the renderer need to match images delivered by the camera with which that footage was produced.">
    <meta property="og:title" content="3D Viewing: the Pinhole Camera Model :: Hugo Relearn Theme">
    <meta property="og:description" content="How a pinhole camera works (part 1) What Will You Learn in this Lesson? In the previous lesson, we learned about some key concepts involved in the process of generating images, however, we didn&rsquo;t speak specifically about cameras. 3D rendering is not only about producing realistic images by the mean of perspective projection. It is also about being able to deliver images similar to that of real-world cameras. Why? Because when CG images are combined with live-action footage, images delivered by the renderer need to match images delivered by the camera with which that footage was produced.">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://example.com/computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/index.html">
    <meta property="og:image" content="https://example.com/images/hero.png">
    <meta property="article:section" content="Scratchapixe 系列短文 :: Hugo Relearn Theme">
    <meta property="og:site_name" content="Hugo Relearn Theme">
    <title>3D Viewing: the Pinhole Camera Model :: Hugo Relearn Theme</title>
    <link href="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/index.xml" rel="alternate" type="application/rss+xml" title="3D Viewing: the Pinhole Camera Model :: Hugo Relearn Theme">
    <link href="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/index.print.html" rel="alternate" type="text/html" title="3D Viewing: the Pinhole Camera Model :: Hugo Relearn Theme"><link rel="icon" href="../../../../../images/favicon.ico">
    <!-- https://github.com/filamentgroup/loadCSS/blob/master/README.md#how-to-use -->
    <link href="../../../../../css/fontawesome-all.min.css?1708235101" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../../../../../css/fontawesome-all.min.css?1708235101" rel="stylesheet"></noscript>
    <link href="../../../../../css/nucleus.css?1708235101" rel="stylesheet">
    <link href="../../../../../css/auto-complete.css?1708235101" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../../../../../css/auto-complete.css?1708235101" rel="stylesheet"></noscript>
    <link href="../../../../../css/perfect-scrollbar.min.css?1708235101" rel="stylesheet">
    <link href="../../../../../css/fonts.css?1708235101" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../../../../../css/fonts.css?1708235101" rel="stylesheet"></noscript>
    <link href="../../../../../css/theme.css?1708235101" rel="stylesheet">
    <link href="../../../../../css/theme-auto.css?1708235101" rel="stylesheet" id="R-variant-style">
    <link href="../../../../../css/variant.css?1708235101" rel="stylesheet">
    <link href="../../../../../css/print.css?1708235101" rel="stylesheet" media="print">
    <link href="../../../../../css/ie.css?1708235101" rel="stylesheet">
    <script src="../../../../../js/url.js?1708235101"></script>
    <script src="../../../../../js/variant.js?1708235101"></script>
    <script>
      // hack to let hugo tell us how to get to the root when using relativeURLs, it needs to be called *url= for it to do its magic:
      // https://github.com/gohugoio/hugo/blob/145b3fcce35fbac25c7033c91c1b7ae6d1179da8/transform/urlreplacers/absurlreplacer.go#L72
      window.index_js_url="../../../../../index.search.js";
      var root_url="../../../../../";
      var baseUri=root_url.replace(/\/$/, '');
      window.relearn = window.relearn || {};
      window.relearn.baseUriFull='https:\/\/example.com/';
      // variant stuff
      window.variants && variants.init( [ 'auto', 'relearn-light', 'relearn-dark', 'zen-light', 'zen-dark', 'neon', 'learn', 'blue', 'green', 'red' ] );
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
    </script>
    <style>
      #R-body img.bg-white {
        background-color: white;
      }
    </style>
  </head>
  <body class="mobile-support html" data-url="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/index.html">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide">
              <button class="topbar-control" onclick="toggleNav()" type="button" title="Menu (CTRL&#43;ALT&#43;n)">
                <i class="fa-fw fas fa-bars"></i>
              </button>
            </div>
            <div class="topbar-button topbar-button-toc" data-content-empty="hide" data-width-s="show" data-width-m="show" data-width-l="show">
              <button class="topbar-control" onclick="toggleTopbarFlyout(this)" type="button" title="Table of Contents (CTRL&#43;ALT&#43;t)">
                <i class="fa-fw fas fa-list-alt"></i>
              </button>
              <div class="topbar-content">
                <div class="topbar-content-wrapper">
<nav class="TableOfContents">
  <ul>
    <li><a href="#how-a-pinhole-camera-works-part-1">How a pinhole camera works (part 1)</a>
      <ul>
        <li><a href="#what-will-you-learn-in-this-lesson">What Will You Learn in this Lesson?</a></li>
        <li><a href="#camera-obscura-how-is-an-image-formed">Camera Obscura: How is an Image Formed?</a></li>
        <li><a href="#how-does-real-camera-work">How Does Real Camera Work?</a></li>
        <li><a href="#pinhole-cameras">Pinhole Cameras</a></li>
      </ul>
    </li>
    <li><a href="#how-a-pinhole-camera-works-part-2">How a pinhole camera works (part 2)</a>
      <ul>
        <li><a href="#focal-length-angle-of-view-and-field-of-view">Focal Length, Angle Of View, and Field of View</a></li>
        <li><a href="#film-size-matters-too">Film Size Matters Too</a></li>
        <li><a href="#image-resolution-and-frame-aspect-ratio">Image Resolution and Frame Aspect Ratio</a></li>
        <li><a href="#canvas-size-and-image-resolution-mind-the-aspect-ratio">Canvas Size and Image Resolution: Mind the Aspect Ratio!</a></li>
        <li><a href="#conclusion-and-summary-everything-you-need-to-know-about-cameras">Conclusion and Summary: Everything You Need to Know about Cameras</a></li>
        <li><a href="#whats-next">What&rsquo;s Next?</a></li>
      </ul>
    </li>
    <li><a href="#a-virtual-pinhole-camera-model">A Virtual Pinhole Camera Model</a>
      <ul>
        <li><a href="#how-do-we-represent-cameras-in-the-cg-world">How Do We Represent Cameras in the CG World?</a></li>
        <li><a href="#near-and-far-clipping-planes-and-the-viewing-frustum">Near and Far Clipping Planes and the Viewing Frustum</a></li>
        <li><a href="#the-near-clipping-plane-and-the-image-plane">The Near Clipping Plane and the Image Plane</a></li>
        <li><a href="#computing-the-canvas-size-and-the-canvas-coordinates">Computing the Canvas Size and the Canvas Coordinates</a></li>
        <li><a href="#camera-to-world-and-world-to-camera-matrix">Camera to World and World to Camera Matrix</a></li>
        <li><a href="#understanding-how-virtual-cameras-are-used">Understanding How Virtual Cameras Are Used</a></li>
        <li><a href="#whats-next-1">What&rsquo;s Next?</a></li>
      </ul>
    </li>
    <li><a href="#implementing-a-virtual-pinhole-camera">Implementing a Virtual Pinhole Camera</a>
      <ul>
        <li><a href="#implementing-a-virtual-pinhole-camera-model">Implementing a Virtual Pinhole Camera Model</a></li>
        <li><a href="#implementing-an-ideal-pinhole-camera-model">Implementing an Ideal Pinhole Camera Model</a></li>
        <li><a href="#conclusion">Conclusion</a></li>
      </ul>
    </li>
  </ul>
</nav>
                </div>
              </div>
            </div>
          </div>
          <ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype="http://schema.org/BreadcrumbList"><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../index.html"><span itemprop="name">主页</span></a><meta itemprop="position" content="1">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../computer_graphics/index.html"><span itemprop="name">计算机图形学</span></a><meta itemprop="position" content="2">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../computer_graphics/classic_tutorial/index.html"><span itemprop="name">经典教程</span></a><meta itemprop="position" content="3">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/index.html"><span itemprop="name">光线追踪</span></a><meta itemprop="position" content="4">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/index.html"><span itemprop="name">Scratchapixe 系列短文</span></a><meta itemprop="position" content="5">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><span itemprop="name">3D Viewing: the Pinhole Camera Model</span><meta itemprop="position" content="6"></li>
          </ol>
          <div class="topbar-area topbar-area-end" data-area="end">
            <div class="topbar-button topbar-button-print" data-content-empty="disable" data-width-s="area-more" data-width-m="show" data-width-l="show">
              <a class="topbar-control" href="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/index.print.html" title="Print whole chapter (CTRL&#43;ALT&#43;p)">
                <i class="fa-fw fas fa-print"></i>
              </a>
            </div>
            <div class="topbar-button topbar-button-prev" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show">
              <a class="topbar-control" href="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/index.html" title="Computing the Pixel Coordinates of a 3D Point (🡐)">
                <i class="fa-fw fas fa-chevron-left"></i>
              </a>
            </div>
            <div class="topbar-button topbar-button-next" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show">
              <a class="topbar-control" href="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/index.html" title="Rasterization: a Practical Implementation (🡒)">
                <i class="fa-fw fas fa-chevron-right"></i>
              </a>
            </div>
            <div class="topbar-button topbar-button-more" data-content-empty="hide" data-width-s="show" data-width-m="show" data-width-l="show">
              <button class="topbar-control" onclick="toggleTopbarFlyout(this)" type="button" title="More">
                <i class="fa-fw fas fa-ellipsis-v"></i>
              </button>
              <div class="topbar-content">
                <div class="topbar-content-wrapper">
                  <div class="topbar-area topbar-area-more" data-area="more">
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable default" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="default">
            <header class="headline">
            </header>
<h1 id="3d-viewing-the-pinhole-camera-model">3D Viewing: the Pinhole Camera Model</h1>

<h2 id="how-a-pinhole-camera-works-part-1">How a pinhole camera works (part 1)</h2>
<h3 id="what-will-you-learn-in-this-lesson">What Will You Learn in this Lesson?</h3>
<p>In the previous lesson, we learned about some key concepts involved in the process of generating images, however, we didn&rsquo;t speak specifically about cameras. 3D rendering is not only about producing realistic images by the mean of perspective projection. It is also about being able to deliver images similar to that of real-world cameras. Why? Because when CG images are combined with live-action footage, images delivered by the renderer need to match images delivered by the camera with which that footage was produced. In this lesson, we will develop a camera model that allows us to simulate results produced by real cameras (we will use with real-world parameters to set the camera). To do so, we will first start to review how film and photographic cameras work.</p>
<p>More specifically, we will show in this lesson how to implement a camera model similar to that used in Maya and most (if not all) 3D applications (such as Houdini, 3DS Max, Blender, etc.). We will show the effect each control that you can find on a camera has on the final image and how to simulate these controls in CG. This lesson will answer all questions you may have about CG cameras such as what the film aperture parameter does and how the focal length parameter relates to the angle of view parameter.</p>
<p>While the optical laws involved in the process of generating images with a real-world camera are simple, they can be hard to reproduce in CG, not because they are complex but because they are essentially and potentially expensive to simulate. Hopefully, though you don&rsquo;t need very complex cameras to produce images. It&rsquo;s quite the opposite. You can take photographs with a very simple imaging device called a <strong>pinhole camera</strong> which is just a box with a small hole on one side and photographic film lying on the other. Images produced by pinhole cameras are much easier to reproduce (and less costly) than those produced with more sophisticated cameras, and for this reason, the pinhole camera is the model used by most (if not all) 3D applications and video games. Let&rsquo;s start to review how these cameras work in the real world and build a mathematical model from there.</p>
<blockquote>
<details>
It is best to understand the pinhole camera model which is the most commonly used camera model in CG, before getting to the topic of the perspective projection matrix that reuses concepts we will be studying in this lesson such as the camera angle of view, the clipping planes, etc.
</details>
</blockquote>
<h3 id="camera-obscura-how-is-an-image-formed">Camera Obscura: How is an Image Formed?</h3>
<p>Most algorithms we use in computer graphics simulate how things work in the real world. This is particularly true of virtual cameras which are fundamental to the process of creating a computer graphics image. The creation of an image in a real camera is pretty simple to reproduce with a computer. It mainly relies on simulating the way light travels in space and interacts with objects including camera lenses. The light-matter interaction process is highly complex but the laws of optics are relatively simple and can easily be simulated in a computer program. There are two main parts to the principle of photography:</p>
<ul>
<li>The process by which an image is stored on film or in a file.</li>
<li>The process by which this image is created in the camera.</li>
</ul>
<p>In computer graphics, we don&rsquo;t need a physical support to store an image thus simulating the photochemical processes used in traditional film photography won&rsquo;t be necessary (unless like the Maxwell renderer, you want to provide a realistic camera model but this is not necessary to get a basic model working).</p>
<p><a href="#R-image-d740bdc9010304717774907193470543" class="lightbox-link"><img src="../assets/pinholeprinciple.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d740bdc9010304717774907193470543"><img src="../assets/pinholeprinciple.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 1:</strong> <em>The pinhole camera and camera obscura principle illustrated in 1925, in The Boy Scientist.</em></p>
<p><a href="#R-image-96bbf1a97542a71c5dc3259ebcb9bc8a" class="lightbox-link"><img src="../assets/cameraobscura.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-96bbf1a97542a71c5dc3259ebcb9bc8a"><img src="../assets/cameraobscura.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 2:</strong> <em>a camera obscura is a box with a hole on one side. Light passing through that hole forms an inverted image of the scene on the opposite side of the box.</em></p>
<p>Now let&rsquo;s talk about the second part of the photography process: how images are formed in the camera. The <strong>basic</strong> principle of the image creation process is very simple and shown in the reproduction of this illustration published in the early 20th century (Figure 1). In the setup from Figure 1, the first surface (in red) blocks light from reaching the second surface (in green). First, however, make a small hole (a pinhole). Light rays can then pass through the first surface at one point and, by doing so, form an (inverted) image of the candle on the other side (if you follow the path of the rays from the candle to the surface onto which the image of the candle is projected, you can see how the image is geometrically constructed). In reality, the image of the candle will be very hard to see because the amount of light emitted by the candle passing through point B is very small compared to the overall amount of light emitted by the candle itself (only a fraction of the light rays emitted by the flame or reflected off of the candle will pass through the hole).</p>
<p>A <a href="https://en.wikipedia.org/wiki/Camera_obscura" target="_blank">camera obscura</a> (which in Latin means dark room) works on the same principle. It is a lightproof box or room with a black interior (to prevent light reflections) and a tiny hole in the center on one end (Figure 2). Light passing through the hole forms an inverted image of the external scene on the opposite side of the box. This simple device led to the development of photographic cameras. You can perfectly convert your room into a camera obscura, as shown in this video from National Geographic (all rights reserved).</p>
<p><video src="assets/Making-Your-Own-Room-With-a-View.mp4" width="600" height="450" controls="" preload="auto"></video></p>
<p>To perceive the projected image on the wall your eyes first need to adjust to the darkness of the room, and to capture the effect on a camera, long exposure times are needed (from a few seconds to half a minute). To turn your camera obscura into a <strong>pinhole camera</strong> all you need to do is put a piece of film on the face opposite the pinhole. If you wait long enough (and keep the camera perfectly still), light will modify the chemicals on the film and a latent image will form over time. The principle for a digital camera is the same but the film is replaced by a sensor that converts light into electrical charges.</p>
<h3 id="how-does-real-camera-work">How Does Real Camera Work?</h3>
<p>In a real camera, images are created when light falls on a surface that is sensitive to light (note that this is also true for the eye). For a film camera, this is the surface of the film and for a digital camera, this is the surface of a sensor (or CCD). Some of these concepts have been explained in the lesson <a href="../../../../../lessons/3d-basic-rendering/introduction-to-ray-tracing/">Introduction to Ray-Tracing</a>, but we will explain them again here briefly.</p>
<p><a href="#R-image-32311667dab2fcb59d9375308f6b90da" class="lightbox-link"><img src="../assets/cameragen.gif" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-32311667dab2fcb59d9375308f6b90da"><img src="../assets/cameragen.gif" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 3:</strong> <em>in the real world, when the light from a light source reaches an object, it is reflected into the scene in many directions. However, only one ray goes in the direction of the camera and hits the film&rsquo;s surface or CCD.</em></p>
<p>In the real world, light comes from various light sources (the most important one being the sun). When light hits an object, it can either be absorbed or reflected into the scene. This phenomenon is explained in detail in the lesson devoted to light-matter interaction which you can find in the section Mathematics and Physics for Computer Graphics. When you take a picture, some of that reflected light (in the form of packets of photons) travels in the direction of the camera and passes through the pinhole to form a sharp image on the film or digital camera sensor. We have illustrated this process in Figure 3.</p>
<blockquote>
<details>
Many documents on how photographic film works can be found on the internet. Let's just mention that a film that is exposed to light doesn't generally directly create a visible image. It produces what we call a latent image (invisible to the eye) and we need to process the film with some chemicals in a darkroom to make it visible. If you remove the back door of a disposable camera and replace it with a translucent plastic sheet, you should be able to see the inverted image that is normally projected onto the film (as shown in the images below).
</details>
</blockquote>
<p><a href="#R-image-9927adfa4b73a6de8ab0d0e88ef69e8d" class="lightbox-link"><img src="../assets/realcamera.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-9927adfa4b73a6de8ab0d0e88ef69e8d"><img src="../assets/realcamera.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<h3 id="pinhole-cameras">Pinhole Cameras</h3>
<p>The simplest type of camera we can find in the real world is the pinhole camera. It is a simple lightproof box with a very small hole in the front which is also called an <strong>aperture</strong> and some light-sensitive film paper laid inside the box on the side facing this pinhole. When you want to take a picture, you simply open the aperture to expose the film to light (to prevent light from entering the box, you keep a piece of opaque tape on the pinhole which you remove to take the photograph and put back afterward).</p>
<p><a href="#R-image-6cee86928b0965c019fbe06556f8c141" class="lightbox-link"><img src="../assets/pinholecam.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-6cee86928b0965c019fbe06556f8c141"><img src="../assets/pinholecam.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 4:</strong> <em>principle of a pinhole camera. Light rays (which we have artificially colored to track their path better) converge at the aperture and form an inverted image of the scene at the back of the camera, on the film plane.</em></p>
<p>The principle of a pinhole camera is simple. Objects from the scene reflect light in all directions. The size of the aperture is so small that among the many rays that are reflected off at P, a point on the surface of an object in the scene, only one of these rays enter the camera (in reality it&rsquo;s never exactly one ray, but more a bundle of light rays or photons composing a very narrow beam of light). In Figure 3, we can see how one single light ray among the many reflected at P passes through the aperture. In Figure 4, we have colored six of these rays to track their path to the film plane more easily; notice one more time by following these rays how they form an image of the object rotated by 180 degrees. In geometry, the pinhole is also called the <strong>center of projection</strong>; all rays entering the camera converge to this point and diverge from it on the other side.</p>
<p>To summarize: light striking an object is reflected in random directions in the scene, but only one of these rays (or, more exactly, a bundle of these rays traveling along the same direction) enters the camera and strikes the film in one single point. <strong>To each point in the scene corresponds a single point on the film</strong>.</p>
<blockquote>
<details>
In the above explanation, we used the concept of point to describe what's happening locally at the surface of an object (and what's happening locally at the surface of the film); however, keep in mind that the surface of objects is continuous (at least at the macroscopic level) therefore the image of these objects on the surface of the film also appears as continuous.  
What we call a point for simplification, is a small area on the surface of an object or a small area on the surface of the film. It would be best to describe the process involved as an exchange of light energy between surfaces (the emitting surface of the object and the receiving surface or the film in our example), but for simplification, we will just treat these small surfaces as points for now.
</details>
</blockquote>
<p><a href="#R-image-4b1f72302739b6cf04a6cbe5ed8e0a04" class="lightbox-link"><img src="../assets/pinholeaperture1.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-4b1f72302739b6cf04a6cbe5ed8e0a04"><img src="../assets/pinholeaperture1.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 5:</strong> <em>top, when the pinhole is small only a small set of rays are entering the camera. Bottom, when the pinhole is much larger, the same point from an object, appears multiple times on the film plane. The resulting image is blurred.</em></p>
<p><a href="#R-image-4ceb2aa012fd0f8387454cf1d1e28a08" class="lightbox-link"><img src="../assets/cone.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-4ceb2aa012fd0f8387454cf1d1e28a08"><img src="../assets/cone.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 6:</strong> <em>in reality, light rays passing through the pinhole can be seen as forming a small cone of light. Its size depends on the diameter of the pinhole (top). When the cones are too large, the disk of light they project on the film surface overlap, which is the cause of blur in images.</em></p>
<p>The size of the aperture matters. To get a fairly sharp image each point (or small area) on the surface of an object needs to be represented as one single point (another small area) on the film. As mentioned before, what passes through the hole is never exactly one ray but more a small set of rays contained within a cone of directions. The angle of this cone (or more precisely its <a href="https://en.wikipedia.org/wiki/Angular_diameter" target="_blank">angular diameter</a>) depends on the size of the hole as shown in Figure 6.</p>
<p><a href="#R-image-31d0fccefc7609807504a28e3d6bb1ba" class="lightbox-link"><img src="../assets/blur.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-31d0fccefc7609807504a28e3d6bb1ba"><img src="../assets/blur.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 7:</strong> <em>the smaller the pinhole, the sharper the image. When the aperture is too large, the image is blurred.</em></p>
<p><a href="#R-image-c9c504ff4f98e90f34830bcec5913b63" class="lightbox-link"><img src="../assets/confusion.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c9c504ff4f98e90f34830bcec5913b63"><img src="../assets/confusion.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 8:</strong> <em>circles of confusion are much more visible when you photograph bright small objects such as fairy lights on a dark background.</em></p>
<p>The smaller the pinhole, the smaller the cone and the sharper the image. However, a smaller pinhole requires a longer exposure time because as the hole becomes smaller, the amount of light passing through the hole and striking the film surface decreases. It takes a certain amount of light for an image to form on the surface of a photographic paper; thus, the less light it receives, the longer the exposure time. It won&rsquo;t be a problem for a CG camera, but for real pinhole cameras, a longer exposure time increases the risk of producing a blurred image if the camera is not perfectly still or if objects from the scene move. As a general rule, the shorter the exposure time, the better. There is a limit, though, to the size of the pinhole. When it gets very small (when the hole size is about the same as the light&rsquo;s wavelength), light rays are diffracted, which is not good either. For a shoe-box-sized pinhole camera, a pinhole of about 2 mm in diameter should produce optimum results (a good compromise between image focus and exposure time). Note that when the aperture is too large (Figure 5 bottom), a single point on the image, if you keep using the concept of point or discrete lines to represent light rays (for example, point A or B in Figure 5), appears multiple times on the image. A more accurate way of visualizing what&rsquo;s happening in that particular case is to imagine the footprints of the cones overlapping each over on the film (Figure 6 bottom). As the size of the pinhole increases, the cones become larger, and the amount of overlap increases. The fact that a point appears multiple times in the image (in the form of the cone&rsquo;s footprint or spot becoming larger on the film, which you can see as the color of the object at the light ray&rsquo;s origin being spread out on the surface of the film over a larger region rather than appearing as a singular point as it theoretically should) is what causes an image to be blurred (or out of focus). This effect is much more visible in photography when you take a picture of very small and bright objects on a dark background, such as fairy lights at night (Figure 8). Because they are small and generally spaced away from each other, the disks they generate on the picture (when the camera hole is too large) are visible. In photography, these disks (which are not always perfectly circular but explaining why is outside the scope of this lesson) are called <strong>circles of confusion</strong> or disks of confusion, blur circles, blur spots, etc. (Figure 8).</p>
<p>To better understand the image formation process, we created two short animations showing light rays from two disks passing through the camera&rsquo;s pinhole. In the first animation (Figure 9), the pinhole is small, and the image of the disks is sharp because each point on the object corresponds to a single point on the film.</p>
<p><a href="#R-image-0e44e4f92d00b1fd791130aae0d2db7d" class="lightbox-link"><img src="../assets/pinhole1.gif" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-0e44e4f92d00b1fd791130aae0d2db7d"><img src="../assets/pinhole1.gif" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 9:</strong> <em>animation showing light rays passing through the pinhole and forming an image on the film plane. The image of the scene is inverted.</em></p>
<p>The second animation (Figure 10) shows what happens when the pinhole is too large. In this particular case, each point on the object corresponds to multiple points on the film. The result is a blurred image of the disks.</p>
<p><a href="#R-image-f0d8d87f3f42cd3273cc436675e39dbb" class="lightbox-link"><img src="../assets/pinhole2.gif" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f0d8d87f3f42cd3273cc436675e39dbb"><img src="../assets/pinhole2.gif" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 10:</strong> <em>when the aperture or pinhole is too larger, a point from the geometry appears in multiple places on the film plane, and the resulting image is blurred.</em></p>
<p>In conclusion, to produce a sharp image we need to make the aperture of the pinhole camera as small as possible to ensure that only a narrow beam of photons coming from one single direction enters the camera and hits the film or sensor in one single point (or a surface as small as possible). The <strong>ideal pinhole camera</strong> has an aperture so small that only a single light ray enters the camera for each point in the scene. Such a camera can&rsquo;t be built in the real world though for reasons we already explained (when the hole gets too small, light rays are diffracted) but it can in the virtual world of computers (in which light rays are not affected by diffraction). Note that a renderer using an ideal pinhole camera to produce images of 3D scenes outputs perfectly sharp images.</p>
<p><a href="#R-image-64b3c028d7e654a7d7133bc1087ffa10" class="lightbox-link"><img src="../assets/gnome-dof.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-64b3c028d7e654a7d7133bc1087ffa10"><img src="../assets/gnome-dof.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 11:</strong> <em>the lens of a camera causes the depth of field. Lenses can only focus objects at a given distance from the camera. Any objects whose distance to the camera is much smaller or greater than this distance will appear blurred in the image. Depth of field defines the distance between the nearest and the farthest object from the scene that appears &ldquo;reasonably&rdquo; sharp in the image. Pinhole cameras have an infinite depth of field, resulting in perfectly sharp images.</em></p>
<p>In photography, the term <strong>depth of field</strong> (or DOF) defines the distance between the nearest and the farthest object from the scene that appears &ldquo;reasonably&rdquo; sharp in the image. Pinhole cameras have an <strong>infinite depth of field</strong> (but lens cameras have a finite DOF). In other words, the sharpness of an object does not depend on its distance from the camera. Computer graphics images are most of the time produced using an ideal pinhole camera model, and similarly to real-world pinhole cameras, they have an infinite depth of field; all objects from the scene visible through the camera are rendered perfectly sharp. Computer-generated images have sometimes been criticized for being very clean and sharp; the use of this camera model has certainly a lot to do with it. Depth of field however can be simulated quite easily and a lesson from this section is devoted to this topic alone.</p>
<blockquote>
<details>
Very little light can pass through the aperture when the pinhole is very small, and long exposure times are required. It is a limitation if you wish to produce sharp images of moving objects or in low-light conditions. Of course, the bigger the aperture, the more light enters the camera; however, as explained before, this also produces blurred images. The solution is to place a lens in front of the aperture to focus the rays back into one point on the film plane, as shown in the adjacent figure. This lesson is only an introduction to pinhole cameras rather than a thorough explanation of how cameras work and the role of lenses in photography. More information on this topic can be found in the lesson from this section devoted to the topic of depth of field. However, as a note, and if you try to make the relation between how a pinhole camera and a modern camera works, it is important to know that lenses are used to make the aperture as large as possible, allowing more light to get in the camera and therefore reducing exposure times. The role of the lens is to cancel the blurry look of the image we would get if we were using a pinhole camera with a large aperture by refocusing light rays reflected off of the surface of objects to single points on the film. By combining the two, a large aperture and a lens, we get the best of both systems, shorter exposure times, and sharp images (however, the use of lenses introduces depth of field, but as we mentioned before, this won't be studied or explained in this lesson). The great thing about pinhole cameras, though, is that they don't require lenses and are, therefore, very simple to build and are also very simple to simulate in computer graphics.
<p><a href="#R-image-e54ab3d46cb79d8bed9919020dae3f43" class="lightbox-link"><img src="../assets/lens.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-e54ab3d46cb79d8bed9919020dae3f43"><img src="../assets/lens.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
</details>
</blockquote>
<h2 id="how-a-pinhole-camera-works-part-2">How a pinhole camera works (part 2)</h2>
<p>In the first chapter of this lesson, we presented the principle of a pinhole camera. In this chapter, we will show that the size of the photographic film on which the image is projected and the distance between the hole and the back side of the box also play an important role in how a camera delivers images. One possible use of CGI is combining CG images with live-action footage. Therefore, we need our virtual camera to deliver the same type of images as those delivered with a real camera so that images produced by both systems can be composited with each other seamlessly. In this chapter, we will again use the pinhole camera model to study the effect of changing the film size and the distance between the photographic paper and the hole on the image captured by the camera. In the following chapters, we will show how these different controls can be integrated into our virtual camera model.</p>
<h3 id="focal-length-angle-of-view-and-field-of-view">Focal Length, Angle Of View, and Field of View</h3>
<p><a href="#R-image-7f58a1ce198192d3090e92d820d654e9" class="lightbox-link"><img src="../assets/zoom.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7f58a1ce198192d3090e92d820d654e9"><img src="../assets/zoom.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 1:</strong> <em>the sphere projected on the image plane becomes bigger as the image plane moves away from the aperture (or smaller when the image plane gets closer to the aperture). This is equivalent to zooming in and out.</em></p>
<p><a href="#R-image-e41f59e175981b12ec2701e98f755d86" class="lightbox-link"><img src="../assets/focallength.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-e41f59e175981b12ec2701e98f755d86"><img src="../assets/focallength.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 2:</strong> the focal length is the distance from the hole where light enters the camera to the image plane.</p>
<p><a href="#R-image-1ad78e3b7e7a248afb8b073d07023671" class="lightbox-link"><img src="../assets/focallength2.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-1ad78e3b7e7a248afb8b073d07023671"><img src="../assets/focallength2.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 3:</strong> <em>focal length is one of the parameters that determines the value of the angle of view.</em></p>
<p>Similarly to real-world cameras, our camera model will need a mechanism to control how much of the scene we see from a given point of view. Let&rsquo;s get back to our pinhole camera. We will call the back face of the camera the face on which the image of the scene is projected, the <strong>image plane</strong>. Objects get smaller, and a larger portion of the scene is projected on this plane when you move it closer to the aperture: you <strong>zoom out</strong>. Moving the film plane away from the aperture has the opposite effect; a smaller portion of the scene is captured: you <strong>zoom in</strong> (as illustrated in Figure 1). This feature can be described or defined in two ways: distance from the film plane to the aperture (you can change this distance to adjust how much of the scene you see on film). This distance is generally referred to as the <strong>focal length</strong> or <strong>focal distance</strong> (Figure 2). Or you can also see this effect as varying the angle (making it larger or smaller) of the apex of a triangle defined by the aperture and the film edges (Figures 3 and 4). This angle is called the <strong>angle of view</strong> or <strong>field of view</strong> (or AOV and FOV, respectively).</p>
<p><a href="#R-image-dcdb8b7c966b36a0ddc27b24463ebcdf" class="lightbox-link"><img src="../assets/fov.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-dcdb8b7c966b36a0ddc27b24463ebcdf"><img src="../assets/fov.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 4:</strong> <em>the field of view can be defined as the angle of the triangle in the horizontal or vertical plane of the camera. The horizontal field of view varies with the width of the image plane, and the vertical field of view varies with the height of the image plane.</em></p>
<p><a href="#R-image-d48781f212231b4ab95b4e4d1681c30d" class="lightbox-link"><img src="../assets/angleofview.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d48781f212231b4ab95b4e4d1681c30d"><img src="../assets/angleofview.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 5:</strong> <em>we can use Pythagorean trigonometric identities to find AC if we know both</em> � <em>(which is half the angle of view) and AB (which is the distance from the eye to the canvas).</em></p>
<p>In 3D, the triangle defining how much we see of the scene can be expressed by connecting the aperture to the top and bottom edges of the film or to the left and right edges of the film. The first is the <strong>vertical field of view</strong>, and the second is the <strong>horizontal field of view</strong> (Figure 4). Of course, there&rsquo;s no convention here again; each rendering API uses its own. OpenGL, for example, uses a vertical FOV, while the RenderMan Interface and Maya use a horizontal FOV.</p>
<p>As you can see from Figure 3, there is a direct relation between the focal length and the angle of view. So if AB is the distance from the eye to the canvas (so far, we always assumed that this distance was equal to 1, but this won&rsquo;t always be the case, so we need to consider the generic case), AC is half the canvas size (either the width or the height of the canvas), and the angle (\theta) is half the angle of view. Because ABC is a right triangle, we can use <a href="https://en.wikipedia.org/wiki/Pythagorean_trigonometric_identity" target="_blank">Pythagorean trigonometric identities</a> to find AC if we know both (\theta) and AB:</p>

<span class="math align-center">$$
\begin{array}{l}
\tan(\theta) = \frac {BC}{AB} \\
BC = \tan(\theta) * AB \\
\text{Canvas Size } = 2 * \tan(\theta) * AB \\
\text{Canvas Size } = 2 * \tan(\theta) * \text{ Distance to Canvas }. 
\end{array}
$$</span><p>This is an important relationship because we now have a way of controlling the size of the objects in the camera&rsquo;s view by simply changing one parameter, the angle of view. As we just explained, changing the angle of view can change the extent of a given scene imaged by a camera, an effect more commonly referred to in photography as <strong>zooming in</strong> or <strong>out</strong>.</p>
<h3 id="film-size-matters-too">Film Size Matters Too</h3>
<p><a href="#R-image-91cb0f93f829891a86cc8f78bbded9c6" class="lightbox-link"><img src="../assets/filmsize3.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-91cb0f93f829891a86cc8f78bbded9c6"><img src="../assets/filmsize3.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 6:</strong> <em>a larger surface (in blue) captures a larger extent of the scene than a smaller surface (in red). A relation exists between the size of the film and the camera angle of view. The smaller the surface, the smaller the angle of view.</em></p>
<p><a href="#R-image-038777ac7ded432c4d806b4570cc62f9" class="lightbox-link"><img src="../assets/filmsize4.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-038777ac7ded432c4d806b4570cc62f9"><img src="../assets/filmsize4.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 7:</strong> <em>if you use different film sizes but your goal is to capture the same extent of a scene, you need to adjust the focal length (in this figure denoted by A and B).</em></p>
<p>You can see, in Figure 6, that how much of the scene we capture also depends on the film (or sensor) size. In photography, film size or image sensor size matters. A larger surface (in blue) captures a larger extent of the scene than a smaller surface (in red). Thus, a relation also exists between the size of the film and the camera angle of view. The smaller the surface, the smaller the angle of view (Figure 6b).</p>
<p>Be careful. Confusion is sometimes made between film size and image quality. There is a relation between the two, of course. The motivation behind developing large formats, whether in film or photography, was mostly image quality. The larger the film, the more details and the better the image quality. However, note that if you use films of different sizes but always want to capture the same extent of a scene, you will need to adjust the focal length accordingly (as shown in Figure 7). That is why a 35mm camera with a 50mm lens doesn&rsquo;t produce the same image as a <a href="https://en.wikipedia.org/wiki/Large_format" target="_blank">large format</a> camera with a 50mm lens (in which the film size is about at least three times larger than a 35mm film). The focal length in both cases is the same, but because the film size is different, the angular extent of the scene imaged by the large format camera will be bigger than that of the 35mm camera. It is very important to remember that the size of the surface capturing the image (whether in digital or film) also determines the angle of view (as well as the focal length).</p>
<blockquote>
<details>
The terms **film back** or **film gate** technically designate two things slightly different, but they both relate to film size, which is why the terms are used interchangeably. The first term relates to the film holder, a device generally placed at the back of the camera to hold the film. The second term designates a rectangular opening placed in front of the film. By changing the gate size, we can change the area of the 35 mm film exposed to light. This allows us to change the film format without changing the camera or the film. For example, CinemaScope and Widescreen are formats shot on 35mm 4-perf film with a film gate. Note that film gates are also used with digital film cameras. The film gate defines the film aspect ratio.
<p><a href="#R-image-8ef74bce2a5da56aa49dd0a031eeceaf" class="lightbox-link"><img src="../assets/filmgate.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-8ef74bce2a5da56aa49dd0a031eeceaf"><img src="../assets/filmgate.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>The 3D application Maya groups all these parameters in a Film Back section. For example, when you change the Film Gate parameter, which can be any predefined film format such as 35mm Academy (the most common format used in film) or any custom format, it will change the value of a parameter called Camera Aperture, which defines the horizontal and vertical dimension (in inch or mm) of the film. Under the Camera Aperture parameter, you can see the Film Aspect Ratio, which is the ratio between the &ldquo;physical&rdquo; width of the film and its height. See <a href="https://en.wikipedia.org/wiki/List_of_film_formats" target="_blank">list of film formats</a> for a table of available formats.</p>
<p><a href="#R-image-902b18360038ba1631118d514af66707" class="lightbox-link"><img src="../assets/mayacamera.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-902b18360038ba1631118d514af66707"><img src="../assets/mayacamera.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>At the end of this chapter, we will discuss the relationship between the film aspect ratio and the image aspect ratio.</p>
</details>
</blockquote>
<blockquote>
<p>It is important to remember that two parameters determine the angle of view: the focal length and the film size. The angle of view changes when you change either one of these parameters: the focal length or the film size.</p>
<ul>
<li>For a fixed film size, changing the focal length will change the angle of view. The longer the focal length, the narrower the angle of view.</li>
<li>For a fixed focal length, changing the film size will change the angle of view. The larger the film, the wider the angle of view.</li>
<li>If you wish to change the film size but keep the same angle of view, you will need to adjust the focal length accordingly.</li>
</ul>
</blockquote>
<p><a href="#R-image-bf135ccb5bac59621b8863105eb3d0e2" class="lightbox-link"><img src="../assets/filmformat.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-bf135ccb5bac59621b8863105eb3d0e2"><img src="../assets/filmformat.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 8:</strong> <em>70 mm (left) and 24x35 film (right).</em></p>
<p>Note that three parameters are inter-connected, the angle of view, the focal length, and the film size. With two parameters, we can always infer the third one. Knowing the focal length and the film size, you can calculate the angle of view. If you know the angle of view and the film size, you can calculate the focal length. The next chapter will provide the mathematical equations and code to calculate these values. Though in the end, note that we want the angle of view. If you don&rsquo;t want to bother with the code and the equations to calculate the angle of view from the film size and the focal length, you don&rsquo;t need to do so; you can directly provide your program with a value for the angle of view instead. However, in this lesson, our goal is to simulate a real physical camera. Thus, our model will effectively take into account both parameters.</p>
<blockquote>
<details>
The choice of a film format is generally a compromise between cost, the workability of the camera (the larger the film, the bigger the camera), and the image definition you need. The most common film format (known as the [135 camera film format](https://en.wikipedia.org/wiki/135_film)) used for still photography was (and still is) 36 mm (1.4 in) wide (this file format is better known for being 24 by 35 mm however the exact horizontal size of the image is 36 mm). The next larger size of film for still cameras is the medium format film which is larger than 35 mm (generally 6 by 7 cm), and the large format, which refers to any imaging format of 4 by 5 inches or larger. Film formats used in filmmaking also come in a large variety of sizes. Refrain from assuming though that because we now (mainly) use digital cameras, we should not be concerned by the size of the film anymore. Rather than the size of the film, it is the size of the sensor that we will be concerned about for digital cameras, and similarly to film, that size also defines the extent of the scene being captured. Not surprisingly, sensors you can find on high-end digital DLSR cameras (such as the Canon 1D or 5D) have the same size as the 135 film format: they are 36 mm wide and have a height of 24 mm (Figure 8).
</details>
</blockquote>
<h3 id="image-resolution-and-frame-aspect-ratio">Image Resolution and Frame Aspect Ratio</h3>
<p><strong>The size of a film (measured in inches or millimeters) is not to be confused with the number of pixels in a digital image</strong>. The film&rsquo;s size affects the angle of view, but the image resolution (as in the number of pixels in an image) doesn&rsquo;t. These two camera properties (how big is the image sensor and how many pixels fit on it) are independent of each other.</p>
<p><a href="#R-image-787a84dc8c8c609a4547fc31974999cd" class="lightbox-link"><img src="../assets/sensor.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-787a84dc8c8c609a4547fc31974999cd"><img src="../assets/sensor.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 9:</strong> <em>image sensor from a Leica camera. Its dimensions are 36 by 24 mm. Its resolution is 6000 by 4000 pixels.</em></p>
<p><a href="#R-image-599cf4abd0dae4046ac402feef90eac0" class="lightbox-link"><img src="../assets/imageaspectratio.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-599cf4abd0dae4046ac402feef90eac0"><img src="../assets/imageaspectratio.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 10:</strong> <em>some common image aspect ratios (the first two examples were common in the 1990s. Today, most cameras or display systems support 2K or 4K image resolutions).</em></p>
<p>In digital cameras, the film is replaced by a sensor. An image sensor is a device that captures light and converts it into an image. You can think of the sensor as the electronic equivalent of film. The image quality depends not only on the size of the sensor but also on how many millions of pixels fit on it. It is important to understand that the film size is equivalent to the sensor size and that it plays the same role in defining the angle of view (Figure 9). However, the number of pixels fitting on the sensor, which defines the image resolution, has no effect on the angle and is a concept purely specific to digital cameras. Pixel resolution (how many pixels fit on the sensor) only determines how good images look and nothing else.</p>
<p>The same concept applies to CG images. We can calculate the same image with different image resolutions. These images will look the same (assuming a constant ratio of width to height), but those rendered using higher resolutions will have more detail than those rendered at lower resolutions. The resolution of the frame is expressed in terms of pixels. We will use the terms <strong>width</strong> and <strong>height resolution</strong> to denote the number of pixels our digital image will have along the horizontal and vertical dimensions. The image itself can be seen as a gate (both the image and the film gate define a rectangle), and for this reason, it is referred to in Maya as the <strong>resolution gate</strong>. At the end of this chapter, we will study what happens when the resolution and film gate <strong>relative size</strong> don&rsquo;t match.</p>
<p>One particular value we can calculate from the image resolution is the <strong>image aspect ratio</strong>, called in CG the <strong>device aspect ratio</strong>. Image aspect ratio is measured as:</p>

<span class="math align-center">$$\text{Image (or Device) Aspect Ratio} = { width \over height }$$</span><p>When the width resolution is greater than the height resolution, the image aspect ratio is greater than 1 (and lower than 1 in the opposite case). This value is important in the real world as most films or display devices, such as computer screens or televisions, have standard aspect ratios. The most common aspect ratios are:</p>
<ul>
<li><strong>4:3</strong>. It was the aspect ratio of old television systems and computer monitors until about 2003; It is still often the default setting on digital cameras. While it seems like an old aspect ratio, this might be true for television screens and monitors, but this is not true for film. The 35mm film format has an aspect ratio of 4:3 (the dimension of one frame is 0.980x0.735 inches).</li>
<li><strong>5:3</strong> and <strong>1.85:1</strong>. These are two very common standard image ratios used in film.</li>
<li><strong>16:9</strong>. It is the standard image ratio used by high-definition television, monitors, and laptops today (with a resolution of 1920x1080).</li>
</ul>
<blockquote>
<details>
The RenderMan Interface specifications set the default image resolution to 640 by 480 pixels, giving a 4:3 Image aspect ratio.
</details>
</blockquote>
<h3 id="canvas-size-and-image-resolution-mind-the-aspect-ratio">Canvas Size and Image Resolution: Mind the Aspect Ratio!</h3>
<p>Digital images have a particularity that physical film doesn&rsquo;t have. The aspect ratio of the sensor or the aspect ratio of what we called the canvas in the previous lesson (the 2D surface on which the image of a 3D scene is drawn) can be different from the aspect ratio of the digital image. You might think: &ldquo;why would we ever want that anyway?&rdquo;. Generally, indeed, this is something other than what we want, and we are going to show why. And yet it happens more often than not. Film frames are often scanned with a gate different than the gate they were shot with, and this situation also arises when working with <a href="https://en.wikipedia.org/wiki/Anamorphic_format" target="_blank">anamorphic formats</a> (we will explain what anamorphic formats are later in this chapter).</p>
<p><a href="#R-image-1c922156729946d21940134fea0ffb90" class="lightbox-link"><img src="../assets/aspectratio.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-1c922156729946d21940134fea0ffb90"><img src="../assets/aspectratio.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 11:</strong> <em>if the image aspect ratio is different than the film size or film gate aspect ratio, the final image will be stretched in either x or y.</em></p>
<p>Before we consider the case of anamorphic format, let&rsquo;s first consider what happens when the canvas aspect ratio is different from the image or device aspect ratio. Let&rsquo;s take a simple example: what we called the canvas in the previous lesson is a square, and the image on the canvas is that of a circle. We will also assume that the coordinates of the lower-left and upper-right corners of the canvas are [-1,1] and [1,1], respectively. Recall that the process for converting pixel coordinates from screen space to raster space consists of first converting the pixel coordinates from screen space to NDC space and then NDC space to raster space. In this process, the NDC space is the space in which the canvas is remapped to a unit square. From there, this unit square is remapped to the final raster image space. Remapping our canvas from the range [-1,1] to the range [0,1] in x and y is simple enough. Note that both the canvas and the NDC &ldquo;screen&rdquo; are square (their aspect ratio is 1:1). Because the &ldquo;image aspect ratio&rdquo; is preserved in the conversion, the image is not stretched in either x or y (it&rsquo;s only squeezed down within a smaller &ldquo;surface&rdquo;). In other words, visually, it means that if we were to look at the image in NDC space, our circle would still look like a circle. Let&rsquo;s imagine now that the final image resolution in pixels is 640x480. What happens now? The image, which originally had a 1:1 aspect ratio in screen space, is now remapped to a raster image with a 4:3 ratio. Our circle will be stretched along the x-axis, looking more like an oval than a circle (as depicted in Figure 11). <strong>Not preserving the canvas aspect ratio and the raster image aspect ratio leads to stretching the image in either x or y</strong>. It doesn&rsquo;t matter if the NDC space aspect ratio is different from the screen and raster image aspect ratio. You can very well remap a rectangle to a square and then a square back to a rectangle. All that matters is that both rectangles have the same aspect ratio (obviously, stretching is something we want only if the effect is desired, as in the case of anamorphic format).</p>
<p>You may think again, &ldquo;why would that ever happen anyway?&rdquo;. Generally, it doesn&rsquo;t happen because, as we will see in the next chapter, the canvas aspect ratio is often directly computed from the image aspect ratio. Thus if your image resolution is 640x480, we will set the canvas aspect ratio to 4:3.</p>
<p><a href="#R-image-e53f70ee248d2a0d887d3d26cb206713" class="lightbox-link"><img src="../assets/filmgate3.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-e53f70ee248d2a0d887d3d26cb206713"><img src="../assets/filmgate3.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 12:</strong> <em>when the resolution and film gates are different (top), you need to choose between two possible options. You can either fit the resolution gate within the film gate (middle) or the film gate within the resolution gate (bottom). Note that the renders look different.</em></p>
<p>However, you may calculate the canvas aspect ratio from the film size (called Film Aperture in Maya) rather than the image size and render the image with a resolution whose aspect ratio is different than that of the canvas. For example, the dimension of a 35mm film format (also known as academy) is 22mm in width and 16mm in height (these numbers are generally given in inches), and the ratio of this format is 1.375. However, a standard 2K scan of a full 35 mm film frame is 2048x1556 pixels, giving a device aspect ratio of 1.31. Thus, the canvas and the device aspect ratios are not the same in this case! What happens, then? Software like Maya offers different user strategies to solve this problem. No matter what, Maya will force at render time your canvas ratio to be the same as your device aspect ratio; however, this can be done in several ways:</p>
<ul>
<li>You can either force the resolution gate within the film gate. This is known as the <strong>Fill</strong> mode in Maya.</li>
<li>Or you can force the film gate within the resolution gate. This is known as the <strong>Overscan</strong> mode in Maya.</li>
</ul>
<p>Both modes are illustrated in Figure 12. Note that if the resolution gate and the film gate are the same, switching between those modes has no effect. However, when they are different, objects in the overscan mode appear smaller than in the fill mode. We will implement this feature in our program (see the last two chapters of this lesson for more detail).</p>
<p><a href="#R-image-903833e18193d5e7ed3788740ce905ec" class="lightbox-link"><img src="../assets/filmgate2.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-903833e18193d5e7ed3788740ce905ec"><img src="../assets/filmgate2.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<blockquote>
<details>
What do we do in film production? The Kodak standard for scanning a frame from a 35mm film in 2K is 2048x1556, The resulting 1.31 aspect ratio is slightly lower than the actual film aspect ratio of a full aperture 35mm film, which is 1.33 (the dimension of the frame is 0.980x0.735 inches). This means that we scan slightly more of the film than what's strictly necessary for height (as shown in the adjacent image). Thus, if you set your camera aperture to "35mm Full Aperture", but render your CG renders at resolution 2048x1556 to match the resolution of your 2K scans, the resolution and film aspect ratio won't match. In this case, because the actual film gate fits within the resolution gate during the scanning process, you need to select the "Overscan" mode to render your CG images. This means you will render slightly more than you need at the frame's top and bottom. Once your CG images are rendered, you will be able to composite them to your 2K scan. But you will need to crop your composited images to 2048x1536 to get back to a 1.33 aspect ratio if required (to match the 35mm Full Aperture ratio). Another solution is scanning your 2K images to exactly 2048x1536 (1.33 aspect ratio), another common choice. That way, both the film gate and the resolution gate match.
</details>
</blockquote>
<blockquote>
<details>
The only exception to keeping the canvas and the image aspect ratio the same is when you work with **anamorphic formats**. The concept is simple. Traditional 35mm film cameras have a 1.375:1 gate ratio. To shoot with a widescreen ratio, you need to put a gate in front of the film (as shown in the adjacent image). What it means, though, is that part of the film is wasted. However, you can use a special lens called an anamorphic lens, which will compress the image horizontally so that it fits within as much of the 1.375:1 gate ratio as possible. When the film is projected, another lens stretches images back to their original proportions. The main benefit of shooting anamorphic is the increased resolution (since the image uses a larger portion of the film). Typically anamorphic lenses squeeze the image by a factor of two. For instance, Star Wars (1977) was filmed in a 2.35:1 ratio using an anamorphic camera lens. If you were to composite CG renders into Star Wars footage, you would need to set the resolution gate aspect ratio to ~4:3 (the lens squeezes the image by a factor of 2; if the image ratio is 2:35, then the film ratio is closer to 1.175), and the "film" aspect ratio (the canvas aspect ratio) to 2.35:1. In CG this is typically done by changing what we call the pixel aspect ratio. In Maya, there is also a parameter in the camera controls called Lens Squeeze Ratio, which has the same effect. But this is left to another lesson.
<p><a href="#R-image-82cb46435d4635612f4628d8eca64d22" class="lightbox-link"><img src="../assets/anamorphic.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-82cb46435d4635612f4628d8eca64d22"><img src="../assets/anamorphic.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
</details>
</blockquote>
<h3 id="conclusion-and-summary-everything-you-need-to-know-about-cameras">Conclusion and Summary: Everything You Need to Know about Cameras</h3>
<p>What is important to remember from the last chapter is that all that matters at the end is the camera&rsquo;s angle of view. You can set its value directly to get the visual result you want.</p>
<blockquote>
<p>I want to combine real film footage with CG elements. The real footage is shot and loaded into Maya as an image plane. Now I want to set up the camera (manually) and create some rough 3D surroundings. I noted down a couple of camera parameters during the shooting and tried to feed them into Maya, but it didn&rsquo;t work out. For example, if I enter the focal length, the resulting view field is too big. I need to familiarize myself with the relationship between focal length, film gate, field of view, etc. How do you tune a camera in Maya to match a real camera? How should I tune a camera to match these settings?</p>
</blockquote>
<p>However, Suppose you wish to build a camera model to simulate physical cameras (the goal of the person we quoted above). In that case, you will need to compute the angle of view by considering the focal length and the film gate size. Many applications, such as Maya, expose these controls (the image below is a screenshot of Maya&rsquo;s UI showing the Render Settings and the Camera attributes). You now understand exactly why they are there, what they do and how to set their value to match the result produced by a real camera. If your goal is to combine CG images with live-action footage, you will need to know the following:</p>
<ul>
<li>
<p>The film gate size. This information is generally given in inches or mm. This information is always available in camera specifications.</p>
</li>
<li>
<p>The focal length. Remember that the angle of view depends on film size for a given focal length. In other words, if you set the focal length to a given value but change the film aperture, the object size will change in the camera&rsquo;s view.</p>
</li>
</ul>
<p><a href="#R-image-bc903e5998732750bdaaa43ec7a5d868" class="lightbox-link"><img src="../assets/mayacamcontrols.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-bc903e5998732750bdaaa43ec7a5d868"><img src="../assets/mayacamcontrols.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>However, remember that the resolution gate ratio may differ from the film gate ratio, which you only want if you work with anamorphic formats. For example, suppose the resolution gate ratio of your scan is smaller than the film gate ratio. In that case, you will need to set the Fit Resolution Gate parameter to Overscan as with the example of 2K scans of 35mm full aperture film, whose ratio (1.316:1) is smaller than the actual frame ratio (1.375:1). You need to pay a great deal of attention to this detail if you want CG renders to match the footage.</p>
<p>Finally, the only time when the &ldquo;film gate ratio&rdquo; can be different from the &ldquo;resolution gate ratio&rdquo; is when you work with anamorphic formats (which is quite rare, though).</p>
<h3 id="whats-next">What&rsquo;s Next?</h3>
<p>We are now ready to develop a virtual camera model capable of producing images that match the output of real-world pinhole cameras. In the next chapter, we will show that the angle of view is the only thing we need if we use ray tracing. However, if we use the rasterization algorithm, we must compute the angle of view and the canvas size. We will explain why we need these values in the next chapter and how we can compute them in chapter four.</p>
<h2 id="a-virtual-pinhole-camera-model">A Virtual Pinhole Camera Model</h2>
<p>Our next step is to develop a virtual camera working on the same principle as a pinhole camera. More precisely, our goal is to create a camera model delivering images similar to those produced by a real pinhole camera. For example, if we take a picture of a given object with a pinhole camera, then when a 3D replica of that object is rendered with our virtual camera, the size and shape of the object in the CG render must match exactly the size and shape of the real object in the photograph. But before we start looking into the model itself, it is important to learn a few more things about computer graphics camera models.</p>
<p>First, the details:</p>
<ul>
<li>CG cameras have a near and far clipping plane. Objects closer than the near-clipping plane or farther than the far-clipping plane are invisible to the camera. This lets us can exclude some of a scene&rsquo;s geometry and render only certain portions of the scene. This is necessary for rasterization to work.</li>
<li>In this chapter, we will also see why in CG, the image plane is positioned in front of the camera&rsquo;s aperture rather than behind, as with real pinhole cameras. This plays an important role in how cameras are conventionally defined in CG.</li>
<li>Finally, we must look into how we can render a scene from any given viewpoint. We discussed this in the previous lesson, but this chapter will briefly cover this point.</li>
</ul>
<p>The important question we haven&rsquo;t looked into yet (asked and answered) is, &ldquo;studying real cameras to understand how they work is great, but how is the camera model being used to produce images?&rdquo;. We will show in this chapter that the answer to this question depends on whether we use the rasterization or ray-tracing rendering technique.</p>
<p>In this chapter, we will first review the points listed above one by one to give a complete &ldquo;picture&rdquo; of how cameras work in CG. Then, the virtual camera model will be introduced and implemented in a program in this lesson&rsquo;s next (and final) chapter.</p>
<h3 id="how-do-we-represent-cameras-in-the-cg-world">How Do We Represent Cameras in the CG World?</h3>
<p>Photographs produced by real-world pinhole cameras are upside down. This is happening because, as explained in the first chapter, the film plane is located behind the center of the projection. However, this can be avoided if the projection plane lies on the same side as the scene, as shown in Figure 1. In the real world, the image plane can&rsquo;t be located in front of the aperture because it will not be possible to isolate it from unwanted light, but in the virtual world of computers, constructing our camera that way is not a problem. Conceptually, by construction, this leads to seeing the hole of the camera (which is also the center of projection) as the actual position of the eye, and the image plane, the image that the eye is looking at.</p>
<p><a href="#R-image-3cc2ac11c9046008a2c3f27e0819bf9f" class="lightbox-link"><img src="../assets/pinholecam1.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-3cc2ac11c9046008a2c3f27e0819bf9f"><img src="../assets/pinholecam1.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 1:</strong> <em>for our virtual camera, we can move the image plane in front of the aperture. That way, the projected image of the scene on the image plane is not inverted.</em></p>
<p>Defining our virtual camera that way shows us more clearly how constructing an image by following light rays from wherever point in the scene they are emitted from to the eye turns out to be a simple geometrical problem which was given the name of (as you know it now) <strong>perspective projection</strong>. Perspective projection is a method for building an image through this apparatus, a sort of pyramid whose apex is aligned with the eye, whose base defines the surface of a canvas on which the image of the 3D scene is &ldquo;projected&rdquo; onto.</p>
<h3 id="near-and-far-clipping-planes-and-the-viewing-frustum">Near and Far Clipping Planes and the Viewing Frustum</h3>
<p>The <strong>near</strong> and <strong>far clipping</strong> planes are virtual planes located in front of the camera and parallel to the image plane (the plane in which the image is contained). The location of each clipping plane is measured along the camera&rsquo;s line of sight (the camera&rsquo;s local z-axis). They are used in most virtual camera models and have no equivalent in the real world. Objects closer than the near-clipping plane or farther than the far-clipping plane are invisible to the camera. Scanline renderers using the z-buffer algorithm, such as OpenGL, need these clipping planes to control the range of depth values over which the objects&rsquo; depth coordinates are remapped when points from the scene are projected onto the image plane (and this is their primary if only function). Adjusting the near and far clipping planes without getting into too many details can also help resolve precision issues with this type of renderer. The next lesson will find more information on this problem known as z-fighting. In ray tracing, clipping planes are not required by the algorithm to work and are generally not used.</p>
<p><a href="#R-image-58bffe3546647d9f789add5e3a3b54a0" class="lightbox-link"><img src="../assets/frustum.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-58bffe3546647d9f789add5e3a3b54a0"><img src="../assets/frustum.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 2:</strong> <em>any object contained within the viewing frustum is visible.</em></p>
<h3 id="the-near-clipping-plane-and-the-image-plane">The Near Clipping Plane and the Image Plane</h3>
<p><a href="#R-image-a66ec43fcd50a0ed75daa666ec79d03a" class="lightbox-link"><img src="../assets/clippingplanescanvas1.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a66ec43fcd50a0ed75daa666ec79d03a"><img src="../assets/clippingplanescanvas1.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 3:</strong> <em>the canvas can be positioned anywhere along the local camera z-axis. Note that its size varies with position.</em></p>
<p><a href="#R-image-3e0247eb95514cf705b8e05f41927947" class="lightbox-link"><img src="../assets/canvascoordinates5.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-3e0247eb95514cf705b8e05f41927947"><img src="../assets/canvascoordinates5.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 4:</strong> <em>The canvas is positioned at the near-clipping plane in this example. The bottom-left and top-right coordinates of the canvas are used to determine whether a point projected on the canvas is visible to the camera.</em></p>
<p>The canvas (also called screen in other CG books) is the 2D surface (a bounded region of the image plane) onto which the scene&rsquo;s image is projected. In the previous lesson, we placed the canvas 1 unit away from the eye by convention. However, the position of the canvas along the camera&rsquo;s local z-axis doesn&rsquo;t matter. We only made that choice because it simplified the equations for computing the point&rsquo;s projected coordinates, but, as you can see in Figure 3, the projection of the geometry onto the canvas produces the same image regardless of its position. Thus you are not required to keep the distance from the eye to the canvas equal to 1. We also know that the viewing frustum is a truncated pyramid (the pyramid&rsquo;s base is defined by the far clipping plane, and the top is cut off by the near clipping plane). This volume defines the part of the scene that is visible to the camera. A common way of projecting points onto the canvas in CG is to remap points within the volume defined by the viewing frustum to the <strong>unit cube</strong> (a cube of side length 1). This technique is central to developing the perspective projection matrix, which is the topic of our next lesson. Therefore, we don&rsquo;t need to understand it for now. What is interesting to know about the perspective projection matrix in the context of this lesson, though, is that it works because the image plane is located near the clipping plane. We won&rsquo;t be using the matrix in this lesson nor studying it; however, in anticipation of the next lesson devoted to this topic, we will place the canvas at the near-clipping plane. Remember that this is an arbitrary decision and that unless you use a special technique, such as the perspective projection matrix that requires the canvas to be positioned at a specific location, it can be positioned anywhere along the camera&rsquo;s local z-axis.</p>
<p>From now on, and for the rest of this lesson, we will assume that the canvas (or screen or image plane) is positioned at the near-clipping plane. Remember that this is just an arbitrary decision and that the equations we will develop in the next chapter to project points onto the canvas work independently from its position along the camera&rsquo;s line of sight (which is also the camera z-axis). This setup is illustrated in Figure 4.</p>
<p>Remember that the distance between the eye and the canvas, the near-clipping plane, and the focal length are also different things. We will focus on this point more fully in the next chapter.</p>
<h3 id="computing-the-canvas-size-and-the-canvas-coordinates">Computing the Canvas Size and the Canvas Coordinates</h3>
<p><a href="#R-image-c346217dd4d79644ed62becf58ecc551" class="lightbox-link"><img src="../assets/clippingplanes2.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c346217dd4d79644ed62becf58ecc551"><img src="../assets/clippingplanes2.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 5:</strong> <em>side view of our camera setup. Objects closer than the near-clipping plane or farther than the far-clipping plane are invisible to the camera. The distance from the eye to the canvas is defined as the near-clipping plane. The canvas size depends on this distance (Znear) and the angle of view. A point is only visible to the camera if the projected point&rsquo;s x and y coordinates are contained within the canvas boundaries (in this example, P1 is visible because P1&rsquo; is contained within the limits of the canvas, while P2 is invisible).</em></p>
<p><a href="#R-image-6c3cbfe192aeb8ceefdad6b22b9dcc3e" class="lightbox-link"><img src="../assets/clippingplanes1.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-6c3cbfe192aeb8ceefdad6b22b9dcc3e"><img src="../assets/clippingplanes1.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 6:</strong> <em>a point is only visible to the camera if the projected point x- and y-coordinates are contained within the canvas boundaries (in this example P1 is visible because P1&rsquo; is contained within the limits of the canvas, while P2 is invisible).</em></p>
<p><a href="#R-image-746a37da51374138ed58f3f4fdf15496" class="lightbox-link"><img src="../assets/canvascoordinates6.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-746a37da51374138ed58f3f4fdf15496"><img src="../assets/canvascoordinates6.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 7:</strong> <em>the canvas coordinates are used to determine whether a point lying on the image plane is visible to the camera.</em></p>
<p>We insisted a lot in the previous section on the fact that the canvas could be anywhere along the camera&rsquo;s local z-axis because that position affects the canvas size. When the distance between the eye and the canvas decreases, the canvas gets smaller, and when that distance increases, it gets bigger. The bottom-left and top-right coordinates of the canvas are directly linked to the canvas size. Once we know the size, computing these coordinates is trivial, considering that the canvas (or screen) is centered on the origin of the image plane coordinate system. Why are these coordinates important? Because they can be used to easily check whether a point projected on the image plane lies within the canvas and is, therefore, visible to the camera. Two points are projected onto the canvas in figures 5, 6, and 7. One of them (P1&rsquo;) is within the canvas limits and visible to the camera. The other (P2&rsquo;) is outside the boundaries and is thus invisible. When we both know the canvas coordinates and the projected coordinates, testing if the point is visible is simple.</p>
<p>Let&rsquo;s see how we can mathematically compute these coordinates. In the second chapter of this lesson, we gave the equation to compute the canvas size (we will assume that the canvas is a square for now, as in figures 3, 4, and 6):</p>

<span class="math align-center">$$\text{Canvas Size} = 2 * \tan({\theta \over 2}) * \text{Distance to Canvas}$$</span><p><strong>Where (\theta) is the angle of view</strong> (hence the division by 2). Note that the vertical and horizontal angles of view are the same when the canvas is a square. Since the distance from the eye to the canvas is defined as the near clipping plane, we can write:</p>

<span class="math align-center">$$\text{Canvas Size} = 2 * \tan({\theta \over 2}) * Z_{near}.$$</span><p>Where (Z_{near}) is the distance between the eye and the near-clipping plane along the camera&rsquo;s local z-axis (Figure 5), since the canvas is centered on the image plane coordinate system&rsquo;s origin, computing the canvas&rsquo;s corner coordinates is trivial. But first, we need to divide the canvas size by 2 and set the sign of the coordinate based on the corner&rsquo;s position relative to the coordinate system&rsquo;s origin:</p>

<span class="math align-center">$$
\begin{array}{l}
\text{top} &=&&\dfrac{\text {canvas size}}{2}\\
\text{right} &=&&\dfrac{\text {canvas size}}{2}\\
\text{bottom} &=&-&\dfrac{\text {canvas size}}{2}\\
\text{left} &=&-&\dfrac{\text {canvas size}}{2}\\
\end{array}
$$</span><p>Once we know the canvas bottom-left and top-right canvas coordinates, we can then compare the projected point coordinates with these values (we, of course, first need to compute the coordinates of the point onto the image plane, which is positioned at the near clipping plane. We will learn how to do so in the next chapter). Points lie within the canvas boundary (and are therefore visible) if their x and y coordinates are either greater or equal and lower or equal than the canvas bottom-left and top-right canvas coordinates, respectively. The following code fragment computes the canvas coordinates and tests the coordinates of a point lying on the image plane against these coordinates:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">float</span> <span class="n">canvasSize</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">tan</span><span class="p">(</span><span class="n">angleOfView</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">Znear</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="kt">float</span> <span class="n">top</span> <span class="o">=</span> <span class="n">canvasSize</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="kt">float</span> <span class="n">bottom</span> <span class="o">=</span> <span class="o">-</span><span class="n">top</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="kt">float</span> <span class="n">right</span> <span class="o">=</span> <span class="n">canvasSize</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="kt">float</span> <span class="n">left</span> <span class="o">=</span> <span class="o">-</span><span class="n">right</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="c1">// compute projected point coordinates
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1"></span><span class="n">Vec3f</span> <span class="n">Pproj</span> <span class="o">=</span> <span class="p">...;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">Pproj</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">left</span> <span class="o">||</span> <span class="n">Pproj</span><span class="p">.</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">right</span> <span class="o">||</span> <span class="n">Pproj</span><span class="p">.</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">bottom</span> <span class="o">||</span> <span class="n">Pproj</span><span class="p">.</span><span class="n">y</span> <span class="o">&gt;</span> <span class="n">top</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="c1">// point outside canvas boundaries. It is not visible.
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="c1">// point inside canvas boundaries. Point is visible
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></div><h3 id="camera-to-world-and-world-to-camera-matrix">Camera to World and World to Camera Matrix</h3>
<p><a href="#R-image-fb36c5152dfeab22d31b945a749c57a3" class="lightbox-link"><img src="../assets/camera2.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-fb36c5152dfeab22d31b945a749c57a3"><img src="../assets/camera2.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 8:</strong> <em>transforming the camera coordinate system with the camera-to-word transformation matrix.</em></p>
<p>Finally, we need a method to produce images of objects or scenes from any viewpoint. We discussed this topic in the previous lesson, but we will cover it briefly in this chapter. CG cameras are similar to real cameras in that respect. However, in CG, we look at the camera&rsquo;s view (the equivalent of a real camera viewfinder) and move around the scene or object to select a viewpoint (&ldquo;viewpoint&rdquo; is the camera position in relation to the subject).</p>
<p>When a camera is created, by default, it is located at the origin and oriented along the negative z-axis (Figure 8). This orientation is explained in detail in the <a href="../../../../../lessons/3d-basic-rendering/computing-pixel-coordinates-of-3d-point/mathematics-computing-2d-coordinates-of-3d-points">previous lesson</a>. By doing so, the camera&rsquo;s local and world coordinate system&rsquo;s x-axis point in the same direction. Therefore, defining the camera&rsquo;s transformations with a 4x4 matrix is convenient. This 4x4 matrix which is no different from 4x4 matrices used to transform 3D objects, is called the <strong>camera-to-world</strong> transformation matrix (because it defines the camera&rsquo;s transformations with respect to the world coordinate system).</p>
<p>The camera-to-world transformation matrix is used differently depending on whether rasterization or ray tracing is being used:</p>
<ul>
<li>In rasterization, the inverse of the matrix (the world-to-camera 4x4 matrix) is used to convert points defined in world space to camera space. Once in camera space, we can perform a perspective divide to compute the projected point coordinates in the image plane. An in-depth description of this process can be found in the previous lesson.</li>
<li>In ray tracing, we build camera rays in the camera&rsquo;s default position (the rays&rsquo; origin and direction) and then transform them with the camera-to-world matrix. The full process is detailed in the &ldquo;Ray-Tracing: Generating Camera Rays&rdquo; lesson.</li>
</ul>
<p>Don&rsquo;t worry if you still need to understand how ray tracing works. We will study rasterization first and then move on to ray tracing next.</p>
<h3 id="understanding-how-virtual-cameras-are-used">Understanding How Virtual Cameras Are Used</h3>
<p>At this point of the lesson, we have explained almost everything there is to know about pinhole cameras and CG cameras. However, we still need to explain how images are formed with these cameras. The process depends on whether the rendering technique is rasterization or ray tracing. We are now going to consider each case individually.</p>
<p><a href="#R-image-d66055f8e485059f6e39238212537b3c" class="lightbox-link"><img src="../assets/pinholecam3.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d66055f8e485059f6e39238212537b3c"><img src="../assets/pinholecam3.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 9:</strong> <em>in the real world, when the light from a light source reaches an object, it is reflected into the scene in many directions. Only one ray goes in the camera&rsquo;s direction and strikes the film or sensor.</em></p>
<p><a href="#R-image-e2b6a63461ea3ff7ef67bb24291bce15" class="lightbox-link"><img src="../assets/pinholecam2.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-e2b6a63461ea3ff7ef67bb24291bce15"><img src="../assets/pinholecam2.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 10:</strong> <em>each ray reflected off of the surface of an object and passing through the aperture, strikes a pixel.</em></p>
<p>Before we do so, let&rsquo;s briefly recall the principle of a pinhole camera again. When light rays emitted by a light source intersect objects from the scene, they are reflected off of the surface of these objects in random directions. For each point of the scene visible by the camera, only one of these reflected rays will pass through the aperture of the pinhole camera and strike the surface of the photographic paper (or film or sensor) in one unique location. If we divide the film&rsquo;s surface into a regular grid of pixels, what we get is a <strong>digital pinhole camera</strong>, which is essentially what we want our virtual camera to be (Figures 9 and 10).</p>
<p>This is how things work with a real pinhole camera. But how does it work in CG? In CG, cameras are built on the principle of a pinhole camera, but the image plane is in front of the center of projection (the aperture, which in our virtual camera model we prefer to call the eye), as shown in Figure 11. How the image is produced with this virtual pinhole camera model depends on the rendering technique. First, let&rsquo;s consider the two main visibility algorithms: rasterization and ray tracing.</p>
<h4 id="rasterization">Rasterization</h4>
<p><a href="#R-image-79cfa7e8fc2d56c2770bd6393eac292a" class="lightbox-link"><img src="../assets/pinholecam4.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-79cfa7e8fc2d56c2770bd6393eac292a"><img src="../assets/pinholecam4.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 11:</strong> <em>perspective projection of 3D points onto the image plane.</em></p>
<p><a href="#R-image-a0de2e67c360aa4f521a7f052d043190" class="lightbox-link"><img src="../assets/pinholecam5.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a0de2e67c360aa4f521a7f052d043190"><img src="../assets/pinholecam5.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 12:</strong> <em>perspective projection of a 3D point onto the image plane.</em></p>
<p>We will have to explain how the rasterization algorithm works in this chapter. To have a complete overview of the algorithm, you are invited to read the lesson devoted to the REYES algorithm, a popular rasterization algorithm. Next, we will examine how the pinhole camera model is used with this particular rendering technique. To do so, let&rsquo;s recall that each ray passing through the aperture of a pinhole camera strikes the film&rsquo;s surface in one location, which is eventually a pixel if we consider the case of digital images.</p>
<p>Let&rsquo;s take the case of one particular ray, R, reflected off of the surface of an object at O, traveling towards the eye in the direction D, passing through the aperture of the camera in A, and striking the image at the pixel location X (Figure 12). To simulate this process, all we need to do is compute in which pixel of an image any given light ray strikes the image and record the color of this light ray (the color of the object at the point where the ray was emitted from, which in the real world, is essentially the information carried by the light ray itself) at that pixel location in the image.</p>
<p>This is the same as calculating the pixel coordinates X of the 3D point O using perspective projection. In perspective projection, the position of a 3D point onto the image plane is found by computing the intersection of a line connecting the point to the eye with the image plane. The method for computing this point of intersection was described in detail in the <a href="../../../../../lessons/3d-basic-rendering/computing-pixel-coordinates-of-3d-point/mathematics-computing-2d-coordinates-of-3d-points">previous lesson</a>. In the next chapter; we will learn how to compute these coordinates when the canvas is positioned at an arbitrary distance from the eye (in the previous lesson, the distance between the eye and the canvas was always assumed to be equal to 1).</p>
<p>Don&rsquo;t worry too much if you need help understanding clearly how rasterization works at this point. As mentioned before, a lesson is devoted to this topic alone. The only thing you need to remember from that lesson is how we can &ldquo;project&rdquo; 3D points onto the image plane and compute the projected point pixel coordinates. Remember that this is the method that we will be using with rasterization. The projection process can be seen as an interpretation of the way an image is formed inside a pinhole camera by &ldquo;following&rdquo; the path of light rays from whether points they are emitted from in the scene to the eye and &ldquo;recording&rdquo; the position (in terms of pixel coordinates) where these light rays intersect the image plane. To do so, we first need to transform points from world space to camera space, perform a perspective divide on the points in camera space to compute their coordinates in screen space, then convert the points&rsquo; coordinates in screen space to NDC space, and finally convert these coordinates from NDC space to raster space. We used this method in the previous lesson to produce a wireframe image of a 3D object.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="n">each</span> <span class="n">point</span> <span class="n">in</span> <span class="n">the</span> <span class="n">scene</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    <span class="n">transform</span> <span class="n">a</span> <span class="n">point</span> <span class="n">from</span> <span class="n">world</span> <span class="n">space</span> <span class="n">to</span> <span class="n">camera</span> <span class="n">space</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="n">perform</span> <span class="n">perspective</span> <span class="nf">divide</span> <span class="p">(</span><span class="n">x</span><span class="o">/-</span><span class="n">z</span><span class="p">,</span> <span class="n">y</span><span class="o">/-</span><span class="n">z</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">point</span> <span class="n">lies</span> <span class="n">within</span> <span class="n">canvas</span> <span class="n">boundaries</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">        <span class="n">convert</span> <span class="n">coordinates</span> <span class="n">to</span> <span class="n">NDC</span> <span class="n">space</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">        <span class="n">convert</span> <span class="n">coordinates</span> <span class="n">from</span> <span class="n">NDC</span> <span class="n">to</span> <span class="n">raster</span> <span class="n">space</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">        <span class="n">record</span> <span class="n">point</span> <span class="n">in</span> <span class="n">the</span> <span class="n">image</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1">// connect projected points to recreate the object&#39;s edges
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="c1"></span><span class="p">...</span></span></span></code></pre></div><p>In this technique, the image is formed by a collection of &ldquo;points&rdquo; (these are not points, but conceptually, it is convenient to define where the light rays are reflected off the objects&rsquo; surface as points) projected onto the image. In other words, you start from the geometry, and you &ldquo;cast&rdquo; light paths to the eye, to find the pixel coordinates where these rays hit the image plane, and from the coordinates of these intersections points on the canvas, you can then find where they should be recorded in the digital image. So, in a way, the rasterization approach is &ldquo;object-centric&rdquo;.</p>
<h4 id="ray-tracing">Ray-Tracing</h4>
<p><a href="#R-image-b1243260b9ecb8f1e587b71b90f4e97c" class="lightbox-link"><img src="../assets/pinholecam6.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b1243260b9ecb8f1e587b71b90f4e97c"><img src="../assets/pinholecam6.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 13:</strong> <em>the direction of a light ray R can be defined by tracing a line from point O to the camera&rsquo;s aperture A or from the camera&rsquo;s aperture A to the pixel X, the pixel struck by the ray.</em></p>
<p><a href="#R-image-51eee201f5d05239b07fff135ac5f63a" class="lightbox-link"><img src="../assets/pinholecam7.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-51eee201f5d05239b07fff135ac5f63a"><img src="../assets/pinholecam7.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 14:</strong> <em>the ray-tracing algorithm can be described in three steps. First, we build a ray by tracing a line from the eye to the center of the current pixel. Then, we cast this ray into the scene and check if this ray intersects any geometry in the scene. If it does, we set the current pixel&rsquo;s color to the object&rsquo;s color at the intersection point. This process is repeated for each pixel in the image.</em></p>
<p>The way things work in ray tracing (with respect to the camera model) is the opposite of how the rasterization algorithm works. When a light ray R reflected off of the surface of an object passes through the aperture of the pinhole camera and hits the surface of the image plane, it hits a particular pixel X on the image, as described earlier. In other words, each pixel, X, in an image corresponds to a light ray, R, with a given direction, D, and a given origin O. Note that we do not need to know the ray&rsquo;s origin to define its direction. The ray&rsquo;s direction can be found by tracing a line from O (the point where the ray is emitted) to the camera&rsquo;s aperture A. It can also be defined by tracing a line from pixel X where the ray intersects the camera&rsquo;s aperture A (as shown in Figure 13). Therefore, if you can find the ray direction D by tracing a line from X (the pixel) to A (the camera&rsquo;s aperture), then you can extend this ray into the scene to find O (the origin of the light ray) as shown in Figure 14. This is the ray tracing principle (also called ray casting). We can produce an image by setting the pixel&rsquo;s colors with the color of the light rays&rsquo; respective points of origin. Due to the nature of the pinhole camera, each pixel in the image corresponds to one singular light ray that we can construct by tracing a line from the pixel to the camera&rsquo;s aperture. We then cast this ray into the scene and set the pixel&rsquo;s color to the color of the object the ray intersects (if any — the ray might not intersect any geometry indeed, in which case we set the pixel&rsquo;s color to black). This point of intersection corresponds to the point on the object&rsquo;s surface, from which the light ray was reflected off towards the eye.</p>
<p>Contrary to the rasterization algorithm, ray tracing is &ldquo;image-centric&rdquo;. Rather than following the natural path of the light ray, from the object to the camera (as we do with rasterization in a way), <strong>we follow the same path but in the other direction</strong>, from the camera to the object.</p>
<p>In our virtual camera model, rays are all emitted from the camera origin; thus, the aperture is reduced to a singular point (the center of projection); the concept of aperture size in this model doesn&rsquo;t exist. Our CG camera model behaves as an <strong>ideal pinhole camera</strong> because we consider that a single ray only passes through the aperture (as opposed to a beam of light containing many rays as with real pinhole cameras). This is, of course, impossible with a real pinhole camera. When the hole becomes too small, light rays are diffracted. With such an ideal pinhole camera, we can create perfectly sharp images. Here is the complete algorithm in pseudo-code:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="n">each</span> <span class="n">pixel</span> <span class="n">in</span> <span class="n">the</span> <span class="n">image</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    <span class="c1">// step 1
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="c1"></span>    <span class="n">build</span> <span class="n">a</span> <span class="n">camera</span> <span class="nl">ray</span><span class="p">:</span> <span class="n">trace</span> <span class="n">line</span> <span class="n">from</span> <span class="n">the</span> <span class="n">current</span> <span class="n">pixel</span> <span class="n">location</span> <span class="n">to</span> <span class="n">the</span> <span class="n">camera</span><span class="err">&#39;</span><span class="n">s</span> <span class="n">aperture</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="c1">// step 2
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="c1"></span>    <span class="n">cast</span> <span class="n">ray</span> <span class="n">into</span> <span class="n">the</span> <span class="n">scene</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="c1">// step 3
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">ray</span> <span class="n">intersects</span> <span class="n">an</span> <span class="n">object</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        <span class="n">set</span> <span class="n">the</span> <span class="n">current</span> <span class="n">pixel</span><span class="err">&#39;</span><span class="n">s</span> <span class="n">color</span> <span class="n">with</span> <span class="n">the</span> <span class="n">object</span><span class="err">&#39;</span><span class="n">s</span> <span class="n">color</span> <span class="n">at</span> <span class="n">the</span> <span class="n">intersection</span> <span class="n">point</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">        <span class="n">set</span> <span class="n">the</span> <span class="n">current</span> <span class="n">pixel</span><span class="err">&#39;</span><span class="n">s</span> <span class="n">color</span> <span class="n">to</span> <span class="n">black</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p><a href="#R-image-e7cadb99c679d79a111d1a6047aad56c" class="lightbox-link"><img src="../assets/pinholecam8.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-e7cadb99c679d79a111d1a6047aad56c"><img src="../assets/pinholecam8.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 15:</strong> <em>the point visible to the camera is the point with the closest distance to the eye.</em></p>
<p>As explained in the first lesson, ray-tracing things are a bit more complex because any camera ray can intersect several objects, as shown in Figure 15. Of all these points, the point visible to the camera is the closest distance to the eye. Suppose you are interested in a quick introduction to the ray-tracing algorithm. In that case, you can read the <a href="../../../../../lessons/3d-basic-rendering/introduction-to-ray-tracing/">first lesson</a> of this section or keep reading the lessons from this section devoted to ray-tracing specifically.</p>
<p>Advanced: it may have come to your mind that several rays may be striking the image at the same pixel location. This idea is illustrated in the adjacent image. This happens all the time in the real world because the surfaces from which the rays are reflected are continuous. In reality, we have the projection of a continuous surface (the surface of an object) onto another continuous surface (the surface of a pixel). It is important to remember that a pixel in the physical world is not an ideal point but a surface receiving light reflected off from another surface. It would be more accurate to see the phenomenon (which we often do in CG) as <strong>an &ldquo;exchange&rdquo; or transport of light energy between surfaces</strong>. You can find information on this topic in lessons from the Mathematics and Physics of Compute Graphics (check the Mathematics of Shading and Monte Carlo Methods) as well as the lesson called Monte Carlo Ray Tracing and Path Tracing.</p>
<h3 id="whats-next-1">What&rsquo;s Next?</h3>
<p>We are finally ready to implement a pinhole camera model with the same controls as the controls you can find in software such as Maya. It will be followed as usual with the source code of a program capable of producing images matching the output of Maya.</p>
<h2 id="implementing-a-virtual-pinhole-camera">Implementing a Virtual Pinhole Camera</h2>
<h3 id="implementing-a-virtual-pinhole-camera-model">Implementing a Virtual Pinhole Camera Model</h3>
<p>In the last three chapters, we have learned everything there is to know about the pinhole camera model. This type of camera is the simplest to simulate in CG and is the model most commonly used by video games and 3D applications. As briefly mentioned in the first chapter, pinhole cameras, by their design, can only produce sharp images (without any depth of field). While simple and easy to implement, the model is also often criticized for not being able to simulate visual effects such as depth of field or lens flare. While some perceive these effects as visual artifacts, they play an important role in the aesthetic experiences of photographs and films. Simulating these effects is relatively easy (because it essentially relies on well-known and basic optical rules) but very costly, especially compared to the time it takes to render an image with a basic pinhole camera model. We will present a method for simulating depth of field in another lesson (which is still costly but less costly than if we had to simulate depth of field by following the path of light rays through the various optics of a camera lens).</p>
<p>In this chapter, we will use everything we have learned in the previous chapters about the pinhole camera model and write a program to implement this model. To convince you that this model works and that there is nothing mysterious or magical about how images are produced in software such as Maya. We will produce a series of images by changing different camera parameters in Maya and our program and compare the results. If all goes well, when the camera settings match, the two applications&rsquo; images should also match. Let&rsquo;s get started.</p>
<h3 id="implementing-an-ideal-pinhole-camera-model">Implementing an Ideal Pinhole Camera Model</h3>
<p>When we refer to the pinhole camera in the rest of this chapter, we will use the terms focal length and film size. Please distinguish them from the near-clipping plane and the canvas size terms. The former applies to the pinhole camera, and the latter applies to the virtual camera model only. However, they do relate to each other. Let&rsquo;s quickly explain again how.</p>
<p><a href="#R-image-6eea8d21e3d2244fde000ec7bfcde21c" class="lightbox-link"><img src="../assets/clippingplanescanvas.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-6eea8d21e3d2244fde000ec7bfcde21c"><img src="../assets/clippingplanescanvas.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 1:</strong> <em>mathematically, the canvas can be anywhere we want along the line of sight. Its boundaries are defined as the intersection of the image plane with the viewing frustum.</em></p>
<p>The pinhole and virtual cameras must have the same viewing frustum to deliver the same image. The viewing frustum itself is defined by two and only two parameters: the point of convergence, the camera or eye origin (all these terms designate the same point), and the angle of view. We also learned in the previous chapters that the angle of view was defined by the film size and the focal length, two parameters of the pinhole camera.</p>
<h4 id="where-shall-the-canvasscreen-be">Where Shall the Canvas/Screen Be?</h4>
<p>In CG, once the viewing frustum is defined, we then need to define where is the virtual image plane going to be. Mathematically though, the canvas can be anywhere we want along the line of sight, as long as the surface on which we project the image is contained within the viewing frustum, as shown in Figure 1; it can be anywhere between the apex of the pyramid (obviously not the apex itself) and its base (which is defined by the far clipping plane) or even further if we wanted to.</p>
<blockquote>
<details>
**Don't mistake the distance between the eye (the center of projection) and the canvas for the focal length**. They are not the same. The **position of the canvas does not define how wide or narrow the viewing frustum is** (neither does the near clipping plane); the viewing frustum shape is only defined by the focal length and the film size (the combination of both parameters defines the angle of view and thus the magnification at the image plane). As for the near-clipping plane, it is just an arbitrary plane which, with the far-clipping plane, is used to "clip" geometry along the camera's local z-axis and remap points z-coordinates to the range [0,1]. Why and how the remapping is done is explained in the lesson on the REYES algorithm, a popular rasterization algorithm, and the next lesson is devoted to the perspective projection matrix.
</details>
</blockquote>
<p>When the distance between the eye and the image plane is equal to 1, it is convenient because it simplifies the equations to compute the coordinates of a point projected on the canvas. However, if we were making that choice, we wouldn&rsquo;t have the opportunity to study the generic (and slightly more complex) case in which the distance to the canvas is arbitrary. And since our goal on Scratchapixel is to learn how things work rather than make our life easier, let&rsquo;s skip this option and choose the generic case instead. For now, we decided to position the canvas at the near-clipping plane. Refrain from trying to make any sense as to why we decide to do so. It is only motivated by pedagogical reasons. The near-clipping plane is a parameter that the user can change by setting the image plane at the near-clipping plane; this forces us to study the equations for projecting points on a canvas located at an arbitrary distance from the eye. We are also cheating slightly because the way the perspective projection matrix works is based on implicitly setting up the image plane at the near-clipping plane. Thus by making this choice, we also anticipate what we will study in the next lesson. However, remember that <strong>where the canvas is positioned does not affect the output image</strong> (the image plane can be located between the eye and the near-clipping plane. Objects between the eye and the near clipping plane could still be projected on the image plane; equations for the perspective matrix would still work).</p>
<h4 id="what-will-our-program-do">What Will our Program Do</h4>
<p>In this lesson, we will create a program to generate a wireframe image of a 3D object by projecting the object&rsquo;s vertices onto the image plane. The program will be very similar to the one we wrote in the previous lesson; we will now extend the code to integrate the concept of focal length and film size. Film formats are generally rectangular, not square. Thus, our program will also output images with a rectangular shape. Remember that in chapter 2, we mentioned that the resolution gate aspect ratio, also called the device aspect ratio (the image width over its height), was not necessarily the same as the film gate aspect ratio (the film width over its height). In the last part of this chapter, we will also write some code to handle this case.</p>
<p>Here is a list of the parameters our pinhole camera model will require:</p>
<h4 id="intrinsic-parameters">Intrinsic Parameters</h4>
<p><a href="#R-image-fbc3162292b085820227f5b599a80df1" class="lightbox-link"><img src="../assets/table-1.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-fbc3162292b085820227f5b599a80df1"><img src="../assets/table-1.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<h4 id="extrinsic-parameters">Extrinsic Parameters</h4>
<p><a href="#R-image-b7a66878c417e1e2a3487491b30ca20f" class="lightbox-link"><img src="../assets/20240216172757.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b7a66878c417e1e2a3487491b30ca20f"><img src="../assets/20240216172757.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>We will also need the following parameters, which we can compute from the parameters listed above:</p>
<p><a href="#R-image-9730f7eec119a718e840fc18d188e393" class="lightbox-link"><img src="../assets/20240216172826.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-9730f7eec119a718e840fc18d188e393"><img src="../assets/20240216172826.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><a href="#R-image-e30e2a8bd85e56e5290b271eeef6009d" class="lightbox-link"><img src="../assets/canvascoordinates.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-e30e2a8bd85e56e5290b271eeef6009d"><img src="../assets/canvascoordinates.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 2:</strong> <em>the bottom-left and top-right coordinates define the boundaries of the canvas. Any projected point whose x- and y-coordinates are contained within these boundaries are visible to the camera.</em></p>
<p><a href="#R-image-e5bdadf63cfb7a9a3918980e63084bb7" class="lightbox-link"><img src="../assets/canvascoordinates2.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-e5bdadf63cfb7a9a3918980e63084bb7"><img src="../assets/canvascoordinates2.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 3:</strong> <em>the canvas size depends on the near-clipping plane and the horizontal angle of the field of view. We can easily infer the canvas&rsquo;s bottom-left and top-right coordinates from the canvas size.</em></p>
<p>Remember that when a 3D point is projected onto the image plane, we need to test the projected point x- and y-coordinates against the canvas coordinates to find out if the point is visible in the camera&rsquo;s view or not. Of course, the point can only be visible if it lies within the canvas limits. We already know how to compute the projected point coordinates using perspective divide. But we still need to know the canvas&rsquo;s bottom-left and top-right coordinates (Figure 2). How do we find these coordinates, then?</p>
<p>In almost every case, we want the canvas to be centered around the canvas coordinate system origin (Figures 2, 3, and 4). However, this is only sometimes or doesn&rsquo;t have to be the case. A stereo camera setup, for example, requires the canvas to be slightly shifted to the left or the right of the coordinate system origin. Therefore, this lesson will always assume that the canvas is centered on the image plane coordinate system origin.</p>
<p><a href="#R-image-238d79960c35bda07d1d6e7c32226f2a" class="lightbox-link"><img src="../assets/canvascoordinates3.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-238d79960c35bda07d1d6e7c32226f2a"><img src="../assets/canvascoordinates3.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 4:</strong> <em>computing the canvas bottom-left and top-right coordinates is simple when we know the canvas size.</em></p>
<p><a href="#R-image-cf1e0ac5be1b2e61cabf5da29dc49f43" class="lightbox-link"><img src="../assets/angleofview1.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-cf1e0ac5be1b2e61cabf5da29dc49f43"><img src="../assets/angleofview1.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 5:</strong> <em>vertical and horizontal angle of view.</em></p>
<p><a href="#R-image-d751deed73c1111ca2512c7f99c404e7" class="lightbox-link"><img src="../assets/canvascoordinates4.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d751deed73c1111ca2512c7f99c404e7"><img src="../assets/canvascoordinates4.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 6:</strong> <em>the film aperture width and the focal length are used to calculate the camera&rsquo;s angle of view.</em></p>
<p>Computing the canvas or screen window coordinates is simple. Since the canvas is centered about the screen coordinate system origin, they are equal to half the canvas size. They are negative if they are either below or to the left of the y-axis and x-axis of the screen coordinate system, respectively (Figure 4). The canvas size depends on the angle of view and the near-clipping plane (since we decided to position the image plane at the near-clipping plane). The angle of view depends on the film size and the focal length. Let&rsquo;s compute each one of these variables.</p>
<p>Note, though, that the film format is more often rectangular than square, as mentioned several times. Thus the angular horizontal and vertical extent of the viewing frustum is different. So we will need the horizontal angle of view to compute the left and right coordinates and the vertical angle of view to compute the bottom and top coordinates.</p>
<h4 id="computing-the-canvas-coordinates-the-long-way">Computing the Canvas Coordinates: The Long Way</h4>
<p>Let&rsquo;s start with the horizontal angle of view. In the previous chapters, we introduced the equation to compute the angle of view. It can easily be done using trigonometric identities. If you look at the camera setup from the top, you can see that we can trace a right triangle (Figure 6). The adjacent and opposite sides of the triangles are known: they correspond to the focal length and half of the film&rsquo;s horizontal aperture. However, they must be defined in the same unit to be used in a trigonometric identity. Typically, film gate dimensions are defined in inches, and focal length is defined in millimeters. Generally, inches are converted into millimeters, but you can convert millimeters to inches if you prefer; the result will be the same. One inch corresponds to 25.4 millimeters. To find the horizontal angle of view, we will use a trigonometric identity that says that the tangent of an angle is the ratio of the length of the opposite side to the length of the adjacent side (equation 1):</p>

<span class="math align-center">$$
\begin{array}{l}
\tan({\theta_H \over 2}) & = & {A \over B} \\& = & \color{red}{\dfrac {\dfrac { (\text{Film Aperture Width} * 25.4) } { 2 } } { \text{Focal Length} }}.
\end{array}
$$</span><p>Where (\theta_H) is the horizontal angle of view, we can compute the canvas size now that we have theta. We know it depends on the angle of view and the near-clipping plane (because the canvas is positioned at the near-clipping plane). We will use the same trigonometric identity (Figure 6) to compute the canvas size (equation 2):</p>

<span class="math align-center">$$
\begin{array}{l}
\tan({\theta_H \over 2}) = {A \over B} =
\dfrac{\dfrac{\text{Canvas Width} } { 2 } } { Z_{near} }, \\
\dfrac{\text{Canvas Width} } { 2 } = \tan({\theta_H \over 2}) * Z_{near},\\
\text{Canvas Width}= 2 * \color{red}{\tan({\theta_H \over 2})} * Z_{near}.
\end{array}
$$</span><p>If we want to avoid computing the trigonometric function <code>tan()</code>, we can substitute the function on the right-hand side of equation 1:</p>

<span class="math align-center">$$
\begin{array}{l}
\text{Canvas Width}= 2 * \color{red}{\dfrac {\dfrac { (\text{Film Aperture Width} * 25.4) } { 2 } } { \text{Focal Length} }} * Z_{near}.
\end{array}
$$</span><p>To compute the right coordinate, we need to divide the whole equation by 2. We get:</p>

<span class="math align-center">$$
\begin{array}{l}
\text{right} = \color{red}{\dfrac {\dfrac { (\text{Film Aperture Width} * 25.4) } { 2 } } { \text{Focal Length} }} * Z_{near}.
\end{array}
$$</span><p>Computing the left is trivial. For example, here is a code fragment to compute the left and right coordinates:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">float</span> <span class="n">focalLength</span> <span class="o">=</span> <span class="mi">35</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1">// 35mm Full Aperture
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="c1"></span><span class="kt">float</span> <span class="n">filmApertureWidth</span> <span class="o">=</span> <span class="mf">0.980</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="kt">float</span> <span class="n">filmApertureHeight</span> <span class="o">=</span> <span class="mf">0.735</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="k">static</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">inchToMm</span> <span class="o">=</span> <span class="mf">25.4</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="kt">float</span> <span class="n">nearClippingPlane</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="kt">float</span> <span class="n">farClipingPlane</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="cp">#if 0</span><span class="c">
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="c">    // First method. Compute the horizontal angle of view first
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="c">    float angleOfViewHorizontal = 2 * atan((filmApertureWidth * inchToMm / 2) / focalLength);
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="c">    float right = tan(angleOfViewHorizontal / 2) * nearClippingPlane;
</span></span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="c"></span><span class="cp">#else
</span></span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="cp"></span>    <span class="c1">// Second method. Compute the right coordinate directly
</span></span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="c1"></span>    <span class="kt">float</span> <span class="n">right</span> <span class="o">=</span> <span class="p">((</span><span class="n">filmApertureWidth</span> <span class="o">*</span> <span class="n">inchToMm</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">focalLength</span><span class="p">)</span> <span class="o">*</span> <span class="n">nearClippingPlane</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">    <span class="kt">float</span> <span class="n">left</span> <span class="o">=</span> <span class="o">-</span><span class="n">right</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">
</span></span><span class="line"><span class="ln">22</span><span class="cl">    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Screen window left/right coordinates %f %f</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">
</span></span><span class="line"><span class="ln">24</span><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>We can use the same technique to compute the top and bottom coordinates, only this time; we need to compute the vertical angle of view ((\theta_V)):</p>

<span class="math align-center">$$
\tan({\theta_V \over 2}) = {A \over B} = \color{red}{\dfrac {\dfrac { (\text{Film Aperture Height} * 25.4) } { 2 } } { \text{Focal Length} }}.
$$</span><p>We can then find the equation for the top coordinate:</p>

<span class="math align-center">$$
\text{top} = \color{red}{\dfrac {\dfrac { (\text{Film Aperture Height} * 25.4) } { 2 } } { \text{Focal Length} }} * Z_{near}.
$$</span><p>Here is the code to compute all four coordinates:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="cp">#if 0</span><span class="c">
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c">    // First method. Compute the horizontal and vertical angle of view first
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="c">    float angleOfViewHorizontal = 2 * atan((filmApertureWidth * inchToMm / 2) / focalLength);
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="c">    float right = tan(angleOfViewHorizontal / 2) * nearClippingPlane;
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c">    float angleOfViewVertical = 2 * atan((filmApertureHeight * inchToMm / 2) / focalLength);
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="c">    float top = tan(angleOfViewVertical / 2) * nearClippingPlane;
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c"></span><span class="cp">#else
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="cp"></span>    <span class="c1">// Second method. Compute the right and top coordinates directly
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="c1"></span>    <span class="kt">float</span> <span class="n">right</span> <span class="o">=</span> <span class="p">((</span><span class="n">filmApertureWidth</span> <span class="o">*</span> <span class="n">inchToMm</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">focalLength</span><span class="p">)</span> <span class="o">*</span> <span class="n">nearClippingPlane</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="kt">float</span> <span class="n">top</span> <span class="o">=</span> <span class="p">((</span><span class="n">filmApertureHeight</span> <span class="o">*</span> <span class="n">inchToMm</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">focalLength</span><span class="p">)</span> <span class="o">*</span> <span class="n">nearClippingPlane</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="kt">float</span> <span class="n">left</span> <span class="o">=</span> <span class="o">-</span><span class="n">right</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="kt">float</span> <span class="n">bottom</span> <span class="o">=</span> <span class="o">-</span><span class="n">top</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">
</span></span><span class="line"><span class="ln">18</span><span class="cl">    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Screen window bottom-left, top-right coordinates %f %f %f %f</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">bottom</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">top</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><h4 id="computing-the-canvas-coordinates-the-quick-way">Computing the Canvas Coordinates: The Quick Way</h4>
<p>The code we wrote is working just fine. However, there is a slightly faster way of computing the canvas coordinates (which you will likely see being used in production code). The method consists of computing the vertical angle of view to get the bottom-top coordinates, and they multiply these coordinates by the film aspect ratio. Mathematically this is working because this comes back to writing:</p>

<span class="math align-center">$$
\begin{array}{l}
\text{right} & = & \text{top} * \dfrac{\text{Film Aperture Width}}{\text{Film Aperture Height}} \\
& = & \color{}{\dfrac {\dfrac { (\text{Film Aperture Height} * 25.4) } { 2 } } { \text{Focal Length} }} * Z_{near} * \dfrac{\text{Film Aperture Width}}{\text{Film Aperture Height}} \\
& = & \color{}{\dfrac {\dfrac { (\text{Film Aperture Width} * 25.4) } { 2 } } { \text{Focal Length} }} * Z_{near}.
\end{array}
$$</span><p>The following code shows how to implement this solution:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="kt">float</span> <span class="n">top</span> <span class="o">=</span> <span class="p">((</span><span class="n">filmApertureHeight</span> <span class="o">*</span> <span class="n">inchToMm</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">focalLength</span><span class="p">)</span> <span class="o">*</span> <span class="n">nearClippingPlane</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="kt">float</span> <span class="n">bottom</span> <span class="o">=</span> <span class="o">-</span><span class="n">top</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="kt">float</span> <span class="n">filmAspectRatio</span> <span class="o">=</span> <span class="n">filmApertureWidth</span> <span class="o">/</span> <span class="n">filmApertureHeight</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="kt">float</span> <span class="n">left</span> <span class="o">=</span> <span class="n">bottom</span> <span class="o">*</span> <span class="n">filmAspectRatio</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="kt">float</span> <span class="n">left</span> <span class="o">=</span> <span class="o">-</span><span class="n">right</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Screen window bottom-left, top-right coordinates %f %f %f %f</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">bottom</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">top</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><h4 id="does-it-work-checking-the-code">Does it Work? Checking the Code</h4>
<p><a href="#R-image-7101fef3fadfa1adcb299bc5f59c6726" class="lightbox-link"><img src="../assets/similartriangles1.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7101fef3fadfa1adcb299bc5f59c6726"><img src="../assets/similartriangles1.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 7:</strong> <em>P&rsquo; is the projection of P on the canvas.</em></p>
<p>Before we test the code, we need to make a slight change to the function that projects points onto the image plane. Remember that to compute the projected point coordinates; we use a property of similar triangles. For example, if A, B, A&rsquo; and B&rsquo; are the opposite and adjacent sides of two similar triangles, then we can write:</p>

<span class="math align-center">$$
\begin{array}{l}
{A \over B} = {A' \over B'} = {P.y \over P.z} = {P'.y \over Z_{near}}\\
P'.y = {P.y \over P.z } * Z_{near} 
\end{array}
$$</span><p>In the previous lesson, we positioned the canvas 1 unit away from the eye. Thus the near clipping plane was equal to 1, and it reduced the equation to a simple division of the point x- and y-coordinates by the point z-coordinate (in other words, we ignored \(Z_{near}\)). We will also test whether the point is visible in the function to compute the projected point coordinates. We will compare the Finally, projected point coordinates with the canvas coordinates. In the program, if any of the triangle&rsquo;s vertices are outside the canvas boundaries, we will draw the triangle in red (if you see a red triangle in the image, then at least one of its vertices lies outside the canvas). Here is an updated version of the function projecting points onto the canvas and computing the raster coordinates of a 3D point:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">bool</span> <span class="nf">computePixelCoordinates</span><span class="p">(</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    <span class="k">const</span> <span class="n">Vec3f</span> <span class="o">&amp;</span><span class="n">pWorld</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="k">const</span> <span class="n">Matrix44f</span> <span class="o">&amp;</span><span class="n">worldToCamera</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="k">const</span> <span class="kt">float</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="k">const</span> <span class="kt">float</span> <span class="o">&amp;</span><span class="n">l</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="k">const</span> <span class="kt">float</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="k">const</span> <span class="kt">float</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="k">const</span> <span class="kt">float</span> <span class="o">&amp;</span><span class="n">near</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="k">const</span> <span class="kt">uint32_t</span> <span class="o">&amp;</span><span class="n">imageWidth</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="k">const</span> <span class="kt">uint32_t</span> <span class="o">&amp;</span><span class="n">imageHeight</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="n">Vec2i</span> <span class="o">&amp;</span><span class="n">pRaster</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="n">Vec3f</span> <span class="n">pCamera</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="n">worldToCamera</span><span class="p">.</span><span class="n">multVecMatrix</span><span class="p">(</span><span class="n">pWorld</span><span class="p">,</span> <span class="n">pCamera</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="n">Vec2f</span> <span class="n">pScreen</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="n">pScreen</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">pCamera</span><span class="p">.</span><span class="n">x</span> <span class="o">/</span> <span class="o">-</span><span class="n">pCamera</span><span class="p">.</span><span class="n">z</span> <span class="o">*</span> <span class="n">near</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">    <span class="n">pScreen</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">pCamera</span><span class="p">.</span><span class="n">y</span> <span class="o">/</span> <span class="o">-</span><span class="n">pCamera</span><span class="p">.</span><span class="n">z</span> <span class="o">*</span> <span class="n">near</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">
</span></span><span class="line"><span class="ln">19</span><span class="cl">    <span class="n">Vec2f</span> <span class="n">pNDC</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">    <span class="n">pNDC</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">pScreen</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">r</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">    <span class="n">pNDC</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">pScreen</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">t</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">t</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">    <span class="n">pRaster</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">pNDC</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">imageWidth</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">    <span class="n">pRaster</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">pNDC</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="n">imageHeight</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">
</span></span><span class="line"><span class="ln">25</span><span class="cl">    <span class="kt">bool</span> <span class="n">visible</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">pScreen</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">l</span> <span class="o">||</span> <span class="n">pScreen</span><span class="p">.</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">r</span> <span class="o">||</span> <span class="n">pScreen</span><span class="p">.</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">b</span> <span class="o">||</span> <span class="n">pScreen</span><span class="p">.</span><span class="n">y</span> <span class="o">&gt;</span> <span class="n">t</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl">        <span class="n">visible</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">28</span><span class="cl">
</span></span><span class="line"><span class="ln">29</span><span class="cl">    <span class="k">return</span> <span class="n">visible</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">30</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>Here is a summary of the changes we made to the function:</p>
<ul>
<li>Lines 16 and 17: the result of the perspective divide is multiplied by the near-clipping plane.</li>
<li>Lines 20 and 21: to remap the point from screen space to NDC space, we divide the point x and y-coordinates in screen space by the canvas width and height, respectively.</li>
<li>Lines 26 and 27: the point coordinates in screen space are compared with the bottom-left, top-right canvas coordinates. If the point lies outside, we set the visible variable to false.</li>
</ul>
<p>The rest of the program (which you can find in the source code section) is similar to the previous program. We loop over all the triangles of the 3D model, convert the triangle&rsquo;s vertices coordinates to raster coordinates and store the result in an SVG file. Let&rsquo;s render a few images in Maya and with our program and check the results.</p>
<p><a href="#R-image-3d46a4dc4daabeb84ead2fa0adceb924" class="lightbox-link"><img src="../assets/cameraresults.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-3d46a4dc4daabeb84ead2fa0adceb924"><img src="../assets/cameraresults.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>As you can see, the results match. Maya and our program produce the same results (the size and position of the model in the images are consistent between applications). When the triangles overlap the canvas boundaries, they are red, as expected.</p>
<h4 id="when-the-resolution-gate-and-film-gate-ratio-dont-match">When the Resolution Gate and Film Gate Ratio Don&rsquo;t Match</h4>
<p>When the film gate aspect ratio and the resolution gate aspect ratio (also called device aspect ratio) are different, we need to decide whether we fit the resolution gate within the film gate or the other way around (the film gate is fit to match the resolution gate). Let&rsquo;s check what the different options are:</p>
<blockquote>
<details>
In the following text, when we say that the film gate matches the resolution gate, we only mean that they match in terms of relative size (otherwise, they couldn't be compared to each other since they are not expressed in the same units. The former is expressed in inches and the latter in pixels). Therefore, if we draw a rectangle to represent the film gate, for instance, then we will draw the resolution gate so that either the top and bottom of the left and right side of the resolution gate rectangle are aligned with the top and bottom or left and right side of the film gate rectangle respectively (this is what we did in Figure 8).
</details>
</blockquote>
<p><a href="#R-image-28132df3a3825d67aa94b91edd2b489a" class="lightbox-link"><img src="../assets/fitgateresolution3.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-28132df3a3825d67aa94b91edd2b489a"><img src="../assets/fitgateresolution3.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 8:</strong> <em>when the film gate aspect ratio and the resolution gate ratio don&rsquo;t match, we need to choose between four options.</em></p>
<ul>
<li><strong>Fill Mode</strong>: we fit the resolution gate within the film gate (the blue box is contained within the red box). We have to handle two cases:
<ul>
<li>Figure 8a: when the film aspect ratio is greater than the device aspect ratio, the canvas left, and right coordinates need to be scaled down to match the left and right coordinates of the resolution gate. This can be done by multiplying the left and right coordinates by the resolution aspect ratio over the film aspect ratio.</li>
<li>Figure 8c: when the film aspect ratio is lower than the device aspect ratio, the canvas top and bottom coordinates need to be scaled down to match the top and bottom coordinates of the resolution gate. This can be done by multiplying the top and bottom coordinates by the film aspect ratio over the resolution aspect ratio.</li>
</ul>
</li>
<li><strong>Overscan Mode</strong>: we fit the film gate within the resolution gate (the red box is contained within the blue box). We have to handle two cases:
<ul>
<li>Figure 8b: when the film aspect ratio is greater than the device aspect ratio, the canvas top and bottom coordinates need to be scaled up to match the resolution gate top and bottom coordinates. To do so, we multiply the canvas top and bottom coordinates by the film aspect ratio over the resolution aspect ratio.</li>
<li>Figure 8d: when the film aspect ratio is lower than the device aspect ratio, the canvas left, and right coordinates need to be scaled up to match the resolution gate top and bottom coordinates. To do so, we multiply the canvas top and bottom coordinates by the resolution aspect ratio over the film aspect ratio.</li>
</ul>
</li>
</ul>
<p>The following code fragment demonstrates how you can implement these four cases:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">float</span> <span class="n">xscale</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="kt">float</span> <span class="n">yscale</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="k">switch</span> <span class="p">(</span><span class="n">fitFilm</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="k">default</span><span class="o">:</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="k">case</span> <span class="nl">kFill</span><span class="p">:</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">filmAspectRatio</span> <span class="o">&gt;</span> <span class="n">deviceAspectRatio</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">            <span class="c1">// 8a
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1"></span>            <span class="n">xscale</span> <span class="o">=</span> <span class="n">deviceAspectRatio</span> <span class="o">/</span> <span class="n">filmAspectRatio</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">        <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">            <span class="c1">// 8c
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="c1"></span>            <span class="n">yscale</span> <span class="o">=</span> <span class="n">filmAspectRatio</span> <span class="o">/</span> <span class="n">deviceAspectRatio</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">        <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="k">case</span> <span class="nl">kOverscan</span><span class="p">:</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">filmAspectRatio</span> <span class="o">&gt;</span> <span class="n">deviceAspectRatio</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">            <span class="c1">// 8b
</span></span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="c1"></span>            <span class="n">yscale</span> <span class="o">=</span> <span class="n">filmAspectRatio</span> <span class="o">/</span> <span class="n">deviceAspectRatio</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">        <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">            <span class="c1">// 8d
</span></span></span><span class="line"><span class="ln">23</span><span class="cl"><span class="c1"></span>            <span class="n">xscale</span> <span class="o">=</span> <span class="n">deviceAspectRatio</span> <span class="o">/</span> <span class="n">filmAspectRatio</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl">        <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl">
</span></span><span class="line"><span class="ln">28</span><span class="cl"><span class="n">right</span> <span class="o">*=</span> <span class="n">xscale</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">29</span><span class="cl"><span class="n">top</span> <span class="o">*=</span> <span class="n">yscale</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">30</span><span class="cl"><span class="n">left</span> <span class="o">=</span> <span class="o">-</span><span class="n">right</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">31</span><span class="cl"><span class="n">bottom</span> <span class="o">=</span> <span class="o">-</span><span class="n">top</span><span class="p">;</span></span></span></code></pre></div><p>Check the next chapter to get the source code of the complete program.</p>
<h3 id="conclusion">Conclusion</h3>
<p>In this lesson, you have learned everything there is to know about simulating a pinhole camera in CG. In the process, we also learned how to project points onto the image plane and find if they are visible to the camera by comparing their coordinates to the canvas coordinates. The concepts learned in this lesson will be useful for studying the perspective projection matrix (the next lesson&rsquo;s topic), the REYES algorithm, a popular rasterization algorithm, and how images are formed in ray tracing.</p>

            <footer class="footline">
            </footer>
          </article>
        </div>
      </main>
    </div>
    <aside id="R-sidebar" class="default-animation">
      <div id="R-header-topbar" class="default-animation"></div>
      <div id="R-header-wrapper" class="default-animation">
        <div id="R-header" class="default-animation">
          
<span style="font-size:26px">晟世清风</span>
        </div>
        <form action="../../../../../search.html" method="get"><div class="searchbox default-animation">
          <button class="search-detail" type="submit" title="Search (CTRL+ALT+f)"><i class="fas fa-search"></i></button>
          <label class="a11y-only" for="R-search-by">Search</label>
          <input data-search-input id="R-search-by" name="search-by" class="search-by" type="search" placeholder="Search...">
          <button class="search-clear" type="button" data-search-clear="" title="Clear search"><i class="fas fa-times" title="Clear search"></i></button>
        </div></form>
        <script>
          var contentLangs=['en'];
        </script>
        <script src="../../../../../js/auto-complete.js?1708235102" defer></script>
        <script src="../../../../../js/lunr/lunr.min.js?1708235102" defer></script>
        <script src="../../../../../js/lunr/lunr.stemmer.support.min.js?1708235102" defer></script>
        <script src="../../../../../js/lunr/lunr.multi.min.js?1708235102" defer></script>
        <script src="../../../../../js/lunr/lunr.en.min.js?1708235102" defer></script>
        <script src="../../../../../js/search.js?1708235102" defer></script>
      </div>
      <div id="R-homelinks" class="default-animation homelinks">
        <ul>
          <li><a class="padding" href="../../../../../index.html"><i class='fas fa-home'></i> Home</a></li>
        </ul>
        <hr class="padding">
      </div>
      <div id="R-content-wrapper" class="highlightable">
        <div id="R-topics">
          <ul class="enlarge morespace collapsible-menu">
          <li data-nav-id="/programming/index.html" class=""><input type="checkbox" id="R-section-d205f2b94e06f539e77f2bc392064cb6" aria-controls="R-subsections-d205f2b94e06f539e77f2bc392064cb6"><label for="R-section-d205f2b94e06f539e77f2bc392064cb6"><i class="fas fa-chevron-down"></i><i class="fas fa-chevron-right"></i><span class="a11y-only">Submenu 程序设计与开发</span></label><a class="padding" href="../../../../../programming/index.html">程序设计与开发</a><ul id="R-subsections-d205f2b94e06f539e77f2bc392064cb6" class="morespace collapsible-menu">
          <li data-nav-id="/programming/java/index.html" class="alwaysopen"><input type="checkbox" id="R-section-1a585580994f9dab2d4547c8eaf11987" aria-controls="R-subsections-1a585580994f9dab2d4547c8eaf11987" checked><label for="R-section-1a585580994f9dab2d4547c8eaf11987"><i class="fas fa-chevron-down"></i><i class="fas fa-chevron-right"></i><span class="a11y-only">Submenu Java 语言</span></label><a class="padding" href="../../../../../programming/java/index.html">Java 语言</a><ul id="R-subsections-1a585580994f9dab2d4547c8eaf11987" class="morespace collapsible-menu">
          <li data-nav-id="/programming/java/java_basics/index.html" class=""><a class="padding" href="../../../../../programming/java/java_basics/index.html">Java 基础知识</a></li>
          <li data-nav-id="/programming/java/java_collection_framework/index.html" class=""><a class="padding" href="../../../../../programming/java/java_collection_framework/index.html">Java 集合框架</a></li>
          <li data-nav-id="/programming/java/java_concurrency/index.html" class=""><a class="padding" href="../../../../../programming/java/java_concurrency/index.html">Java 并发编程</a></li>
          <li data-nav-id="/programming/java/java_memory_model/index.html" class=""><a class="padding" href="../../../../../programming/java/java_memory_model/index.html">Java 内存模型</a></li>
          <li data-nav-id="/programming/java/java_annotation/index.html" class=""><a class="padding" href="../../../../../programming/java/java_annotation/index.html">Java 注解相关</a></li></ul></li></ul></li>
          <li data-nav-id="/test/index.html" class=""><input type="checkbox" id="R-section-40aaf63da4d8c6f43df4cc726b56321f" aria-controls="R-subsections-40aaf63da4d8c6f43df4cc726b56321f"><label for="R-section-40aaf63da4d8c6f43df4cc726b56321f"><i class="fas fa-chevron-down"></i><i class="fas fa-chevron-right"></i><span class="a11y-only">Submenu Test</span></label><a class="padding" href="../../../../../test/index.html">Test</a><ul id="R-subsections-40aaf63da4d8c6f43df4cc726b56321f" class="morespace collapsible-menu">
          <li data-nav-id="/test/demo/index.html" class=""><a class="padding" href="../../../../../test/demo/index.html">Test</a></li></ul></li>
          <li data-nav-id="/algorithms_and_data_structures/index.html" class=""><a class="padding" href="../../../../../algorithms_and_data_structures/index.html">数据结构与算法</a></li>
          <li data-nav-id="/computer_graphics/index.html" class="parent "><input type="checkbox" id="R-section-17dabdd0438dc68716ce11b90ee5aa30" aria-controls="R-subsections-17dabdd0438dc68716ce11b90ee5aa30" checked><label for="R-section-17dabdd0438dc68716ce11b90ee5aa30"><i class="fas fa-chevron-down"></i><i class="fas fa-chevron-right"></i><span class="a11y-only">Submenu 计算机图形学</span></label><a class="padding" href="../../../../../computer_graphics/index.html">计算机图形学</a><ul id="R-subsections-17dabdd0438dc68716ce11b90ee5aa30" class="morespace collapsible-menu">
          <li data-nav-id="/computer_graphics/classic_tutorial/index.html" class="parent "><input type="checkbox" id="R-section-0e0951862a264269c87df7fac4f297fb" aria-controls="R-subsections-0e0951862a264269c87df7fac4f297fb" checked><label for="R-section-0e0951862a264269c87df7fac4f297fb"><i class="fas fa-chevron-down"></i><i class="fas fa-chevron-right"></i><span class="a11y-only">Submenu 经典教程</span></label><a class="padding" href="../../../../../computer_graphics/classic_tutorial/index.html">经典教程</a><ul id="R-subsections-0e0951862a264269c87df7fac4f297fb" class="morespace collapsible-menu">
          <li data-nav-id="/computer_graphics/classic_tutorial/basics_tutorial/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/basics_tutorial/index.html">基础教程</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/shader_tutorial/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/shader_tutorial/index.html">着色教程</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/raytracing_tutorial/index.html" class="parent "><input type="checkbox" id="R-section-06ac295778bd74c824886a3ab22c212c" aria-controls="R-subsections-06ac295778bd74c824886a3ab22c212c" checked><label for="R-section-06ac295778bd74c824886a3ab22c212c"><i class="fas fa-chevron-down"></i><i class="fas fa-chevron-right"></i><span class="a11y-only">Submenu 光线追踪</span></label><a class="padding" href="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/index.html">光线追踪</a><ul id="R-subsections-06ac295778bd74c824886a3ab22c212c" class="morespace collapsible-menu">
          <li data-nav-id="/computer_graphics/classic_tutorial/raytracing_tutorial/ray_tracing_in_one_weekend/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/ray_tracing_in_one_weekend/index.html">Ray Tracing in One Weekend</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/raytracing_tutorial/ray_tracing_the_next_week/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/ray_tracing_the_next_week/index.html">Ray Tracing The Next Week</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/raytracing_tutorial/ray_tracing_the_rest_of_your_life/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/ray_tracing_the_rest_of_your_life/index.html">Ray Tracing The Rest of Your Life</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/index.html" class="parent "><input type="checkbox" id="R-section-c33da7e0886830ccf91b260ac3fff456" aria-controls="R-subsections-c33da7e0886830ccf91b260ac3fff456" checked><label for="R-section-c33da7e0886830ccf91b260ac3fff456"><i class="fas fa-chevron-down"></i><i class="fas fa-chevron-right"></i><span class="a11y-only">Submenu Scratchapixe 系列短文</span></label><a class="padding" href="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/index.html">Scratchapixe 系列短文</a><ul id="R-subsections-c33da7e0886830ccf91b260ac3fff456" class="morespace collapsible-menu">
          <li data-nav-id="/computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/index.html">Chapter - 1</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-2/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-2/index.html">Chapter - 2</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/index.html">Chapter - 3</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/index.html">Chapter - 4</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/index.html" class="active"><a class="padding" href="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/index.html">Chapter - 5</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/index.html">Chapter - 6</a></li></ul></li></ul></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/index.html" class=""><input type="checkbox" id="R-section-23d956a7f1e516a9e3d46517dfb799dd" aria-controls="R-subsections-23d956a7f1e516a9e3d46517dfb799dd"><label for="R-section-23d956a7f1e516a9e3d46517dfb799dd"><i class="fas fa-chevron-down"></i><i class="fas fa-chevron-right"></i><span class="a11y-only">Submenu OpenGL教程</span></label><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/index.html">OpenGL教程</a><ul id="R-subsections-23d956a7f1e516a9e3d46517dfb799dd" class="morespace collapsible-menu">
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/learn_opengl/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/learn_opengl/index.html">Learn OpenGL</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/index.html" class=""><input type="checkbox" id="R-section-ae6b71edd18a266dbd92162060f7614e" aria-controls="R-subsections-ae6b71edd18a266dbd92162060f7614e"><label for="R-section-ae6b71edd18a266dbd92162060f7614e"><i class="fas fa-chevron-down"></i><i class="fas fa-chevron-right"></i><span class="a11y-only">Submenu OGL dev 教程</span></label><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/index.html">OGL dev 教程</a><ul id="R-subsections-ae6b71edd18a266dbd92162060f7614e" class="morespace collapsible-menu">
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_1_open_a_window/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_1_open_a_window/index.html">Chapter - 1</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_2_hello_dot/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_2_hello_dot/index.html">Chapter - 2</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_3_first_triangle/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_3_first_triangle/index.html">Chapter - 3</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_4_shaders/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_4_shaders/index.html">Chapter - 4</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_5_uniform_variables/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_5_uniform_variables/index.html">Chapter - 5</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_6_translation_transformation/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_6_translation_transformation/index.html">Chapter - 6</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_7_rotation_transformation/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_7_rotation_transformation/index.html">Chapter - 7</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_8_scaling_transformation/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_8_scaling_transformation/index.html">Chapter - 8</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_9_interpolation/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_9_interpolation/index.html">Chapter - 9</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_10_indexed_draws/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_10_indexed_draws/index.html">Chapter - 10</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_11_concatenating_transformations/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_11_concatenating_transformations/index.html">Chapter - 11</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_12_perspective_projection/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_12_perspective_projection/index.html">Chapter - 12</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_13_camera_space/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_13_camera_space/index.html">Chapter - 13</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_14_camera_control_-_part_1/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_14_camera_control_-_part_1/index.html">Chapter - 14</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_15_camera_control_-_part_2/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_15_camera_control_-_part_2/index.html">Chapter - 15</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_16_basic_texture_mapping/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_16_basic_texture_mapping/index.html">Chapter - 16</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_17_ambient_lighting/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_17_ambient_lighting/index.html">Chapter - 17</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_18_diffuse_lighting/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_18_diffuse_lighting/index.html">Chapter - 18</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_19_specular_lighting/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_19_specular_lighting/index.html">Chapter - 19</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_20_point_light/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_20_point_light/index.html">Chapter - 20</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_21_spot_light/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_21_spot_light/index.html">Chapter - 21</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_22_loading_models_using_the_open_asset_import_library/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_22_loading_models_using_the_open_asset_import_library/index.html">Chapter - 22</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_23_shadow_mapping_-_part_1/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_23_shadow_mapping_-_part_1/index.html">Chapter - 23</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_24_shadow_mapping_-_part_2/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_24_shadow_mapping_-_part_2/index.html">Chapter - 24</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_25_skybox/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_25_skybox/index.html">Chapter - 25</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_26_normal_mapping/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_26_normal_mapping/index.html">Chapter - 26</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_27_billboarding_and_the_geometry_shader/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_27_billboarding_and_the_geometry_shader/index.html">Chapter - 27</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_28_particle_system_using_transform_feedback/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_28_particle_system_using_transform_feedback/index.html">Chapter - 28</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_29_3d_picking/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_29_3d_picking/index.html">Chapter - 29</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_30_basic_tessellation/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_30_basic_tessellation/index.html">Chapter - 30</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_31_pn_triangles_tessellation/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_31_pn_triangles_tessellation/index.html">Chapter - 31</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_32_vertex_array_objects/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_32_vertex_array_objects/index.html">Chapter - 32</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_33_instanced_rendering/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_33_instanced_rendering/index.html">Chapter - 33</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_34_glfx_-_an_opengl_effect_library/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_34_glfx_-_an_opengl_effect_library/index.html">Chapter - 34</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_35_deferred_shading_-_part_1/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_35_deferred_shading_-_part_1/index.html">Chapter - 35</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_36_deferred_shading_-_part_2/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_36_deferred_shading_-_part_2/index.html">Chapter - 36</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_37_deferred_shading_-_part_3/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_37_deferred_shading_-_part_3/index.html">Chapter - 37</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_38_skeletal_animation_with_assimp/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_38_skeletal_animation_with_assimp/index.html">Chapter - 38</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_39_silhouette_detection/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_39_silhouette_detection/index.html">Chapter - 39</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_40_stencil_shadow_volume/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_40_stencil_shadow_volume/index.html">Chapter - 40</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_41_object_motion_blur/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_41_object_motion_blur/index.html">Chapter - 41</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_42_percentage_closer_filtering/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_42_percentage_closer_filtering/index.html">Chapter - 42</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_43_multipass_shadow_mapping_with_point_lights/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_43_multipass_shadow_mapping_with_point_lights/index.html">Chapter - 43</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_44_glfw/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_44_glfw/index.html">Chapter - 44</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_45_screen_space_ambient_occlusion/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_45_screen_space_ambient_occlusion/index.html">Chapter - 45</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_46_ssao_with_depth_reconstruction/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_46_ssao_with_depth_reconstruction/index.html">Chapter - 46</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_47_shadow_mapping_with_directional_lights/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_47_shadow_mapping_with_directional_lights/index.html">Chapter - 47</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_48_user_interface_with_ant_tweak_bar/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_48_user_interface_with_ant_tweak_bar/index.html">Chapter - 48</a></li>
          <li data-nav-id="/computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_49_cascaded_shadow_mapping/index.html" class=""><a class="padding" href="../../../../../computer_graphics/classic_tutorial/opengl_tutorial/ogl_dev_modern_opengl_tutorial/tutorial_49_cascaded_shadow_mapping/index.html">Chapter - 49</a></li></ul></li></ul></li></ul></li>
          <li data-nav-id="/computer_graphics/book_recommend/index.html" class=""><a class="padding" href="../../../../../computer_graphics/book_recommend/index.html">书籍推荐</a></li>
          <li data-nav-id="/computer_graphics/blog_article/index.html" class=""><a class="padding" href="../../../../../computer_graphics/blog_article/index.html">博客文章</a></li>
          <li data-nav-id="/computer_graphics/reference/index.html" class=""><a class="padding" href="../../../../../computer_graphics/reference/index.html">参考资料</a></li></ul></li>
          <li data-nav-id="/computer_science/index.html" class=""><input type="checkbox" id="R-section-7d71eaebfb32275fa70e6b3397a5fe7c" aria-controls="R-subsections-7d71eaebfb32275fa70e6b3397a5fe7c"><label for="R-section-7d71eaebfb32275fa70e6b3397a5fe7c"><i class="fas fa-chevron-down"></i><i class="fas fa-chevron-right"></i><span class="a11y-only">Submenu 计算机科学</span></label><a class="padding" href="../../../../../computer_science/index.html">计算机科学</a><ul id="R-subsections-7d71eaebfb32275fa70e6b3397a5fe7c" class="morespace collapsible-menu">
          <li data-nav-id="/computer_science/blog_article/index.html" class=""><a class="padding" href="../../../../../computer_science/blog_article/index.html">博客文章</a></li>
          <li data-nav-id="/computer_science/operating_system/index.html" class=""><a class="padding" href="../../../../../computer_science/operating_system/index.html">操作系统</a></li></ul></li>
          <li data-nav-id="/computer_networks/index.html" class=""><a class="padding" href="../../../../../computer_networks/index.html">计算机网络</a></li>
          <li data-nav-id="/game_programming/index.html" class=""><a class="padding" href="../../../../../game_programming/index.html">游戏编程</a></li>
          <li data-nav-id="/database/index.html" class=""><a class="padding" href="../../../../../database/index.html">数据库</a></li>
          </ul>
        </div>
        <div id="R-shortcuts">
          <div class="nav-title padding">More</div>
          <ul class="space">
            <li><a class="padding" href="https://github.com/McShelby/hugo-theme-relearn"><i class='fab fa-fw fa-github'></i> GitHub repo</a></li>
            <li><a class="padding" href="../../../../../tags/index.html"><i class='fas fa-fw fa-tags'></i> Tags</a></li>
            <li><a class="padding" href="../../../../../categories/index.html"><i class='fas fa-fw fa-layer-group'></i> Categories</a></li>
          </ul>
        </div>
        <div class="padding footermargin footerLangSwitch footerVariantSwitch footerVisitedLinks footerFooter showVariantSwitch showFooter"></div>
        <div id="R-menu-footer">
          <hr class="padding default-animation footerLangSwitch footerVariantSwitch footerVisitedLinks footerFooter showVariantSwitch showFooter">
          <div id="R-prefooter" class="footerLangSwitch footerVariantSwitch footerVisitedLinks showVariantSwitch">
            <ul>
              <li id="R-select-language-container" class="footerLangSwitch">
                <div class="padding menu-control">
                  <i class="fas fa-language fa-fw"></i>
                  <span>&nbsp;</span>
                  <div class="control-style">
                    <label class="a11y-only" for="R-select-language">Language</label>
                    <select id="R-select-language" onchange="location = baseUri + this.value;">
                    </select>
                  </div>
                  <div class="clear"></div>
                </div>
              </li>
              <li id="R-select-variant-container" class="footerVariantSwitch showVariantSwitch">
                <div class="padding menu-control">
                  <i class="fas fa-paint-brush fa-fw"></i>
                  <span>&nbsp;</span>
                  <div class="control-style">
                    <label class="a11y-only" for="R-select-variant">Theme</label>
                    <select id="R-select-variant" onchange="window.variants && variants.changeVariant( this.value );">
                      <option id="R-auto" value="auto" selected>Auto</option>
                      <option id="R-relearn-light" value="relearn-light">Relearn Light</option>
                      <option id="R-relearn-dark" value="relearn-dark">Relearn Dark</option>
                      <option id="R-zen-light" value="zen-light">Zen Light</option>
                      <option id="R-zen-dark" value="zen-dark">Zen Dark</option>
                      <option id="R-neon" value="neon">Neon</option>
                      <option id="R-learn" value="learn">Learn</option>
                      <option id="R-blue" value="blue">Blue</option>
                      <option id="R-green" value="green">Green</option>
                      <option id="R-red" value="red">Red</option>
                    </select>
                  </div>
                  <div class="clear"></div>
                </div>
                <script>window.variants && variants.markSelectedVariant();</script>
              </li>
              <li class="footerVisitedLinks">
                <div class="padding menu-control">
                  <i class="fas fa-history fa-fw"></i>
                  <span>&nbsp;</span>
                  <div class="control-style">
                    <button onclick="clearHistory();">Clear History</button>
                  </div>
                  <div class="clear"></div>
                </div>
              </li>
            </ul>
          </div>
          <div id="R-footer" class="footerFooter showFooter">
          <span class="github-buttons"></span>
          <p>Built with <a href="https://github.com/McShelby/hugo-theme-relearn" title="love"><i class="fas fa-heart"></i></a> by <a href="https://gohugo.io/">Hugo</a></p>
          <script>
            function githubButtonsScheme(){
              var scheme = 'light';
              var colorPropertyValue = window.getComputedStyle( document.querySelector( '#R-sidebar' ) ).getPropertyValue( 'background-color' );
              var colorValues = colorPropertyValue.match( /\d+/g ).map( function( e ){ return parseInt(e,10); });
              if( colorValues.length === 3 && ((0.2126 * colorValues[0]) + (0.7152 * colorValues[1]) + (0.0722 * colorValues[2]) < 165) ){
                
                scheme = 'dark';
              }
              return scheme;
            }
            function githubButtonsInit(){
              if( !window.githubButtons ){
                
                setTimeout( githubButtonsInit, 50 );
                return;
              }
              var scheme = githubButtonsScheme();
              var githubButtonsHTML = `
                <a class="github-button" href="https://github.com/McShelby/hugo-theme-relearn/archive/main.zip" data-color-scheme="${scheme}" data-icon="octicon-cloud-download" aria-label="Download McShelby/hugo-theme-relearn on GitHub">Download</a>
                <a class="github-button" href="https://github.com/McShelby/hugo-theme-relearn" data-color-scheme="${scheme}" data-icon="octicon-star" data-show-count="true" aria-label="Star McShelby/hugo-theme-relearn on GitHub">Star</a>
                <a class="github-button" href="https://github.com/McShelby/hugo-theme-relearn/fork" data-color-scheme="${scheme}" data-icon="octicon-repo-forked" data-show-count="true" aria-label="Fork McShelby/hugo-theme-relearn on GitHub">Fork</a>
               `;
              document.querySelector( '.github-buttons' ).innerHTML = githubButtonsHTML;
              document.querySelectorAll( '.github-button' ).forEach( function( anchor ){
                anchor.dataset.colorScheme = scheme;
                window.githubButtons.render( anchor, function( el ){
                  anchor.parentNode.replaceChild( el, anchor );
                });
              });
            }
            document.addEventListener( 'themeVariantLoaded', function( e ){
              
              setTimeout( githubButtonsInit, 400 );
            });
          </script>
          <script async src="../../../../../js/github-buttons.js?1708235102"></script>
          </div>
        </div>
      </div>
    </aside>
    <script src="../../../../../js/clipboard.min.js?1708235102" defer></script>
    <script src="../../../../../js/perfect-scrollbar.min.js?1708235102" defer></script>
    <script>
      function useMathJax( config ){
        if( !Object.assign ){
          
          return;
        }
        window.MathJax = Object.assign( window.MathJax || {}, {
          loader: {
            load: ['[tex]/mhchem']
          },
          startup: {
            elements: [
              '.math'
            ]
          },
          tex: {
            inlineMath: [
              ['$', '$'], 
              ['\\(', '\\)']
            ]
          },
          options: {
            enableMenu: false 
          }
        }, config );
      }
      useMathJax( JSON.parse("{}") );
    </script>
    <script id="MathJax-script" async src="../../../../../js/mathjax/tex-mml-chtml.js?1708235102"></script>
    <script src="../../../../../js/theme.js?1708235102" defer></script>
  </body>
</html>
