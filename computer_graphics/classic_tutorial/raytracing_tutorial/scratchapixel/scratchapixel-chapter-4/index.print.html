<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.122.0">
    <meta name="generator" content="Relearn 5.23.2+tip">
    <meta name="description" content="啊啊啊啊">
    <meta name="author" content="Sören Weber">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="https://example.com/images/hero.png">
    <meta name="twitter:title" content="Computing the Pixel Coordinates of a 3D Point :: Hugo Relearn Theme">
    <meta name="twitter:description" content="Perspective Projection How Do I Find the 2D Pixel Coordinates of a 3D Point? &ldquo;How do I find the 2D pixel coordinates of a 3D point?&rdquo; is one of the most common questions in 3D rendering on the Web. It is an essential question because it is the fundamental method to create an image of a 3D scene. In this lesson, we will use the term rasterization to describe the process of finding 2D pixel coordinates of 3D points.">
    <meta property="og:title" content="Computing the Pixel Coordinates of a 3D Point :: Hugo Relearn Theme">
    <meta property="og:description" content="Perspective Projection How Do I Find the 2D Pixel Coordinates of a 3D Point? &ldquo;How do I find the 2D pixel coordinates of a 3D point?&rdquo; is one of the most common questions in 3D rendering on the Web. It is an essential question because it is the fundamental method to create an image of a 3D scene. In this lesson, we will use the term rasterization to describe the process of finding 2D pixel coordinates of 3D points.">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://example.com/computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/index.html">
    <meta property="og:image" content="https://example.com/images/hero.png">
    <meta property="article:section" content="Scratchapixe 系列短文 :: Hugo Relearn Theme">
    <meta property="og:site_name" content="Hugo Relearn Theme">
    <title>Computing the Pixel Coordinates of a 3D Point :: Hugo Relearn Theme</title>
    <link href="https://example.com/computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/index.html" rel="canonical" type="text/html" title="Computing the Pixel Coordinates of a 3D Point :: Hugo Relearn Theme">
    <link href="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/index.xml" rel="alternate" type="application/rss+xml" title="Computing the Pixel Coordinates of a 3D Point :: Hugo Relearn Theme"><link rel="icon" href="../../../../../images/favicon.ico">
    <!-- https://github.com/filamentgroup/loadCSS/blob/master/README.md#how-to-use -->
    <link href="../../../../../css/fontawesome-all.min.css?1708235103" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../../../../../css/fontawesome-all.min.css?1708235103" rel="stylesheet"></noscript>
    <link href="../../../../../css/nucleus.css?1708235103" rel="stylesheet">
    <link href="../../../../../css/auto-complete.css?1708235103" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../../../../../css/auto-complete.css?1708235103" rel="stylesheet"></noscript>
    <link href="../../../../../css/perfect-scrollbar.min.css?1708235103" rel="stylesheet">
    <link href="../../../../../css/fonts.css?1708235103" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../../../../../css/fonts.css?1708235103" rel="stylesheet"></noscript>
    <link href="../../../../../css/theme.css?1708235103" rel="stylesheet">
    <link href="../../../../../css/theme-auto.css?1708235103" rel="stylesheet" id="R-variant-style">
    <link href="../../../../../css/variant.css?1708235103" rel="stylesheet">
    <link href="../../../../../css/print.css?1708235103" rel="stylesheet" media="print">
    <link href="../../../../../css/format-print.css?1708235103" rel="stylesheet">
    <link href="../../../../../css/ie.css?1708235103" rel="stylesheet">
    <script src="../../../../../js/url.js?1708235103"></script>
    <script src="../../../../../js/variant.js?1708235103"></script>
    <script>
      // hack to let hugo tell us how to get to the root when using relativeURLs, it needs to be called *url= for it to do its magic:
      // https://github.com/gohugoio/hugo/blob/145b3fcce35fbac25c7033c91c1b7ae6d1179da8/transform/urlreplacers/absurlreplacer.go#L72
      window.index_js_url="../../../../../index.search.js";
      var root_url="../../../../../";
      var baseUri=root_url.replace(/\/$/, '');
      window.relearn = window.relearn || {};
      window.relearn.baseUriFull='https:\/\/example.com/';
      // variant stuff
      window.variants && variants.init( [ 'auto', 'relearn-light', 'relearn-dark', 'zen-light', 'zen-dark', 'neon', 'learn', 'blue', 'green', 'red' ] );
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
    </script>
    <style>
      #R-body img.bg-white {
        background-color: white;
      }
    </style>
  </head>
  <body class="mobile-support print" data-url="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/index.html">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide">
              <button class="topbar-control" onclick="toggleNav()" type="button" title="Menu (CTRL&#43;ALT&#43;n)">
                <i class="fa-fw fas fa-bars"></i>
              </button>
            </div>
          </div>
          <ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype="http://schema.org/BreadcrumbList"><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../index.html"><span itemprop="name">主页</span></a><meta itemprop="position" content="1">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../computer_graphics/index.html"><span itemprop="name">计算机图形学</span></a><meta itemprop="position" content="2">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../computer_graphics/classic_tutorial/index.html"><span itemprop="name">经典教程</span></a><meta itemprop="position" content="3">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/index.html"><span itemprop="name">光线追踪</span></a><meta itemprop="position" content="4">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/index.html"><span itemprop="name">Scratchapixe 系列短文</span></a><meta itemprop="position" content="5">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><span itemprop="name">Computing the Pixel Coordinates of a 3D Point</span><meta itemprop="position" content="6"></li>
          </ol>
          <div class="topbar-area topbar-area-end" data-area="end">
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable default" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="default">
            <header class="headline">
            </header>
<h1 id="computing-the-pixel-coordinates-of-a-3d-point">Computing the Pixel Coordinates of a 3D Point</h1>

<h2 id="perspective-projection">Perspective Projection</h2>
<h3 id="how-do-i-find-the-2d-pixel-coordinates-of-a-3d-point">How Do I Find the 2D Pixel Coordinates of a 3D Point?</h3>
<p>&ldquo;<strong>How do I find the 2D pixel coordinates of a 3D point?</strong>&rdquo; is one of the most common questions in 3D rendering on the Web. It is an essential question because it is the fundamental method to create an image of a 3D scene. In this lesson, we will use the term <strong>rasterization</strong> to describe the process of finding 2D pixel coordinates of 3D points. In its broader sense, Rasterization refers to converting 3D shapes into a raster image. A raster image, as explained in the <a href="../../../../../lessons/3d-basic-rendering/rendering-3d-scene-overview/">previous lesson</a>, is the technical term given to a digital image; it designates a two-dimensional array (or rectangular grid if you prefer) of pixels.</p>
<p>Don&rsquo;t be mistaken: different rendering techniques exist for producing images of 3D scenes. Rasterization is only one of them. Ray tracing is another. Note that all these techniques rely on the same concept to make that image: the idea of <strong>perspective projection</strong>. Therefore, for a given camera and a given 3D scene, all rendering techniques produce the same visual result; they use a different approach to produce that result.</p>
<p>Also, computing the 2D pixel coordinates of 3D points is only one of the two steps in creating a photo-realistic image. The other step is the process of shading, in which the color of these points will be computed to simulate the appearance of objects. You need more than just converting 3D points to pixel coordinates to produce a &ldquo;complete&rdquo; image.</p>
<p><a href="#R-image-9eb04a0d603104e0a6aca06303bd403d" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/xtree.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-9eb04a0d603104e0a6aca06303bd403d"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/xtree.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>To understand rasterization, you first need to be familiar with a series of essential techniques that we will also introduce in this chapter, such as:</p>
<ul>
<li>The concept of local vs. global coordinate system.</li>
<li>Learning how to interpret 4x4 matrices as coordinate systems.</li>
<li>Converting points from one coordinate system to another.</li>
</ul>
<p>Read this lesson carefully, as it will provide you with the fundamental tools that almost all rendering techniques are built upon.</p>
<p>We will use matrices in this lesson, so read the Geometry lesson if you are uncomfortable with coordinate systems and matrices.</p>
<p>We will apply the techniques studied in this lesson to render a <strong>wireframe</strong> image of a 3D object (adjacent image). The files of this program can be found in the source code chapter of the lesson, as usual.</p>
<h3 id="a-quick-refresher-on-the-perspective-projection-process">A Quick Refresher on the Perspective Projection Process</h3>
<p><a href="#R-image-985d229b24823323ab3ba684f26256ba" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/perspective4.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-985d229b24823323ab3ba684f26256ba"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/perspective4.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 1:</strong> <em>to create an image of a cube, we need to extend lines from the corners of the object towards the eye and find the intersection of these lines with a flat surface (the canvas) perpendicular to the line of sight.</em></p>
<p>We talked about the perspective projection process in quite a few lessons already. For instance, check out the chapter <a href="../../../../../lessons/3d-basic-rendering/rendering-3d-scene-overview/visibility-problem">The Visibility Problem</a> in the lesson &ldquo;Rendering an Image of a 3D Scene: an Overview&rdquo;. However, let&rsquo;s quickly recall what perspective projection is. In short, this technique can be used to create a 2D image of a 3D scene by projecting points (or vertices) that make up the objects of that scene onto the surface of a canvas.</p>
<p>We use this technique because it is similar to how the human eye works. Since we are used to seeing the world through our eyes, it&rsquo;s pretty natural to think that images created with this technique will also look natural and &ldquo;real&rdquo; to us. You can think of the human eye as just a &ldquo;point&rdquo; in space (Figure 2) (of course, the eye is not exactly a point; it is an optical system converging rays onto a small surface - the retina). What we see of the world results from light rays (reflected by objects) traveling to the eye and entering the eye. So again, one way of making an image of a 3D scene in computer graphics (CG) is to do the same thing: project vertices onto the surface of the canvas (or screen) as if the rays were sliding along straight lines that connect the vertices to the eye.</p>
<p>It is essential to understand that perspective projection is just an arbitrary way of representing 3D geometry onto a two-dimensional surface. This method is most commonly used because it simulates one of the essential properties of human vision called <strong>foreshortening</strong>: objects far away from us appear smaller than objects close by. Nonetheless, as mentioned in the Wikipedia article on <a href="https://en.wikipedia.org/wiki/Perspective_%28graphical%29" target="_blank">perspective</a>, it is essential to understand that the perspective projection is only an <strong>approximate representation</strong> of what the eye sees, represented on a flat surface (such as paper). The important word here is &ldquo;approximate&rdquo;.</p>
<p><a href="#R-image-a52436c4c9af505309be182569c6bdf7" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/raystoeye.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a52436c4c9af505309be182569c6bdf7"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/raystoeye.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 2:</strong> among all light rays reflected by an object, some of these rays enter the eye, and the image we have of this object, is the result of these rays.</p>
<p><a href="#R-image-7f3b877fc5ea3cf150641f770457aa62" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/projection3.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7f3b877fc5ea3cf150641f770457aa62"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/projection3.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 3:</strong> we can think of the projection process as moving a point down along the line that connects the point to the eye. We can stop moving the point along that line when the point lies on the plane of the canvas. We don&rsquo;t explicitly &ldquo;slide&rdquo; the point along this line, but this is how the projection process can be interpreted.</p>
<p>In the lesson mentioned above, we also explained how the world coordinates of a point located in front of the camera (and enclosed within the viewing frustum of the camera, thus visible to the camera) could be computed using a simple geometric construction based on one of the properties of similar triangles (Figure 3). We will review this technique one more time in this lesson. The equations to compute the coordinates of projected points can be conveniently expressed as a 4x4 matrix. The computation is simple but a series of operations on the original point&rsquo;s coordinates: this is what you will learn in this lesson. However, by expressing the computation as a matrix, you can reduce these operations to a single point-matrix multiplication. This approach&rsquo;s main advantage is representing this critical operation in such a compact and easy-to-use form. It turns out that the perspective projection process, and its associated equations, can be expressed in the form of a 4x4 matrix, as we will demonstrate in the lesson devoted to the <a href="../../../../../lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/">the perspective and orthographic projection matrices</a>. This is what we call the <strong>perspective projection matrix</strong>. Multiplying any point whose coordinates are expressed with respect to the <strong>camera coordinate system</strong> (see below) with this perspective projection matrix will give you the position (or coordinates) of that point on the canvas.</p>
<blockquote>
<details>
In CG, transformations are almost always linear. But it is essential to know that the perspective projection, which belongs to the more generic family of **projective transformation**, is a non-linear transformation. If you're looking for a visual explanation of which transformations are linear and which transformations are not, this [Youtube video](https://www.youtube.com/watch?v=kYB8IZa5AuE) does a good job.
</details>
</blockquote>
<p>Again, in this lesson, we will learn about computing the 2D pixel coordinates of a 3D point without using the perspective projection matrix. To do so, we will need to learn how to &ldquo;project&rdquo; a 3D point onto a 2D drawable surface (which we will call in this lesson a canvas) using some simple geometry rules. Once we understand the mathematics of this process (and all the other steps involved in computing these 2D coordinates), we will then be ready to study the construction and use of the perspective projection matrix: a matrix used to simplify the projection step (and the projection step only). This will be the topic of the next lesson.</p>
<h3 id="some-history">Some History</h3>
<p><a href="#R-image-52b390a5c6bd6776531bd2737e4e6d61" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/duerer.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-52b390a5c6bd6776531bd2737e4e6d61"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/duerer.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>The mathematics behind perspective projection started to be understood and mastered by artists towards the end of the fourteenth century and the beginning of the fifteenth century. Artists significantly contributed to educating others about the mathematical basis of perspective drawing through books they wrote and illustrated themselves. A notable example is &ldquo;The Painter&rsquo;s Manual&rdquo; published by Albrecht Dürer in 1538 (the illustration above comes from this book). Two concepts broadly characterize perspective drawing:</p>
<ul>
<li>Objects appear smaller as their distances to the viewer increase.</li>
<li><strong>Foreshortening</strong>: the impression, or optical illusion, that an object or a distance is smaller than it is due to being angled towards the viewer.</li>
</ul>
<p>Another rule in foreshortening states that vertical lines are parallel, while nonvertical lines converge to a perspective point, appearing shorter than they are. These effects give a sense of depth, which helps evaluate the distance of objects from the viewer. Today, the same mathematical principles are used in computer graphics to create a perspective view of a 3D scene.</p>
<h2 id="mathematics-of-computing-the-2d-coordinates-of-a-3d-point">Mathematics of Computing the 2D Coordinates of a 3D Point</h2>
<h3 id="finding-the-2d-pixel-coordinates-of-a-3d-point-explained-from-beginning-to-end">Finding the 2D Pixel Coordinates of a 3D Point: Explained from Beginning to End</h3>
<p>When a point or vertex is defined in the scene and is visible to the camera, the point appears in the image as a dot (or, more precisely, as a pixel if the image is digital). We already talked about the perspective projection process, which is used to convert the position of that point in 3D space to a position on the surface of the image. But this position is not expressed in terms of pixel coordinates. How do we find the final 2D pixel coordinates of the projected point in the image? In this chapter, we will review how points are converted from their original world position to their final raster position (their position in the image in terms of pixel coordinates).</p>
<blockquote>
<details>
The technique we will describe in this lesson is specific to the rasterization algorithm (the rendering technique used by GPUs to produce images of 3D scenes). If you want to learn how it is done in ray-tracing, check the lesson [Ray-Tracing: Generating Camera Rays](/lessons/3d-basic-rendering/ray-tracing-generating-camera-rays/).
</details>
</blockquote>
<h4 id="world-coordinate-system-and-world-space">World Coordinate System and World Space</h4>
<p>When a point is first defined in the scene, we say its coordinates are specified in <strong>world space</strong>: the coordinates of this point are described with respect to a global or world Cartesian coordinate system. The coordinate system has an origin, called the <strong>world origin</strong>, and the coordinates of any point defined in that space are described with respect to that origin (the point whose coordinates are [0,0,0]). Points are expressed in world space (Figure 4).</p>
<h4 id="4x4-matrix-visualized-as-a-cartesian-coordinate-system">4x4 Matrix Visualized as a Cartesian Coordinate System</h4>
<p>Objects in 3D can be transformed using any of the three operators: translation, rotation, and scale. Suppose you remember what we said in the lesson dedicated to <a href="../../../../../lessons/mathematics-physics-for-computer-graphics/geometry/">Geometry</a>. In that case, linear transformations (in other words, any combination of these three operators) can be represented by a 4x4 matrix. If you are not sure why and how this works, read the lesson on Geometry again and particularly the following two chapters: How Does Matrix Work <a href="../../../../../lessons/mathematics-physics-for-computer-graphics/geometry/how-does-matrix-work-part-1">Part 1</a> and <a href="../../../../../lessons/mathematics-physics-for-computer-graphics/geometry/how-does-matrix-work-part-2">Part 2</a>. Remember that the first three coefficients along the diagonal encode the scale (the coefficients c00, c11, and c22 in the matrix below), the first three values of the last row encode the translation (the coefficients c30, c31, and c32 — assuming you use the row-major order convention) and the 3x3 upper-left inner matrix encodes the rotation (the red, green and blue coefficients).</p>

<span class="math align-center">$$
\begin{bmatrix}
\color{red}{c_{00}}& \color{red}{c_{01}}&\color{red}{c_{02}}&\color{black}{c_{03}}\\
\color{green}{c_{10}}& \color{green}{c_{11}}&\color{green}{c_{12}}&\color{black}{c_{13}}\\
\color{blue}{c_{20}}& \color{blue}{c_{21}}&\color{blue}{c_{22}}&\color{black}{c_{23}}\\
\color{purple}{c_{30}}& \color{purple}{c_{31}}&\color{purple}{c_{32}}&\color{black}{c_{33}}\\
\end{bmatrix}
\begin{array}{l}
\rightarrow \quad \color{red} {x-axis}\\
\rightarrow \quad \color{green} {y-axis}\\
\rightarrow \quad \color{blue} {z-axis}\\
\rightarrow \quad \color{purple} {translation}\\
\end{array}
$$</span><p>When you look at the coefficients of a matrix (the actual numbers), it might be challenging to know precisely what the scaling or rotation values are because rotation and scale are combined within the first three coefficients along the diagonal of the matrix. So let&rsquo;s ignore scale now and only focus on rotation and translation.</p>
<p>As you can see, we have nine coefficients that represent a rotation. But how can we interpret what these nine coefficients are? So far, we have looked at matrices, but let&rsquo;s now consider what coordinate systems are. We will answer this question by connecting the two - matrices and coordinate systems.</p>
<p><a href="#R-image-e6aa59993a19771ab5b579008d926bd9" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/coordsys.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-e6aa59993a19771ab5b579008d926bd9"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/coordsys.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 4:</strong> <em>coordinate systems: translation and axes coordinates are defined with respect to the world coordinate system (a right-handed coordinate system is used).</em></p>
<p>The only Cartesian coordinate system we have discussed so far is the <strong>world coordinate system</strong>. This coordinate system is a convention used to define the coordinates [0,0,0] in our 3D virtual space and three unit axes that are orthogonal to each other (Figure 4). It&rsquo;s the <a href="https://en.wikipedia.org/wiki/Prime_meridian" target="_blank">prime meridian</a> of a 3D scene - any other point or arbitrary coordinate system in the scene is defined with respect to the world coordinate system. Once this coordinate system is defined, we can create other Cartesian coordinate systems. As with points, these coordinate systems are characterized by a position in space (a translation value) but also by three unit axes or vectors that are orthogonal to each other (which, by definition, are what Cartesian coordinate systems are). <strong>Both the position and the values of these three unit vectors are defined with respect to the world coordinate system</strong>, as depicted in Figure 4.</p>
<p>In Figure 4, the purple coordinates define the position. The coordinates of the x, y, and z axes are in red, green, and blue, respectively. These are the axes of an arbitrary coordinate system, which are all defined with respect to the world coordinate system. Note that the axes that make up this arbitrary coordinate system are unit vectors.</p>
<p>The upper-left 3x3 matrix inside our 4x4 matrix contains the coordinates of our arbitrary coordinate system&rsquo;s axes. We have three axes, each with three coordinates, which makes nine coefficients. If the 4x4 matrix stores its coefficients using the row-major order convention (this is the convention used by Scratchapixel), then:</p>
<ul>
<li>@@\rThe first three coefficients of the matrix&rsquo;s first row (c00, c01, c02) correspond to the coordinates of the coordinate system&rsquo;s x-axis.@@</li>
<li>@@\gThe first three coefficients of the matrix&rsquo;s second row (c10, c11, c12) are the coordinates of the coordinate system&rsquo;s y-axis.@@</li>
<li>@@\bThe first three coefficients of the matrix&rsquo;s third row (c20, c21, c22) are the coordinates of the coordinate system&rsquo;s z-axis.@@</li>
<li>@@\pThe first three coefficients of the matrix&rsquo;s fourth row (c30, c31, c32) are the coordinates of the coordinate system&rsquo;s position (translation values).@@</li>
</ul>
<p>For example, here is the transformation matrix of the coordinate system in Figure 4:</p>

<span class="math align-center">$$
\begin{bmatrix}
\color{red}{+0.718762}&\color{red}{+0.615033}&\color{red}{-0.324214}&0\\
\color{green}{-0.393732}&\color{green}{+0.744416}&\color{green}{+0.539277}&0\\
\color{blue}{+0.573024}&\color{blue}{-0.259959}&\color{blue}{+0.777216}&0\\
\color{purple}{+0.526967}&\color{purple}{+1.254234}&\color{purple}{-2.532150}&1\\
\end{bmatrix}
\begin{array}{l}
\rightarrow \quad \color{red} {x-axis}\\
\rightarrow \quad \color{green} {y-axis}\\
\rightarrow \quad \color{blue} {z-axis}\\
\rightarrow \quad \color{purple} {translation}\\
\end{array}
$$</span><blockquote>
<p>In conclusion, <strong>a 4x4 matrix represents a coordinate system</strong> (or, reciprocally, a 4x4 matrix can represent any Cartesian coordinate system). You must always see a 4x4 matrix as nothing more than a coordinate system and vice versa (we also sometimes speak of a &ldquo;local&rdquo; coordinate system about the &ldquo;global&rdquo; coordinate system, which in our case, is the world coordinate system).</p>
</blockquote>
<h4 id="local-vs-global-coordinate-system">Local vs. Global Coordinate System</h4>
<p><a href="#R-image-acf091cc94b8d98e37f35033fb6ffb2e" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/localcoordsys.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-acf091cc94b8d98e37f35033fb6ffb2e"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/localcoordsys.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 5:</strong> <em>a global coordinate system, such as longitude and latitude coordinates, can be used to locate a house. We can also find a house using a numbering system in which the first house defines the origin of a local coordinate system. Note that the local coordinate system &ldquo;coordinate&rdquo; can also be described with respect to the global coordinate system (i.e., in terms of longitude/latitude coordinates).</em></p>
<p>Now that we have established how a 4x4 matrix can be interpreted (and introduced the concept of a local coordinate system) let&rsquo;s recall what local coordinate systems are used for. By default, the coordinates of a 3D point are defined with respect to the world coordinate system. The world coordinate system is just one among infinite possible coordinate systems. But we need a coordinate system to measure all things against by default, so we created one and gave it the special name of &ldquo;world coordinate system&rdquo; (it is a convention, like the Greenwich meridian: the meridian at which longitude is defined to be 0). Having one reference is good but not always the best way to track where things are in space. For instance, imagine you are looking for a house on the street. If you know that house&rsquo;s longitude and latitude coordinates, you can always use a GPS to find it. However, if you are already on the street where the house is situated, getting to this house using its number is more straightforward and quicker than using a GPS. A house number is a coordinate defined with respect to a reference: the first house on the street. In this example, the street numbers can be seen as a <strong>local coordinate system</strong>. In contrast, the longitude/latitude coordinate system can be seen as a <strong>global coordinate system</strong> (while the street numbers <em>can</em> be defined with respect to a global coordinate system, they are represented with their coordinates with respect to a local reference: the first house on the street). Local coordinate systems are helpful to &ldquo;find&rdquo; things when you put &ldquo;yourself&rdquo; within the frame of reference in which these things are defined (for example, when you are on the street itself). Note that the local coordinate system can be described with respect to the global coordinate system (for instance, we can determine its origin in terms of latitude/longitude coordinates).</p>
<p>Things are the same in CG. It&rsquo;s always possible to know where things are with respect to the world coordinate system. Still, to simplify calculations, it is often convenient to define things with respect to a local coordinate system (we will show this with an example further down). This is what &ldquo;local&rdquo; coordinate systems are used for.</p>
<p><a href="#R-image-58a23fb11d5038ef34ef3d3c9c40c2ab" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/coordsys1.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-58a23fb11d5038ef34ef3d3c9c40c2ab"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/coordsys1.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 6:</strong> <em>coordinates of a vertex defined with respect to the object&rsquo;s local coordinate system and to the world coordinate system.</em></p>
<p>When you move a 3D object in a scene, such as a 3D cube (but this is true regardless of the object&rsquo;s shape or complexity), transformations applied to that object (translation, scale, and rotation) can be represented by what we call a 4x4 transformation matrix (it is nothing more than a 4x4 matrix, but since it&rsquo;s used to change the position, scale and rotation of that object in space, we call it a transformation matrix). This 4x4 transformation matrix can be seen as the object&rsquo;s local frame of reference or local coordinate system. In a way, you don&rsquo;t transform the object but transform the local coordinate system of that object, but since the vertices making up the object are defined with respect to that local coordinate system, moving the coordinate system moves the object&rsquo;s vertices with it (see Figure 6). <strong>It&rsquo;s important to understand that we don&rsquo;t explicitly transform that coordinate system. We translate, scale, and rotate the object. A 4x4 matrix represents these transformations, and this matrix can be <em>visualized</em> as a coordinate system.</strong></p>
<h4 id="transforming-points-from-one-coordinate-system-to-another">Transforming Points from One Coordinate System to Another</h4>
<p>Note that even though the house is the same, the coordinates of the house, depending on whether you use its address or its longitude/latitude coordinates, are different (as the coordinates relate to the frame of reference in which the location of the house is defined). Look at the highlighted vertex in Figure 6. The coordinates of this vertex in the local coordinate system are [-0.5,0.5,-0.5]. But in &ldquo;world space&rdquo; (when the coordinates are defined with respect to the world coordinate system), the coordinates are [-0.31,1.44,-2.49]. <strong>Different coordinates, same point</strong>.</p>
<p>As suggested before, it is more convenient to operate on points when they are defined with respect to a local coordinate system rather than defined with respect to the world coordinate system. For instance, in the example of the cube (Figure 6), representing the cube&rsquo;s corners in local space is more accessible than in world space. But how do we convert a point or vertex from one coordinate system (such as the world coordinate space) to another coordinate system? Converting points from one coordinate system to another is a widespread process in CG, and the process is easy. Suppose we know the 4x4 matrix M that transforms a coordinate system A into a coordinate system B. In that case, if we transform a point whose coordinates are defined initially with respect to B with the <strong>inverse of M</strong> (we will explain next why we use the inverse of M rather than M), we get the coordinates of point P with respect to A.</p>
<p>Let&rsquo;s try an example using Figure 6. The matrix M that transforms the local coordinate system to which the cube is attached is:</p>

<span class="math align-center">$$
\begin{bmatrix}
\color{red}{+0.718762}&\color{red}{+0.615033}&\color{red}{-0.324214}&0\\
\color{green}{-0.393732}&\color{green}{+0.744416}&\color{green}{+0.539277}&0\\
\color{blue}{+0.573024}&\color{blue}{-0.259959}&\color{blue}{+0.777216}&0\\
\color{purple}{+0.526967}&\color{purple}{+1.254234}&\color{purple}{-2.532150}&1\\
\end{bmatrix}
$$</span><p><a href="#R-image-a8f76cf6082f1c0c19f0cf17fa84521c" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/coordsys2.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a8f76cf6082f1c0c19f0cf17fa84521c"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/coordsys2.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 7:</strong> <em>to transform a point that is defined in the local coordinate system to world space, we multiply the point&rsquo;s local coordinates by M (in Figure 7a, the coordinate systems coincide; they have been shifted slightly to make them visible).</em></p>
<p>By default, the local coordinate system coincides with the world coordinate system (the cube vertices are defined with respect to this local coordinate system). This is illustrated in Figure 7a. Then, we apply the matrix M to the local coordinate system, which changes its position, scale, and rotation (this depends on the matrix values). This is illustrated in Figure 7b. So before we apply the transform, the coordinates of the highlighted vertex in Figures 6 and 7 (the purple dot) are the same in both coordinate systems (since the frames of reference coincide). But after the transformation, the world and local coordinates of the points are different (Figures 7a and 7b). To calculate the world coordinates of that vertex, we need to multiply the point&rsquo;s original coordinates by the <strong>local-to-world matrix</strong>: we call it <strong>local-to-world</strong> because it defines the coordinate system with respect to the world coordinate system. This is pretty logical! If you transform the local coordinate system and want the cube to move with this coordinate system, you want to apply the same transformation that was applied to the local coordinate system to the cube vertices. To do this, you multiply the cube&rsquo;s vertices by the local-to-world matrix (denoted (M) here for the sake of simplicity):</p>

<span class="math align-center">$$
P_{world} = P_{local} * M
$$</span><p>If you now want to go the other way around (to get the point &ldquo;local coordinates&rdquo; from its &ldquo;world coordinates&rdquo;), you need to transform the point world coordinates with the inverse of M:</p>

<span class="math align-center">$$P_{local} = P_{world} * M_{inverse}$$</span><p>Or in mathematical notation:</p>

<span class="math align-center">$$P_{local} = P_{world} * M^{-1}$$</span><p>As you may have guessed already, the inverse of M is also called the <strong>world-to-local</strong> coordinate system (it defines where the world coordinate system is with respect to the local coordinate system frame of reference):</p>

<span class="math align-center">$$
\begin{array}{l}
P_{world} = P_{local} * M_{local-to-world}\\
P_{local} = P_{world} * M_{world-to-local}.
\end{array}
$$</span><p>Let&rsquo;s check that it works. The coordinates of the highlighted vertex in local space are [-0.5,0.5,0.5] and in world space: [-0.31,1.44,-2.49]. We also know the matrix M (local-to-world). If we apply this matrix to the point&rsquo;s local coordinates, we should obtain the point&rsquo;s world coordinates:</p>

<span class="math align-center">$$
\begin{array}{l}
P_{world} = P_{local} * M\\
P_{world}.x = P_{local}.x * M_{00} + P_{local}.y * M_{10} + P_{local}.z * M_{20} + M_{30}\\
P_{world}.y = P_{local}.x * M_{01} + P_{local}.y * M_{11} + P_{local}.z * M_{22} + M_{31}\\
P_{world}.z = P_{local}.x * M_{02} + P_{local}.y * M_{12} + P_{local}.z * M_{22} + M_{32}\\
\end{array}
$$</span><p>Let&rsquo;s implement and check the results (you can use the code from the Geometry lesson):</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">Matrix44f</span> <span class="nf">m</span><span class="p">(</span><span class="mf">0.718762</span><span class="p">,</span> <span class="mf">0.615033</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.324214</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.393732</span><span class="p">,</span> <span class="mf">0.744416</span><span class="p">,</span> <span class="mf">0.539277</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.573024</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.259959</span><span class="p">,</span> <span class="mf">0.777216</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.526967</span><span class="p">,</span> <span class="mf">1.254234</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.53215</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">Vec3f</span> <span class="nf">Plocal</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">),</span> <span class="n">Pworld</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">m</span><span class="p">.</span><span class="n">multVecMatrix</span><span class="p">(</span><span class="n">Plocal</span><span class="p">,</span> <span class="n">Pworld</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="n">Pworld</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span></span></span></code></pre></div><p>The output is: <code>(-0.315792 1.4489 -2.48901)</code>.</p>
<p>Let&rsquo;s now transform the world coordinates of this point into local coordinates. Our implementation of the Matrix class contains a method to invert the current matrix. We will use it to compute the world-to-local transformation matrix and then apply this matrix to the point world coordinates:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">Matrix44f</span> <span class="nf">m</span><span class="p">(</span><span class="mf">0.718762</span><span class="p">,</span> <span class="mf">0.615033</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.324214</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.393732</span><span class="p">,</span> <span class="mf">0.744416</span><span class="p">,</span> <span class="mf">0.539277</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.573024</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.259959</span><span class="p">,</span> <span class="mf">0.777216</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.526967</span><span class="p">,</span> <span class="mf">1.254234</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.53215</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">m</span><span class="p">.</span><span class="n">invert</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">Vec3f</span> <span class="nf">Pworld</span><span class="p">(</span><span class="o">-</span><span class="mf">0.315792</span><span class="p">,</span> <span class="mf">1.4489</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.48901</span><span class="p">),</span> <span class="n">Plocal</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="n">m</span><span class="p">.</span><span class="n">multVecMatrix</span><span class="p">(</span><span class="n">Pworld</span><span class="p">,</span> <span class="n">Plocal</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="n">Plocal</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span></span></span></code></pre></div><p>The output is: <code>(-0.500004 0.499998 -0.499997)</code>.</p>
<p>The coordinates are not precisely (-0.5, 0.5, -0.5) because of some floating point precision issue and also because we&rsquo;ve truncated the input point world coordinates, but if we round it off to one decimal place, we get (-0.5, 0.5, -0.5) which is the correct result.</p>
<blockquote>
<p>At this point of the chapter, you should understand the difference between the world/global and local coordinate systems and how to transform points or vectors from one system to the other (and vice versa).</p>
<p>When we transform a point from the world to the local coordinate system (or the other way around), we often say that we go from <strong>world space</strong> to <strong>local space</strong>. We will use this terminology often.</p>
</blockquote>
<h4 id="camera-coordinate-system-and-camera-space">Camera Coordinate System and Camera Space</h4>
<p><a href="#R-image-7a066de42ea8b2136d127779524da199" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/camera.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7a066de42ea8b2136d127779524da199"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/camera.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 8:</strong> <em>when you create a camera, by default, it is aligned along the world coordinate system&rsquo;s negative z-axis. This is a convention used by most 3D applications.</em></p>
<p><a href="#R-image-e00b7195e4ecbbba3b6e3d23f815513c" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/camera2.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-e00b7195e4ecbbba3b6e3d23f815513c"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/camera2.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 9:</strong> <em>transforming the camera coordinate system with the camera-to-world transformation matrix.</em></p>
<p>A camera in CG (and the natural world) is no different from any 3D object. When you take a photograph, you need to move and rotate the camera to adjust the viewpoint. So in a way, when you transform a camera (by translating and rotating it — note that scaling a camera doesn&rsquo;t make much sense), what you are doing is <strong>transforming a local coordinate system, which implicitly represents the transformations applied to that camera</strong>. In CG, we call this spatial reference system (the term spatial reference system or reference is sometimes used in place of the term coordinate system) the <strong>camera coordinate system</strong> (you might also find it called the eye coordinate system in other references). We will explain why this coordinate system is essential in a moment.</p>
<p>A camera is nothing more than a coordinate system. Thus, the technique we described earlier to transform points from one coordinate system to another can also be applied here to transform points from the world coordinate system to the camera coordinate system (and vice versa). We say that we transform points from <strong>world space to camera space</strong> (or camera space to world space if we apply the transformation the other way around).</p>
<p>However, cameras always point along the world coordinate system&rsquo;s negative z-axis. In Figure 8, you will see that the camera&rsquo;s z-axis is pointing in the opposite direction of the world coordinate system&rsquo;s z-axis (when the x-axis points to the right and the z-axis goes inward into the screen rather than outward).</p>
<blockquote>
<details>
Cameras point along the world coordinate system's negative z-axis so that when a point is converted from world space to camera space (and then later from camera space to screen space) if the point is to the left of the world coordinate system's y-axis, the point will also map to the left of the camera coordinate system's y-axis. In other words, we need the x-axis of the camera coordinate system to point to the right when the world coordinate system x-axis also points to the right; the only way you can get that configuration is by having the camera look down the negative z-axis.
</details>
</blockquote>
<p>Because of this, the sign of the z coordinate of points is inverted when we go from one system to the other. Keep this in mind, as it will play a role when we (finally) get to study the perspective projection matrix.</p>
<p>To summarize: if we want to convert the coordinates of a point in 3D from world space (which is the space in which points are defined in a 3D scene) to the space of a local coordinate system, we need to multiply the point world coordinates by the inverse of the local-to-world matrix.</p>
<h4 id="of-the-importance-of-converting-points-to-camera-space">Of the Importance of Converting Points to Camera Space</h4>
<p>This a lot of reading, but what for? We will now show that to &ldquo;project&rdquo; a point on the canvas (the 2D surface on which we will draw an image of the 3D scene), we will need to convert or transform points from the world to camera space. And here is why.</p>
<p><a href="#R-image-dbcfa5a1c7c94e0828258e101585b1c6" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/box-setup4.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-dbcfa5a1c7c94e0828258e101585b1c6"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/box-setup4.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 10:</strong> <em>the coordinates of the point P&rsquo;, the projection of P on the canvas, can be computed using simple geometry. The rectangle ABC and AB&rsquo;C&rsquo; are said to be similar (side view).</em></p>
<p>Let&rsquo;s recall that what we are trying to achieve is to compute P&rsquo;, the coordinates of a point P from the 3D scene on the surface of a canvas, which is the 2D surface where the image of the scene will be drawn (the canvas is also called the projection plane, or in CG, the <strong>image plane</strong>). If you trace a line from P to the eye (the origin of the camera coordinate system), P&rsquo; is the line&rsquo;s point of intersection with the canvas (Figure 10). When the point P coordinates are defined with respect to the camera coordinate system, computing the position of P&rsquo; is trivial. If you look at Figure 10, which shows a side view of our setup, you can see that by construction, we can trace two triangles (\triangle ABC) and (\triangle AB&rsquo;C&rsquo;), where:</p>
<ul>
<li>A is the eye.</li>
<li>B is the distance from the eye to point P along the camera coordinate system&rsquo;s z-axis.</li>
<li>C is the distance from the eye to P along the camera coordinate system&rsquo;s y-axis.</li>
<li>B&rsquo; is the distance from the eye to the canvas (for now, we will assume that this distance is 1, which will simplify our calculations).</li>
<li>C&rsquo; is the distance from the eye to P&rsquo; along the camera coordinate system y-axis.</li>
</ul>
<p>The triangles (\triangle ABC) and (\triangle AB&rsquo;C&rsquo;) are said to be similar (similar triangles have the same shape but different sizes). Similar triangles have an interesting property: the ratio between their adjacent and opposite sides is the same. In other words:</p>

<span class="math align-center">$${ BC \over AB } = { B'C' \over AB' }.$$</span><p>Because the canvas is 1 unit away from the origin, we know that AB&rsquo; equals 1. We also know the position of B and C, which are the z- (depth) and y-coordinate (height) of point P (assuming P&rsquo;s coordinates are defined in the camera coordinate system). If we substitute these numbers in the above equation, we get:</p>

<span class="math align-center">$${ P.y \over P.z } = { P'.y \over 1 }.$$</span><p>Where y&rsquo; is the y coordinate of P&rsquo;. Thus:</p>

<span class="math align-center">$$P'.y = { P.y \over P.z }.$$</span><p>This is one of computer graphics&rsquo; simplest and most fundamental relations, known as the z or perspective divide. The same principle applies to the x coordinate. The projected point&rsquo;s x coordinate (x&rsquo;) is the corner&rsquo;s x coordinate divided by its z coordinate:</p>

<span class="math align-center">$$P'.x = { P.x \over P.z }.$$</span><blockquote>
<p>We described this method several times in other lessons on the website, but we want to show here that <strong>to compute P&rsquo; using these equations, the coordinates of P should be defined with respect to the camera coordinate system. However, points from the 3D scene are defined initially with respect to the world coordinate system. Therefore, the first and foremost operation we need to apply to points before projecting them onto the canvas is to convert them from world space to camera space</strong>.</p>
</blockquote>
<p>How do we do that? Suppose we know the camera-to-world matrix (similar to the local-to-camera matrix we studied in the previous case). In that case, we can transform any point(whose coordinates are defined in world space) to camera space by multiplying this point by the camera-to-world inverse matrix (the world-to-camera matrix):</p>

<span class="math align-center">$$P_{camera} = P_{world} * M_{world-to-camera}.$$</span><p>Then at this stage, we can &ldquo;project&rdquo; the point on the canvas using the equations we presented before:</p>

<span class="math align-center">$$
\begin{array}{l}
P'.x = \dfrac{P_{camera}.x}{P_{camera}.z}\\
P'.y = \dfrac{P_{camera}.y}{P_{camera}.z}.
\end{array}
$$</span><p>Recall that cameras are usually oriented along the world coordinate system&rsquo;s negative z-axis. This means that when we convert a point from world space to camera space, the sign of the point&rsquo;s z-coordinate is necessarily reversed; it becomes negative if the z-coordinate was positive in world space, or it becomes positive if it was initially negative. <strong>Note that a point defined in camera space can only be visible if its z-coordinate is negative</strong> (take a moment to verify this statement). As a result, when the x- and y-coordinate of the original point are divided by the point&rsquo;s negative z-coordinate, the sign of the resulting projected point&rsquo;s x and y-coordinates is also reversed. This is a problem because a point that is situated to the right of the screen coordinate system&rsquo;s y-axis when you look through the camera or a point that appears above the horizontal line passing through the middle of the frame ends up either to the left of the vertical line or below the horizontal line once projected. The point&rsquo;s coordinates are mirrored. The solution to this problem is simple. We need to make the point&rsquo;s z-coordinate positive, which we can easily do by reversing its sign at the time that the projected point&rsquo;s coordinates are computed:</p>

<span class="math align-center">$$
\begin{array}{l}
P'.x = \dfrac{P_{camera}.x}{-P_{camera}.z}\\
P'.y = \dfrac{P_{camera}.y}{-P_{camera}.z}.
\end{array}
$$</span><p>To summarize: points in a scene are defined in the world coordinate space. However, to project them onto the surface of the canvas, we first need to convert the 3D point coordinates from world space to camera space. This can be done by multiplying the point world coordinates by the inverse of the camera-to-world matrix. Here is the code for performing this conversion:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">Matrix44f</span> <span class="nf">cameraToWorld</span><span class="p">(</span><span class="mf">0.718762</span><span class="p">,</span> <span class="mf">0.615033</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.324214</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.393732</span><span class="p">,</span> <span class="mf">0.744416</span><span class="p">,</span> <span class="mf">0.539277</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.573024</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.259959</span><span class="p">,</span> <span class="mf">0.777216</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.526967</span><span class="p">,</span> <span class="mf">1.254234</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.53215</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">Matrix4ff</span> <span class="n">worldToCamera</span> <span class="o">=</span> <span class="n">cameraToWorld</span><span class="p">.</span><span class="n">inverse</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">Vec3f</span> <span class="nf">Pworld</span><span class="p">(</span><span class="o">-</span><span class="mf">0.315792</span><span class="p">,</span> <span class="mf">1.4489</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.48901</span><span class="p">),</span> <span class="n">Pcamera</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="n">worldToCamera</span><span class="p">.</span><span class="n">multVecMatrix</span><span class="p">(</span><span class="n">Pworld</span><span class="p">,</span> <span class="n">Pcamera</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="n">Pcamera</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span></span></span></code></pre></div><p>We can now use the resulting point in camera space to compute its 2D coordinates on the canvas by using the perspective projection equations (dividing the point coordinates with the <strong>inverse</strong> of the point&rsquo;s z-coordinate).</p>
<h4 id="from-screen-space-to-raster-space">From Screen Space to Raster Space</h4>
<p><a href="#R-image-de6f158768a28c9cb5279a2eb2d70fc8" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/screen.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-de6f158768a28c9cb5279a2eb2d70fc8"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/screen.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 11:</strong> <em>the screen coordinate system is a 2D Cartesian coordinate system. It marks the center of the canvas. The image plane is infinite, but the canvas delimits the surface over which the image of the scene will be drawn onto. The canvas size can have any size. In this example, it is two units long in both dimensions (as with every Cartesian coordinate system, the screen coordinate system&rsquo;s axes have unit length).</em></p>
<p><a href="#R-image-e2412413c3ee264e6bdab55d87dba7fc" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/frustum.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-e2412413c3ee264e6bdab55d87dba7fc"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/frustum.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 12:</strong> <em>in this example, the canvas is 2 units along the x-axis and 2 units along the y-axis. You can change the dimension of the canvas if you wish. By making it bigger or smaller, you will see more or less of the scene.</em></p>
<p>At this point, we know how to compute the projection of a point on the canvas. We first need to transform points from world space to camera space and divide the point&rsquo;s x- and y-coordinates by their respective z-coordinate. Let&rsquo;s recall that the canvas lies on what we call the <strong>image plane</strong> in CG. So you now have a point P&rsquo; lying on the image plane, which is the projection of P onto that plane. <strong>But in which space is the coordinates of P&rsquo; defined?</strong> Note that because point P&rsquo; lies on a plane, we are no longer interested in the z-coordinate of P.&rsquo; In other words, we don&rsquo;t need to declare P&rsquo; as a 3D point; a 2D point suffices (this is partially true. To solve the visibility problem, the rasterization algorithm uses the z-coordinates of the projected points. However, we will ignore this technical detail for now).</p>
<p><a href="#R-image-ae95b5ded5ff46a0ed1b2bb581e977f1" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/canvassize.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-ae95b5ded5ff46a0ed1b2bb581e977f1"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/canvassize.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 13:</strong> <em>changing the dimensions/size of the canvas changes the extent of a given scene that is imaged by the camera. In this particular example, two canvases are represented. On the smaller one, the triangle is only partially visible. On the larger one, the entire triangle is visible. Canvas size and field-of-view relate to each other.</em></p>
<p>Since P&rsquo; is a 2D point, it is defined with respect to a 2D coordinate system which in CG is called the <strong>image or screen coordinate system</strong>. This coordinate system marks the center of the canvas; the coordinates of any point projected onto the image plane refer to this coordinative system. 3D points with positive x-coordinates are projected to the right of the image coordinate system&rsquo;s y-axis. 3D points with positive y-coordinates are projected above the image coordinate system&rsquo;s x-axis (Figure 11). An image plane is a plane, so technically, it is infinite. But images are not infinite in size; they have a width and a height. Thus, we will cut off a rectangular shape centered around the image coordinate system, which we will define as the &ldquo;bounded region&rdquo; over which the image of the 3D scene will be drawn (Figure 11). You can see that this region is a canvas&rsquo;s paintable or drawable surface. The dimension of this rectangular region can be anything we want. Changing its size changes the extent of a given scene imaged by the camera (Figure 13). We will study the effect of the canvas size in the next lesson. In figures 12 and 14 (top), the canvas is 2 units long in each dimension (vertical and horizontal).</p>
<p>Any projected point whose absolute x- and y-coordinate is greater than half of the canvas&rsquo; width <strong>or</strong> half of the canvas&rsquo; height, respectively, is not visible in the image (the projected point is clipped).</p>

<span class="math align-center">$$
\text {visible} =
\begin{cases}
yes & |P'.x| \le {W \over 2} \text{ or }  |P'.y| \le {H \over 2}\\
no & \text{otherwise}
\end{cases}
$$</span><p>|a| in mathematics means the <a href="https://www.khanacademy.org/math/cc-sixth-grade-math/cc-6th-negative-number-topic/cc-6th-absolute-value/a/intro-to-absolute-value" target="_blank">absolute value</a> of a. The variables W and H are the width and height of the canvas.</p>
<p><a href="#R-image-7508efd132fb90d05332eec9b01d978b" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/canvascoordsys.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7508efd132fb90d05332eec9b01d978b"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/canvascoordsys.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 14:</strong> <em>to convert P&rsquo; from screen space to raster space, we first need to go from screen space (top) to NDC space (middle), then NDC space to raster space (bottom). Note that the y-axis of the NDC coordinate system goes up but that the y-axis of the raster coordinate system goes down. This implies that we invert P&rsquo; y-coordinate when we go from NDC to raster space.</em></p>
<p>If the coordinates of P are real numbers (floats or doubles in programming), P&rsquo;s coordinates are also real numbers. If P&rsquo;s coordinates are within the canvas boundaries, then P&rsquo; is visible. Otherwise, the point is not visible, and we can ignore it. If P&rsquo; is visible, it should appear as a dot in the image. A dot in a digital image is a pixel. Note that pixels are also 2D points, only their coordinates are integers, and the coordinate system that these coordinates refer to is located in the upper-left corner of the image. Its x-axis points to the right (when the world coordinate system x-axis points to the right), and its y-axis points downwards (Figure 14). This coordinate system in computer graphics is called the <strong>raster coordinate system</strong>. A pixel in this coordinate system is one unit long in x and y. We need to convert P&rsquo; coordinates, defined with respect to the image or screen coordinate system, into pixel coordinates (the position of P&rsquo; in the image in terms of pixel coordinates). This is another change in the coordinate system; we say that we need to go from <strong>screen space to raster space</strong>. How do we do that?</p>
<p>The first thing we will do is remap P coordinates in the range [0,1]. This is mathematically easy. Since we know the dimension of the canvas, all we need to do is apply the following formulas:</p>

<span class="math align-center">$$
\begin{array}{l}
P'_{normalized}.x = \dfrac{P'.x + width / 2}{ width }\\
P'_{normalised}.y = \dfrac{P'.y + height / 2}{ height }
\end{array}
$$</span><p>Because the coordinates of the projected point P&rsquo; are now in the range [0,1], we say that the coordinates are normalized. For this reason, we also call the coordinate system in which the points are defined after normalization the <strong>NDC coordinate system</strong> or <strong>NDC space</strong>. NDC stands for <strong>Normalized Device Coordinate</strong>. The NDC coordinate system&rsquo;s origin is situated in the lower-left corner of the canvas. Note that the coordinates are still real numbers at this point, only they are now in the range [0,1].</p>
<p>The last step is simple. We need to multiply the projected point&rsquo;s x- and y-coordinates in NDC space by the actual image pixel width and image pixel height, respectively. This is a simple remapping of the range [0,1] to the range [0, Pixel Width] for the x-coordinate and [0,Pixel Height] for the y-coordinate, respectively. Since the pixel coordinates need to be integers, we need to round off the resulting numbers to the smallest following integer value (to do that, we will use the mathematical floor function; it rounds off a real number to its smallest next integer). After this final step, P&rsquo;s coordinates are defined in <strong>raster space</strong>:</p>

<span class="math align-center">$$
\begin{array}{l}
P'_{raster}.x = \lfloor{ P'_{normalized}.x * \text{ Pixel Width} }\rfloor\\
P'_{raster}.y = \lfloor{ P'_{normalized}.y * \text{Pixel Height} }\rfloor
\end{array}
$$</span><p>In mathematics, (\lfloor{a}\rfloor), denotes the <a href="https://en.wikipedia.org/wiki/Floor_and_ceiling_functions" target="_blank">floor function</a>. Pixel width and pixel height are the actual dimensions of the image in pixels. However, there is a small detail that we need to take care of. The y-axis in the NDC coordinate system points up, while in the raster coordinate system, the y-axis points down. Thus, to go from one coordinate system to the other, the y-coordinate of P&rsquo; also needs to be inverted. We can easily account for this by doing a small modification to the above equations:</p>

<span class="math align-center">$$
\begin{array}{l}
P'_{raster}.x = \lfloor{ P'_{normalized}.x * \text{ Pixel Width} }\rfloor\\
P'_{raster}.y = \lfloor{ (1 - P'_{normalized}.y) * \text{Pixel Height} }\rfloor
\end{array}
$$</span><p>In OpenGL, the conversion from NDC space to raster space is called the viewport transform. The canvas in this lesson is generally called the <strong>viewport</strong> in CG. However, the viewport means different things to different people. To some, it designates the &ldquo;normalized window&rdquo; of the NDC space. To others, it represents the window of pixels on the screen in which the final image is displayed.</p>
<p>Done! You have converted a point P defined in world space into a visible point in the image, whose pixel coordinates you have computed using a series of conversion operations:</p>
<ul>
<li>World space to camera space.</li>
<li>Camera space to screen space.</li>
<li>Screen space to NDC space.</li>
<li>NDC space to raster space.</li>
</ul>
<h3 id="summary">Summary</h3>
<p>Because this process is so fundamental, we will summarize everything that we&rsquo;ve learned in this chapter:</p>
<ul>
<li>Points in a 3D scene are defined with respect to the world coordinate system.</li>
<li>A 4x4 matrix can be seen as a &ldquo;local&rdquo; coordinate system.</li>
<li>We learned how to convert points from the world coordinate system to any local coordinate system.
<ul>
<li>If we know the local-to-world matrix, we can multiply the world coordinate of the point by the inverse of the local-to-world matrix (the world-to-local matrix).</li>
</ul>
</li>
<li>We also use 4x4 matrices to transform cameras. Therefore, we can also convert points from world space to camera space.</li>
<li>Computing the coordinates of a point from camera space onto the canvas can be done using perspective projection (camera space to image space). This process requires a simple division of the point&rsquo;s x- and y-coordinate by the point&rsquo;s z-coordinate. Before projecting the point onto the canvas, we need to convert the point from world space to camera space. The resulting projected point is a 2D point defined in image space (the z-coordinate can be discarded).</li>
<li>We then convert the 2D point in image space to Normalized Device Coordinate (NDC) space. In NDC space (image space to NDC space), the coordinates of the point are remapped to the range [0,1].</li>
<li>Finally, we convert the 2D point in NDC space to raster space. To do this, we must multiply the NDC point&rsquo;s x and y coordinates with the image width and height (in pixels). Pixel coordinates are integers rather than real numbers. Thus, they need to be rounded off to the smallest following integer when converting from NDC space to raster space. In the NDC coordinate system, the y-axis is located in the lower-left corner of the image and is pointing up. In raster space, the y-axis is located in the upper-left corner of the image and is pointing down. Therefore, the y-coordinates need to be inverted when converting from NDC to raster space.</li>
</ul>
<p><a href="#R-image-bb9132a2897c7ff7b435db1187efc0c5" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/20240216151742.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-bb9132a2897c7ff7b435db1187efc0c5"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/20240216151742.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<h3 id="code">Code</h3>
<p>The function converts a point from 3D world coordinates to 2D pixel coordinates. The function returns&rsquo; false&rsquo; if the point is not visible in the canvas. This implementation is quite naive, but we should have written it for efficiency. We wrote it, so that every step is visible and contained within a single function.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">bool</span> <span class="nf">computePixelCoordinates</span><span class="p">(</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    <span class="k">const</span> <span class="n">Vec3f</span> <span class="o">&amp;</span><span class="n">pWorld</span><span class="p">,</span> 
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="k">const</span> <span class="n">Matrix44f</span> <span class="o">&amp;</span><span class="n">cameraToWorld</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="k">const</span> <span class="kt">float</span> <span class="o">&amp;</span><span class="n">canvasWidth</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="k">const</span> <span class="kt">float</span> <span class="o">&amp;</span><span class="n">canvasHeight</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">imageWidth</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">imageHeight</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="n">Vec2i</span> <span class="o">&amp;</span><span class="n">pRaster</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="c1">// First, transform the 3D point from world space to camera space. 
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="c1"></span>    <span class="c1">// It is, of course inefficient to compute the inverse of the cameraToWorld
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="c1"></span>    <span class="c1">// matrix in this function. It should be done only once outside the function
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="c1"></span>    <span class="c1">// and the worldToCamera should be passed to the function instead. 
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="c1"></span>    <span class="c1">// We only compute the inverse of this matrix in this function ...
</span></span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="c1"></span>    <span class="n">Vec3f</span> <span class="n">pCamera</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="n">Matrix44f</span> <span class="n">worldToCamera</span> <span class="o">=</span> <span class="n">cameraToWorld</span><span class="p">.</span><span class="n">inverse</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">    <span class="n">worldToCamera</span><span class="p">.</span><span class="n">multVecMatrix</span><span class="p">(</span><span class="n">pWorld</span><span class="p">,</span> <span class="n">pCamera</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">
</span></span><span class="line"><span class="ln">19</span><span class="cl">    <span class="c1">// Coordinates of the point on the canvas. Use perspective projection.
</span></span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="c1"></span>    <span class="n">Vec2f</span> <span class="n">pScreen</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">    <span class="n">pScreen</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">pCamera</span><span class="p">.</span><span class="n">x</span> <span class="o">/</span> <span class="o">-</span><span class="n">pCamera</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">    <span class="n">pScreen</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">pCamera</span><span class="p">.</span><span class="n">y</span> <span class="o">/</span> <span class="o">-</span><span class="n">pCamera</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">
</span></span><span class="line"><span class="ln">24</span><span class="cl">    <span class="c1">// If the x- or y-coordinate absolute value is greater than the canvas width 
</span></span></span><span class="line"><span class="ln">25</span><span class="cl"><span class="c1"></span>    <span class="c1">// or height respectively, the point is not visible
</span></span></span><span class="line"><span class="ln">26</span><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">abs</span><span class="p">(</span><span class="n">pScreen</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">canvasWidth</span> <span class="o">||</span> <span class="n">std</span><span class="o">::</span><span class="n">abs</span><span class="p">(</span><span class="n">pScreen</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">canvasHeight</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">28</span><span class="cl">
</span></span><span class="line"><span class="ln">29</span><span class="cl">    <span class="c1">// Normalize. Coordinates will be in the range [0,1]
</span></span></span><span class="line"><span class="ln">30</span><span class="cl"><span class="c1"></span>    <span class="n">Vec2f</span> <span class="n">pNDC</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">31</span><span class="cl">    <span class="n">pNDC</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">pScreen</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">canvasWidth</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">canvasWidth</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">32</span><span class="cl">    <span class="n">pNDC</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">pScreen</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">canvasHeight</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">canvasHeight</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">33</span><span class="cl">
</span></span><span class="line"><span class="ln">34</span><span class="cl">    <span class="c1">// Finally, convert to pixel coordinates. Don&#39;t forget to invert the y coordinate
</span></span></span><span class="line"><span class="ln">35</span><span class="cl"><span class="c1"></span>    <span class="n">pRaster</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">floor</span><span class="p">(</span><span class="n">pNDC</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">imageWidth</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">36</span><span class="cl">    <span class="n">pRaster</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">floor</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">pNDC</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="n">imageHeight</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">37</span><span class="cl">
</span></span><span class="line"><span class="ln">38</span><span class="cl">    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">39</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">40</span><span class="cl">
</span></span><span class="line"><span class="ln">41</span><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(...)</span>
</span></span><span class="line"><span class="ln">42</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">43</span><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="ln">44</span><span class="cl">    <span class="n">Matrix44f</span> <span class="n">cameraToWorld</span><span class="p">(...);</span>
</span></span><span class="line"><span class="ln">45</span><span class="cl">    <span class="n">Vec3f</span> <span class="n">pWorld</span><span class="p">(...);</span>
</span></span><span class="line"><span class="ln">46</span><span class="cl">    <span class="kt">float</span> <span class="n">canvasWidth</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">canvasHeight</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">47</span><span class="cl">    <span class="kt">uint32_t</span> <span class="n">imageWidth</span> <span class="o">=</span> <span class="mi">512</span><span class="p">,</span> <span class="n">imageHeight</span> <span class="o">=</span> <span class="mi">512</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">48</span><span class="cl">
</span></span><span class="line"><span class="ln">49</span><span class="cl">    <span class="c1">// The 2D pixel coordinates of pWorld in the image if the point is visible
</span></span></span><span class="line"><span class="ln">50</span><span class="cl"><span class="c1"></span>    <span class="n">Vec2i</span> <span class="n">pRaster</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">51</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">computePixelCoordinates</span><span class="p">(</span><span class="n">pWorld</span><span class="p">,</span> <span class="n">cameraToWorld</span><span class="p">,</span> <span class="n">canvasWidth</span><span class="p">,</span> <span class="n">canvasHeight</span><span class="p">,</span> <span class="n">imageWidth</span><span class="p">,</span> <span class="n">imageHeight</span><span class="p">,</span> <span class="n">pRaster</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">52</span><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Pixel coordinates &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">pRaster</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">53</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">54</span><span class="cl">    <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">55</span><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cert</span> <span class="o">&lt;&lt;</span> <span class="n">Pworld</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; is not visible&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">56</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">57</span><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="ln">58</span><span class="cl">
</span></span><span class="line"><span class="ln">59</span><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">60</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>We will use a similar function in our example program (look at the source code chapter). To demonstrate the technique, we created a simple object in Maya (a tree with a star sitting on top) and rendered an image of that tree from a given camera in Maya (see the image below). To simplify the exercise, we triangulated the geometry. We then stored a description of that geometry and the Maya camera 4x4 transform matrix (the camera-to-world matrix) in our program.</p>
<p>To create an image of that object, we need to:</p>
<ul>
<li>Loop over each triangle that makes up the geometry.</li>
<li>Extract from the vertex list the vertices making up the current triangle.</li>
<li>Convert these vertices&rsquo; world coordinates to 2D pixel coordinates.</li>
<li>Draw lines connecting the resulting 2D points to draw an image of that triangle as viewed from the camera (we trace a line from the first point to the second point, from the second point to the third, and then from the third point back to the first point).</li>
</ul>
<p>We then store the resulting lines in an SVG file. The SVG format is designed to create images using simple geometric shapes such as lines, rectangles, circles, etc., described in XML. Here is how we define a line in SVG, for instance:</p>
<div class="wrap-code highlight"><pre tabindex="0"><code>&lt;line x1=&#34;0&#34; y1=&#34;0&#34; x2=&#34;200&#34; y2=&#34;200&#34; style=&#34;stroke:rgb(255,0,0);stroke-width:2&#34; /&gt;</code></pre></div><p>SVG files themselves can be read and displayed as images by most Internet browsers. Storing the result of our programs in SVG is very convenient. Rather than rendering these shapes ourselves, we can store their description in an SVG file and have other applications render the final image for us (we don&rsquo;t need to care for anything that relates to rendering these shapes and displaying the image to the screen, which is not apparent from a programming point of view).</p>
<p>The complete source code of this program can be found in the source code chapter. Finally, here is the result of our program (left) compared to a render of the same geometry from the same camera in Maya (right). As expected, the visual results are the same (you can read the SVG file produced by the program in any Internet browser).</p>
<p><a href="#R-image-34b14103e04454c80bf54b4a510c63e4" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/projexample.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-34b14103e04454c80bf54b4a510c63e4"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/projexample.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Suppose you wish to reproduce this result in Maya. In that case, you will need to import the geometry (which we provide in the next chapter as an obj file), create a camera, set its angle of view to 90 degrees (we will explain why in the next lesson), and make the film gate square (by setting up the vertical and horizontal film gate parameters to 1). Set the render resolution to 512x512 and render from Maya. It would be best if you then exported the camera&rsquo;s transformation matrix using, for example, the following Mel command:</p>
<div class="wrap-code highlight"><pre tabindex="0"><code>getAttr camera1.worldMatrix;</code></pre></div><p>Set the camera-to-world matrix in our program with the result of this command (the 16 coefficients of the matrix). Compile the source code, and run the program. The impact exported to the SVG file should match Maya&rsquo;s render.</p>
<h3 id="what-else">What Else?</h3>
<p>This chapter contains a lot of information. Most resources devoted to the process focus their explanation on the perspective process. Still, they must remember to mention everything that comes before and after the perspective projection (such as the world-to-camera transformation or the conversion of the screen coordinates to raster coordinates). We aim for you to produce an actual result at the end of this lesson, which we could also match to a render from a professional 3D application such as Maya. We wanted you to have a complete picture of the process from beginning to end. However, dealing with cameras is slightly more complicated than what we described in this chapter. For instance, if you have used a 3D program before, you are probably familiar with the fact that the camera transform is not the only parameter you can change to adjust what you see in the camera&rsquo;s view. You can also vary, for example, its focal length. How the focal length affects the result of the conversion process is something we have yet to explain in this lesson. The near and far clipping planes associated with cameras also affect the perspective projection process, more notably the perspective and orthographic projection matrix. In this lesson, we assumed that the canvas was located one unit away from the camera coordinate system. However, this is only sometimes the case, which can be controlled through the near-clipping plane. How do we compute pixel coordinates when the distance between the camera coordinate system&rsquo;s origin and the canvas is different than 1? These unanswered questions will be addressed in the next lesson, devoted to 3D viewing.</p>
<h3 id="exercises">Exercises</h3>
<ul>
<li>Change the canvas dimension in the program (the <code>canvasWidth</code> and <code>canvasHeight</code> parameters). Keep the value of the two parameters equal. What happens when the values get smaller? What happens when they get bigger?</li>
</ul>
<p><a href="https://github.com/scratchapixel/code/tree/main/computing-pixel-coordinates-of-3d-point" target="_blank">Source Code (external link GitHub)</a></p>
<p>[Source Code (external link Gitee)](</p>

            <footer class="footline">
            </footer>
          </article>

        </div>
      </main>
    </div>
    <script src="../../../../../js/clipboard.min.js?1708235103" defer></script>
    <script src="../../../../../js/perfect-scrollbar.min.js?1708235103" defer></script>
    <script>
      function useMathJax( config ){
        if( !Object.assign ){
          
          return;
        }
        window.MathJax = Object.assign( window.MathJax || {}, {
          loader: {
            load: ['[tex]/mhchem']
          },
          startup: {
            elements: [
              '.math'
            ]
          },
          tex: {
            inlineMath: [
              ['$', '$'], 
              ['\\(', '\\)']
            ]
          },
          options: {
            enableMenu: false 
          }
        }, config );
      }
      useMathJax( JSON.parse("{}") );
    </script>
    <script id="MathJax-script" async src="../../../../../js/mathjax/tex-mml-chtml.js?1708235103"></script>
    <script src="../../../../../js/theme.js?1708235103" defer></script>
  </body>
</html>
