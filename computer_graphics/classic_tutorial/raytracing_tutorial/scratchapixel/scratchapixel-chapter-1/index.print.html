<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.122.0">
    <meta name="generator" content="Relearn 5.23.2+tip">
    <meta name="description" content="啊啊啊啊">
    <meta name="author" content="Sören Weber">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="https://example.com/images/hero.png">
    <meta name="twitter:title" content="Introduction to Raytracing: A Simple Method for Creating 3D Images :: Hugo Relearn Theme">
    <meta name="twitter:description" content="转自：https://www.scratchapixel.com/lessons/3d-basic-rendering/introduction-to-ray-tracing/how-does-it-work.html
How Does it Work This lesson serves as a broad introduction to the concept of 3D rendering and computer graphics programming. For those specifically interested in the ray-tracing method, you might want to explore the lesson An Overview of the Ray-Tracing Rendering Technique.
Embarking on the exploration of 3D graphics, especially within the realm of computer graphics programming, the initial step involves understanding the conversion of a three-dimensional scene into a two-dimensional image that can be viewed.">
    <meta property="og:title" content="Introduction to Raytracing: A Simple Method for Creating 3D Images :: Hugo Relearn Theme">
    <meta property="og:description" content="转自：https://www.scratchapixel.com/lessons/3d-basic-rendering/introduction-to-ray-tracing/how-does-it-work.html
How Does it Work This lesson serves as a broad introduction to the concept of 3D rendering and computer graphics programming. For those specifically interested in the ray-tracing method, you might want to explore the lesson An Overview of the Ray-Tracing Rendering Technique.
Embarking on the exploration of 3D graphics, especially within the realm of computer graphics programming, the initial step involves understanding the conversion of a three-dimensional scene into a two-dimensional image that can be viewed.">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://example.com/computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/index.html">
    <meta property="og:image" content="https://example.com/images/hero.png">
    <meta property="article:section" content="Scratchapixe 系列短文 :: Hugo Relearn Theme">
    <meta property="og:site_name" content="Hugo Relearn Theme">
    <title>Introduction to Raytracing: A Simple Method for Creating 3D Images :: Hugo Relearn Theme</title>
    <link href="https://example.com/computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/index.html" rel="canonical" type="text/html" title="Introduction to Raytracing: A Simple Method for Creating 3D Images :: Hugo Relearn Theme">
    <link href="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/index.xml" rel="alternate" type="application/rss+xml" title="Introduction to Raytracing: A Simple Method for Creating 3D Images :: Hugo Relearn Theme"><link rel="icon" href="../../../../../images/favicon.ico">
    <!-- https://github.com/filamentgroup/loadCSS/blob/master/README.md#how-to-use -->
    <link href="../../../../../css/fontawesome-all.min.css?1708235103" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../../../../../css/fontawesome-all.min.css?1708235103" rel="stylesheet"></noscript>
    <link href="../../../../../css/nucleus.css?1708235103" rel="stylesheet">
    <link href="../../../../../css/auto-complete.css?1708235103" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../../../../../css/auto-complete.css?1708235103" rel="stylesheet"></noscript>
    <link href="../../../../../css/perfect-scrollbar.min.css?1708235103" rel="stylesheet">
    <link href="../../../../../css/fonts.css?1708235103" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../../../../../css/fonts.css?1708235103" rel="stylesheet"></noscript>
    <link href="../../../../../css/theme.css?1708235103" rel="stylesheet">
    <link href="../../../../../css/theme-auto.css?1708235103" rel="stylesheet" id="R-variant-style">
    <link href="../../../../../css/variant.css?1708235103" rel="stylesheet">
    <link href="../../../../../css/print.css?1708235103" rel="stylesheet" media="print">
    <link href="../../../../../css/format-print.css?1708235103" rel="stylesheet">
    <link href="../../../../../css/ie.css?1708235103" rel="stylesheet">
    <script src="../../../../../js/url.js?1708235103"></script>
    <script src="../../../../../js/variant.js?1708235103"></script>
    <script>
      // hack to let hugo tell us how to get to the root when using relativeURLs, it needs to be called *url= for it to do its magic:
      // https://github.com/gohugoio/hugo/blob/145b3fcce35fbac25c7033c91c1b7ae6d1179da8/transform/urlreplacers/absurlreplacer.go#L72
      window.index_js_url="../../../../../index.search.js";
      var root_url="../../../../../";
      var baseUri=root_url.replace(/\/$/, '');
      window.relearn = window.relearn || {};
      window.relearn.baseUriFull='https:\/\/example.com/';
      // variant stuff
      window.variants && variants.init( [ 'auto', 'relearn-light', 'relearn-dark', 'zen-light', 'zen-dark', 'neon', 'learn', 'blue', 'green', 'red' ] );
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
    </script>
    <style>
      #R-body img.bg-white {
        background-color: white;
      }
    </style>
  </head>
  <body class="mobile-support print" data-url="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/index.html">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide">
              <button class="topbar-control" onclick="toggleNav()" type="button" title="Menu (CTRL&#43;ALT&#43;n)">
                <i class="fa-fw fas fa-bars"></i>
              </button>
            </div>
          </div>
          <ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype="http://schema.org/BreadcrumbList"><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../index.html"><span itemprop="name">主页</span></a><meta itemprop="position" content="1">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../computer_graphics/index.html"><span itemprop="name">计算机图形学</span></a><meta itemprop="position" content="2">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../computer_graphics/classic_tutorial/index.html"><span itemprop="name">经典教程</span></a><meta itemprop="position" content="3">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/index.html"><span itemprop="name">光线追踪</span></a><meta itemprop="position" content="4">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/index.html"><span itemprop="name">Scratchapixe 系列短文</span></a><meta itemprop="position" content="5">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><span itemprop="name">Introduction to Raytracing: A Simple Method for Creating 3D Images</span><meta itemprop="position" content="6"></li>
          </ol>
          <div class="topbar-area topbar-area-end" data-area="end">
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable default" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="default">
            <header class="headline">
            </header>
<h1 id="introduction-to-raytracing-a-simple-method-for-creating-3d-images">Introduction to Raytracing: A Simple Method for Creating 3D Images</h1>

<blockquote>
<p>转自：https://www.scratchapixel.com/lessons/3d-basic-rendering/introduction-to-ray-tracing/how-does-it-work.html</p>
</blockquote>
<h2 id="how-does-it-work">How Does it Work</h2>
<p>This lesson serves as a broad introduction to the concept of 3D rendering and computer graphics programming. For those specifically interested in the ray-tracing method, you might want to explore the lesson <a href="https://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-overview/ray-tracing-rendering-technique-overview.html" target="_blank">An Overview of the Ray-Tracing Rendering Technique</a>.</p>
<p>Embarking on the exploration of 3D graphics, especially within the realm of computer graphics programming, the initial step involves understanding the conversion of a three-dimensional scene into a two-dimensional image that can be viewed. Grasping this conversion process paves the way for utilizing computers to develop software that produces &ldquo;synthetic&rdquo; images through emulation of these processes. Essentially, the creation of computer graphics often mimics natural phenomena (occasionally in reverse order), though surpassing nature&rsquo;s complexity is a feat yet to be achieved by humans – a limitation that, nevertheless, does not diminish the enjoyment derived from these endeavors. This lesson, and particularly this segment, lays out the foundational principles of Computer-Generated Imagery (CGI).</p>
<p>The lesson&rsquo;s second chapter delves into the ray-tracing algorithm, providing an overview of its functionality. We&rsquo;ve been queried by many about our focus on ray tracing over other algorithms. Scratchapixel&rsquo;s aim is to present a diverse range of topics within computer animation, extending beyond rendering to include aspects like animation and simulation. The choice to spotlight ray tracing stems from its straightforward approach to simulating the physical reasons behind object visibility. Hence, for beginners, ray tracing emerges as the ideal method to elucidate the image generation process from code. This rationale underpins our preference for ray tracing in this introductory lesson, with subsequent lessons also linking back to ray tracing. However – be reassured – we will learn about alternative rendering techniques, such as scanline rendering, which remains the predominant method for image generation via GPUs.</p>
<p>This lesson is perfectly suited for those merely curious about computer-generated 3D graphics without the intention of pursuing a career in this field. It is designed to be self-explanatory, packed with sufficient information, and includes a simple, compilable program that facilitates a comprehensive understanding of the concept. With this knowledge, you can acknowledge your familiarity with the subject and proceed with your life or, if inspired by CGI, delve deeper into the field—a domain fueled by passion, where creating meaningful computer-generated pixels is nothing short of extraordinary. More lessons await those interested to expand their understanding and skills in CGI programming.</p>
<p>Scratchapixel is tailored for beginners with minimal background in mathematics or physics. We aim to explain everything from the ground up in straightforward English, accompanied by coding examples to demonstrate the practical application of theoretical concepts. Let&rsquo;s embark on this journey together&hellip;</p>
<h3 id="how-is-an-image-created">How Is an Image Created?</h3>
<p><a href="#R-image-fe9a3bd3534660c8e9034dcbf60ef046" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/../assets/vantagepoint.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-fe9a3bd3534660c8e9034dcbf60ef046"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/../assets/vantagepoint.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 1:</strong> <em>we can visualize a picture as a cut made through a pyramid whose apex is located at the center of our eye and whose height is parallel to our line of sight.</em></p>
<p>The creation of an image necessitates a two-dimensional surface, which acts as the medium for projection. Conceptually, this can be imagined as slicing through a pyramid, with the apex positioned at the viewer&rsquo;s eye and extending in the direction of the line of sight. This conceptual slice is termed the <strong>image plane</strong>, akin to a canvas for artists. It serves as the stage upon which the three-dimensional scene is projected to form a two-dimensional image. This fundamental principle underlies the image creation process across various mediums, from the photographic film or digital sensor in cameras to the traditional canvas of painters, illustrating the universal application of this concept in visual representation.</p>
<h3 id="perspective-projection">Perspective Projection</h3>
<p>Perspective projection is a technique that translates three-dimensional objects onto a two-dimensional plane, creating the illusion of depth and space on a flat surface. Imagine wanting to depict a cube on a blank canvas. The process begins by drawing lines from each corner of the cube towards the viewer&rsquo;s eye. Where each line intersects the image plane—a flat surface akin to a canvas or the screen of a camera—a mark is made. For instance, if a cube corner labeled c0 connects to corners c1, c2, and c3, their projection onto the canvas results in points c0&rsquo;, c1&rsquo;, c2&rsquo;, and c3&rsquo;. Lines are then drawn between these projected points on the canvas to represent the cube&rsquo;s edges, such as from c0&rsquo; to c1&rsquo; and from c0&rsquo; to c2'.</p>
<p><a href="#R-image-f848b4b0055b7b066807aadd789fd6ee" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/../assets/projperspective.gif" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f848b4b0055b7b066807aadd789fd6ee"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/../assets/projperspective.gif" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 2:</strong> <em>Projecting the four corners of the front face of a cube onto a canvas.</em></p>
<p>Repeating this procedure for all cube edges yields a two-dimensional depiction of the cube. This method, known as perspective projection, was mastered by painters in the early 15th century and allows for the representation of a scene from a specific viewpoint.</p>
<h3 id="light-and-color">Light and Color</h3>
<p>After mastering the technique of sketching the outlines of three-dimensional objects onto a two-dimensional surface, the next step in creating a vivid image involves the addition of color.</p>
<p>Briefly recapping our learning: the process of transforming a three-dimensional scene into an image unfolds in two primary steps. Initially, we project the contours of the three-dimensional objects onto a two-dimensional plane, known as the image surface or image plane. This involves drawing lines from the object&rsquo;s edges to the observer&rsquo;s viewpoint and marking where these lines intersect with the image plane, thereby sketching the object&rsquo;s outline—a purely geometric task. Following this, the second step involves coloring within these outlines, a technique referred to as shading, which brings the image to life.</p>
<p>The color and brightness of an object within a scene are predominantly determined by how light interacts with the material of the object. Light consists of photons, electromagnetic particles that embody both electric and magnetic properties. These particles carry energy and oscillate similarly to sound waves, traveling in direct lines. Sunlight is a prime example of a natural light source emitting photons. When photons encounter an object, they can be absorbed, reflected, or transmitted, with the outcome varying depending on the material&rsquo;s properties. However, a universal principle across all materials is the conservation of photon count: the sum of absorbed, reflected, and transmitted photons must equal the initial number of incoming photons. For instance, if 100 photons illuminate an object&rsquo;s surface, the distribution of absorbed and reflected photons must total 100, ensuring energy conservation.</p>
<p>Materials are broadly categorized into two types: <strong>conductors</strong>, which are metals, and <strong>dielectrics</strong>, encompassing non-metals such as glass, plastic, wood, and water. Interestingly, dielectrics are insulators of electricity, with even pure water acting as an insulator. These materials may vary in their transparency, with some being completely opaque and others transparent to certain wavelengths of electromagnetic radiation, like X-rays penetrating human tissue.</p>
<p>Moreover, materials can be composite or layered, combining different properties. For example, a wooden object might be coated with a transparent layer of varnish, giving it a simultaneously diffuse and glossy appearance, similar to the effect seen on colored plastic balls. This complexity in material composition adds depth and realism to the rendered scene by mimicking the multifaceted interactions between light and surfaces in the real world.</p>
<p><a href="#R-image-8429f884cb4455c0f1fe7d2b09e2e4a5" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/../assets/material.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-8429f884cb4455c0f1fe7d2b09e2e4a5"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/../assets/material.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Focusing on opaque and diffuse materials simplifies the understanding of how objects acquire their color. The color perception of an object under white light, which is composed of red, blue, and green photons, is determined by which photons are absorbed and which are reflected. For instance, a red object under white light appears red because it absorbs the blue and green photons while reflecting the red photons. The visibility of the object is due to the reflected red photons reaching our eyes, where each point on the object&rsquo;s surface disperses light rays in all directions. However, only the rays that strike our eyes perpendicularly are perceived, converted by the photoreceptors in our eyes into neural signals. These signals are then processed by our brain, enabling us to discern different colors and shades, though the exact mechanisms of this process are complex and still being explored. This explanation offers a simplified view of the intricate phenomena involved, with further details available in specialized lessons on color in the field of computer graphics.</p>
<p><a href="#R-image-5ef2d2193186873364e2608232d75e13" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/../assets/lighttoeye.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-5ef2d2193186873364e2608232d75e13"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/../assets/lighttoeye.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 3:</strong> <em>al-Haytham&rsquo;s model of light perception.</em></p>
<p>The understanding of light and how we perceive it has evolved significantly over time. Ancient Greek philosophers posited that vision occurred through beams of light emitted from the eyes, interacting with the environment. Contrary to this, the Arab scholar <strong>Ibn al-Haytham</strong> (c. 965-1039) introduced a groundbreaking theory, explaining that vision results from light rays originating from luminous bodies like the sun, reflecting off objects and into our eyes, thereby forming visual images. This model marked a pivotal shift in the comprehension of light and vision, laying the groundwork for the modern scientific approach to studying light behavior. As we delve into simulating these natural processes with computers, these historical insights provide a rich context for the development of realistic rendering techniques in computer graphics.</p>
<h2 id="the-raytracing-algorithm-in-a-nutshell">The Raytracing Algorithm in a Nutshell</h2>
<p><strong>Reading time: 8 mins.</strong></p>
<p>Ibn al-Haytham&rsquo;s work sheds light on the fundamental principles behind our ability to see objects. From his studies, two key observations emerge: first, without light, visibility is null, and second, without objects to interact with, light itself remains invisible to us. This becomes evident in scenarios such as traveling through intergalactic space, where the absence of matter results in nothing but darkness, despite the potential presence of photons traversing the void (assuming photons are present, they must originate from a source, and seeing them would involve their direct interaction with our eyes, revealing the source from which they were reflected or emitted).</p>
<h3 id="forward-tracing">Forward Tracing</h3>
<p><a href="#R-image-2ded8cf5c966658d58a698fcaf4f88d0" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/../assets/lighttoeyebounce.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-2ded8cf5c966658d58a698fcaf4f88d0"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/../assets/lighttoeyebounce.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><em><strong>Figure 1:</strong> countless photons emitted by the light source hit the green sphere, but only one will reach the eye&rsquo;s surface.</em></p>
<p>In the context of simulating the interaction between light and objects in computer graphics, it&rsquo;s crucial to understand another physical concept. Of the myriad rays reflected off an object, only a minuscule fraction will actually be perceived by the human eye. For instance, consider a hypothetical light source designed to emit a single photon at a time. When this photon is released, it travels in a straight line until it encounters an object&rsquo;s surface. Assuming no absorption, the photon is then reflected in a seemingly random direction. If this photon reaches our eye, we discern the point of its reflection on the object (as illustrated in figure 1).</p>
<blockquote>
<p><em>You&rsquo;ve stated previously that &ldquo;each point on an illuminated object disperses light rays in all directions.&rdquo; How does this align with the notion of &lsquo;random&rsquo; reflection?</em></p>
<p>The comprehensive explanation for light&rsquo;s omnidirectional reflection from surfaces falls outside this lesson&rsquo;s scope (for a detailed discussion, refer to the lesson on light-matter interaction). To succinctly address your query: it&rsquo;s both yes and no. Naturally, a photon&rsquo;s reflection off a surface follows a specific direction, determined by the surface&rsquo;s microstructure and the photon&rsquo;s approach angle. Although an object&rsquo;s surface may appear uniformly smooth to the naked eye, microscopic examination reveals a complex topography. The accompanying image illustrates paper under varying magnifications, highlighting this microstructure. Given photons&rsquo; diminutive scale, they are reflected by the myriad micro-features on a surface. When a light beam contacts a diffuse object, the photons encounter diverse parts of this microstructure, scattering in numerous directions—so many, in fact, that it simulates reflection in &ldquo;every conceivable direction.&rdquo; In simulations of photon-surface interactions, rays are cast in random directions, which statistically mirrors the effect of omnidirectional reflection.</p>
<p>Certain materials exhibit organized macrostructures that guide light reflection in specific directions, a phenomenon known as anisotropic reflection. This, along with other unique optical effects like iridescence seen in butterfly wings, stems from the material&rsquo;s macroscopic structure and will be explored in detail in lessons on light-material interactions.</p>
<p><a href="#R-image-327c1c0c7935051748de775d9d632bda" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/../assets/paperstruct.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-327c1c0c7935051748de775d9d632bda"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/../assets/paperstruct.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
</blockquote>
<p>In the realm of computer graphics, we substitute our eyes with an image plane made up of pixels. Here, photons emitted by a light source impact the pixels on this plane, incrementally brightening them. This process continues until all pixels have been appropriately adjusted, culminating in the creation of a computer-generated image. This method is referred to as <strong>forward ray tracing</strong>, tracing the path of photons from their source to the observer.</p>
<p>Yet, this approach raises a significant issue:</p>
<p>In our scenario, we assumed that every reflected photon would intersect with the eye&rsquo;s surface. However, given that rays scatter in all possible directions, each has a minuscule chance of actually reaching the eye. To encounter just one photon that hits the eye, an astronomical number of photons would need to be emitted from the light source. This mirrors the natural world, where countless photons move in all directions at the speed of light. For computational purposes, simulating such an extensive interaction between photons and objects in a scene is impractical, as we will soon elaborate.</p>
<p>One might ponder: &ldquo;Should we not direct photons towards the eye, knowing its location, to ascertain which pixel they intersect, if any?&rdquo; This could serve as an optimization for certain material types. We&rsquo;ll later delve into how diffuse surfaces, which reflect photons in all directions within a hemisphere around the contact point&rsquo;s normal, don&rsquo;t require directional precision. However, for mirror-like surfaces that reflect rays in a precise, mirrored direction (a computation we&rsquo;ll explore later), arbitrarily altering the photon&rsquo;s direction is not viable, making this solution less than ideal.</p>
<blockquote>
<p><em>Is the eye merely a point receptor, or does it possess a surface area? Even if small, the receiving surface is larger than a point, thus capable of capturing more than a singular ray out of zillions.</em></p>
<p>Indeed, the eye functions more like a surface receptor, akin to the film or CCD in cameras, rather than a mere point receptor. This introduction to the ray-tracing algorithm doesn&rsquo;t delve deeply into this aspect. Cameras and eyes alike utilize a lens to focus reflected light onto a surface. Should the lens be extremely small (unlike actuality), reflected light from an object would be confined to a single direction, reminiscent of pinhole cameras&rsquo; operation, a topic for future discussion.</p>
</blockquote>
<p>Even adopting this approach for scenes composed solely of diffuse objects presents challenges. Visualize directing photons from a light source into a scene as akin to spraying paint particles onto an object&rsquo;s surface. Insufficient spray density results in uneven illumination.</p>
<p>Consider the analogy of attempting to paint a teapot by dotting a black sheet of paper with a white marker, with each dot representing a photon. Initially, only a sparse number of photons intersect the teapot, leaving vast areas unmarked. Increasing the dots gradually fills in the gaps, making the teapot progressively more discernible.</p>
<p><a href="#R-image-96b7a58706c653c1824d49451e0601db" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/../assets/teapotracing.gif" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-96b7a58706c653c1824d49451e0601db"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/../assets/teapotracing.gif" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>However, deploying even thousands or multiples thereof of photons cannot guarantee complete coverage of the object&rsquo;s surface. This method&rsquo;s inherent flaw necessitates running the program until we subjectively deem enough photons have been applied to accurately depict the object. This process, requiring constant monitoring of the rendering process, is impractical in a production setting. The primary cost in ray tracing lies in detecting ray-geometry intersections, not in generating photons, but in identifying all their intersections within the scene, which is exceedingly resource-intensive.</p>
<p>Conclusion: <strong>Forward ray tracing</strong> or <strong>light tracing</strong>, which involves casting rays from the light source, can theoretically replicate natural light behavior on a computer. However, as discussed, this technique is neither efficient nor practical for actual use. Turner Whitted, a pioneer in computer graphics research, critiqued this method in his seminal 1980 paper, &ldquo;An Improved Illumination Model for Shaded Display&rdquo;, noting:</p>
<blockquote>
<p>In an evident approach to ray tracing, light rays emanating from a source are traced through their paths until they strike the viewer. Since only a few will reach the viewer, this approach could be better. In a second approach suggested by Appel, rays are traced in the opposite direction, from the viewer to the objects in the scene.</p>
</blockquote>
<p>Let&rsquo;s explore this alternative strategy Whitted mentions.</p>
<h3 id="backward-tracing">Backward Tracing</h3>
<p><a href="#R-image-8f52f116e368a8d0c975b79e06b1e32f" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/../assets/tracefromeyetolight.gif" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-8f52f116e368a8d0c975b79e06b1e32f"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/../assets/tracefromeyetolight.gif" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 2:</strong> <em>backward ray-tracing. We trace a ray from the eye to a point on the sphere, then a ray from that point to the light source.</em></p>
<p>In contrast to the natural process where rays emanate from the light source to the receptor (like our eyes), backward tracing reverses this flow by initiating rays from the receptor towards the objects. This technique, known as <strong>backward ray-tracing</strong> or <strong>eye tracing</strong> because rays commence from the eye&rsquo;s position (as depicted in figure 2), effectively addresses the limitations of forward ray tracing. Given the impracticality of mirroring nature&rsquo;s efficiency and perfection in simulations, we adopt a compromise by casting a ray from the eye into the scene. Upon impacting an object, we evaluate the light it receives by dispatching another ray—termed a light or shadow ray—from the contact point towards the light source. If this &ldquo;light ray&rdquo; encounters obstruction by another object, it indicates that the initial point of contact is shadowed, receiving no light. Hence, these rays are more aptly called <strong>shadow rays</strong>. The inaugural ray shot from the eye (or camera) into the scene is referred to in computer graphics literature as a <strong>primary ray</strong>, <strong>visibility ray</strong>, or <strong>camera ray</strong>.</p>
<blockquote>
<p>Throughout this lesson, forward tracing is used to describe the method of casting rays from the light, in contrast to backward tracing, where rays are projected from the camera. Nonetheless, some authors invert these terminologies, with forward tracing denoting rays emitted from the camera due to its prevalence in CG path-tracing techniques. To circumvent confusion, the explicit terms of light and eye tracing can be employed, particularly within discussions on bi-directional path tracing (refer to the Light Transport section for more).</p>
</blockquote>
<h3 id="conclusion">Conclusion</h3>
<p>The technique of initiating rays either from the light source or from the eye is encapsulated by the term <strong>path tracing</strong> in computer graphics. While ray-tracing is a synonymous term, path tracing emphasizes the methodological essence of generating computer-generated imagery by tracing the journey of light from its source to the camera, or vice versa. This approach facilitates the realistic simulation of optical phenomena such as caustics or indirect illumination, where light reflects off surfaces within the scene. These subjects are slated for exploration in forthcoming lessons.</p>
<h2 id="implementing-the-raytracing-algorithm">Implementing the Raytracing Algorithm</h2>
<p><strong>Reading time: 5 mins.</strong></p>
<p>Armed with an understanding of light-matter interactions, cameras and digital images, we are poised to construct our very first ray tracer. This chapter will delve into the heart of the ray-tracing algorithm, laying the groundwork for our exploration. However, it&rsquo;s important to note that what we develop here in this chapter won&rsquo;t yet be a complete, functioning program. For the moment, I invite you to trust in the learning process, understanding that the functions we mention without providing explicit code will be thoroughly explained as we progress.</p>
<p>Remember, this lesson bears the title &ldquo;Raytracing in a Nutshell.&rdquo; In subsequent lessons, we&rsquo;ll delve into greater detail on each technique introduced, progressively enhancing our understanding and our ability to simulate light and shadow through computation. Nevertheless, by the end of this lesson, you&rsquo;ll have crafted a functional ray tracer capable of compiling and generating images. This marks not just a significant milestone in your learning journey but also a testament to the power and elegance of ray tracing in generating images. Let&rsquo;s go.</p>
<p>Consider the natural propagation of light: a myriad of rays emitted from various light sources, meandering until they converge upon the eye&rsquo;s surface. Ray tracing, in its essence, mirrors this natural phenomenon, albeit in reverse, rendering it a virtually flawless simulator of reality.</p>
<p>The essence of the ray-tracing algorithm is to render an image pixel by pixel. For each pixel, it launches a primary ray into the scene, its direction determined by drawing a line from the eye through the pixel&rsquo;s center. This primary ray&rsquo;s journey is then tracked to ascertain if it intersects with any scene objects. In scenarios where multiple intersections occur, the algorithm selects the intersection nearest to the eye for further processing. A secondary ray, known as a shadow ray, is then projected from this nearest intersection point towards the light source (Figure 1).</p>
<p><a href="#R-image-1ebf7019502ff804a50978181f57a06a" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/../assets/lightingnoshadow.gif" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-1ebf7019502ff804a50978181f57a06a"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/../assets/lightingnoshadow.gif" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 1:</strong> <em>A primary ray is cast through the pixel center to detect object intersections. Upon finding one, a shadow ray is dispatched to determine the illumination status of the point.</em></p>
<p>An intersection point is deemed illuminated if the shadow ray reaches the light source unobstructed. Conversely, if it intersects another object en route, it signifies the casting of a shadow on the initial point (Figure 2).</p>
<p><a href="#R-image-ccefaaadf32613ba8858a19a76c837d2" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/../assets/lightingshadow.gif" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-ccefaaadf32613ba8858a19a76c837d2"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/../assets/lightingshadow.gif" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 2:</strong> <em>A shadow is cast on the larger sphere by the smaller one, as the shadow ray encounters the smaller sphere before reaching the light.</em></p>
<p>Repeating this procedure across all pixels yields a two-dimensional depiction of our three-dimensional scene (Figure 3).</p>
<p><a href="#R-image-9bcd6b876d4f1a2016b4dee547b36352" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/../assets/pixelrender.gif" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-9bcd6b876d4f1a2016b4dee547b36352"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/../assets/pixelrender.gif" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 3:</strong> <em>Rendering a frame involves dispatching a primary ray for every pixel within the frame buffer.</em></p>
<p>Below is the pseudocode for implementing this algorithm:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">imageHeight</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">imageWidth</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">        <span class="c1">// Determine the direction of the primary ray
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1"></span>        <span class="n">Ray</span> <span class="n">primRay</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">        <span class="n">computePrimRay</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">primRay</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">        <span class="c1">// Initiate a search for intersections within the scene
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1"></span>        <span class="n">Point</span> <span class="n">pHit</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        <span class="n">Normal</span> <span class="n">nHit</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">        <span class="kt">float</span> <span class="n">minDist</span> <span class="o">=</span> <span class="n">INFINITY</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">10</span><span class="cl">        <span class="n">Object</span> <span class="o">*</span><span class="n">object</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">11</span><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">objects</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln">12</span><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">Intersect</span><span class="p">(</span><span class="n">objects</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">primRay</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pHit</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nHit</span><span class="p">))</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln">13</span><span class="cl">                <span class="kt">float</span> <span class="n">distance</span> <span class="o">=</span> <span class="n">Distance</span><span class="p">(</span><span class="n">eyePosition</span><span class="p">,</span> <span class="n">pHit</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">14</span><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">distance</span> <span class="o">&lt;</span> <span class="n">minDist</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln">15</span><span class="cl">                    <span class="n">object</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">objects</span><span class="p">[</span><span class="n">k</span><span class="p">];</span> 
</span></span><span class="line"><span class="ln">16</span><span class="cl">                    <span class="n">minDist</span> <span class="o">=</span> <span class="n">distance</span><span class="p">;</span>  <span class="c1">// Update the minimum distance
</span></span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="c1"></span>                <span class="p">}</span> 
</span></span><span class="line"><span class="ln">18</span><span class="cl">            <span class="p">}</span> 
</span></span><span class="line"><span class="ln">19</span><span class="cl">        <span class="p">}</span> 
</span></span><span class="line"><span class="ln">20</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">object</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln">21</span><span class="cl">            <span class="c1">// Illuminate the intersection point
</span></span></span><span class="line"><span class="ln">22</span><span class="cl"><span class="c1"></span>            <span class="n">Ray</span> <span class="n">shadowRay</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">23</span><span class="cl">            <span class="n">shadowRay</span><span class="p">.</span><span class="n">direction</span> <span class="o">=</span> <span class="n">lightPosition</span> <span class="o">-</span> <span class="n">pHit</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">24</span><span class="cl">            <span class="kt">bool</span> <span class="n">isInShadow</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">25</span><span class="cl">            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">objects</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln">26</span><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">Intersect</span><span class="p">(</span><span class="n">objects</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">shadowRay</span><span class="p">))</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln">27</span><span class="cl">                    <span class="n">isInShadow</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">28</span><span class="cl">                    <span class="k">break</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">29</span><span class="cl">                <span class="p">}</span> 
</span></span><span class="line"><span class="ln">30</span><span class="cl">            <span class="p">}</span> 
</span></span><span class="line"><span class="ln">31</span><span class="cl">        <span class="p">}</span> 
</span></span><span class="line"><span class="ln">32</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isInShadow</span><span class="p">)</span> 
</span></span><span class="line"><span class="ln">33</span><span class="cl">            <span class="n">pixels</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">object</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">*</span> <span class="n">light</span><span class="p">.</span><span class="n">brightness</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">34</span><span class="cl">        <span class="k">else</span> 
</span></span><span class="line"><span class="ln">35</span><span class="cl">            <span class="n">pixels</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">36</span><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="ln">37</span><span class="cl"><span class="p">}</span> 
</span></span></code></pre></div><p>The elegance of ray tracing lies in its simplicity and direct correlation with the physical world, allowing for the creation of a basic ray tracer in as few as 200 lines of code. This simplicity contrasts sharply with more complex algorithms, like scanline rendering, making ray tracing comparatively effortless to implement.</p>
<p>Arthur Appel first introduced ray tracing in his 1969 paper, &ldquo;Some Techniques for Shading Machine Renderings of Solids&rdquo;. Given its numerous advantages, one might wonder why ray tracing hasn&rsquo;t completely supplanted other rendering techniques. The primary hindrance, both historically and to some extent currently, is its computational speed. As Appel noted:</p>
<blockquote>
<p>This method is very time consuming, usually requiring several thousand times as much calculation time for beneficial results as a wireframe drawing. About one-half of this time is devoted to determining the point-to-point correspondence of the projection and the scene.</p>
</blockquote>
<p>Thus, the crux of the issue with ray tracing is its slowness—a sentiment echoed by James Kajiya, a pivotal figure in computer graphics, who remarked, &ldquo;ray tracing is not slow - computers are&rdquo;. The challenge lies in the extensive computation required to calculate ray-geometry intersections. For years, this computational demand was the primary drawback of ray tracing. However, with the continual advancement of computing power, this limitation is becoming increasingly mitigated. Although ray tracing remains slower compared to methods like z-buffer algorithms, modern computers can now render frames in minutes that previously took hours. The development of real-time and interactive ray tracing is currently a vibrant area of research.</p>
<p>In summary, ray tracing&rsquo;s rendering process can be bifurcated into visibility determination and shading, both of which necessitate computationally intensive ray-geometry intersection tests. This method offers a trade-off between rendering speed and accuracy. Since Appel&rsquo;s seminal work, extensive research has been conducted to expedite ray-object intersection calculations. With these advancements and the rise in computing power, ray tracing has emerged as a standard in offline rendering software. While rasterization algorithms continue to dominate video game engines, the advent of GPU-accelerated ray tracing and RTX technology in 2017-2018 marks a significant milestone towards real-time ray tracing. Some video games now feature options to enable ray tracing, albeit for limited effects like enhanced reflections and shadows, heralding a new era in gaming graphics.</p>
<h2 id="adding-reflection-and-refraction">Adding Reflection and Refraction</h2>
<p><strong>Reading time: 6 mins.</strong></p>
<p>Another key benefit of ray tracing is its capacity to seamlessly simulate intricate optical effects such as <strong>reflection</strong> and <strong>refraction</strong>. These capabilities are crucial for accurately rendering materials like glass or mirrored surfaces. <strong>Turner Whitted</strong> pioneered the enhancement of Appel&rsquo;s basic ray-tracing algorithm to include such advanced rendering techniques in his landmark 1979 paper, &ldquo;An Improved Illumination Model for Shaded Display.&rdquo; Whitted&rsquo;s innovation involved extending the algorithm to account for the computations necessary for handling reflection and refraction effects.</p>
<p><a href="#R-image-fc634f9c68ebfecf324171bf19b2db12" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/../assets/boule-neige.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-fc634f9c68ebfecf324171bf19b2db12"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/../assets/boule-neige.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Reflection and refraction are fundamental optical phenomena. While detailed exploration of these concepts will occur in a future lesson, it&rsquo;s beneficial to understand their basics for simulation purposes. Consider a glass sphere that exhibits both reflective and refractive qualities. Knowing the incident ray&rsquo;s direction upon the sphere allows us to calculate the subsequent behavior of the ray. The directions for both reflected and refracted rays are determined by the surface normal at the point of contact and the incident ray&rsquo;s approach. Additionally, calculating the direction of refraction requires knowledge of the material&rsquo;s <strong>index of refraction</strong>. Refraction can be visualized as the bending of the ray&rsquo;s path when it transitions between mediums of differing refractive indices.</p>
<p>It&rsquo;s also important to recognize that materials like a glass sphere possess both reflective and refractive properties simultaneously. The challenge arises in determining how to blend these effects at a specific surface point. Is it as simple as combining 50% reflection with 50% refraction? The reality is more complex. The blend ratio is influenced by the angle of incidence and factors like the surface normal and the material&rsquo;s refractive index. Here, the <strong>Fresnel equation</strong> plays a critical role, providing the formula needed to ascertain the appropriate mix of reflection and refraction.</p>
<p><a href="#R-image-f73f47dd4c430f04176933b4aa4b887a" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/../assets/reflectionrefraction.gif" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f73f47dd4c430f04176933b4aa4b887a"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/../assets/reflectionrefraction.gif" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 1:</strong> <em>Utilizing optical principles to calculate the paths of reflected and refracted rays.</em></p>
<p>In summary, the Whitted algorithm operates as follows: a primary ray is cast from the observer to identify the nearest intersection with any scene objects. Upon encountering a non-diffuse or transparent object, additional calculations are required. For an object such as a glass sphere, determining the surface color involves calculating both the reflected and refracted colors and then appropriately blending them according to the Fresnel equation. This three-step process—calculating reflection, calculating refraction, and applying the Fresnel equation—enables the realistic rendering of complex optical phenomena.</p>
<p><a href="#R-image-250ea44b3ba9f84d305e451d601a0b35" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/../assets/glassball.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-250ea44b3ba9f84d305e451d601a0b35"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/../assets/glassball.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>To achieve the realistic rendering of materials that exhibit both reflection and refraction, such as glass, the ray-tracing algorithm incorporates a few key steps:</p>
<ul>
<li><strong>Reflection Calculation</strong>: The first step involves determining the direction in which light is reflected off an object. This calculation requires two critical pieces of information: the surface normal at the point of intersection and the incoming direction of the primary ray. With the reflection direction determined, a new ray is cast into the scene. For instance, if this reflection ray encounters a red sphere, we use the established algorithm to assess the amount of light reaching that point on the sphere by sending a shadow ray toward the light source. The color acquired (which turns black if in shadow) is then adjusted by the light&rsquo;s intensity before being factored into the final color reflected back to the surface of the glass ball.</li>
<li><strong>Refraction Calculation</strong>: Next, we simulate the refraction effect, or the bending of light, as it passes through the glass ball, referred to as the <strong>transmission ray</strong>. To accurately compute the ray&rsquo;s new direction upon entering and exiting the glass, the normal at the point of intersection, the direction of the primary ray, and the material&rsquo;s refractive index are required. As the refractive ray exits the sphere, it undergoes refraction once more due to the change in medium, altering its path. This bending effect is responsible for the visual distortion seen when looking through materials with different refractive indices. If this refracted ray then intersects with, for example, a green sphere, local illumination at that point is calculated (again using a shadow ray), and the resulting color is influenced by whether the point is in shadow or light, which is then considered in the visual effect on the glass ball&rsquo;s surface.</li>
<li><strong>Applying the Fresnel Equation</strong>: The final step involves using the Fresnel equation to calculate the proportions of reflected and refracted light contributing to the color at the point of interest on the glass ball. The equation requires the refractive index of the material, the angle between the primary ray and the normal at the point of intersection, and outputs the mixing values for reflection and refraction.</li>
</ul>
<p>The pseudo-code provided outlines the process of integrating reflection and refraction colors to determine the appearance of a glass ball at the point of intersection:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="c1">// compute reflection color
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1"></span><span class="n">color</span> <span class="n">reflectionColor</span> <span class="o">=</span> <span class="n">computeReflectionColor</span><span class="p">();</span> 
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1">// compute refraction color
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="c1"></span><span class="n">color</span> <span class="n">refractionColor</span> <span class="o">=</span> <span class="n">computeRefractionColor</span><span class="p">();</span> 
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="kt">float</span> <span class="n">Kr</span><span class="p">;</span> <span class="c1">// reflection mix value
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="c1"></span><span class="kt">float</span> <span class="n">Kt</span><span class="p">;</span> <span class="c1">// refraction mix value
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1">// Calculate the mixing values using the Fresnel equation
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="c1"></span><span class="n">fresnel</span><span class="p">(</span><span class="n">refractiveIndex</span><span class="p">,</span> <span class="n">normalHit</span><span class="p">,</span> <span class="n">primaryRayDirection</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Kr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Kt</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="c1">// Mix the reflection and refraction colors based on the Fresnel equation. Note Kt = 1 - Kr
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="c1"></span><span class="n">glassBallColorAtHit</span> <span class="o">=</span> <span class="n">Kr</span> <span class="o">*</span> <span class="n">reflectionColor</span> <span class="o">+</span> <span class="n">Kt</span> <span class="o">*</span> <span class="n">refractionColor</span><span class="p">;</span></span></span></code></pre></div><p>The principle that light cannot be created or destroyed underpins the relationship between the reflected (Kr) and refracted (Kt) portions of incident light. This conservation of light means that the portion of light not reflected is necessarily refracted, ensuring that the sum of reflected and refracted light equals the total incoming light. This concept is elegantly captured by the Fresnel equation, which provides values for <code>Kr</code> and <code>Kt</code> that, when correctly calculated, should sum to one. This relationship allows for a simplification in calculations; knowing either <code>Kr</code> or <code>Kt</code> enables the determination of the other by simple subtraction from one.</p>
<p>This algorithm&rsquo;s beauty also lies in its <strong>recursive</strong> nature, which, while powerful, introduces complexity. For instance, if the reflection ray from our initial glass ball scenario strikes a red sphere and the refraction ray intersects with a green sphere, and both these spheres are also made of glass, the process of calculating reflection and refraction colors repeats for these new intersections. This recursive aspect allows for the detailed rendering of scenes with multiple reflective and refractive surfaces. However, it also presents challenges, particularly in scenarios like a camera inside a box with reflective interior walls, where rays could theoretically bounce indefinitely. To manage this, an arbitrary limit on recursion depth is imposed, ceasing the calculation once a ray reaches a predefined depth. This limitation ensures that the rendering process concludes, providing an approximate representation of the scene rather than becoming bogged down in endless calculations. While this may compromise absolute accuracy, it strikes a balance between detail and computational feasibility, ensuring that the rendering process yields results within practical timeframes.</p>
<h2 id="writing-a-basic-raytracer">Writing a Basic Raytracer</h2>
<p><strong>Reading time: 6 mins.</strong></p>
<p>Many of our readers have reached out, curious to see a practical example of ray tracing in action, asking, &ldquo;If it&rsquo;s as straightforward as you say, why not show us a real example?&rdquo; Deviating slightly from our original step-by-step approach to building a renderer, we decided to put together a basic ray tracer. This compact program, consisting of roughly 300 lines, was developed in just a few hours. While it&rsquo;s not a showcase of our best work (hopefully) — given the quick turnaround — we aimed to demonstrate that with a solid grasp of the underlying concepts, creating such a program is quite easy. The source code is up for grabs for those interested.</p>
<p>This quick project wasn&rsquo;t polished with detailed comments, and there&rsquo;s certainly room for optimization. In our ray tracer version, we chose to make the light source a visible sphere, allowing its reflection to be observed on the surfaces of reflective spheres. To address the challenge of visualizing transparent glass spheres—which can be tricky to detect due to their clear appearance—we opted to color them slightly red. This decision was informed by the real-world behavior of clear glass, which may not always be perceptible, heavily influenced by its surroundings. It&rsquo;s worth noting, however, that the image produced by this preliminary version isn&rsquo;t flawless; for example, the shadow cast by the transparent red sphere appears unrealistically solid. Future lessons will delve into refining such details for more accurate visual representation. Additionally, we experimented with implementing features like a simplified Fresnel effect (using a method known as the facing ratio) and refraction, topics we plan to explore in depth later on. If any of these concepts seem unclear, rest assured they will be clarified in due course. For now, you have a small, functional program to tinker with.</p>
<p>To get started with the program, first download the source code to your local machine. You&rsquo;ll need a C++ compiler, such as clang++, to compile the code. This program is straightforward to compile and doesn&rsquo;t require any special libraries. Open a terminal window (GitBash on Windows, or a standard terminal in Linux or macOS), navigate to the directory containing the source file, and run the following command (assuming you&rsquo;re using gcc):</p>
<div class="wrap-code highlight"><pre tabindex="0"><code>c++ -O3 -o raytracer raytracer.cpp</code></pre></div><p>If you use <code>clang</code>, use the following command instead:</p>
<div class="wrap-code highlight"><pre tabindex="0"><code>clang++ -O3 -o raytracer raytracer.cpp</code></pre></div><p>To generate an image, execute the program by entering ./raytracer into a terminal. After a brief pause, the program will produce a file named untitled.ppm on your computer. This file can be viewed using Photoshop, Preview (for Mac users), or Gimp. Additionally, we will cover how to open and view PPM images in an upcoming lesson.</p>
<p>Below is a sample implementation of the traditional recursive ray-tracing algorithm, presented in pseudo-code:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#define MAX_RAY_DEPTH 3 
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span> 
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">color</span> <span class="nf">Trace</span><span class="p">(</span><span class="k">const</span> <span class="n">Ray</span> <span class="o">&amp;</span><span class="n">ray</span><span class="p">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">)</span> 
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="n">Object</span> <span class="o">*</span><span class="n">object</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="kt">float</span> <span class="n">minDistance</span> <span class="o">=</span> <span class="n">INFINITY</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="n">Point</span> <span class="n">pHit</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="n">Normal</span> <span class="n">nHit</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">objects</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln">10</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">Intersect</span><span class="p">(</span><span class="n">objects</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">ray</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pHit</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nHit</span><span class="p">))</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln">11</span><span class="cl">            <span class="kt">float</span> <span class="n">distance</span> <span class="o">=</span> <span class="n">Distance</span><span class="p">(</span><span class="n">ray</span><span class="p">.</span><span class="n">origin</span><span class="p">,</span> <span class="n">pHit</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">12</span><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">distance</span> <span class="o">&lt;</span> <span class="n">minDistance</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln">13</span><span class="cl">                <span class="n">object</span> <span class="o">=</span> <span class="n">objects</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">                <span class="n">minDistance</span> <span class="o">=</span> <span class="n">distance</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">            <span class="p">}</span> 
</span></span><span class="line"><span class="ln">16</span><span class="cl">        <span class="p">}</span> 
</span></span><span class="line"><span class="ln">17</span><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="ln">18</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">object</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> 
</span></span><span class="line"><span class="ln">19</span><span class="cl">        <span class="k">return</span> <span class="n">backgroundColor</span><span class="p">;</span> <span class="c1">// Returning a background color instead of 0
</span></span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="c1"></span>    <span class="c1">// if the object material is glass and depth is less than MAX_RAY_DEPTH, split the ray
</span></span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">isGlass</span> <span class="o">&amp;&amp;</span> <span class="n">depth</span> <span class="o">&lt;</span> <span class="n">MAX_RAY_DEPTH</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln">22</span><span class="cl">        <span class="n">Ray</span> <span class="n">reflectionRay</span><span class="p">,</span> <span class="n">refractionRay</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">        <span class="n">color</span> <span class="n">reflectionColor</span><span class="p">,</span> <span class="n">refractionColor</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">24</span><span class="cl">        <span class="kt">float</span> <span class="n">Kr</span><span class="p">,</span> <span class="n">Kt</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">25</span><span class="cl"> 
</span></span><span class="line"><span class="ln">26</span><span class="cl">        <span class="c1">// Compute the reflection ray
</span></span></span><span class="line"><span class="ln">27</span><span class="cl"><span class="c1"></span>        <span class="n">reflectionRay</span> <span class="o">=</span> <span class="n">computeReflectionRay</span><span class="p">(</span><span class="n">ray</span><span class="p">.</span><span class="n">direction</span><span class="p">,</span> <span class="n">nHit</span><span class="p">,</span> <span class="n">ray</span><span class="p">.</span><span class="n">origin</span><span class="p">,</span> <span class="n">pHit</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">28</span><span class="cl">        <span class="n">reflectionColor</span> <span class="o">=</span> <span class="n">Trace</span><span class="p">(</span><span class="n">reflectionRay</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">29</span><span class="cl"> 
</span></span><span class="line"><span class="ln">30</span><span class="cl">        <span class="c1">// Compute the refraction ray
</span></span></span><span class="line"><span class="ln">31</span><span class="cl"><span class="c1"></span>        <span class="n">refractionRay</span> <span class="o">=</span> <span class="n">computeRefractionRay</span><span class="p">(</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">indexOfRefraction</span><span class="p">,</span> <span class="n">ray</span><span class="p">.</span><span class="n">direction</span><span class="p">,</span> <span class="n">nHit</span><span class="p">,</span> <span class="n">ray</span><span class="p">.</span><span class="n">origin</span><span class="p">,</span> <span class="n">pHit</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">32</span><span class="cl">        <span class="n">refractionColor</span> <span class="o">=</span> <span class="n">Trace</span><span class="p">(</span><span class="n">refractionRay</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">33</span><span class="cl"> 
</span></span><span class="line"><span class="ln">34</span><span class="cl">        <span class="c1">// Compute Fresnel&#39;s effect
</span></span></span><span class="line"><span class="ln">35</span><span class="cl"><span class="c1"></span>        <span class="n">fresnel</span><span class="p">(</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">indexOfRefraction</span><span class="p">,</span> <span class="n">nHit</span><span class="p">,</span> <span class="n">ray</span><span class="p">.</span><span class="n">direction</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Kr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Kt</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">36</span><span class="cl"> 
</span></span><span class="line"><span class="ln">37</span><span class="cl">        <span class="c1">// Combine reflection and refraction colors based on Fresnel&#39;s effect
</span></span></span><span class="line"><span class="ln">38</span><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="n">reflectionColor</span> <span class="o">*</span> <span class="n">Kr</span> <span class="o">+</span> <span class="n">refractionColor</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">Kr</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">39</span><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">isGlass</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Check if object is not glass (diffuse/opaque)
</span></span></span><span class="line"><span class="ln">40</span><span class="cl"><span class="c1"></span>        <span class="c1">// Compute illumination only if object is not in shadow
</span></span></span><span class="line"><span class="ln">41</span><span class="cl"><span class="c1"></span>        <span class="n">Ray</span> <span class="n">shadowRay</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">42</span><span class="cl">        <span class="n">shadowRay</span><span class="p">.</span><span class="n">origin</span> <span class="o">=</span> <span class="n">pHit</span> <span class="o">+</span> <span class="n">nHit</span> <span class="o">*</span> <span class="n">bias</span><span class="p">;</span> <span class="c1">// Adding a small bias to avoid self-intersection
</span></span></span><span class="line"><span class="ln">43</span><span class="cl"><span class="c1"></span>        <span class="n">shadowRay</span><span class="p">.</span><span class="n">direction</span> <span class="o">=</span> <span class="n">Normalize</span><span class="p">(</span><span class="n">lightPosition</span> <span class="o">-</span> <span class="n">pHit</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">44</span><span class="cl">        <span class="kt">bool</span> <span class="n">isInShadow</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">45</span><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">objects</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln">46</span><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">Intersect</span><span class="p">(</span><span class="n">objects</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">shadowRay</span><span class="p">))</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln">47</span><span class="cl">                <span class="n">isInShadow</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">48</span><span class="cl">                <span class="k">break</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">49</span><span class="cl">            <span class="p">}</span> 
</span></span><span class="line"><span class="ln">50</span><span class="cl">        <span class="p">}</span> 
</span></span><span class="line"><span class="ln">51</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isInShadow</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">52</span><span class="cl">            <span class="k">return</span> <span class="n">object</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">*</span> <span class="n">light</span><span class="p">.</span><span class="n">brightness</span><span class="p">;</span> <span class="c1">// point is illuminated
</span></span></span><span class="line"><span class="ln">53</span><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="ln">54</span><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="ln">55</span><span class="cl">    <span class="k">return</span> <span class="n">backgroundColor</span><span class="p">;</span> <span class="c1">// Return background color if no interaction
</span></span></span><span class="line"><span class="ln">56</span><span class="cl"><span class="c1"></span><span class="p">}</span> 
</span></span><span class="line"><span class="ln">57</span><span class="cl"> 
</span></span><span class="line"><span class="ln">58</span><span class="cl"><span class="c1">// Render loop for each pixel of the image
</span></span></span><span class="line"><span class="ln">59</span><span class="cl"><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">imageHeight</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln">60</span><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">imageWidth</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln">61</span><span class="cl">        <span class="n">Ray</span> <span class="n">primRay</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">62</span><span class="cl">        <span class="n">computePrimRay</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">primRay</span><span class="p">);</span> <span class="c1">// Assume computePrimRay correctly sets the ray origin and direction
</span></span></span><span class="line"><span class="ln">63</span><span class="cl"><span class="c1"></span>        <span class="n">pixels</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">Trace</span><span class="p">(</span><span class="n">primRay</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">64</span><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="ln">65</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p><a href="#R-image-8a06efd0ae2e552420bc1b81972b508e" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/../assets/raytrace1.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-8a06efd0ae2e552420bc1b81972b508e"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/../assets/raytrace1.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 1:</strong> <em>Result of our ray tracing algorithm.</em></p>
<h3 id="a-minimal-ray-tracer">A Minimal Ray Tracer</h3>
<p><a href="#R-image-cbd83334a5011b3a7ca1f5adea1ce380" class="lightbox-link"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/../assets/aek.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-cbd83334a5011b3a7ca1f5adea1ce380"><img src="../../../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/../assets/aek.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 2:</strong> <em>Result of our Paul Heckbert&rsquo;s ray tracing algorithm.</em></p>
<p>The concept of condensing a ray tracer to fit on a business card, pioneered by researcher Paul Heckbert, stands as a testament to the power of minimalistic programming. Heckbert&rsquo;s innovative challenge, aimed at distilling a ray tracer into the most concise C/C++ code possible, was detailed in his contribution to Graphics Gems IV. This initiative sparked a wave of enthusiasm among programmers, inspiring many to undertake this compact coding exercise.</p>
<p>A notable example of such an endeavor is a version crafted by Andrew Kensler. His work resulted in a visually compelling output, as demonstrated by the image produced by his program. Particularly impressive is the depth of field effect he achieved, where objects blur as they recede into the distance. The ability to generate an image of considerable complexity from a remarkably succinct piece of code is truly remarkable.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="c1">// minray &gt; minray.ppm
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;math.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="cp"></span><span class="k">typedef</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span><span class="k">typedef</span> <span class="kt">float</span> <span class="n">f</span><span class="p">;</span><span class="k">struct</span> <span class="nc">v</span><span class="p">{</span><span class="n">f</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">;</span><span class="n">v</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="n">v</span> <span class="n">r</span><span class="p">){</span><span class="k">return</span> <span class="nf">v</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">r</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">+</span><span class="n">r</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="o">+</span><span class="n">r</span><span class="p">.</span><span class="n">z</span><span class="p">);}</span><span class="n">v</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="n">f</span> <span class="n">r</span><span class="p">){</span><span class="k">return</span> <span class="nf">v</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">r</span><span class="p">,</span><span class="n">y</span><span class="o">*</span><span class="n">r</span><span class="p">,</span><span class="n">z</span><span class="o">*</span><span class="n">r</span><span class="p">);}</span><span class="n">f</span> <span class="k">operator</span><span class="o">%</span><span class="p">(</span><span class="n">v</span> <span class="n">r</span><span class="p">){</span><span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="n">r</span><span class="p">.</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="o">*</span><span class="n">r</span><span class="p">.</span><span class="n">y</span><span class="o">+</span><span class="n">z</span><span class="o">*</span><span class="n">r</span><span class="p">.</span><span class="n">z</span><span class="p">;}</span><span class="n">v</span><span class="p">(){}</span><span class="n">v</span> <span class="k">operator</span><span class="o">^</span><span class="p">(</span><span class="n">v</span> <span class="n">r</span><span class="p">){</span><span class="k">return</span> <span class="nf">v</span><span class="p">(</span><span class="n">y</span><span class="o">*</span><span class="n">r</span><span class="p">.</span><span class="n">z</span><span class="o">-</span><span class="n">z</span><span class="o">*</span><span class="n">r</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="o">*</span><span class="n">r</span><span class="p">.</span><span class="n">x</span><span class="o">-</span><span class="n">x</span><span class="o">*</span><span class="n">r</span><span class="p">.</span><span class="n">z</span><span class="p">,</span><span class="n">x</span><span class="o">*</span><span class="n">r</span><span class="p">.</span><span class="n">y</span><span class="o">-</span><span class="n">y</span><span class="o">*</span><span class="n">r</span><span class="p">.</span><span class="n">x</span><span class="p">);}</span><span class="n">v</span><span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">,</span><span class="n">f</span> <span class="n">b</span><span class="p">,</span><span class="n">f</span> <span class="n">c</span><span class="p">){</span><span class="n">x</span><span class="o">=</span><span class="n">a</span><span class="p">;</span><span class="n">y</span><span class="o">=</span><span class="n">b</span><span class="p">;</span><span class="n">z</span><span class="o">=</span><span class="n">c</span><span class="p">;}</span><span class="n">v</span> <span class="k">operator</span><span class="o">!</span><span class="p">(){</span><span class="k">return</span><span class="o">*</span><span class="k">this</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">sqrt</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="o">%*</span><span class="k">this</span><span class="p">));}};</span><span class="n">i</span> <span class="n">G</span><span class="p">[]</span><span class="o">=</span><span class="p">{</span><span class="mi">247570</span><span class="p">,</span><span class="mi">280596</span><span class="p">,</span><span class="mi">280600</span><span class="p">,</span><span class="mi">249748</span><span class="p">,</span><span class="mi">18578</span><span class="p">,</span><span class="mi">18577</span><span class="p">,</span><span class="mi">231184</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="p">};</span><span class="n">f</span> <span class="nf">R</span><span class="p">(){</span><span class="k">return</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="n">rand</span><span class="p">()</span><span class="o">/</span><span class="n">RAND_MAX</span><span class="p">;}</span><span class="n">i</span> <span class="nf">T</span><span class="p">(</span><span class="n">v</span> <span class="n">o</span><span class="p">,</span><span class="n">v</span> <span class="n">d</span><span class="p">,</span><span class="n">f</span><span class="o">&amp;</span><span class="n">t</span><span class="p">,</span><span class="n">v</span><span class="o">&amp;</span><span class="n">n</span><span class="p">){</span><span class="n">t</span><span class="o">=</span><span class="mf">1e9</span><span class="p">;</span><span class="n">i</span> <span class="n">m</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">f</span> <span class="n">p</span><span class="o">=-</span><span class="n">o</span><span class="p">.</span><span class="n">z</span><span class="o">/</span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="p">;</span><span class="k">if</span><span class="p">(</span><span class="mf">.01</span><span class="o">&lt;</span><span class="n">p</span><span class="p">)</span><span class="n">t</span><span class="o">=</span><span class="n">p</span><span class="p">,</span><span class="n">n</span><span class="o">=</span><span class="n">v</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">m</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="n">k</span><span class="o">=</span><span class="mi">19</span><span class="p">;</span><span class="n">k</span><span class="o">--</span><span class="p">;)</span><span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="n">j</span><span class="o">=</span><span class="mi">9</span><span class="p">;</span><span class="n">j</span><span class="o">--</span><span class="p">;)</span><span class="k">if</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">&amp;</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">k</span><span class="p">){</span><span class="n">v</span> <span class="n">p</span><span class="o">=</span><span class="n">o</span><span class="o">+</span><span class="n">v</span><span class="p">(</span><span class="o">-</span><span class="n">k</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="n">j</span><span class="o">-</span><span class="mi">4</span><span class="p">);</span><span class="n">f</span> <span class="n">b</span><span class="o">=</span><span class="n">p</span><span class="o">%</span><span class="n">d</span><span class="p">,</span><span class="n">c</span><span class="o">=</span><span class="n">p</span><span class="o">%</span><span class="n">p</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">q</span><span class="o">=</span><span class="n">b</span><span class="o">*</span><span class="n">b</span><span class="o">-</span><span class="n">c</span><span class="p">;</span><span class="k">if</span><span class="p">(</span><span class="n">q</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">){</span><span class="n">f</span> <span class="n">s</span><span class="o">=-</span><span class="n">b</span><span class="o">-</span><span class="n">sqrt</span><span class="p">(</span><span class="n">q</span><span class="p">);</span><span class="k">if</span><span class="p">(</span><span class="n">s</span><span class="o">&lt;</span><span class="n">t</span><span class="o">&amp;&amp;</span><span class="n">s</span><span class="o">&gt;</span><span class="mf">.01</span><span class="p">)</span><span class="n">t</span><span class="o">=</span><span class="n">s</span><span class="p">,</span><span class="n">n</span><span class="o">=!</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="n">d</span><span class="o">*</span><span class="n">t</span><span class="p">),</span><span class="n">m</span><span class="o">=</span><span class="mi">2</span><span class="p">;}}</span><span class="k">return</span> <span class="n">m</span><span class="p">;}</span><span class="n">v</span> <span class="nf">S</span><span class="p">(</span><span class="n">v</span> <span class="n">o</span><span class="p">,</span><span class="n">v</span> <span class="n">d</span><span class="p">){</span><span class="n">f</span> <span class="n">t</span><span class="p">;</span><span class="n">v</span> <span class="n">n</span><span class="p">;</span><span class="n">i</span> <span class="n">m</span><span class="o">=</span><span class="n">T</span><span class="p">(</span><span class="n">o</span><span class="p">,</span><span class="n">d</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">n</span><span class="p">);</span><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">m</span><span class="p">)</span><span class="k">return</span> <span class="n">v</span><span class="p">(</span><span class="mf">.7</span><span class="p">,</span><span class="mf">.6</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">pow</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span><span class="n">v</span> <span class="n">h</span><span class="o">=</span><span class="n">o</span><span class="o">+</span><span class="n">d</span><span class="o">*</span><span class="n">t</span><span class="p">,</span><span class="n">l</span><span class="o">=!</span><span class="p">(</span><span class="n">v</span><span class="p">(</span><span class="mi">9</span><span class="o">+</span><span class="n">R</span><span class="p">(),</span><span class="mi">9</span><span class="o">+</span><span class="n">R</span><span class="p">(),</span><span class="mi">16</span><span class="p">)</span><span class="o">+</span><span class="n">h</span><span class="o">*-</span><span class="mi">1</span><span class="p">),</span><span class="n">r</span><span class="o">=</span><span class="n">d</span><span class="o">+</span><span class="n">n</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">%</span><span class="n">d</span><span class="o">*-</span><span class="mi">2</span><span class="p">);</span><span class="n">f</span> <span class="n">b</span><span class="o">=</span><span class="n">l</span><span class="o">%</span><span class="n">n</span><span class="p">;</span><span class="k">if</span><span class="p">(</span><span class="n">b</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">||</span><span class="n">T</span><span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">n</span><span class="p">))</span><span class="n">b</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">f</span> <span class="n">p</span><span class="o">=</span><span class="n">pow</span><span class="p">(</span><span class="n">l</span><span class="o">%</span><span class="n">r</span><span class="o">*</span><span class="p">(</span><span class="n">b</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">),</span><span class="mi">99</span><span class="p">);</span><span class="k">if</span><span class="p">(</span><span class="n">m</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">){</span><span class="n">h</span><span class="o">=</span><span class="n">h</span><span class="o">*</span><span class="mf">.2</span><span class="p">;</span><span class="k">return</span><span class="p">((</span><span class="n">i</span><span class="p">)(</span><span class="n">ceil</span><span class="p">(</span><span class="n">h</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="o">+</span><span class="n">ceil</span><span class="p">(</span><span class="n">h</span><span class="p">.</span><span class="n">y</span><span class="p">))</span><span class="o">&amp;</span><span class="mi">1</span><span class="o">?</span><span class="n">v</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="n">v</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="n">b</span><span class="o">*</span><span class="mf">.2</span><span class="o">+</span><span class="mf">.1</span><span class="p">);}</span><span class="k">return</span> <span class="n">v</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">p</span><span class="p">)</span><span class="o">+</span><span class="n">S</span><span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="n">r</span><span class="p">)</span><span class="o">*</span><span class="mf">.5</span><span class="p">;}</span><span class="n">i</span> <span class="nf">main</span><span class="p">(){</span><span class="n">printf</span><span class="p">(</span><span class="s">&#34;P6 512 512 255 &#34;</span><span class="p">);</span><span class="n">v</span> <span class="n">g</span><span class="o">=!</span><span class="n">v</span><span class="p">(</span><span class="o">-</span><span class="mi">6</span><span class="p">,</span><span class="o">-</span><span class="mi">16</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="n">a</span><span class="o">=!</span><span class="p">(</span><span class="n">v</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">^</span><span class="n">g</span><span class="p">)</span><span class="o">*</span><span class="mf">.002</span><span class="p">,</span><span class="n">b</span><span class="o">=!</span><span class="p">(</span><span class="n">g</span><span class="o">^</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="mf">.002</span><span class="p">,</span><span class="n">c</span><span class="o">=</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">)</span><span class="o">*-</span><span class="mi">256</span><span class="o">+</span><span class="n">g</span><span class="p">;</span><span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="n">y</span><span class="o">=</span><span class="mi">512</span><span class="p">;</span><span class="n">y</span><span class="o">--</span><span class="p">;)</span><span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="n">x</span><span class="o">=</span><span class="mi">512</span><span class="p">;</span><span class="n">x</span><span class="o">--</span><span class="p">;){</span><span class="n">v</span> <span class="n">p</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">13</span><span class="p">);</span><span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="n">r</span><span class="o">=</span><span class="mi">64</span><span class="p">;</span><span class="n">r</span><span class="o">--</span><span class="p">;){</span><span class="n">v</span> <span class="n">t</span><span class="o">=</span><span class="n">a</span><span class="o">*</span><span class="p">(</span><span class="n">R</span><span class="p">()</span><span class="o">-</span><span class="mf">.5</span><span class="p">)</span><span class="o">*</span><span class="mi">99</span><span class="o">+</span><span class="n">b</span><span class="o">*</span><span class="p">(</span><span class="n">R</span><span class="p">()</span><span class="o">-</span><span class="mf">.5</span><span class="p">)</span><span class="o">*</span><span class="mi">99</span><span class="p">;</span><span class="n">p</span><span class="o">=</span><span class="n">S</span><span class="p">(</span><span class="n">v</span><span class="p">(</span><span class="mi">17</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span><span class="o">+</span><span class="n">t</span><span class="p">,</span><span class="o">!</span><span class="p">(</span><span class="n">t</span><span class="o">*-</span><span class="mi">1</span><span class="o">+</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="p">(</span><span class="n">R</span><span class="p">()</span><span class="o">+</span><span class="n">x</span><span class="p">)</span><span class="o">+</span><span class="n">b</span><span class="o">*</span><span class="p">(</span><span class="n">y</span><span class="o">+</span><span class="n">R</span><span class="p">())</span><span class="o">+</span><span class="n">c</span><span class="p">)</span><span class="o">*</span><span class="mi">16</span><span class="p">))</span><span class="o">*</span><span class="mf">3.5</span><span class="o">+</span><span class="n">p</span><span class="p">;}</span><span class="n">printf</span><span class="p">(</span><span class="s">&#34;%c%c%c&#34;</span><span class="p">,(</span><span class="n">i</span><span class="p">)</span><span class="n">p</span><span class="p">.</span><span class="n">x</span><span class="p">,(</span><span class="n">i</span><span class="p">)</span><span class="n">p</span><span class="p">.</span><span class="n">y</span><span class="p">,(</span><span class="n">i</span><span class="p">)</span><span class="n">p</span><span class="p">.</span><span class="n">z</span><span class="p">);}}</span></span></span></code></pre></div><p>To execute the program, start by copying and pasting the code into a new text document. Rename this file to something like <code>minray.cpp</code> or any other name you prefer. Next, compile the code using the command <code>c++ -O3 -o minray minray.cpp</code> or <code>clang++ -O3 -o minray minray.cpp</code> if you choose to use the clang compiler. Once compiled, run the program using the command line <code>minray &gt; minray.ppm</code>. This approach outputs the final image data directly to standard output (the terminal you&rsquo;re using), which is then redirected to a file using the <code>&gt;</code> operator, saving it as a PPM file. This file format is compatible with Photoshop, allowing for easy viewing.</p>
<p>The presentation of this program here is meant to demonstrate the compactness with which the ray tracing algorithm can be encapsulated. The code employs several techniques that will be detailed and expanded upon in subsequent lessons within this series.</p>
<p><a href="https://github.com/scratchapixel/code/tree/main/introduction-to-ray-tracing" target="_blank">Source Code (external link GitHub)</a></p>
<p><a href="https://gitee.com/zhaoshengxuan108/scratchapixel_code" target="_blank">Source Code (external link Gitee)</a></p>

            <footer class="footline">
            </footer>
          </article>

        </div>
      </main>
    </div>
    <script src="../../../../../js/clipboard.min.js?1708235103" defer></script>
    <script src="../../../../../js/perfect-scrollbar.min.js?1708235103" defer></script>
    <script src="../../../../../js/theme.js?1708235103" defer></script>
  </body>
</html>
