<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.122.0">
    <meta name="generator" content="Relearn 5.23.2+tip">
    <meta name="description" content="啊啊啊啊">
    <meta name="author" content="Sören Weber">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="https://example.com/images/hero.png">
    <meta name="twitter:title" content="光线追踪 :: Hugo Relearn Theme">
    <meta name="twitter:description" content="啊啊啊啊">
    <meta property="og:title" content="光线追踪 :: Hugo Relearn Theme">
    <meta property="og:description" content="啊啊啊啊">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://example.com/computer_graphics/classic_tutorial/raytracing_tutorial/index.html">
    <meta property="og:image" content="https://example.com/images/hero.png">
    <meta property="og:site_name" content="Hugo Relearn Theme">
    <title>光线追踪 :: Hugo Relearn Theme</title>
    <link href="https://example.com/computer_graphics/classic_tutorial/raytracing_tutorial/index.html" rel="canonical" type="text/html" title="光线追踪 :: Hugo Relearn Theme">
    <link href="../../../computer_graphics/classic_tutorial/raytracing_tutorial/index.xml" rel="alternate" type="application/rss+xml" title="光线追踪 :: Hugo Relearn Theme"><link rel="icon" href="../../../images/favicon.ico">
    <!-- https://github.com/filamentgroup/loadCSS/blob/master/README.md#how-to-use -->
    <link href="../../../css/fontawesome-all.min.css?1708235002" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../../../css/fontawesome-all.min.css?1708235002" rel="stylesheet"></noscript>
    <link href="../../../css/nucleus.css?1708235002" rel="stylesheet">
    <link href="../../../css/auto-complete.css?1708235002" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../../../css/auto-complete.css?1708235002" rel="stylesheet"></noscript>
    <link href="../../../css/perfect-scrollbar.min.css?1708235002" rel="stylesheet">
    <link href="../../../css/fonts.css?1708235002" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../../../css/fonts.css?1708235002" rel="stylesheet"></noscript>
    <link href="../../../css/theme.css?1708235002" rel="stylesheet">
    <link href="../../../css/theme-auto.css?1708235002" rel="stylesheet" id="R-variant-style">
    <link href="../../../css/variant.css?1708235002" rel="stylesheet">
    <link href="../../../css/print.css?1708235002" rel="stylesheet" media="print">
    <link href="../../../css/format-print.css?1708235002" rel="stylesheet">
    <link href="../../../css/ie.css?1708235002" rel="stylesheet">
    <script src="../../../js/url.js?1708235002"></script>
    <script src="../../../js/variant.js?1708235002"></script>
    <script>
      // hack to let hugo tell us how to get to the root when using relativeURLs, it needs to be called *url= for it to do its magic:
      // https://github.com/gohugoio/hugo/blob/145b3fcce35fbac25c7033c91c1b7ae6d1179da8/transform/urlreplacers/absurlreplacer.go#L72
      window.index_js_url="../../../index.search.js";
      var root_url="../../../";
      var baseUri=root_url.replace(/\/$/, '');
      window.relearn = window.relearn || {};
      window.relearn.baseUriFull='https:\/\/example.com/';
      // variant stuff
      window.variants && variants.init( [ 'auto', 'relearn-light', 'relearn-dark', 'zen-light', 'zen-dark', 'neon', 'learn', 'blue', 'green', 'red' ] );
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
    </script>
    <style>
      #R-body img.bg-white {
        background-color: white;
      }
    </style>
  </head>
  <body class="mobile-support print" data-url="../../../computer_graphics/classic_tutorial/raytracing_tutorial/index.html">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide">
              <button class="topbar-control" onclick="toggleNav()" type="button" title="Menu (CTRL&#43;ALT&#43;n)">
                <i class="fa-fw fas fa-bars"></i>
              </button>
            </div>
          </div>
          <ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype="http://schema.org/BreadcrumbList"><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../index.html"><span itemprop="name">主页</span></a><meta itemprop="position" content="1">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../computer_graphics/index.html"><span itemprop="name">计算机图形学</span></a><meta itemprop="position" content="2">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../../computer_graphics/classic_tutorial/index.html"><span itemprop="name">经典教程</span></a><meta itemprop="position" content="3">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><span itemprop="name">光线追踪</span><meta itemprop="position" content="4"></li>
          </ol>
          <div class="topbar-area topbar-area-end" data-area="end">
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable default" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="default">
            <header class="headline">
            </header>
<h1 id="光线追踪">光线追踪</h1>

<h2 id="前言">前言</h2>
<p>光线追踪首先要看的是 Peter Shirley 大师三部曲，<a href="https://raytracing.github.io/books/RayTracingInOneWeekend.html" target="_blank">《Ray Tracing in One Weekend》</a>、<a href="https://raytracing.github.io/books/RayTracingTheNextWeek.html" target="_blank">《Ray Tracing: The Next Week》</a>和<a href="https://raytracing.github.io/books/RayTracingTheRestOfYourLife.html" target="_blank">《Ray Tracing: The Rest of Your Life》</a>与三本书配套的<a href="https://github.com/RayTracing/raytracing.github.io" target="_blank">示例代码</a>。还有 <a href="https://gitee.com/link?target=https%3A%2F%2Fwww.scratchapixel.com%2Flessons%2F3d-basic-rendering%2Fintroduction-to-ray-tracing%2Fhow-does-it-work" target="_blank">Scratchapixe 六篇系列短文</a> 也是入门的好教程。</p>
<h2 id="三部曲">三部曲</h2>
<p><a href="../../../computer_graphics/classic_tutorial/raytracing_tutorial/ray_tracing_in_one_weekend/index.html">Ray Tracing in One Weekend</a></p>
<p><a href="../../../computer_graphics/classic_tutorial/raytracing_tutorial/ray_tracing_the_next_week/index.html">Ray Tracing: The Next Week</a></p>
<p><a href="../../../computer_graphics/classic_tutorial/raytracing_tutorial/ray_tracing_the_rest_of_your_life/index.html">Ray Tracing: The Rest of Your Life</a></p>
<h2 id="scratchapixe-六篇系列短文">Scratchapixe 六篇系列短文</h2>

            <footer class="footline">
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of 光线追踪</h1>
          <article class="default">
            <header class="headline">
            </header>
<h1 id="ray-tracing-in-one-weekend">Ray Tracing in One Weekend</h1>

<h2 id="contents">Contents</h2>
<p><strong>Ray Tracing in One Weekend</strong></p>
<ul>
<li>
<p>1 Overview</p>
</li>
<li>
<p>2 Output an Image</p>
<ul>
<li>
<p>2.1  The PPM Image Format</p>
</li>
<li>
<p>2.2  Creating an Image File</p>
</li>
<li>
<p>2.3  Adding a Progress Indicator</p>
</li>
</ul>
</li>
<li>
<p>3  The vec3 Class</p>
<ul>
<li>3.1  Color Utility Functions</li>
</ul>
</li>
<li>
<p>4  Rays, a Simple Camera, and Background</p>
<ul>
<li>4.1  The ray Class</li>
<li>4.2  Sending Rays Into the Scene</li>
</ul>
</li>
<li>
<p>5  Adding a Sphere</p>
<ul>
<li>5.1  Ray-Sphere Intersection</li>
<li>5.2  Creating Our First Raytraced Image</li>
</ul>
</li>
<li>
<p>6  Surface Normals and Multiple Objects</p>
<ul>
<li>6.1  Shading with Surface Normals</li>
<li>6.2  Simplifying the Ray-Sphere Intersection Code</li>
<li>6.3  An Abstraction for Hittable Objects</li>
<li>6.4  Front Faces Versus Back Faces</li>
<li>6.5  A List of Hittable Objects</li>
<li>6.6  Some New C++ Features</li>
<li>6.7  Common Constants and Utility Functions</li>
<li>6.8  An Interval Class</li>
</ul>
</li>
<li>
<p>7  Moving Camera Code Into Its Own Class</p>
</li>
<li>
<p>8  Antialiasing</p>
<ul>
<li>8.1  Some Random Number Utilities</li>
<li>8.2  Generating Pixels with Multiple Samples</li>
</ul>
</li>
<li>
<p>9  Diffuse Materials</p>
<ul>
<li>9.1  A Simple Diffuse Material</li>
<li>9.2  Limiting the Number of Child Rays</li>
<li>9.3  Fixing Shadow Acne</li>
<li>9.4  True Lambertian Reflection</li>
<li>9.5  Using Gamma Correction for Accurate Color Intensity</li>
</ul>
</li>
<li>
<p>10  Metal</p>
<ul>
<li>10.1  An Abstract Class for Materials</li>
<li>10.2  A Data Structure to Describe Ray-Object Intersections</li>
<li>10.3  Modeling Light Scatter and Reflectance</li>
<li>10.4  Mirrored Light Reflection</li>
<li>10.5  A Scene with Metal Spheres</li>
<li>10.6  Fuzzy Reflection</li>
</ul>
</li>
<li>
<p>11  Dielectrics</p>
<ul>
<li>11.1  Refraction</li>
<li>11.2  Snell&rsquo;s Law</li>
<li>11.3  Total Internal Reflection</li>
<li>11.4  Schlick Approximation</li>
<li>11.5  Modeling a Hollow Glass Sphere</li>
</ul>
</li>
<li>
<p>12  Positionable Camera</p>
<ul>
<li>12.1  Camera Viewing Geometry</li>
<li>12.2  Positioning and Orienting the Camera</li>
</ul>
</li>
<li>
<p>13  Defocus Blur</p>
<ul>
<li>13.1  A Thin Lens Approximation</li>
<li>13.2  Generating Sample Rays</li>
</ul>
</li>
<li>
<p>14  Where Next?</p>
<ul>
<li>14.1  A Final Render</li>
<li>14.2  Next Steps</li>
</ul>
</li>
<li>
<p>15  Acknowledgments</p>
</li>
<li>
<p>16  Citing This Book</p>
<ul>
<li>16.1  Basic Data</li>
<li>16.2  Snippets
<ul>
<li>16.2.1  Markdown</li>
<li>16.2.2  HTML</li>
<li>16.2.3  LaTeX and BibTex</li>
<li>16.2.4  BibLaTeX</li>
<li>16.2.5  IEEE</li>
<li>16.2.6  MLA:</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>Ray Tracing: The Next Week</strong></p>
<ul>
<li>
<p>1  Overview</p>
</li>
<li>
<p>2  Motion Blur</p>
<ul>
<li>2.1  Introduction of SpaceTime Ray Tracing</li>
<li>2.2  Managing Time</li>
<li>2.3  Updating the Camera to Simulate Motion Blur</li>
<li>2.4  Adding Moving Spheres</li>
<li>2.5  Tracking the Time of Ray Intersection</li>
<li>2.6  Putting Everything Together</li>
</ul>
</li>
<li>
<p>3  Bounding Volume Hierarchies</p>
<ul>
<li>3.1  The Key Idea</li>
<li>3.2  Hierarchies of Bounding Volumes</li>
<li>3.3  Axis-Aligned Bounding Boxes (AABBs)</li>
<li>3.4  Ray Intersection with an AABB</li>
<li>3.5  An Optimized AABB Hit Method</li>
<li>3.6  Constructing Bounding Boxes for Hittables</li>
<li>3.7  Creating Bounding Boxes of Lists of Objects</li>
<li>3.8  The BVH Node Class</li>
<li>3.9  Splitting BVH Volumes</li>
<li>3.10  The Box Comparison Functions</li>
</ul>
</li>
<li>
<p>4  Texture Mapping</p>
<ul>
<li>4.1  Constant Color Texture</li>
<li>4.2  Solid Textures: A Checker Texture</li>
<li>4.3  Rendering The Solid Checker Texture</li>
<li>4.4  Texture Coordinates for Spheres</li>
<li>4.5  Accessing Texture Image Data</li>
<li>4.6  Rendering The Image Texture</li>
</ul>
</li>
<li>
<p>5  Perlin Noise</p>
<ul>
<li>5.1  Using Blocks of Random Numbers</li>
<li>5.2  Smoothing out the Result</li>
<li>5.3  Improvement with Hermitian Smoothing</li>
<li>5.4  Tweaking The Frequency</li>
<li>5.5  Using Random Vectors on the Lattice Points</li>
<li>5.6  Introducing Turbulence</li>
<li>5.7  Adjusting the Phase</li>
</ul>
</li>
<li>
<p>6  Quadrilaterals</p>
<ul>
<li>6.1  Defining the Quadrilateral</li>
<li>6.2  Ray-Plane Intersection</li>
<li>6.3  Finding the Plane That Contains a Given Quadrilateral</li>
<li>6.4  Orienting Points on The Plane</li>
<li>6.5  Interior Testing of The Intersection Using UV Coordinates</li>
</ul>
</li>
<li>
<p>7  Lights</p>
<ul>
<li>7.1  Emissive Materials</li>
<li>7.2  Adding Background Color to the Ray Color Function</li>
<li>7.3  Turning Objects into Lights</li>
<li>7.4  Creating an Empty “Cornell Box”</li>
</ul>
</li>
<li>
<p>8  Instances</p>
<ul>
<li>8.1  Instance Translation</li>
<li>8.2  Instance Rotation</li>
</ul>
</li>
<li>
<p>9  Volumes</p>
<ul>
<li>9.1  Constant Density Mediums</li>
<li>9.2  Rendering a Cornell Box with Smoke and Fog Boxes</li>
</ul>
</li>
<li>
<p>10  A Scene Testing All New Features</p>
</li>
<li>
<p>11  Acknowledgments</p>
</li>
<li>
<p>12  Citing This Book</p>
<ul>
<li>12.1  Basic Data</li>
<li>12.2  Snippets
<ul>
<li>12.2.1  Markdown</li>
<li>12.2.2  HTML</li>
<li>12.2.3  LaTeX and BibTex</li>
<li>12.2.4  BibLaTeX</li>
<li>12.2.5  IEEE</li>
<li>12.2.6  MLA:</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>Ray Tracing: The Rest of Your Life</strong></p>
<ul>
<li>
<p>1  Overview</p>
</li>
<li>
<p>2  A Simple Monte Carlo Program</p>
<ul>
<li>2.1  Estimating Pi</li>
<li>2.2  Showing Convergence</li>
<li>2.3  Stratified Samples (Jittering)</li>
</ul>
</li>
<li>
<p>3  One Dimensional Monte Carlo Integration</p>
<ul>
<li>3.1  Expected Value</li>
<li>3.2  Integrating x²</li>
<li>3.3  Density Functions</li>
<li>3.4  Constructing a PDF</li>
<li>3.5  Choosing our Samples</li>
<li>3.6  Approximating Distributions</li>
<li>3.7  Importance Sampling</li>
</ul>
</li>
<li>
<p>4  Monte Carlo Integration on the Sphere of Directions</p>
</li>
<li>
<p>5  Light Scattering</p>
<ul>
<li>5.1  Albedo</li>
<li>5.2  Scattering</li>
<li>5.3  The Scattering PDF</li>
</ul>
</li>
<li>
<p>6  Playing with Importance Sampling</p>
<ul>
<li>6.1  Returning to the Cornell Box</li>
<li>6.2  Using a Uniform PDF Instead of a Perfect Match</li>
<li>6.3  Random Hemispherical Sampling</li>
</ul>
</li>
<li>
<p>7  Generating Random Directions</p>
<ul>
<li>7.1  Random Directions Relative to the Z Axis</li>
<li>7.2  Uniform Sampling a Hemisphere</li>
<li>7.3  Cosine Sampling a Hemisphere</li>
</ul>
</li>
<li>
<p>8  Orthonormal Bases</p>
<ul>
<li>8.1  Relative Coordinates</li>
<li>8.2  Generating an Orthonormal Basis</li>
<li>8.3  The ONB Class</li>
</ul>
</li>
<li>
<p>9  Sampling Lights Directly</p>
<ul>
<li>9.1  Getting the PDF of a Light</li>
<li>9.2  Light Sampling</li>
<li>9.3  Switching to Unidirectional Light</li>
</ul>
</li>
<li>
<p>10  Mixture Densities</p>
<ul>
<li>10.1  The PDF Class</li>
<li>10.2  Sampling Directions towards a Hittable</li>
<li>10.3  The Mixture PDF Class</li>
</ul>
</li>
<li>
<p>11  Some Architectural Decisions</p>
</li>
<li>
<p>12  Cleaning Up PDF Management</p>
<ul>
<li>12.1  Diffuse Versus Specular</li>
<li>12.2  Handling Specular</li>
<li>12.3  Sampling a Sphere Object</li>
<li>12.4  Updating the Sphere Code</li>
<li>12.5  Adding PDF Functions to Hittable Lists</li>
<li>12.6  Handling Surface Acne</li>
</ul>
</li>
<li>
<p>13  The Rest of Your Life</p>
</li>
<li>
<p>14  Acknowledgments</p>
</li>
<li>
<p>15  Citing This Book</p>
<ul>
<li>15.1  Basic Data</li>
<li>15.2  Snippets
<ul>
<li>15.2.1  Markdown</li>
<li>15.2.2  HTML</li>
<li>15.2.3  LaTeX and BibTex</li>
<li>15.2.4  BibLaTeX</li>
<li>15.2.5  IEEE</li>
<li>15.2.6  MLA:</li>
</ul>
</li>
</ul>
</li>
</ul>

            <footer class="footline">
            </footer>
          </article>

          <article class="default">
            <header class="headline">
            </header>
<h1 id="ray-tracing-the-next-week">Ray Tracing The Next Week</h1>

<h2 id="contents">Contents</h2>
<p><strong>Ray Tracing in One Weekend</strong></p>
<ul>
<li>
<p>1 Overview</p>
</li>
<li>
<p>2 Output an Image</p>
<ul>
<li>
<p>2.1  The PPM Image Format</p>
</li>
<li>
<p>2.2  Creating an Image File</p>
</li>
<li>
<p>2.3  Adding a Progress Indicator</p>
</li>
</ul>
</li>
<li>
<p>3  The vec3 Class</p>
<ul>
<li>3.1  Color Utility Functions</li>
</ul>
</li>
<li>
<p>4  Rays, a Simple Camera, and Background</p>
<ul>
<li>4.1  The ray Class</li>
<li>4.2  Sending Rays Into the Scene</li>
</ul>
</li>
<li>
<p>5  Adding a Sphere</p>
<ul>
<li>5.1  Ray-Sphere Intersection</li>
<li>5.2  Creating Our First Raytraced Image</li>
</ul>
</li>
<li>
<p>6  Surface Normals and Multiple Objects</p>
<ul>
<li>6.1  Shading with Surface Normals</li>
<li>6.2  Simplifying the Ray-Sphere Intersection Code</li>
<li>6.3  An Abstraction for Hittable Objects</li>
<li>6.4  Front Faces Versus Back Faces</li>
<li>6.5  A List of Hittable Objects</li>
<li>6.6  Some New C++ Features</li>
<li>6.7  Common Constants and Utility Functions</li>
<li>6.8  An Interval Class</li>
</ul>
</li>
<li>
<p>7  Moving Camera Code Into Its Own Class</p>
</li>
<li>
<p>8  Antialiasing</p>
<ul>
<li>8.1  Some Random Number Utilities</li>
<li>8.2  Generating Pixels with Multiple Samples</li>
</ul>
</li>
<li>
<p>9  Diffuse Materials</p>
<ul>
<li>9.1  A Simple Diffuse Material</li>
<li>9.2  Limiting the Number of Child Rays</li>
<li>9.3  Fixing Shadow Acne</li>
<li>9.4  True Lambertian Reflection</li>
<li>9.5  Using Gamma Correction for Accurate Color Intensity</li>
</ul>
</li>
<li>
<p>10  Metal</p>
<ul>
<li>10.1  An Abstract Class for Materials</li>
<li>10.2  A Data Structure to Describe Ray-Object Intersections</li>
<li>10.3  Modeling Light Scatter and Reflectance</li>
<li>10.4  Mirrored Light Reflection</li>
<li>10.5  A Scene with Metal Spheres</li>
<li>10.6  Fuzzy Reflection</li>
</ul>
</li>
<li>
<p>11  Dielectrics</p>
<ul>
<li>11.1  Refraction</li>
<li>11.2  Snell&rsquo;s Law</li>
<li>11.3  Total Internal Reflection</li>
<li>11.4  Schlick Approximation</li>
<li>11.5  Modeling a Hollow Glass Sphere</li>
</ul>
</li>
<li>
<p>12  Positionable Camera</p>
<ul>
<li>12.1  Camera Viewing Geometry</li>
<li>12.2  Positioning and Orienting the Camera</li>
</ul>
</li>
<li>
<p>13  Defocus Blur</p>
<ul>
<li>13.1  A Thin Lens Approximation</li>
<li>13.2  Generating Sample Rays</li>
</ul>
</li>
<li>
<p>14  Where Next?</p>
<ul>
<li>14.1  A Final Render</li>
<li>14.2  Next Steps</li>
</ul>
</li>
<li>
<p>15  Acknowledgments</p>
</li>
<li>
<p>16  Citing This Book</p>
<ul>
<li>16.1  Basic Data</li>
<li>16.2  Snippets
<ul>
<li>16.2.1  Markdown</li>
<li>16.2.2  HTML</li>
<li>16.2.3  LaTeX and BibTex</li>
<li>16.2.4  BibLaTeX</li>
<li>16.2.5  IEEE</li>
<li>16.2.6  MLA:</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>Ray Tracing: The Next Week</strong></p>
<ul>
<li>
<p>1  Overview</p>
</li>
<li>
<p>2  Motion Blur</p>
<ul>
<li>2.1  Introduction of SpaceTime Ray Tracing</li>
<li>2.2  Managing Time</li>
<li>2.3  Updating the Camera to Simulate Motion Blur</li>
<li>2.4  Adding Moving Spheres</li>
<li>2.5  Tracking the Time of Ray Intersection</li>
<li>2.6  Putting Everything Together</li>
</ul>
</li>
<li>
<p>3  Bounding Volume Hierarchies</p>
<ul>
<li>3.1  The Key Idea</li>
<li>3.2  Hierarchies of Bounding Volumes</li>
<li>3.3  Axis-Aligned Bounding Boxes (AABBs)</li>
<li>3.4  Ray Intersection with an AABB</li>
<li>3.5  An Optimized AABB Hit Method</li>
<li>3.6  Constructing Bounding Boxes for Hittables</li>
<li>3.7  Creating Bounding Boxes of Lists of Objects</li>
<li>3.8  The BVH Node Class</li>
<li>3.9  Splitting BVH Volumes</li>
<li>3.10  The Box Comparison Functions</li>
</ul>
</li>
<li>
<p>4  Texture Mapping</p>
<ul>
<li>4.1  Constant Color Texture</li>
<li>4.2  Solid Textures: A Checker Texture</li>
<li>4.3  Rendering The Solid Checker Texture</li>
<li>4.4  Texture Coordinates for Spheres</li>
<li>4.5  Accessing Texture Image Data</li>
<li>4.6  Rendering The Image Texture</li>
</ul>
</li>
<li>
<p>5  Perlin Noise</p>
<ul>
<li>5.1  Using Blocks of Random Numbers</li>
<li>5.2  Smoothing out the Result</li>
<li>5.3  Improvement with Hermitian Smoothing</li>
<li>5.4  Tweaking The Frequency</li>
<li>5.5  Using Random Vectors on the Lattice Points</li>
<li>5.6  Introducing Turbulence</li>
<li>5.7  Adjusting the Phase</li>
</ul>
</li>
<li>
<p>6  Quadrilaterals</p>
<ul>
<li>6.1  Defining the Quadrilateral</li>
<li>6.2  Ray-Plane Intersection</li>
<li>6.3  Finding the Plane That Contains a Given Quadrilateral</li>
<li>6.4  Orienting Points on The Plane</li>
<li>6.5  Interior Testing of The Intersection Using UV Coordinates</li>
</ul>
</li>
<li>
<p>7  Lights</p>
<ul>
<li>7.1  Emissive Materials</li>
<li>7.2  Adding Background Color to the Ray Color Function</li>
<li>7.3  Turning Objects into Lights</li>
<li>7.4  Creating an Empty “Cornell Box”</li>
</ul>
</li>
<li>
<p>8  Instances</p>
<ul>
<li>8.1  Instance Translation</li>
<li>8.2  Instance Rotation</li>
</ul>
</li>
<li>
<p>9  Volumes</p>
<ul>
<li>9.1  Constant Density Mediums</li>
<li>9.2  Rendering a Cornell Box with Smoke and Fog Boxes</li>
</ul>
</li>
<li>
<p>10  A Scene Testing All New Features</p>
</li>
<li>
<p>11  Acknowledgments</p>
</li>
<li>
<p>12  Citing This Book</p>
<ul>
<li>12.1  Basic Data</li>
<li>12.2  Snippets
<ul>
<li>12.2.1  Markdown</li>
<li>12.2.2  HTML</li>
<li>12.2.3  LaTeX and BibTex</li>
<li>12.2.4  BibLaTeX</li>
<li>12.2.5  IEEE</li>
<li>12.2.6  MLA:</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>Ray Tracing: The Rest of Your Life</strong></p>
<ul>
<li>
<p>1  Overview</p>
</li>
<li>
<p>2  A Simple Monte Carlo Program</p>
<ul>
<li>2.1  Estimating Pi</li>
<li>2.2  Showing Convergence</li>
<li>2.3  Stratified Samples (Jittering)</li>
</ul>
</li>
<li>
<p>3  One Dimensional Monte Carlo Integration</p>
<ul>
<li>3.1  Expected Value</li>
<li>3.2  Integrating x²</li>
<li>3.3  Density Functions</li>
<li>3.4  Constructing a PDF</li>
<li>3.5  Choosing our Samples</li>
<li>3.6  Approximating Distributions</li>
<li>3.7  Importance Sampling</li>
</ul>
</li>
<li>
<p>4  Monte Carlo Integration on the Sphere of Directions</p>
</li>
<li>
<p>5  Light Scattering</p>
<ul>
<li>5.1  Albedo</li>
<li>5.2  Scattering</li>
<li>5.3  The Scattering PDF</li>
</ul>
</li>
<li>
<p>6  Playing with Importance Sampling</p>
<ul>
<li>6.1  Returning to the Cornell Box</li>
<li>6.2  Using a Uniform PDF Instead of a Perfect Match</li>
<li>6.3  Random Hemispherical Sampling</li>
</ul>
</li>
<li>
<p>7  Generating Random Directions</p>
<ul>
<li>7.1  Random Directions Relative to the Z Axis</li>
<li>7.2  Uniform Sampling a Hemisphere</li>
<li>7.3  Cosine Sampling a Hemisphere</li>
</ul>
</li>
<li>
<p>8  Orthonormal Bases</p>
<ul>
<li>8.1  Relative Coordinates</li>
<li>8.2  Generating an Orthonormal Basis</li>
<li>8.3  The ONB Class</li>
</ul>
</li>
<li>
<p>9  Sampling Lights Directly</p>
<ul>
<li>9.1  Getting the PDF of a Light</li>
<li>9.2  Light Sampling</li>
<li>9.3  Switching to Unidirectional Light</li>
</ul>
</li>
<li>
<p>10  Mixture Densities</p>
<ul>
<li>10.1  The PDF Class</li>
<li>10.2  Sampling Directions towards a Hittable</li>
<li>10.3  The Mixture PDF Class</li>
</ul>
</li>
<li>
<p>11  Some Architectural Decisions</p>
</li>
<li>
<p>12  Cleaning Up PDF Management</p>
<ul>
<li>12.1  Diffuse Versus Specular</li>
<li>12.2  Handling Specular</li>
<li>12.3  Sampling a Sphere Object</li>
<li>12.4  Updating the Sphere Code</li>
<li>12.5  Adding PDF Functions to Hittable Lists</li>
<li>12.6  Handling Surface Acne</li>
</ul>
</li>
<li>
<p>13  The Rest of Your Life</p>
</li>
<li>
<p>14  Acknowledgments</p>
</li>
<li>
<p>15  Citing This Book</p>
<ul>
<li>15.1  Basic Data</li>
<li>15.2  Snippets
<ul>
<li>15.2.1  Markdown</li>
<li>15.2.2  HTML</li>
<li>15.2.3  LaTeX and BibTex</li>
<li>15.2.4  BibLaTeX</li>
<li>15.2.5  IEEE</li>
<li>15.2.6  MLA:</li>
</ul>
</li>
</ul>
</li>
</ul>

            <footer class="footline">
            </footer>
          </article>

          <article class="default">
            <header class="headline">
            </header>
<h1 id="ray-tracing-the-rest-of-your-life">Ray Tracing The Rest of Your Life</h1>

<h2 id="contents">Contents</h2>
<p><strong>Ray Tracing in One Weekend</strong></p>
<ul>
<li>
<p>1 Overview</p>
</li>
<li>
<p>2 Output an Image</p>
<ul>
<li>
<p>2.1  The PPM Image Format</p>
</li>
<li>
<p>2.2  Creating an Image File</p>
</li>
<li>
<p>2.3  Adding a Progress Indicator</p>
</li>
</ul>
</li>
<li>
<p>3  The vec3 Class</p>
<ul>
<li>3.1  Color Utility Functions</li>
</ul>
</li>
<li>
<p>4  Rays, a Simple Camera, and Background</p>
<ul>
<li>4.1  The ray Class</li>
<li>4.2  Sending Rays Into the Scene</li>
</ul>
</li>
<li>
<p>5  Adding a Sphere</p>
<ul>
<li>5.1  Ray-Sphere Intersection</li>
<li>5.2  Creating Our First Raytraced Image</li>
</ul>
</li>
<li>
<p>6  Surface Normals and Multiple Objects</p>
<ul>
<li>6.1  Shading with Surface Normals</li>
<li>6.2  Simplifying the Ray-Sphere Intersection Code</li>
<li>6.3  An Abstraction for Hittable Objects</li>
<li>6.4  Front Faces Versus Back Faces</li>
<li>6.5  A List of Hittable Objects</li>
<li>6.6  Some New C++ Features</li>
<li>6.7  Common Constants and Utility Functions</li>
<li>6.8  An Interval Class</li>
</ul>
</li>
<li>
<p>7  Moving Camera Code Into Its Own Class</p>
</li>
<li>
<p>8  Antialiasing</p>
<ul>
<li>8.1  Some Random Number Utilities</li>
<li>8.2  Generating Pixels with Multiple Samples</li>
</ul>
</li>
<li>
<p>9  Diffuse Materials</p>
<ul>
<li>9.1  A Simple Diffuse Material</li>
<li>9.2  Limiting the Number of Child Rays</li>
<li>9.3  Fixing Shadow Acne</li>
<li>9.4  True Lambertian Reflection</li>
<li>9.5  Using Gamma Correction for Accurate Color Intensity</li>
</ul>
</li>
<li>
<p>10  Metal</p>
<ul>
<li>10.1  An Abstract Class for Materials</li>
<li>10.2  A Data Structure to Describe Ray-Object Intersections</li>
<li>10.3  Modeling Light Scatter and Reflectance</li>
<li>10.4  Mirrored Light Reflection</li>
<li>10.5  A Scene with Metal Spheres</li>
<li>10.6  Fuzzy Reflection</li>
</ul>
</li>
<li>
<p>11  Dielectrics</p>
<ul>
<li>11.1  Refraction</li>
<li>11.2  Snell&rsquo;s Law</li>
<li>11.3  Total Internal Reflection</li>
<li>11.4  Schlick Approximation</li>
<li>11.5  Modeling a Hollow Glass Sphere</li>
</ul>
</li>
<li>
<p>12  Positionable Camera</p>
<ul>
<li>12.1  Camera Viewing Geometry</li>
<li>12.2  Positioning and Orienting the Camera</li>
</ul>
</li>
<li>
<p>13  Defocus Blur</p>
<ul>
<li>13.1  A Thin Lens Approximation</li>
<li>13.2  Generating Sample Rays</li>
</ul>
</li>
<li>
<p>14  Where Next?</p>
<ul>
<li>14.1  A Final Render</li>
<li>14.2  Next Steps</li>
</ul>
</li>
<li>
<p>15  Acknowledgments</p>
</li>
<li>
<p>16  Citing This Book</p>
<ul>
<li>16.1  Basic Data</li>
<li>16.2  Snippets
<ul>
<li>16.2.1  Markdown</li>
<li>16.2.2  HTML</li>
<li>16.2.3  LaTeX and BibTex</li>
<li>16.2.4  BibLaTeX</li>
<li>16.2.5  IEEE</li>
<li>16.2.6  MLA:</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>Ray Tracing: The Next Week</strong></p>
<ul>
<li>
<p>1  Overview</p>
</li>
<li>
<p>2  Motion Blur</p>
<ul>
<li>2.1  Introduction of SpaceTime Ray Tracing</li>
<li>2.2  Managing Time</li>
<li>2.3  Updating the Camera to Simulate Motion Blur</li>
<li>2.4  Adding Moving Spheres</li>
<li>2.5  Tracking the Time of Ray Intersection</li>
<li>2.6  Putting Everything Together</li>
</ul>
</li>
<li>
<p>3  Bounding Volume Hierarchies</p>
<ul>
<li>3.1  The Key Idea</li>
<li>3.2  Hierarchies of Bounding Volumes</li>
<li>3.3  Axis-Aligned Bounding Boxes (AABBs)</li>
<li>3.4  Ray Intersection with an AABB</li>
<li>3.5  An Optimized AABB Hit Method</li>
<li>3.6  Constructing Bounding Boxes for Hittables</li>
<li>3.7  Creating Bounding Boxes of Lists of Objects</li>
<li>3.8  The BVH Node Class</li>
<li>3.9  Splitting BVH Volumes</li>
<li>3.10  The Box Comparison Functions</li>
</ul>
</li>
<li>
<p>4  Texture Mapping</p>
<ul>
<li>4.1  Constant Color Texture</li>
<li>4.2  Solid Textures: A Checker Texture</li>
<li>4.3  Rendering The Solid Checker Texture</li>
<li>4.4  Texture Coordinates for Spheres</li>
<li>4.5  Accessing Texture Image Data</li>
<li>4.6  Rendering The Image Texture</li>
</ul>
</li>
<li>
<p>5  Perlin Noise</p>
<ul>
<li>5.1  Using Blocks of Random Numbers</li>
<li>5.2  Smoothing out the Result</li>
<li>5.3  Improvement with Hermitian Smoothing</li>
<li>5.4  Tweaking The Frequency</li>
<li>5.5  Using Random Vectors on the Lattice Points</li>
<li>5.6  Introducing Turbulence</li>
<li>5.7  Adjusting the Phase</li>
</ul>
</li>
<li>
<p>6  Quadrilaterals</p>
<ul>
<li>6.1  Defining the Quadrilateral</li>
<li>6.2  Ray-Plane Intersection</li>
<li>6.3  Finding the Plane That Contains a Given Quadrilateral</li>
<li>6.4  Orienting Points on The Plane</li>
<li>6.5  Interior Testing of The Intersection Using UV Coordinates</li>
</ul>
</li>
<li>
<p>7  Lights</p>
<ul>
<li>7.1  Emissive Materials</li>
<li>7.2  Adding Background Color to the Ray Color Function</li>
<li>7.3  Turning Objects into Lights</li>
<li>7.4  Creating an Empty “Cornell Box”</li>
</ul>
</li>
<li>
<p>8  Instances</p>
<ul>
<li>8.1  Instance Translation</li>
<li>8.2  Instance Rotation</li>
</ul>
</li>
<li>
<p>9  Volumes</p>
<ul>
<li>9.1  Constant Density Mediums</li>
<li>9.2  Rendering a Cornell Box with Smoke and Fog Boxes</li>
</ul>
</li>
<li>
<p>10  A Scene Testing All New Features</p>
</li>
<li>
<p>11  Acknowledgments</p>
</li>
<li>
<p>12  Citing This Book</p>
<ul>
<li>12.1  Basic Data</li>
<li>12.2  Snippets
<ul>
<li>12.2.1  Markdown</li>
<li>12.2.2  HTML</li>
<li>12.2.3  LaTeX and BibTex</li>
<li>12.2.4  BibLaTeX</li>
<li>12.2.5  IEEE</li>
<li>12.2.6  MLA:</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>Ray Tracing: The Rest of Your Life</strong></p>
<ul>
<li>
<p>1  Overview</p>
</li>
<li>
<p>2  A Simple Monte Carlo Program</p>
<ul>
<li>2.1  Estimating Pi</li>
<li>2.2  Showing Convergence</li>
<li>2.3  Stratified Samples (Jittering)</li>
</ul>
</li>
<li>
<p>3  One Dimensional Monte Carlo Integration</p>
<ul>
<li>3.1  Expected Value</li>
<li>3.2  Integrating x²</li>
<li>3.3  Density Functions</li>
<li>3.4  Constructing a PDF</li>
<li>3.5  Choosing our Samples</li>
<li>3.6  Approximating Distributions</li>
<li>3.7  Importance Sampling</li>
</ul>
</li>
<li>
<p>4  Monte Carlo Integration on the Sphere of Directions</p>
</li>
<li>
<p>5  Light Scattering</p>
<ul>
<li>5.1  Albedo</li>
<li>5.2  Scattering</li>
<li>5.3  The Scattering PDF</li>
</ul>
</li>
<li>
<p>6  Playing with Importance Sampling</p>
<ul>
<li>6.1  Returning to the Cornell Box</li>
<li>6.2  Using a Uniform PDF Instead of a Perfect Match</li>
<li>6.3  Random Hemispherical Sampling</li>
</ul>
</li>
<li>
<p>7  Generating Random Directions</p>
<ul>
<li>7.1  Random Directions Relative to the Z Axis</li>
<li>7.2  Uniform Sampling a Hemisphere</li>
<li>7.3  Cosine Sampling a Hemisphere</li>
</ul>
</li>
<li>
<p>8  Orthonormal Bases</p>
<ul>
<li>8.1  Relative Coordinates</li>
<li>8.2  Generating an Orthonormal Basis</li>
<li>8.3  The ONB Class</li>
</ul>
</li>
<li>
<p>9  Sampling Lights Directly</p>
<ul>
<li>9.1  Getting the PDF of a Light</li>
<li>9.2  Light Sampling</li>
<li>9.3  Switching to Unidirectional Light</li>
</ul>
</li>
<li>
<p>10  Mixture Densities</p>
<ul>
<li>10.1  The PDF Class</li>
<li>10.2  Sampling Directions towards a Hittable</li>
<li>10.3  The Mixture PDF Class</li>
</ul>
</li>
<li>
<p>11  Some Architectural Decisions</p>
</li>
<li>
<p>12  Cleaning Up PDF Management</p>
<ul>
<li>12.1  Diffuse Versus Specular</li>
<li>12.2  Handling Specular</li>
<li>12.3  Sampling a Sphere Object</li>
<li>12.4  Updating the Sphere Code</li>
<li>12.5  Adding PDF Functions to Hittable Lists</li>
<li>12.6  Handling Surface Acne</li>
</ul>
</li>
<li>
<p>13  The Rest of Your Life</p>
</li>
<li>
<p>14  Acknowledgments</p>
</li>
<li>
<p>15  Citing This Book</p>
<ul>
<li>15.1  Basic Data</li>
<li>15.2  Snippets
<ul>
<li>15.2.1  Markdown</li>
<li>15.2.2  HTML</li>
<li>15.2.3  LaTeX and BibTex</li>
<li>15.2.4  BibLaTeX</li>
<li>15.2.5  IEEE</li>
<li>15.2.6  MLA:</li>
</ul>
</li>
</ul>
</li>
</ul>

            <footer class="footline">
            </footer>
          </article>

          <article class="default">
            <header class="headline">
            </header>
<h1 id="scratchapixe-系列短文">Scratchapixe 系列短文</h1>

<h2 id="contents">Contents</h2>
<ul>
<li>
<p><a href="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/index.html">Introduction to Raytracing: A Simple Method for Creating 3D Images</a></p>
<ul>
<li><a href="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/index.html#how-does-it-work">How Does it Work</a></li>
<li><a href="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/index.html#the-raytracing-algorithm-in-a-nutshell">The Raytracing Algorithm in a Nutshell</a></li>
<li><a href="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/index.html#implementing-the-raytracing-algorithm">Implementing the Raytracing Algorithm</a></li>
<li><a href="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/index.html#adding-reflection-and-refraction">Adding Reflection and Refraction</a></li>
<li><a href="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/index.html#writing-a-basic-raytracer">Writing a Basic Raytracer</a></li>
</ul>
</li>
<li>
<p><a href="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-2/index.html">Where Do I Start? A Very Gentle Introduction to Computer Graphics Programming</a></p>
<ul>
<li><a href="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-2/index.html#understanding-how-it-works">Understanding How It Works!</a></li>
<li><a href="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-2/index.html#a-gentle-introduction-to-computer-graphics-programming">A Gentle Introduction to Computer Graphics Programming</a></li>
<li><a href="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-2/index.html#describing-objects-populating-the-virtual-world">Describing Objects Populating the Virtual World</a></li>
<li><a href="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-2/index.html#creating-an-image-of-this-virtual-world">Creating an Image of this Virtual World</a></li>
<li><a href="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-2/index.html#what-have-we-learned">What Have We Learned?</a></li>
<li><a href="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-2/index.html#where-should-i-start">Where Should I Start?</a></li>
<li><a href="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-2/index.html#what-should-i-read-next">What Should I Read Next?</a></li>
</ul>
</li>
<li>
<p><a href="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/index.html">Rendering an Image of a 3D Scene: an Overview</a></p>
<ul>
<li><a href="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/index.html#it-all-starts-with-a-computer-and-a-computer-screen">It All Starts with a Computer and a Computer Screen</a></li>
<li><a href="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/index.html#and-it-follows-with-a-3d-scene">And It Follows with a 3D Scene</a></li>
<li><a href="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/index.html#an-overview-of-the-rendering-process-visibility-and-shading">An Overview of the Rendering Process: Visibility and Shading</a></li>
<li><a href="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/index.html#perspective-projection">Perspective Projection</a></li>
<li><a href="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/index.html#the-visibility-problem">The Visibility Problem</a></li>
<li><a href="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/index.html#a-light-simulator">A Light Simulator</a></li>
<li><a href="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/index.html#light-transport-1">Light Transport</a></li>
<li><a href="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/index.html#shading-1">Shading</a></li>
<li><a href="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/index.html#summary-and-other-considerations-about-rendering">Summary and Other Considerations About Rendering</a></li>
</ul>
</li>
<li>
<p><a href="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/index.html">Computing the Pixel Coordinates of a 3D Point</a></p>
<ul>
<li><a href="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/index.html#perspective-projection">Perspective Projection</a></li>
<li><a href="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/index.html#mathematics-of-computing-the-2d-coordinates-of-a-3d-point">Mathematics of Computing the 2D Coordinates of a 3D Point</a></li>
</ul>
</li>
<li>
<p><a href="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/index.html">3D Viewing: the Pinhole Camera Model</a></p>
<ul>
<li><a href="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/index.html#how-a-pinhole-camera-works-part-1">How a pinhole camera works (part 1)</a></li>
<li><a href="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/index.html#how-a-pinhole-camera-works-part-2">How a pinhole camera works (part 2)</a></li>
<li><a href="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/index.html#a-virtual-pinhole-camera-model">A Virtual Pinhole Camera Model</a></li>
<li><a href="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/index.html#implementing-a-virtual-pinhole-camera">Implementing a Virtual Pinhole Camera</a></li>
</ul>
</li>
<li>
<p><a href="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/./scratchapixel/scratchapixel-chapter-6/">Rasterization: a Practical Implementation</a></p>
<ul>
<li><a href="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/index.html#an-overview-of-the-rasterization-algorithm">An Overview of the Rasterization Algorithm</a></li>
<li><a href="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/index.html#the-projection-stage">The Projection Stage</a></li>
<li><a href="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/index.html#the-rasterization-stage">The Rasterization Stage</a></li>
<li>The Visibility Problem, the Depth Buffer Algorithm and Depth Interpolation</li>
<li>Perspective Correct Interpolation and Vertex Attributes</li>
<li>Rasterization: a Practical Implementation</li>
</ul>
</li>
<li>
<p><a href="https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/projection-matrix-introduction.html" target="_blank">The Perspective and Orthographic Projection Matrix</a></p>
</li>
<li>
<p><a href="https://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-overview/ray-tracing-rendering-technique-overview.html" target="_blank">An Overview of the Ray-Tracing Rendering Technique</a></p>
</li>
<li>
<p><a href="https://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-generating-camera-rays/definition-ray.html" target="_blank">Ray-Tracing: Generating Camera Rays</a></p>
</li>
<li>
<p><a href="https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/parametric-and-implicit-surfaces.html" target="_blank">A Minimal Ray-Tracer: Rendering Simple Shapes (Sphere, Cube, Disk, Plane, etc.)</a></p>
</li>
<li>
<p><a href="https://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-rendering-a-triangle/why-are-triangles-useful.html" target="_blank">Ray-Tracing: Rendering a Triangle</a></p>
</li>
<li>
<p><a href="https://www.scratchapixel.com/lessons/3d-basic-rendering/introduction-polygon-mesh/introduction.html" target="_blank">Introduction to Polygon Meshes</a></p>
</li>
<li>
<p><a href="https://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-polygon-mesh/polygon-to-triangle-mesh.html" target="_blank">Ray-Tracing a Polygon Mesh</a></p>
</li>
<li>
<p><a href="https://www.scratchapixel.com/lessons/3d-basic-rendering/transforming-objects-using-matrices/using-4x4-matrices-transform-objects-3D.html" target="_blank">Transforming Objects using Matrices</a></p>
</li>
<li>
<p><a href="https://www.scratchapixel.com/lessons/3d-basic-rendering/introduction-to-shading/what-is-shading-light-matter-interaction.html" target="_blank">Introduction to Shading</a></p>
</li>
<li>
<p><a href="https://www.scratchapixel.com/lessons/3d-basic-rendering/phong-shader-BRDF/phong-illumination-models-brdf.html" target="_blank">The Phong Model, Introduction to the Concepts of Shader, Reflection Models and BRDF</a></p>
</li>
<li>
<p><a href="https://www.scratchapixel.com/lessons/3d-basic-rendering/global-illumination-path-tracing/introduction-global-illumination-path-tracing.html" target="_blank">Global Illumination and Path Tracing</a></p>
</li>
<li>
<p><a href="https://www.scratchapixel.com/lessons/3d-basic-rendering/introduction-acceleration-structure/introduction.html" target="_blank">Introduction to Acceleration Structures</a></p>
</li>
<li>
<p><a href="https://www.scratchapixel.com/lessons/3d-basic-rendering/volume-rendering-for-developers/intro-volume-rendering.html" target="_blank">Volume Rendering for Developers: Foundations</a></p>
</li>
</ul>

            <footer class="footline">
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Scratchapixe 系列短文</h1>
          <article class="default">
            <header class="headline">
            </header>
<h1 id="introduction-to-raytracing-a-simple-method-for-creating-3d-images">Introduction to Raytracing: A Simple Method for Creating 3D Images</h1>

<blockquote>
<p>转自：https://www.scratchapixel.com/lessons/3d-basic-rendering/introduction-to-ray-tracing/how-does-it-work.html</p>
</blockquote>
<h2 id="how-does-it-work">How Does it Work</h2>
<p>This lesson serves as a broad introduction to the concept of 3D rendering and computer graphics programming. For those specifically interested in the ray-tracing method, you might want to explore the lesson <a href="https://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-overview/ray-tracing-rendering-technique-overview.html" target="_blank">An Overview of the Ray-Tracing Rendering Technique</a>.</p>
<p>Embarking on the exploration of 3D graphics, especially within the realm of computer graphics programming, the initial step involves understanding the conversion of a three-dimensional scene into a two-dimensional image that can be viewed. Grasping this conversion process paves the way for utilizing computers to develop software that produces &ldquo;synthetic&rdquo; images through emulation of these processes. Essentially, the creation of computer graphics often mimics natural phenomena (occasionally in reverse order), though surpassing nature&rsquo;s complexity is a feat yet to be achieved by humans – a limitation that, nevertheless, does not diminish the enjoyment derived from these endeavors. This lesson, and particularly this segment, lays out the foundational principles of Computer-Generated Imagery (CGI).</p>
<p>The lesson&rsquo;s second chapter delves into the ray-tracing algorithm, providing an overview of its functionality. We&rsquo;ve been queried by many about our focus on ray tracing over other algorithms. Scratchapixel&rsquo;s aim is to present a diverse range of topics within computer animation, extending beyond rendering to include aspects like animation and simulation. The choice to spotlight ray tracing stems from its straightforward approach to simulating the physical reasons behind object visibility. Hence, for beginners, ray tracing emerges as the ideal method to elucidate the image generation process from code. This rationale underpins our preference for ray tracing in this introductory lesson, with subsequent lessons also linking back to ray tracing. However – be reassured – we will learn about alternative rendering techniques, such as scanline rendering, which remains the predominant method for image generation via GPUs.</p>
<p>This lesson is perfectly suited for those merely curious about computer-generated 3D graphics without the intention of pursuing a career in this field. It is designed to be self-explanatory, packed with sufficient information, and includes a simple, compilable program that facilitates a comprehensive understanding of the concept. With this knowledge, you can acknowledge your familiarity with the subject and proceed with your life or, if inspired by CGI, delve deeper into the field—a domain fueled by passion, where creating meaningful computer-generated pixels is nothing short of extraordinary. More lessons await those interested to expand their understanding and skills in CGI programming.</p>
<p>Scratchapixel is tailored for beginners with minimal background in mathematics or physics. We aim to explain everything from the ground up in straightforward English, accompanied by coding examples to demonstrate the practical application of theoretical concepts. Let&rsquo;s embark on this journey together&hellip;</p>
<h3 id="how-is-an-image-created">How Is an Image Created?</h3>
<p><a href="#R-image-b18c568fecc77f32bc2adfa11a1c6656" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/../assets/vantagepoint.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b18c568fecc77f32bc2adfa11a1c6656"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/../assets/vantagepoint.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 1:</strong> <em>we can visualize a picture as a cut made through a pyramid whose apex is located at the center of our eye and whose height is parallel to our line of sight.</em></p>
<p>The creation of an image necessitates a two-dimensional surface, which acts as the medium for projection. Conceptually, this can be imagined as slicing through a pyramid, with the apex positioned at the viewer&rsquo;s eye and extending in the direction of the line of sight. This conceptual slice is termed the <strong>image plane</strong>, akin to a canvas for artists. It serves as the stage upon which the three-dimensional scene is projected to form a two-dimensional image. This fundamental principle underlies the image creation process across various mediums, from the photographic film or digital sensor in cameras to the traditional canvas of painters, illustrating the universal application of this concept in visual representation.</p>
<h3 id="perspective-projection">Perspective Projection</h3>
<p>Perspective projection is a technique that translates three-dimensional objects onto a two-dimensional plane, creating the illusion of depth and space on a flat surface. Imagine wanting to depict a cube on a blank canvas. The process begins by drawing lines from each corner of the cube towards the viewer&rsquo;s eye. Where each line intersects the image plane—a flat surface akin to a canvas or the screen of a camera—a mark is made. For instance, if a cube corner labeled c0 connects to corners c1, c2, and c3, their projection onto the canvas results in points c0&rsquo;, c1&rsquo;, c2&rsquo;, and c3&rsquo;. Lines are then drawn between these projected points on the canvas to represent the cube&rsquo;s edges, such as from c0&rsquo; to c1&rsquo; and from c0&rsquo; to c2'.</p>
<p><a href="#R-image-359d0920bd3e7af9c27b733dd93af229" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/../assets/projperspective.gif" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-359d0920bd3e7af9c27b733dd93af229"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/../assets/projperspective.gif" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 2:</strong> <em>Projecting the four corners of the front face of a cube onto a canvas.</em></p>
<p>Repeating this procedure for all cube edges yields a two-dimensional depiction of the cube. This method, known as perspective projection, was mastered by painters in the early 15th century and allows for the representation of a scene from a specific viewpoint.</p>
<h3 id="light-and-color">Light and Color</h3>
<p>After mastering the technique of sketching the outlines of three-dimensional objects onto a two-dimensional surface, the next step in creating a vivid image involves the addition of color.</p>
<p>Briefly recapping our learning: the process of transforming a three-dimensional scene into an image unfolds in two primary steps. Initially, we project the contours of the three-dimensional objects onto a two-dimensional plane, known as the image surface or image plane. This involves drawing lines from the object&rsquo;s edges to the observer&rsquo;s viewpoint and marking where these lines intersect with the image plane, thereby sketching the object&rsquo;s outline—a purely geometric task. Following this, the second step involves coloring within these outlines, a technique referred to as shading, which brings the image to life.</p>
<p>The color and brightness of an object within a scene are predominantly determined by how light interacts with the material of the object. Light consists of photons, electromagnetic particles that embody both electric and magnetic properties. These particles carry energy and oscillate similarly to sound waves, traveling in direct lines. Sunlight is a prime example of a natural light source emitting photons. When photons encounter an object, they can be absorbed, reflected, or transmitted, with the outcome varying depending on the material&rsquo;s properties. However, a universal principle across all materials is the conservation of photon count: the sum of absorbed, reflected, and transmitted photons must equal the initial number of incoming photons. For instance, if 100 photons illuminate an object&rsquo;s surface, the distribution of absorbed and reflected photons must total 100, ensuring energy conservation.</p>
<p>Materials are broadly categorized into two types: <strong>conductors</strong>, which are metals, and <strong>dielectrics</strong>, encompassing non-metals such as glass, plastic, wood, and water. Interestingly, dielectrics are insulators of electricity, with even pure water acting as an insulator. These materials may vary in their transparency, with some being completely opaque and others transparent to certain wavelengths of electromagnetic radiation, like X-rays penetrating human tissue.</p>
<p>Moreover, materials can be composite or layered, combining different properties. For example, a wooden object might be coated with a transparent layer of varnish, giving it a simultaneously diffuse and glossy appearance, similar to the effect seen on colored plastic balls. This complexity in material composition adds depth and realism to the rendered scene by mimicking the multifaceted interactions between light and surfaces in the real world.</p>
<p><a href="#R-image-dd59a665a35e6c5ff242a848e89eb058" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/../assets/material.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-dd59a665a35e6c5ff242a848e89eb058"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/../assets/material.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Focusing on opaque and diffuse materials simplifies the understanding of how objects acquire their color. The color perception of an object under white light, which is composed of red, blue, and green photons, is determined by which photons are absorbed and which are reflected. For instance, a red object under white light appears red because it absorbs the blue and green photons while reflecting the red photons. The visibility of the object is due to the reflected red photons reaching our eyes, where each point on the object&rsquo;s surface disperses light rays in all directions. However, only the rays that strike our eyes perpendicularly are perceived, converted by the photoreceptors in our eyes into neural signals. These signals are then processed by our brain, enabling us to discern different colors and shades, though the exact mechanisms of this process are complex and still being explored. This explanation offers a simplified view of the intricate phenomena involved, with further details available in specialized lessons on color in the field of computer graphics.</p>
<p><a href="#R-image-d57af7337c84c56e3a00751700b4db75" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/../assets/lighttoeye.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d57af7337c84c56e3a00751700b4db75"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/../assets/lighttoeye.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 3:</strong> <em>al-Haytham&rsquo;s model of light perception.</em></p>
<p>The understanding of light and how we perceive it has evolved significantly over time. Ancient Greek philosophers posited that vision occurred through beams of light emitted from the eyes, interacting with the environment. Contrary to this, the Arab scholar <strong>Ibn al-Haytham</strong> (c. 965-1039) introduced a groundbreaking theory, explaining that vision results from light rays originating from luminous bodies like the sun, reflecting off objects and into our eyes, thereby forming visual images. This model marked a pivotal shift in the comprehension of light and vision, laying the groundwork for the modern scientific approach to studying light behavior. As we delve into simulating these natural processes with computers, these historical insights provide a rich context for the development of realistic rendering techniques in computer graphics.</p>
<h2 id="the-raytracing-algorithm-in-a-nutshell">The Raytracing Algorithm in a Nutshell</h2>
<p><strong>Reading time: 8 mins.</strong></p>
<p>Ibn al-Haytham&rsquo;s work sheds light on the fundamental principles behind our ability to see objects. From his studies, two key observations emerge: first, without light, visibility is null, and second, without objects to interact with, light itself remains invisible to us. This becomes evident in scenarios such as traveling through intergalactic space, where the absence of matter results in nothing but darkness, despite the potential presence of photons traversing the void (assuming photons are present, they must originate from a source, and seeing them would involve their direct interaction with our eyes, revealing the source from which they were reflected or emitted).</p>
<h3 id="forward-tracing">Forward Tracing</h3>
<p><a href="#R-image-c144de7e3488cdc62bc476cc50543700" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/../assets/lighttoeyebounce.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c144de7e3488cdc62bc476cc50543700"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/../assets/lighttoeyebounce.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><em><strong>Figure 1:</strong> countless photons emitted by the light source hit the green sphere, but only one will reach the eye&rsquo;s surface.</em></p>
<p>In the context of simulating the interaction between light and objects in computer graphics, it&rsquo;s crucial to understand another physical concept. Of the myriad rays reflected off an object, only a minuscule fraction will actually be perceived by the human eye. For instance, consider a hypothetical light source designed to emit a single photon at a time. When this photon is released, it travels in a straight line until it encounters an object&rsquo;s surface. Assuming no absorption, the photon is then reflected in a seemingly random direction. If this photon reaches our eye, we discern the point of its reflection on the object (as illustrated in figure 1).</p>
<blockquote>
<p><em>You&rsquo;ve stated previously that &ldquo;each point on an illuminated object disperses light rays in all directions.&rdquo; How does this align with the notion of &lsquo;random&rsquo; reflection?</em></p>
<p>The comprehensive explanation for light&rsquo;s omnidirectional reflection from surfaces falls outside this lesson&rsquo;s scope (for a detailed discussion, refer to the lesson on light-matter interaction). To succinctly address your query: it&rsquo;s both yes and no. Naturally, a photon&rsquo;s reflection off a surface follows a specific direction, determined by the surface&rsquo;s microstructure and the photon&rsquo;s approach angle. Although an object&rsquo;s surface may appear uniformly smooth to the naked eye, microscopic examination reveals a complex topography. The accompanying image illustrates paper under varying magnifications, highlighting this microstructure. Given photons&rsquo; diminutive scale, they are reflected by the myriad micro-features on a surface. When a light beam contacts a diffuse object, the photons encounter diverse parts of this microstructure, scattering in numerous directions—so many, in fact, that it simulates reflection in &ldquo;every conceivable direction.&rdquo; In simulations of photon-surface interactions, rays are cast in random directions, which statistically mirrors the effect of omnidirectional reflection.</p>
<p>Certain materials exhibit organized macrostructures that guide light reflection in specific directions, a phenomenon known as anisotropic reflection. This, along with other unique optical effects like iridescence seen in butterfly wings, stems from the material&rsquo;s macroscopic structure and will be explored in detail in lessons on light-material interactions.</p>
<p><a href="#R-image-8bd3bf94cd4171efe625270a7167e752" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/../assets/paperstruct.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-8bd3bf94cd4171efe625270a7167e752"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/../assets/paperstruct.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
</blockquote>
<p>In the realm of computer graphics, we substitute our eyes with an image plane made up of pixels. Here, photons emitted by a light source impact the pixels on this plane, incrementally brightening them. This process continues until all pixels have been appropriately adjusted, culminating in the creation of a computer-generated image. This method is referred to as <strong>forward ray tracing</strong>, tracing the path of photons from their source to the observer.</p>
<p>Yet, this approach raises a significant issue:</p>
<p>In our scenario, we assumed that every reflected photon would intersect with the eye&rsquo;s surface. However, given that rays scatter in all possible directions, each has a minuscule chance of actually reaching the eye. To encounter just one photon that hits the eye, an astronomical number of photons would need to be emitted from the light source. This mirrors the natural world, where countless photons move in all directions at the speed of light. For computational purposes, simulating such an extensive interaction between photons and objects in a scene is impractical, as we will soon elaborate.</p>
<p>One might ponder: &ldquo;Should we not direct photons towards the eye, knowing its location, to ascertain which pixel they intersect, if any?&rdquo; This could serve as an optimization for certain material types. We&rsquo;ll later delve into how diffuse surfaces, which reflect photons in all directions within a hemisphere around the contact point&rsquo;s normal, don&rsquo;t require directional precision. However, for mirror-like surfaces that reflect rays in a precise, mirrored direction (a computation we&rsquo;ll explore later), arbitrarily altering the photon&rsquo;s direction is not viable, making this solution less than ideal.</p>
<blockquote>
<p><em>Is the eye merely a point receptor, or does it possess a surface area? Even if small, the receiving surface is larger than a point, thus capable of capturing more than a singular ray out of zillions.</em></p>
<p>Indeed, the eye functions more like a surface receptor, akin to the film or CCD in cameras, rather than a mere point receptor. This introduction to the ray-tracing algorithm doesn&rsquo;t delve deeply into this aspect. Cameras and eyes alike utilize a lens to focus reflected light onto a surface. Should the lens be extremely small (unlike actuality), reflected light from an object would be confined to a single direction, reminiscent of pinhole cameras&rsquo; operation, a topic for future discussion.</p>
</blockquote>
<p>Even adopting this approach for scenes composed solely of diffuse objects presents challenges. Visualize directing photons from a light source into a scene as akin to spraying paint particles onto an object&rsquo;s surface. Insufficient spray density results in uneven illumination.</p>
<p>Consider the analogy of attempting to paint a teapot by dotting a black sheet of paper with a white marker, with each dot representing a photon. Initially, only a sparse number of photons intersect the teapot, leaving vast areas unmarked. Increasing the dots gradually fills in the gaps, making the teapot progressively more discernible.</p>
<p><a href="#R-image-d3d55316a037bc6082540e80f07383a8" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/../assets/teapotracing.gif" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d3d55316a037bc6082540e80f07383a8"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/../assets/teapotracing.gif" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>However, deploying even thousands or multiples thereof of photons cannot guarantee complete coverage of the object&rsquo;s surface. This method&rsquo;s inherent flaw necessitates running the program until we subjectively deem enough photons have been applied to accurately depict the object. This process, requiring constant monitoring of the rendering process, is impractical in a production setting. The primary cost in ray tracing lies in detecting ray-geometry intersections, not in generating photons, but in identifying all their intersections within the scene, which is exceedingly resource-intensive.</p>
<p>Conclusion: <strong>Forward ray tracing</strong> or <strong>light tracing</strong>, which involves casting rays from the light source, can theoretically replicate natural light behavior on a computer. However, as discussed, this technique is neither efficient nor practical for actual use. Turner Whitted, a pioneer in computer graphics research, critiqued this method in his seminal 1980 paper, &ldquo;An Improved Illumination Model for Shaded Display&rdquo;, noting:</p>
<blockquote>
<p>In an evident approach to ray tracing, light rays emanating from a source are traced through their paths until they strike the viewer. Since only a few will reach the viewer, this approach could be better. In a second approach suggested by Appel, rays are traced in the opposite direction, from the viewer to the objects in the scene.</p>
</blockquote>
<p>Let&rsquo;s explore this alternative strategy Whitted mentions.</p>
<h3 id="backward-tracing">Backward Tracing</h3>
<p><a href="#R-image-bee80f8c0b9bfbaec0c89d0f0adbe8a6" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/../assets/tracefromeyetolight.gif" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-bee80f8c0b9bfbaec0c89d0f0adbe8a6"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/../assets/tracefromeyetolight.gif" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 2:</strong> <em>backward ray-tracing. We trace a ray from the eye to a point on the sphere, then a ray from that point to the light source.</em></p>
<p>In contrast to the natural process where rays emanate from the light source to the receptor (like our eyes), backward tracing reverses this flow by initiating rays from the receptor towards the objects. This technique, known as <strong>backward ray-tracing</strong> or <strong>eye tracing</strong> because rays commence from the eye&rsquo;s position (as depicted in figure 2), effectively addresses the limitations of forward ray tracing. Given the impracticality of mirroring nature&rsquo;s efficiency and perfection in simulations, we adopt a compromise by casting a ray from the eye into the scene. Upon impacting an object, we evaluate the light it receives by dispatching another ray—termed a light or shadow ray—from the contact point towards the light source. If this &ldquo;light ray&rdquo; encounters obstruction by another object, it indicates that the initial point of contact is shadowed, receiving no light. Hence, these rays are more aptly called <strong>shadow rays</strong>. The inaugural ray shot from the eye (or camera) into the scene is referred to in computer graphics literature as a <strong>primary ray</strong>, <strong>visibility ray</strong>, or <strong>camera ray</strong>.</p>
<blockquote>
<p>Throughout this lesson, forward tracing is used to describe the method of casting rays from the light, in contrast to backward tracing, where rays are projected from the camera. Nonetheless, some authors invert these terminologies, with forward tracing denoting rays emitted from the camera due to its prevalence in CG path-tracing techniques. To circumvent confusion, the explicit terms of light and eye tracing can be employed, particularly within discussions on bi-directional path tracing (refer to the Light Transport section for more).</p>
</blockquote>
<h3 id="conclusion">Conclusion</h3>
<p>The technique of initiating rays either from the light source or from the eye is encapsulated by the term <strong>path tracing</strong> in computer graphics. While ray-tracing is a synonymous term, path tracing emphasizes the methodological essence of generating computer-generated imagery by tracing the journey of light from its source to the camera, or vice versa. This approach facilitates the realistic simulation of optical phenomena such as caustics or indirect illumination, where light reflects off surfaces within the scene. These subjects are slated for exploration in forthcoming lessons.</p>
<h2 id="implementing-the-raytracing-algorithm">Implementing the Raytracing Algorithm</h2>
<p><strong>Reading time: 5 mins.</strong></p>
<p>Armed with an understanding of light-matter interactions, cameras and digital images, we are poised to construct our very first ray tracer. This chapter will delve into the heart of the ray-tracing algorithm, laying the groundwork for our exploration. However, it&rsquo;s important to note that what we develop here in this chapter won&rsquo;t yet be a complete, functioning program. For the moment, I invite you to trust in the learning process, understanding that the functions we mention without providing explicit code will be thoroughly explained as we progress.</p>
<p>Remember, this lesson bears the title &ldquo;Raytracing in a Nutshell.&rdquo; In subsequent lessons, we&rsquo;ll delve into greater detail on each technique introduced, progressively enhancing our understanding and our ability to simulate light and shadow through computation. Nevertheless, by the end of this lesson, you&rsquo;ll have crafted a functional ray tracer capable of compiling and generating images. This marks not just a significant milestone in your learning journey but also a testament to the power and elegance of ray tracing in generating images. Let&rsquo;s go.</p>
<p>Consider the natural propagation of light: a myriad of rays emitted from various light sources, meandering until they converge upon the eye&rsquo;s surface. Ray tracing, in its essence, mirrors this natural phenomenon, albeit in reverse, rendering it a virtually flawless simulator of reality.</p>
<p>The essence of the ray-tracing algorithm is to render an image pixel by pixel. For each pixel, it launches a primary ray into the scene, its direction determined by drawing a line from the eye through the pixel&rsquo;s center. This primary ray&rsquo;s journey is then tracked to ascertain if it intersects with any scene objects. In scenarios where multiple intersections occur, the algorithm selects the intersection nearest to the eye for further processing. A secondary ray, known as a shadow ray, is then projected from this nearest intersection point towards the light source (Figure 1).</p>
<p><a href="#R-image-bea0ed0feff3758f4774bb42becf70e9" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/../assets/lightingnoshadow.gif" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-bea0ed0feff3758f4774bb42becf70e9"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/../assets/lightingnoshadow.gif" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 1:</strong> <em>A primary ray is cast through the pixel center to detect object intersections. Upon finding one, a shadow ray is dispatched to determine the illumination status of the point.</em></p>
<p>An intersection point is deemed illuminated if the shadow ray reaches the light source unobstructed. Conversely, if it intersects another object en route, it signifies the casting of a shadow on the initial point (Figure 2).</p>
<p><a href="#R-image-08372aead5cb3d1eb00a74cb198dd9f1" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/../assets/lightingshadow.gif" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-08372aead5cb3d1eb00a74cb198dd9f1"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/../assets/lightingshadow.gif" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 2:</strong> <em>A shadow is cast on the larger sphere by the smaller one, as the shadow ray encounters the smaller sphere before reaching the light.</em></p>
<p>Repeating this procedure across all pixels yields a two-dimensional depiction of our three-dimensional scene (Figure 3).</p>
<p><a href="#R-image-88b0f58f01605bdc06da364726b0ba1b" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/../assets/pixelrender.gif" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-88b0f58f01605bdc06da364726b0ba1b"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/../assets/pixelrender.gif" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 3:</strong> <em>Rendering a frame involves dispatching a primary ray for every pixel within the frame buffer.</em></p>
<p>Below is the pseudocode for implementing this algorithm:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">imageHeight</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">imageWidth</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">        <span class="c1">// Determine the direction of the primary ray
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1"></span>        <span class="n">Ray</span> <span class="n">primRay</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">        <span class="n">computePrimRay</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">primRay</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">        <span class="c1">// Initiate a search for intersections within the scene
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1"></span>        <span class="n">Point</span> <span class="n">pHit</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        <span class="n">Normal</span> <span class="n">nHit</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">        <span class="kt">float</span> <span class="n">minDist</span> <span class="o">=</span> <span class="n">INFINITY</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">10</span><span class="cl">        <span class="n">Object</span> <span class="o">*</span><span class="n">object</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">11</span><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">objects</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln">12</span><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">Intersect</span><span class="p">(</span><span class="n">objects</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">primRay</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pHit</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nHit</span><span class="p">))</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln">13</span><span class="cl">                <span class="kt">float</span> <span class="n">distance</span> <span class="o">=</span> <span class="n">Distance</span><span class="p">(</span><span class="n">eyePosition</span><span class="p">,</span> <span class="n">pHit</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">14</span><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">distance</span> <span class="o">&lt;</span> <span class="n">minDist</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln">15</span><span class="cl">                    <span class="n">object</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">objects</span><span class="p">[</span><span class="n">k</span><span class="p">];</span> 
</span></span><span class="line"><span class="ln">16</span><span class="cl">                    <span class="n">minDist</span> <span class="o">=</span> <span class="n">distance</span><span class="p">;</span>  <span class="c1">// Update the minimum distance
</span></span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="c1"></span>                <span class="p">}</span> 
</span></span><span class="line"><span class="ln">18</span><span class="cl">            <span class="p">}</span> 
</span></span><span class="line"><span class="ln">19</span><span class="cl">        <span class="p">}</span> 
</span></span><span class="line"><span class="ln">20</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">object</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln">21</span><span class="cl">            <span class="c1">// Illuminate the intersection point
</span></span></span><span class="line"><span class="ln">22</span><span class="cl"><span class="c1"></span>            <span class="n">Ray</span> <span class="n">shadowRay</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">23</span><span class="cl">            <span class="n">shadowRay</span><span class="p">.</span><span class="n">direction</span> <span class="o">=</span> <span class="n">lightPosition</span> <span class="o">-</span> <span class="n">pHit</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">24</span><span class="cl">            <span class="kt">bool</span> <span class="n">isInShadow</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">25</span><span class="cl">            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">objects</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln">26</span><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">Intersect</span><span class="p">(</span><span class="n">objects</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">shadowRay</span><span class="p">))</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln">27</span><span class="cl">                    <span class="n">isInShadow</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">28</span><span class="cl">                    <span class="k">break</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">29</span><span class="cl">                <span class="p">}</span> 
</span></span><span class="line"><span class="ln">30</span><span class="cl">            <span class="p">}</span> 
</span></span><span class="line"><span class="ln">31</span><span class="cl">        <span class="p">}</span> 
</span></span><span class="line"><span class="ln">32</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isInShadow</span><span class="p">)</span> 
</span></span><span class="line"><span class="ln">33</span><span class="cl">            <span class="n">pixels</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">object</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">*</span> <span class="n">light</span><span class="p">.</span><span class="n">brightness</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">34</span><span class="cl">        <span class="k">else</span> 
</span></span><span class="line"><span class="ln">35</span><span class="cl">            <span class="n">pixels</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">36</span><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="ln">37</span><span class="cl"><span class="p">}</span> 
</span></span></code></pre></div><p>The elegance of ray tracing lies in its simplicity and direct correlation with the physical world, allowing for the creation of a basic ray tracer in as few as 200 lines of code. This simplicity contrasts sharply with more complex algorithms, like scanline rendering, making ray tracing comparatively effortless to implement.</p>
<p>Arthur Appel first introduced ray tracing in his 1969 paper, &ldquo;Some Techniques for Shading Machine Renderings of Solids&rdquo;. Given its numerous advantages, one might wonder why ray tracing hasn&rsquo;t completely supplanted other rendering techniques. The primary hindrance, both historically and to some extent currently, is its computational speed. As Appel noted:</p>
<blockquote>
<p>This method is very time consuming, usually requiring several thousand times as much calculation time for beneficial results as a wireframe drawing. About one-half of this time is devoted to determining the point-to-point correspondence of the projection and the scene.</p>
</blockquote>
<p>Thus, the crux of the issue with ray tracing is its slowness—a sentiment echoed by James Kajiya, a pivotal figure in computer graphics, who remarked, &ldquo;ray tracing is not slow - computers are&rdquo;. The challenge lies in the extensive computation required to calculate ray-geometry intersections. For years, this computational demand was the primary drawback of ray tracing. However, with the continual advancement of computing power, this limitation is becoming increasingly mitigated. Although ray tracing remains slower compared to methods like z-buffer algorithms, modern computers can now render frames in minutes that previously took hours. The development of real-time and interactive ray tracing is currently a vibrant area of research.</p>
<p>In summary, ray tracing&rsquo;s rendering process can be bifurcated into visibility determination and shading, both of which necessitate computationally intensive ray-geometry intersection tests. This method offers a trade-off between rendering speed and accuracy. Since Appel&rsquo;s seminal work, extensive research has been conducted to expedite ray-object intersection calculations. With these advancements and the rise in computing power, ray tracing has emerged as a standard in offline rendering software. While rasterization algorithms continue to dominate video game engines, the advent of GPU-accelerated ray tracing and RTX technology in 2017-2018 marks a significant milestone towards real-time ray tracing. Some video games now feature options to enable ray tracing, albeit for limited effects like enhanced reflections and shadows, heralding a new era in gaming graphics.</p>
<h2 id="adding-reflection-and-refraction">Adding Reflection and Refraction</h2>
<p><strong>Reading time: 6 mins.</strong></p>
<p>Another key benefit of ray tracing is its capacity to seamlessly simulate intricate optical effects such as <strong>reflection</strong> and <strong>refraction</strong>. These capabilities are crucial for accurately rendering materials like glass or mirrored surfaces. <strong>Turner Whitted</strong> pioneered the enhancement of Appel&rsquo;s basic ray-tracing algorithm to include such advanced rendering techniques in his landmark 1979 paper, &ldquo;An Improved Illumination Model for Shaded Display.&rdquo; Whitted&rsquo;s innovation involved extending the algorithm to account for the computations necessary for handling reflection and refraction effects.</p>
<p><a href="#R-image-d19a8df49862ad00225123ba579a21c6" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/../assets/boule-neige.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d19a8df49862ad00225123ba579a21c6"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/../assets/boule-neige.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Reflection and refraction are fundamental optical phenomena. While detailed exploration of these concepts will occur in a future lesson, it&rsquo;s beneficial to understand their basics for simulation purposes. Consider a glass sphere that exhibits both reflective and refractive qualities. Knowing the incident ray&rsquo;s direction upon the sphere allows us to calculate the subsequent behavior of the ray. The directions for both reflected and refracted rays are determined by the surface normal at the point of contact and the incident ray&rsquo;s approach. Additionally, calculating the direction of refraction requires knowledge of the material&rsquo;s <strong>index of refraction</strong>. Refraction can be visualized as the bending of the ray&rsquo;s path when it transitions between mediums of differing refractive indices.</p>
<p>It&rsquo;s also important to recognize that materials like a glass sphere possess both reflective and refractive properties simultaneously. The challenge arises in determining how to blend these effects at a specific surface point. Is it as simple as combining 50% reflection with 50% refraction? The reality is more complex. The blend ratio is influenced by the angle of incidence and factors like the surface normal and the material&rsquo;s refractive index. Here, the <strong>Fresnel equation</strong> plays a critical role, providing the formula needed to ascertain the appropriate mix of reflection and refraction.</p>
<p><a href="#R-image-59cfcfcb597ee9d98428c599042b4d24" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/../assets/reflectionrefraction.gif" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-59cfcfcb597ee9d98428c599042b4d24"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/../assets/reflectionrefraction.gif" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 1:</strong> <em>Utilizing optical principles to calculate the paths of reflected and refracted rays.</em></p>
<p>In summary, the Whitted algorithm operates as follows: a primary ray is cast from the observer to identify the nearest intersection with any scene objects. Upon encountering a non-diffuse or transparent object, additional calculations are required. For an object such as a glass sphere, determining the surface color involves calculating both the reflected and refracted colors and then appropriately blending them according to the Fresnel equation. This three-step process—calculating reflection, calculating refraction, and applying the Fresnel equation—enables the realistic rendering of complex optical phenomena.</p>
<p><a href="#R-image-74b5b9c4e16e0fbfcfd2f36672d6a9fc" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/../assets/glassball.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-74b5b9c4e16e0fbfcfd2f36672d6a9fc"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/../assets/glassball.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>To achieve the realistic rendering of materials that exhibit both reflection and refraction, such as glass, the ray-tracing algorithm incorporates a few key steps:</p>
<ul>
<li><strong>Reflection Calculation</strong>: The first step involves determining the direction in which light is reflected off an object. This calculation requires two critical pieces of information: the surface normal at the point of intersection and the incoming direction of the primary ray. With the reflection direction determined, a new ray is cast into the scene. For instance, if this reflection ray encounters a red sphere, we use the established algorithm to assess the amount of light reaching that point on the sphere by sending a shadow ray toward the light source. The color acquired (which turns black if in shadow) is then adjusted by the light&rsquo;s intensity before being factored into the final color reflected back to the surface of the glass ball.</li>
<li><strong>Refraction Calculation</strong>: Next, we simulate the refraction effect, or the bending of light, as it passes through the glass ball, referred to as the <strong>transmission ray</strong>. To accurately compute the ray&rsquo;s new direction upon entering and exiting the glass, the normal at the point of intersection, the direction of the primary ray, and the material&rsquo;s refractive index are required. As the refractive ray exits the sphere, it undergoes refraction once more due to the change in medium, altering its path. This bending effect is responsible for the visual distortion seen when looking through materials with different refractive indices. If this refracted ray then intersects with, for example, a green sphere, local illumination at that point is calculated (again using a shadow ray), and the resulting color is influenced by whether the point is in shadow or light, which is then considered in the visual effect on the glass ball&rsquo;s surface.</li>
<li><strong>Applying the Fresnel Equation</strong>: The final step involves using the Fresnel equation to calculate the proportions of reflected and refracted light contributing to the color at the point of interest on the glass ball. The equation requires the refractive index of the material, the angle between the primary ray and the normal at the point of intersection, and outputs the mixing values for reflection and refraction.</li>
</ul>
<p>The pseudo-code provided outlines the process of integrating reflection and refraction colors to determine the appearance of a glass ball at the point of intersection:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="c1">// compute reflection color
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1"></span><span class="n">color</span> <span class="n">reflectionColor</span> <span class="o">=</span> <span class="n">computeReflectionColor</span><span class="p">();</span> 
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1">// compute refraction color
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="c1"></span><span class="n">color</span> <span class="n">refractionColor</span> <span class="o">=</span> <span class="n">computeRefractionColor</span><span class="p">();</span> 
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="kt">float</span> <span class="n">Kr</span><span class="p">;</span> <span class="c1">// reflection mix value
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="c1"></span><span class="kt">float</span> <span class="n">Kt</span><span class="p">;</span> <span class="c1">// refraction mix value
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1">// Calculate the mixing values using the Fresnel equation
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="c1"></span><span class="n">fresnel</span><span class="p">(</span><span class="n">refractiveIndex</span><span class="p">,</span> <span class="n">normalHit</span><span class="p">,</span> <span class="n">primaryRayDirection</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Kr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Kt</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="c1">// Mix the reflection and refraction colors based on the Fresnel equation. Note Kt = 1 - Kr
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="c1"></span><span class="n">glassBallColorAtHit</span> <span class="o">=</span> <span class="n">Kr</span> <span class="o">*</span> <span class="n">reflectionColor</span> <span class="o">+</span> <span class="n">Kt</span> <span class="o">*</span> <span class="n">refractionColor</span><span class="p">;</span></span></span></code></pre></div><p>The principle that light cannot be created or destroyed underpins the relationship between the reflected (Kr) and refracted (Kt) portions of incident light. This conservation of light means that the portion of light not reflected is necessarily refracted, ensuring that the sum of reflected and refracted light equals the total incoming light. This concept is elegantly captured by the Fresnel equation, which provides values for <code>Kr</code> and <code>Kt</code> that, when correctly calculated, should sum to one. This relationship allows for a simplification in calculations; knowing either <code>Kr</code> or <code>Kt</code> enables the determination of the other by simple subtraction from one.</p>
<p>This algorithm&rsquo;s beauty also lies in its <strong>recursive</strong> nature, which, while powerful, introduces complexity. For instance, if the reflection ray from our initial glass ball scenario strikes a red sphere and the refraction ray intersects with a green sphere, and both these spheres are also made of glass, the process of calculating reflection and refraction colors repeats for these new intersections. This recursive aspect allows for the detailed rendering of scenes with multiple reflective and refractive surfaces. However, it also presents challenges, particularly in scenarios like a camera inside a box with reflective interior walls, where rays could theoretically bounce indefinitely. To manage this, an arbitrary limit on recursion depth is imposed, ceasing the calculation once a ray reaches a predefined depth. This limitation ensures that the rendering process concludes, providing an approximate representation of the scene rather than becoming bogged down in endless calculations. While this may compromise absolute accuracy, it strikes a balance between detail and computational feasibility, ensuring that the rendering process yields results within practical timeframes.</p>
<h2 id="writing-a-basic-raytracer">Writing a Basic Raytracer</h2>
<p><strong>Reading time: 6 mins.</strong></p>
<p>Many of our readers have reached out, curious to see a practical example of ray tracing in action, asking, &ldquo;If it&rsquo;s as straightforward as you say, why not show us a real example?&rdquo; Deviating slightly from our original step-by-step approach to building a renderer, we decided to put together a basic ray tracer. This compact program, consisting of roughly 300 lines, was developed in just a few hours. While it&rsquo;s not a showcase of our best work (hopefully) — given the quick turnaround — we aimed to demonstrate that with a solid grasp of the underlying concepts, creating such a program is quite easy. The source code is up for grabs for those interested.</p>
<p>This quick project wasn&rsquo;t polished with detailed comments, and there&rsquo;s certainly room for optimization. In our ray tracer version, we chose to make the light source a visible sphere, allowing its reflection to be observed on the surfaces of reflective spheres. To address the challenge of visualizing transparent glass spheres—which can be tricky to detect due to their clear appearance—we opted to color them slightly red. This decision was informed by the real-world behavior of clear glass, which may not always be perceptible, heavily influenced by its surroundings. It&rsquo;s worth noting, however, that the image produced by this preliminary version isn&rsquo;t flawless; for example, the shadow cast by the transparent red sphere appears unrealistically solid. Future lessons will delve into refining such details for more accurate visual representation. Additionally, we experimented with implementing features like a simplified Fresnel effect (using a method known as the facing ratio) and refraction, topics we plan to explore in depth later on. If any of these concepts seem unclear, rest assured they will be clarified in due course. For now, you have a small, functional program to tinker with.</p>
<p>To get started with the program, first download the source code to your local machine. You&rsquo;ll need a C++ compiler, such as clang++, to compile the code. This program is straightforward to compile and doesn&rsquo;t require any special libraries. Open a terminal window (GitBash on Windows, or a standard terminal in Linux or macOS), navigate to the directory containing the source file, and run the following command (assuming you&rsquo;re using gcc):</p>
<div class="wrap-code highlight"><pre tabindex="0"><code>c++ -O3 -o raytracer raytracer.cpp</code></pre></div><p>If you use <code>clang</code>, use the following command instead:</p>
<div class="wrap-code highlight"><pre tabindex="0"><code>clang++ -O3 -o raytracer raytracer.cpp</code></pre></div><p>To generate an image, execute the program by entering ./raytracer into a terminal. After a brief pause, the program will produce a file named untitled.ppm on your computer. This file can be viewed using Photoshop, Preview (for Mac users), or Gimp. Additionally, we will cover how to open and view PPM images in an upcoming lesson.</p>
<p>Below is a sample implementation of the traditional recursive ray-tracing algorithm, presented in pseudo-code:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#define MAX_RAY_DEPTH 3 
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span> 
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">color</span> <span class="nf">Trace</span><span class="p">(</span><span class="k">const</span> <span class="n">Ray</span> <span class="o">&amp;</span><span class="n">ray</span><span class="p">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">)</span> 
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="n">Object</span> <span class="o">*</span><span class="n">object</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="kt">float</span> <span class="n">minDistance</span> <span class="o">=</span> <span class="n">INFINITY</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="n">Point</span> <span class="n">pHit</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="n">Normal</span> <span class="n">nHit</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">objects</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln">10</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">Intersect</span><span class="p">(</span><span class="n">objects</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">ray</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pHit</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nHit</span><span class="p">))</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln">11</span><span class="cl">            <span class="kt">float</span> <span class="n">distance</span> <span class="o">=</span> <span class="n">Distance</span><span class="p">(</span><span class="n">ray</span><span class="p">.</span><span class="n">origin</span><span class="p">,</span> <span class="n">pHit</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">12</span><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">distance</span> <span class="o">&lt;</span> <span class="n">minDistance</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln">13</span><span class="cl">                <span class="n">object</span> <span class="o">=</span> <span class="n">objects</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">                <span class="n">minDistance</span> <span class="o">=</span> <span class="n">distance</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">            <span class="p">}</span> 
</span></span><span class="line"><span class="ln">16</span><span class="cl">        <span class="p">}</span> 
</span></span><span class="line"><span class="ln">17</span><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="ln">18</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">object</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> 
</span></span><span class="line"><span class="ln">19</span><span class="cl">        <span class="k">return</span> <span class="n">backgroundColor</span><span class="p">;</span> <span class="c1">// Returning a background color instead of 0
</span></span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="c1"></span>    <span class="c1">// if the object material is glass and depth is less than MAX_RAY_DEPTH, split the ray
</span></span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">isGlass</span> <span class="o">&amp;&amp;</span> <span class="n">depth</span> <span class="o">&lt;</span> <span class="n">MAX_RAY_DEPTH</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln">22</span><span class="cl">        <span class="n">Ray</span> <span class="n">reflectionRay</span><span class="p">,</span> <span class="n">refractionRay</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">        <span class="n">color</span> <span class="n">reflectionColor</span><span class="p">,</span> <span class="n">refractionColor</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">24</span><span class="cl">        <span class="kt">float</span> <span class="n">Kr</span><span class="p">,</span> <span class="n">Kt</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">25</span><span class="cl"> 
</span></span><span class="line"><span class="ln">26</span><span class="cl">        <span class="c1">// Compute the reflection ray
</span></span></span><span class="line"><span class="ln">27</span><span class="cl"><span class="c1"></span>        <span class="n">reflectionRay</span> <span class="o">=</span> <span class="n">computeReflectionRay</span><span class="p">(</span><span class="n">ray</span><span class="p">.</span><span class="n">direction</span><span class="p">,</span> <span class="n">nHit</span><span class="p">,</span> <span class="n">ray</span><span class="p">.</span><span class="n">origin</span><span class="p">,</span> <span class="n">pHit</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">28</span><span class="cl">        <span class="n">reflectionColor</span> <span class="o">=</span> <span class="n">Trace</span><span class="p">(</span><span class="n">reflectionRay</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">29</span><span class="cl"> 
</span></span><span class="line"><span class="ln">30</span><span class="cl">        <span class="c1">// Compute the refraction ray
</span></span></span><span class="line"><span class="ln">31</span><span class="cl"><span class="c1"></span>        <span class="n">refractionRay</span> <span class="o">=</span> <span class="n">computeRefractionRay</span><span class="p">(</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">indexOfRefraction</span><span class="p">,</span> <span class="n">ray</span><span class="p">.</span><span class="n">direction</span><span class="p">,</span> <span class="n">nHit</span><span class="p">,</span> <span class="n">ray</span><span class="p">.</span><span class="n">origin</span><span class="p">,</span> <span class="n">pHit</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">32</span><span class="cl">        <span class="n">refractionColor</span> <span class="o">=</span> <span class="n">Trace</span><span class="p">(</span><span class="n">refractionRay</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">33</span><span class="cl"> 
</span></span><span class="line"><span class="ln">34</span><span class="cl">        <span class="c1">// Compute Fresnel&#39;s effect
</span></span></span><span class="line"><span class="ln">35</span><span class="cl"><span class="c1"></span>        <span class="n">fresnel</span><span class="p">(</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">indexOfRefraction</span><span class="p">,</span> <span class="n">nHit</span><span class="p">,</span> <span class="n">ray</span><span class="p">.</span><span class="n">direction</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Kr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Kt</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">36</span><span class="cl"> 
</span></span><span class="line"><span class="ln">37</span><span class="cl">        <span class="c1">// Combine reflection and refraction colors based on Fresnel&#39;s effect
</span></span></span><span class="line"><span class="ln">38</span><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="n">reflectionColor</span> <span class="o">*</span> <span class="n">Kr</span> <span class="o">+</span> <span class="n">refractionColor</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">Kr</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">39</span><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">isGlass</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Check if object is not glass (diffuse/opaque)
</span></span></span><span class="line"><span class="ln">40</span><span class="cl"><span class="c1"></span>        <span class="c1">// Compute illumination only if object is not in shadow
</span></span></span><span class="line"><span class="ln">41</span><span class="cl"><span class="c1"></span>        <span class="n">Ray</span> <span class="n">shadowRay</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">42</span><span class="cl">        <span class="n">shadowRay</span><span class="p">.</span><span class="n">origin</span> <span class="o">=</span> <span class="n">pHit</span> <span class="o">+</span> <span class="n">nHit</span> <span class="o">*</span> <span class="n">bias</span><span class="p">;</span> <span class="c1">// Adding a small bias to avoid self-intersection
</span></span></span><span class="line"><span class="ln">43</span><span class="cl"><span class="c1"></span>        <span class="n">shadowRay</span><span class="p">.</span><span class="n">direction</span> <span class="o">=</span> <span class="n">Normalize</span><span class="p">(</span><span class="n">lightPosition</span> <span class="o">-</span> <span class="n">pHit</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">44</span><span class="cl">        <span class="kt">bool</span> <span class="n">isInShadow</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">45</span><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">objects</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln">46</span><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">Intersect</span><span class="p">(</span><span class="n">objects</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">shadowRay</span><span class="p">))</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln">47</span><span class="cl">                <span class="n">isInShadow</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">48</span><span class="cl">                <span class="k">break</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">49</span><span class="cl">            <span class="p">}</span> 
</span></span><span class="line"><span class="ln">50</span><span class="cl">        <span class="p">}</span> 
</span></span><span class="line"><span class="ln">51</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isInShadow</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">52</span><span class="cl">            <span class="k">return</span> <span class="n">object</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">*</span> <span class="n">light</span><span class="p">.</span><span class="n">brightness</span><span class="p">;</span> <span class="c1">// point is illuminated
</span></span></span><span class="line"><span class="ln">53</span><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="ln">54</span><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="ln">55</span><span class="cl">    <span class="k">return</span> <span class="n">backgroundColor</span><span class="p">;</span> <span class="c1">// Return background color if no interaction
</span></span></span><span class="line"><span class="ln">56</span><span class="cl"><span class="c1"></span><span class="p">}</span> 
</span></span><span class="line"><span class="ln">57</span><span class="cl"> 
</span></span><span class="line"><span class="ln">58</span><span class="cl"><span class="c1">// Render loop for each pixel of the image
</span></span></span><span class="line"><span class="ln">59</span><span class="cl"><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">imageHeight</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln">60</span><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">imageWidth</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln">61</span><span class="cl">        <span class="n">Ray</span> <span class="n">primRay</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">62</span><span class="cl">        <span class="n">computePrimRay</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">primRay</span><span class="p">);</span> <span class="c1">// Assume computePrimRay correctly sets the ray origin and direction
</span></span></span><span class="line"><span class="ln">63</span><span class="cl"><span class="c1"></span>        <span class="n">pixels</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">Trace</span><span class="p">(</span><span class="n">primRay</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">64</span><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="ln">65</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p><a href="#R-image-bfad6bfc25093958310dbb033b333b12" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/../assets/raytrace1.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-bfad6bfc25093958310dbb033b333b12"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/../assets/raytrace1.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 1:</strong> <em>Result of our ray tracing algorithm.</em></p>
<h3 id="a-minimal-ray-tracer">A Minimal Ray Tracer</h3>
<p><a href="#R-image-fe2c7b72a83c4d8c7f072841ad31a66f" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/../assets/aek.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-fe2c7b72a83c4d8c7f072841ad31a66f"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-1/../assets/aek.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 2:</strong> <em>Result of our Paul Heckbert&rsquo;s ray tracing algorithm.</em></p>
<p>The concept of condensing a ray tracer to fit on a business card, pioneered by researcher Paul Heckbert, stands as a testament to the power of minimalistic programming. Heckbert&rsquo;s innovative challenge, aimed at distilling a ray tracer into the most concise C/C++ code possible, was detailed in his contribution to Graphics Gems IV. This initiative sparked a wave of enthusiasm among programmers, inspiring many to undertake this compact coding exercise.</p>
<p>A notable example of such an endeavor is a version crafted by Andrew Kensler. His work resulted in a visually compelling output, as demonstrated by the image produced by his program. Particularly impressive is the depth of field effect he achieved, where objects blur as they recede into the distance. The ability to generate an image of considerable complexity from a remarkably succinct piece of code is truly remarkable.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="c1">// minray &gt; minray.ppm
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;math.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="cp"></span><span class="k">typedef</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span><span class="k">typedef</span> <span class="kt">float</span> <span class="n">f</span><span class="p">;</span><span class="k">struct</span> <span class="nc">v</span><span class="p">{</span><span class="n">f</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">;</span><span class="n">v</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="n">v</span> <span class="n">r</span><span class="p">){</span><span class="k">return</span> <span class="nf">v</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">r</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">+</span><span class="n">r</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="o">+</span><span class="n">r</span><span class="p">.</span><span class="n">z</span><span class="p">);}</span><span class="n">v</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="n">f</span> <span class="n">r</span><span class="p">){</span><span class="k">return</span> <span class="nf">v</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">r</span><span class="p">,</span><span class="n">y</span><span class="o">*</span><span class="n">r</span><span class="p">,</span><span class="n">z</span><span class="o">*</span><span class="n">r</span><span class="p">);}</span><span class="n">f</span> <span class="k">operator</span><span class="o">%</span><span class="p">(</span><span class="n">v</span> <span class="n">r</span><span class="p">){</span><span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="n">r</span><span class="p">.</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="o">*</span><span class="n">r</span><span class="p">.</span><span class="n">y</span><span class="o">+</span><span class="n">z</span><span class="o">*</span><span class="n">r</span><span class="p">.</span><span class="n">z</span><span class="p">;}</span><span class="n">v</span><span class="p">(){}</span><span class="n">v</span> <span class="k">operator</span><span class="o">^</span><span class="p">(</span><span class="n">v</span> <span class="n">r</span><span class="p">){</span><span class="k">return</span> <span class="nf">v</span><span class="p">(</span><span class="n">y</span><span class="o">*</span><span class="n">r</span><span class="p">.</span><span class="n">z</span><span class="o">-</span><span class="n">z</span><span class="o">*</span><span class="n">r</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="o">*</span><span class="n">r</span><span class="p">.</span><span class="n">x</span><span class="o">-</span><span class="n">x</span><span class="o">*</span><span class="n">r</span><span class="p">.</span><span class="n">z</span><span class="p">,</span><span class="n">x</span><span class="o">*</span><span class="n">r</span><span class="p">.</span><span class="n">y</span><span class="o">-</span><span class="n">y</span><span class="o">*</span><span class="n">r</span><span class="p">.</span><span class="n">x</span><span class="p">);}</span><span class="n">v</span><span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">,</span><span class="n">f</span> <span class="n">b</span><span class="p">,</span><span class="n">f</span> <span class="n">c</span><span class="p">){</span><span class="n">x</span><span class="o">=</span><span class="n">a</span><span class="p">;</span><span class="n">y</span><span class="o">=</span><span class="n">b</span><span class="p">;</span><span class="n">z</span><span class="o">=</span><span class="n">c</span><span class="p">;}</span><span class="n">v</span> <span class="k">operator</span><span class="o">!</span><span class="p">(){</span><span class="k">return</span><span class="o">*</span><span class="k">this</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">sqrt</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="o">%*</span><span class="k">this</span><span class="p">));}};</span><span class="n">i</span> <span class="n">G</span><span class="p">[]</span><span class="o">=</span><span class="p">{</span><span class="mi">247570</span><span class="p">,</span><span class="mi">280596</span><span class="p">,</span><span class="mi">280600</span><span class="p">,</span><span class="mi">249748</span><span class="p">,</span><span class="mi">18578</span><span class="p">,</span><span class="mi">18577</span><span class="p">,</span><span class="mi">231184</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="p">};</span><span class="n">f</span> <span class="nf">R</span><span class="p">(){</span><span class="k">return</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="n">rand</span><span class="p">()</span><span class="o">/</span><span class="n">RAND_MAX</span><span class="p">;}</span><span class="n">i</span> <span class="nf">T</span><span class="p">(</span><span class="n">v</span> <span class="n">o</span><span class="p">,</span><span class="n">v</span> <span class="n">d</span><span class="p">,</span><span class="n">f</span><span class="o">&amp;</span><span class="n">t</span><span class="p">,</span><span class="n">v</span><span class="o">&amp;</span><span class="n">n</span><span class="p">){</span><span class="n">t</span><span class="o">=</span><span class="mf">1e9</span><span class="p">;</span><span class="n">i</span> <span class="n">m</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">f</span> <span class="n">p</span><span class="o">=-</span><span class="n">o</span><span class="p">.</span><span class="n">z</span><span class="o">/</span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="p">;</span><span class="k">if</span><span class="p">(</span><span class="mf">.01</span><span class="o">&lt;</span><span class="n">p</span><span class="p">)</span><span class="n">t</span><span class="o">=</span><span class="n">p</span><span class="p">,</span><span class="n">n</span><span class="o">=</span><span class="n">v</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">m</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="n">k</span><span class="o">=</span><span class="mi">19</span><span class="p">;</span><span class="n">k</span><span class="o">--</span><span class="p">;)</span><span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="n">j</span><span class="o">=</span><span class="mi">9</span><span class="p">;</span><span class="n">j</span><span class="o">--</span><span class="p">;)</span><span class="k">if</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">&amp;</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">k</span><span class="p">){</span><span class="n">v</span> <span class="n">p</span><span class="o">=</span><span class="n">o</span><span class="o">+</span><span class="n">v</span><span class="p">(</span><span class="o">-</span><span class="n">k</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="n">j</span><span class="o">-</span><span class="mi">4</span><span class="p">);</span><span class="n">f</span> <span class="n">b</span><span class="o">=</span><span class="n">p</span><span class="o">%</span><span class="n">d</span><span class="p">,</span><span class="n">c</span><span class="o">=</span><span class="n">p</span><span class="o">%</span><span class="n">p</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">q</span><span class="o">=</span><span class="n">b</span><span class="o">*</span><span class="n">b</span><span class="o">-</span><span class="n">c</span><span class="p">;</span><span class="k">if</span><span class="p">(</span><span class="n">q</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">){</span><span class="n">f</span> <span class="n">s</span><span class="o">=-</span><span class="n">b</span><span class="o">-</span><span class="n">sqrt</span><span class="p">(</span><span class="n">q</span><span class="p">);</span><span class="k">if</span><span class="p">(</span><span class="n">s</span><span class="o">&lt;</span><span class="n">t</span><span class="o">&amp;&amp;</span><span class="n">s</span><span class="o">&gt;</span><span class="mf">.01</span><span class="p">)</span><span class="n">t</span><span class="o">=</span><span class="n">s</span><span class="p">,</span><span class="n">n</span><span class="o">=!</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="n">d</span><span class="o">*</span><span class="n">t</span><span class="p">),</span><span class="n">m</span><span class="o">=</span><span class="mi">2</span><span class="p">;}}</span><span class="k">return</span> <span class="n">m</span><span class="p">;}</span><span class="n">v</span> <span class="nf">S</span><span class="p">(</span><span class="n">v</span> <span class="n">o</span><span class="p">,</span><span class="n">v</span> <span class="n">d</span><span class="p">){</span><span class="n">f</span> <span class="n">t</span><span class="p">;</span><span class="n">v</span> <span class="n">n</span><span class="p">;</span><span class="n">i</span> <span class="n">m</span><span class="o">=</span><span class="n">T</span><span class="p">(</span><span class="n">o</span><span class="p">,</span><span class="n">d</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">n</span><span class="p">);</span><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">m</span><span class="p">)</span><span class="k">return</span> <span class="n">v</span><span class="p">(</span><span class="mf">.7</span><span class="p">,</span><span class="mf">.6</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">pow</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span><span class="n">v</span> <span class="n">h</span><span class="o">=</span><span class="n">o</span><span class="o">+</span><span class="n">d</span><span class="o">*</span><span class="n">t</span><span class="p">,</span><span class="n">l</span><span class="o">=!</span><span class="p">(</span><span class="n">v</span><span class="p">(</span><span class="mi">9</span><span class="o">+</span><span class="n">R</span><span class="p">(),</span><span class="mi">9</span><span class="o">+</span><span class="n">R</span><span class="p">(),</span><span class="mi">16</span><span class="p">)</span><span class="o">+</span><span class="n">h</span><span class="o">*-</span><span class="mi">1</span><span class="p">),</span><span class="n">r</span><span class="o">=</span><span class="n">d</span><span class="o">+</span><span class="n">n</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">%</span><span class="n">d</span><span class="o">*-</span><span class="mi">2</span><span class="p">);</span><span class="n">f</span> <span class="n">b</span><span class="o">=</span><span class="n">l</span><span class="o">%</span><span class="n">n</span><span class="p">;</span><span class="k">if</span><span class="p">(</span><span class="n">b</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">||</span><span class="n">T</span><span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">n</span><span class="p">))</span><span class="n">b</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">f</span> <span class="n">p</span><span class="o">=</span><span class="n">pow</span><span class="p">(</span><span class="n">l</span><span class="o">%</span><span class="n">r</span><span class="o">*</span><span class="p">(</span><span class="n">b</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">),</span><span class="mi">99</span><span class="p">);</span><span class="k">if</span><span class="p">(</span><span class="n">m</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">){</span><span class="n">h</span><span class="o">=</span><span class="n">h</span><span class="o">*</span><span class="mf">.2</span><span class="p">;</span><span class="k">return</span><span class="p">((</span><span class="n">i</span><span class="p">)(</span><span class="n">ceil</span><span class="p">(</span><span class="n">h</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="o">+</span><span class="n">ceil</span><span class="p">(</span><span class="n">h</span><span class="p">.</span><span class="n">y</span><span class="p">))</span><span class="o">&amp;</span><span class="mi">1</span><span class="o">?</span><span class="n">v</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="n">v</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="n">b</span><span class="o">*</span><span class="mf">.2</span><span class="o">+</span><span class="mf">.1</span><span class="p">);}</span><span class="k">return</span> <span class="n">v</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">p</span><span class="p">)</span><span class="o">+</span><span class="n">S</span><span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="n">r</span><span class="p">)</span><span class="o">*</span><span class="mf">.5</span><span class="p">;}</span><span class="n">i</span> <span class="nf">main</span><span class="p">(){</span><span class="n">printf</span><span class="p">(</span><span class="s">&#34;P6 512 512 255 &#34;</span><span class="p">);</span><span class="n">v</span> <span class="n">g</span><span class="o">=!</span><span class="n">v</span><span class="p">(</span><span class="o">-</span><span class="mi">6</span><span class="p">,</span><span class="o">-</span><span class="mi">16</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="n">a</span><span class="o">=!</span><span class="p">(</span><span class="n">v</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">^</span><span class="n">g</span><span class="p">)</span><span class="o">*</span><span class="mf">.002</span><span class="p">,</span><span class="n">b</span><span class="o">=!</span><span class="p">(</span><span class="n">g</span><span class="o">^</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="mf">.002</span><span class="p">,</span><span class="n">c</span><span class="o">=</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">)</span><span class="o">*-</span><span class="mi">256</span><span class="o">+</span><span class="n">g</span><span class="p">;</span><span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="n">y</span><span class="o">=</span><span class="mi">512</span><span class="p">;</span><span class="n">y</span><span class="o">--</span><span class="p">;)</span><span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="n">x</span><span class="o">=</span><span class="mi">512</span><span class="p">;</span><span class="n">x</span><span class="o">--</span><span class="p">;){</span><span class="n">v</span> <span class="n">p</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">13</span><span class="p">);</span><span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="n">r</span><span class="o">=</span><span class="mi">64</span><span class="p">;</span><span class="n">r</span><span class="o">--</span><span class="p">;){</span><span class="n">v</span> <span class="n">t</span><span class="o">=</span><span class="n">a</span><span class="o">*</span><span class="p">(</span><span class="n">R</span><span class="p">()</span><span class="o">-</span><span class="mf">.5</span><span class="p">)</span><span class="o">*</span><span class="mi">99</span><span class="o">+</span><span class="n">b</span><span class="o">*</span><span class="p">(</span><span class="n">R</span><span class="p">()</span><span class="o">-</span><span class="mf">.5</span><span class="p">)</span><span class="o">*</span><span class="mi">99</span><span class="p">;</span><span class="n">p</span><span class="o">=</span><span class="n">S</span><span class="p">(</span><span class="n">v</span><span class="p">(</span><span class="mi">17</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span><span class="o">+</span><span class="n">t</span><span class="p">,</span><span class="o">!</span><span class="p">(</span><span class="n">t</span><span class="o">*-</span><span class="mi">1</span><span class="o">+</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="p">(</span><span class="n">R</span><span class="p">()</span><span class="o">+</span><span class="n">x</span><span class="p">)</span><span class="o">+</span><span class="n">b</span><span class="o">*</span><span class="p">(</span><span class="n">y</span><span class="o">+</span><span class="n">R</span><span class="p">())</span><span class="o">+</span><span class="n">c</span><span class="p">)</span><span class="o">*</span><span class="mi">16</span><span class="p">))</span><span class="o">*</span><span class="mf">3.5</span><span class="o">+</span><span class="n">p</span><span class="p">;}</span><span class="n">printf</span><span class="p">(</span><span class="s">&#34;%c%c%c&#34;</span><span class="p">,(</span><span class="n">i</span><span class="p">)</span><span class="n">p</span><span class="p">.</span><span class="n">x</span><span class="p">,(</span><span class="n">i</span><span class="p">)</span><span class="n">p</span><span class="p">.</span><span class="n">y</span><span class="p">,(</span><span class="n">i</span><span class="p">)</span><span class="n">p</span><span class="p">.</span><span class="n">z</span><span class="p">);}}</span></span></span></code></pre></div><p>To execute the program, start by copying and pasting the code into a new text document. Rename this file to something like <code>minray.cpp</code> or any other name you prefer. Next, compile the code using the command <code>c++ -O3 -o minray minray.cpp</code> or <code>clang++ -O3 -o minray minray.cpp</code> if you choose to use the clang compiler. Once compiled, run the program using the command line <code>minray &gt; minray.ppm</code>. This approach outputs the final image data directly to standard output (the terminal you&rsquo;re using), which is then redirected to a file using the <code>&gt;</code> operator, saving it as a PPM file. This file format is compatible with Photoshop, allowing for easy viewing.</p>
<p>The presentation of this program here is meant to demonstrate the compactness with which the ray tracing algorithm can be encapsulated. The code employs several techniques that will be detailed and expanded upon in subsequent lessons within this series.</p>
<p><a href="https://github.com/scratchapixel/code/tree/main/introduction-to-ray-tracing" target="_blank">Source Code (external link GitHub)</a></p>
<p><a href="https://gitee.com/zhaoshengxuan108/scratchapixel_code" target="_blank">Source Code (external link Gitee)</a></p>

            <footer class="footline">
            </footer>
          </article>

          <article class="default">
            <header class="headline">
            </header>
<h1 id="where-do-i-start-a-very-gentle-introduction-to-computer-graphics-programming">Where Do I Start? A Very Gentle Introduction to Computer Graphics Programming</h1>

<h2 id="understanding-how-it-works">Understanding How It Works!</h2>
<p>If you are here, it&rsquo;s probably because you want to learn computer graphics. Each reader may have a different reason for being here, but we are all driven by the same desire: to understand how it works! Scratchapixel was created to answer this particular question. Here you will learn how it works and about techniques used to develop computer graphics-generated images, from the simplest and most essential methods to the more complicated and less common ones. You may like video games, and you would like to know how it works and how they are made. You may have seen a Pixar film and wondered what&rsquo;s the magic behind it. Whether you are at school, or university, already working in the industry (or retired), it is never a wrong time to be interested in these topics, to learn or improve your knowledge, and we always need a resource like Scratchapixel to find answers to these questions. That&rsquo;s why we are here.</p>
<p>Scratchapixel is accessible to all. There are lessons for all levels. Of course, it requires a minimum of knowledge in programming. While we plan to write a quick introductory lesson on programming shortly, Scratchapixel&rsquo;s mission is about something other than teaching programming and C++ mainly. However, while learning about implementing different techniques for producing 3D images, you will likely improve your programming skills and learn a few programming tricks in the process. Whether you consider yourself a beginner or an expert in programming, you will find all sorts of lessons adapted to your level here. Start simple, with basic programs, and progress from there.</p>
<p>A gentle note, though, before we proceed further: we do this work on volunteering grounds. We do this in our spare time and provide the content for free. The authors of the lessons are not necessarily native English speakers and writers. While we are experienced in the field, we didn&rsquo;t claim we were the best nor the most educated persons to teach about these topics. We make mistakes; we can write something entirely wrong or (not) precisely accurate. That&rsquo;s why the content of Scratchapixel is now open source. So that you can help fix our mistakes if/when you spot them. Not to make us look better than we are but to help the community access much better quality content. Our goal is not to improve our fame but to provide the community with the best possible educational resources (and that means accuracy).</p>
<h2 id="a-gentle-introduction-to-computer-graphics-programming">A Gentle Introduction to Computer Graphics Programming</h2>
<p>You want to learn Computer Graphics (CG). First, do you know what it is? In the second lesson of this section, you can find a definition of computer graphics and learn about how it generally works. You may have heard about terms such as modeling, geometry, animation, 3D, 2D, digital images, 3D viewport, real-time rendering, and compositing. The primary goal of this section is to clarify their meaning and, more importantly, how they relate to each other &ndash; providing you with a general understanding of the tools and processes involved in making Computer Generated Imagery (CGI).</p>
<p>Our world is <strong>three-dimensional</strong>. At least as far as we can experience it with our senses; in other words, everything around you has some length, width, and depth. A microscope can zoom into a grain of sand to observe its height, width, and depth. Some people also like to add the dimension of <strong>time</strong>. Time plays a vital role in CGI, but we will return to this later. Objects from the real world then are three-dimensional. That&rsquo;s a fact we can all agree on without having to prove it (we invite curious readers to check the book by Donald Hoffman, &ldquo;The Case Against Reality&rdquo;, which challenges our conception of space-time and reality). What&rsquo;s interesting is that <strong>vision</strong>, one of the senses by which this three-dimensional world can be experienced, is primarily a two-dimensional process. We could maybe say that the image created in our mind is dimensionless (we don&rsquo;t understand yet very well how images &lsquo;appear&rsquo; in our brain), but when we speak of an image, it generally means to us a flat surface, on which the dimensionality of objects has been reduced from three to two dimensions (the surface of the canvas or the surface of the screen). The only reason why this image on the canvas looks accurate to our brain is that objects get smaller as they get further away from where you stand, an effect called <strong>foreshortening</strong>. Think of an image as nothing more than a mirror reflection. The surface of the mirror is perfectly flat, and yet, we can&rsquo;t make the difference between looking at the image of a scene reflected from a mirror and looking directly at the scene: you don&rsquo;t perceive the reflection, just the object. It&rsquo;s only because we have two eyes that we can see things in 3D, which we call <strong>stereoscopic vision</strong>. Each eye looks at the same scene from a slightly different angle, and the brain can use these two images of the same scene to approximate the distance and the position of objects in 3D space with respect to each other. However, stereoscopic vision is quite limited as we can&rsquo;t measure the distance to objects or their size very accurately (which computers can do). Human vision is quite sophisticated and an impressive result of evolution, but it&rsquo;s a trick and can be fooled easily (many magicians&rsquo; tricks are based on this). To some extent, computer graphics is a means by which we can create images of artificial worlds and present them to the brain (through the mean of vision), as an experience of reality (something we call photo-realism), exactly like a mirror reflection. This theme is quite common in science fiction, but technology is close to making this possible.</p>
<details>
While we may seem more focused on the process of generating these images, a process we call rendering, computer graphics is not only about making images but also about simulating things such as the motion of fluids, the motion of soft and rigid bodies, finding ways of animating objects and avatars such that their motion and every effect resulting from that motion is accurately simulated (for example when you walk, the shape of your muscles changes and the overall outside shape of your body is a result of these muscles deformations), etc. We will also learn about these techniques on Scratchapixel.
</details>
<p>What have we learned so far? That the world is three-dimensional, that the way we look at it is two-dimensional, and that if you can replicate the shape and the appearance of objects, the brain can not make the difference between looking at these objects directly and looking at an image of these objects. Computer graphics are not limited to creating photoreal images. Still, while it&rsquo;s easier to develop non-photo-realistic images than perfectly photo-realistic ones, the goal of computer graphics is realism (as much in the way things move than they appear).</p>
<p>All we need to do now is learn the rules for making such a photo-real image, and that&rsquo;s what you will also learn here on Scratchapixel.</p>
<h2 id="describing-objects-populating-the-virtual-world">Describing Objects Populating the Virtual World</h2>
<p>The difference between the painter who is painting a real scene (unless the subject of the painting comes from their imagination), and us, trying to create an image with a computer, is that we have first somehow to describe the shape (and the appearance) of objects making up the scene we want to render an image of to the computer.</p>
<p><a href="#R-image-b84f4acc329a2c707f9be6d8008cb039" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-2/../assets/coordinate-system.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b84f4acc329a2c707f9be6d8008cb039"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-2/../assets/coordinate-system.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 1:</strong> <em>a 2D Cartesian coordinative system defined by its two axes (x and y) and the origin. This coordinate system can be used as a reference to define the position or coordinates of points within the plane.</em></p>
<p><a href="#R-image-0e1b7bfc3f976c9b02aac21229ed2e1c" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-2/../assets/box1.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-0e1b7bfc3f976c9b02aac21229ed2e1c"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-2/../assets/box1.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 2:</strong> <em>the size of the box and its position with respect to the world origin can be used to define the position of its corners.</em></p>
<p>One of the simplest and most important concepts we learn at school is the idea of space in which points can be defined. The position of a point is generally determined by an <strong>origin</strong>. This is typically the tick marked with the number zero on a ruler. If we use two rulers, one perpendicular to the other, we can define the position of points in two dimensions. Add a third ruler perpendicular to the first two, and you can determine the position of points in three dimensions. The actual numbers representing the position of the point with respect to one of the tree rulers are called the points <strong>coordinates</strong>. We are all familiar with the concept of coordinates to mark where we are with respect to some reference point or line (for example, the Greenwich meridian). We can now define points in three dimensions. Let&rsquo;s imagine that you just bought a computer. This computer probably came in a box with eight corners (sorry for stating the obvious). One way of describing this box is to measure the distance of these 8 corners with respect to one of the corners. This corner acts as the origin of our <strong>coordinate system</strong>, and the distance of this reference corner with respect to itself will be 0 in all dimensions. However, the distance from the reference corner to the other seven corners will be different than 0. Let&rsquo;s imagine that our box has the following dimensions:</p>
<div class="wrap-code highlight"><pre tabindex="0"><code>corner 1: ( 0, 0,  0)
corner 2: (12, 0,  0)
corner 3: (12, 8,  0)
corner 4: ( 0, 8,  0)
corner 5: ( 0, 0, 10)
corner 6: (12, 0, 10)
corner 7: (12, 8, 10)
corner 8: ( 0, 8, 10)</code></pre></div><p><a href="#R-image-22f7dd66fd30efcc068bce61495a5104" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-2/../assets/box2.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-22f7dd66fd30efcc068bce61495a5104"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-2/../assets/box2.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 3:</strong> <em>a box can be described by specifying the coordinates of its eight corners in a Cartesian coordinate system.</em></p>
<p>The first number represents the width, the second the height, and the third the corner&rsquo;s depth. Corner 1, as you can see, is the origin from which all the corners have been measured. You need to write a program in which you will define the concept of a three-dimensional point and use it to store the coordinates of the eight points you just measured. In C/C++, such a program could look like this:</p>
<div class="wrap-code highlight"><pre tabindex="0"><code>typedef float Point[3];
int main()
{
    Point corners[8] = {
        { 0, 0,  0},
        {12, 0,  0},
        {12, 8,  0},
        { 0, 8,  0},
        { 0, 0, 10},
        {12, 0, 10},
        {12, 8, 10},
        { 0, 8, 10},
    };

    return 0;
}</code></pre></div><p>Like in any language, there are always different ways of doing the same thing. This program shows one possible way in C/C++ to define the concept of point (line 1) and store the box corners in memory (in this example, as an array of eight points).</p>
<p>You have created your first 3D program. It doesn&rsquo;t produce an image yet, but you can already store the description of a 3D object in memory. In CG, the collection of these objects is called a <strong>scene</strong> (a scene also includes the concept of camera and lights, but we will talk about this another time). As suggested, we still need two essential things to make the process complete and interesting. First, to represent the box in the computer&rsquo;s memory, ideally, we also need a system that defines how these eight points are connected to make up the faces of the box. In CG, this is called the <strong>topology</strong> of the object (an object is also called a <strong>model</strong>). We will talk about this in the lesson on <a href="../../../lessons/mathematics-physics-for-computer-graphics/geometry/">Geometry</a> and the 3D Rendering for Beginners section (in the lesson on rendering triangles and polygonal meshes). Topology refers to how points we call <strong>vertices</strong> are connected to form faces (or flat surfaces). These faces are also called <strong>polygons</strong>. The box would be made of six faces or six polygons, and the polygons form what we call a <strong>polygonal mesh</strong> or simply a <strong>mesh</strong>. The second thing we still need is a system to create an image of that box. This requires projecting the box&rsquo;s corners onto an imaginary canvas, a process we call <strong>perspective projection</strong>.</p>
<h2 id="creating-an-image-of-this-virtual-world">Creating an Image of this Virtual World</h2>
<p><a href="#R-image-61c38a6e80300f3626c3c5ccfaa9d231" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-2/../assets/frustum4.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-61c38a6e80300f3626c3c5ccfaa9d231"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-2/../assets/frustum4.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 4:</strong> <em>if you connect the corners of the canvas to the eye, which by default is aligned with our Cartesian coordinate system, and extend the lines further into the scene, you get some pyramid which we call a viewing frustum. Any object within the frustum (or overlapping it) is visible and will appear on the image.</em></p>
<p>Projecting a 3D point on the surface of the canvas involves a particular matrix called the perspective matrix (don&rsquo;t worry if you don&rsquo;t know what a matrix is). Using this matrix to project points is optional but makes things much more manageable. However, you don&rsquo;t need mathematics and matrices to figure out how it works. You can see an image or a canvas as some flat surface is placed away from the eye. Trace four lines, all starting from the eye to each one of the four corners of the canvas, and extend these lines further away into the world (as far as you can see). You get a pyramid which we call a <strong>viewing frustum</strong> (and not <em>frustrum</em>). The viewing frustum defines some volume in 3D space, and the canvas is just a plane cutting of this volume perpendicular to the eye&rsquo;s line of sight. Place your box in front of the canvas. Next, trace a line from each corner of the box to the eye and mark a dot where the line intersects the canvas. Find the dots on the canvas corresponding to each of the twelve edges of the box, and trace a line between these dots. What do you see? An image of the box.</p>
<p><a href="#R-image-6dda18b109f01cbdd66525e80992904b" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-2/../assets/box-setup1.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-6dda18b109f01cbdd66525e80992904b"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-2/../assets/box-setup1.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 5:</strong> <em>the box is moved in front of our camera setup. The coordinates of the box corners are expressed with respect to this Cartesian coordinate system.</em></p>
<p><a href="#R-image-b3f9161c3676d6e978889d5689928845" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-2/../assets/box-setup2.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b3f9161c3676d6e978889d5689928845"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-2/../assets/box-setup2.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 6:</strong> <em>connecting the box corners to the eye.</em></p>
<p><a href="#R-image-abd02179a18f7f87c4eb965a2d74fe90" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-2/../assets/box-setup3.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-abd02179a18f7f87c4eb965a2d74fe90"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-2/../assets/box-setup3.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 7:</strong> <em>the intersection points between these lines and the canvas are the projection of the box corners onto the canvas. Connecting these points creates a wireframe image of the box.</em></p>
<p>The three rulers used to measure the coordinates of the box corner form what we call a coordinate system. It&rsquo;s a system in which points can be measured to. All points&rsquo; coordinates relate to this coordinate system. Note that a coordinate can either be positive or negative (or zero) depending on whether it&rsquo;s located on the right or the left of the ruler&rsquo;s origin (the value 0). In CG, this coordinate system is often called the <strong>world</strong> coordinate system, and the point (0,0,0) is the <strong>origin</strong>.</p>
<p>Let&rsquo;s move the apex of the viewing frustum at the origin and orient the line of sight (the view direction) along the negative z-axis (Figure 3). Many graphics applications use this configuration as their default &ldquo;viewing system&rdquo;. Remember that the top of the pyramid is the point from which we will look at the scene. Let&rsquo;s also move the canvas one unit away from the origin. Finally, let&rsquo;s move the box some distance from the origin, so it is fully contained within the frustum&rsquo;s volume. Because the box is in a new position (we moved it), the coordinates of its eight corners changed, and we need to measure them again. Note that because the box is on the left side of the ruler&rsquo;s origin from which we measure the object&rsquo;s depth, all depth coordinates, also called <strong>z-coordinates</strong>, will be negative. Four corners are below the reference point used to measure the object&rsquo;s height and will have a negative height or y-coordinate. Finally, four corners will be to the left of the ruler&rsquo;s origin, measuring the object&rsquo;s width: their width or x-coordinates will also be negative. The new coordinates of the box&rsquo;s corners are:</p>
<div class="wrap-code highlight"><pre tabindex="0"><code>corner 1: ( 1, -1, -5)
corner 2: ( 1, -1, -3)
corner 3: ( 1,  1, -5)
corner 4: ( 1,  1, -3)
corner 5: (-1, -1, -5)
corner 6: (-1, -1, -3)
corner 7: (-1,  1, -5)
corner 8: (-1,  1, -3)</code></pre></div><p><a href="#R-image-5ef86d0b8cd468b27e4b57a1de7eede9" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-2/../assets/box-setup4.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-5ef86d0b8cd468b27e4b57a1de7eede9"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-2/../assets/box-setup4.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 8:</strong> <em>the coordinates of the point P&rsquo;, the projection of P on the canvas can be computed using simple geometry. The rectangle ABC and AB&rsquo;C&rsquo; are said to be similar.</em></p>
<p>Let&rsquo;s look at our setup from the side and trace a line from one of the corners to the origin (the viewpoint). We can define two triangles: ABC and AB&rsquo;C&rsquo;. As you can see, these two triangles have the same origin (A). They are also somehow copies of each other in that the angle defined by the edges AB and AC is the same as the angle determined by the edge AB&rsquo;, AC&rsquo;. Such triangles are said to be <strong>similar triangles</strong> in mathematics. Similar triangles have an interesting property: the ratio between their adjacent and opposite sides is the same. In other words:</p>

<span class="math align-center">$$
{BC \over AB} = {B'C' \over AB'}.
$$</span><p>Because the canvas is 1 unit away from the origin, we know that AB&rsquo; equals 1. We also know the position of B and C, which are the corner&rsquo;s z (depth) and y coordinates (height), respectively. If we substitute these numbers in the above equation, we get:</p>

<span class="math align-center">$$
{P.y \over P.z} = {P'.y \over 1}.
$$</span><p>Where y&rsquo; is the y coordinate of the point where the line going from the corner to the viewpoint intersects the canvas, which is, as we said earlier, the dot from which we can draw an image of the box on the canvas. Thus:</p>

<span class="math align-center">$$
P'.y = {P.y \over P.z}.
$$</span><p>As you can see, the projection of the corner&rsquo;s y-coordinate on the canvas is nothing more than the corner&rsquo;s y-coordinate divided by its depth (the z-coordinate). This is one of computer graphics&rsquo; most straightforward and fundamental relations, known as the <strong>z or perspective divide</strong>. The same principle applies to the x coordinate. The projected point x coordinate (x&rsquo;) is the corner&rsquo;s x coordinate divided by its z coordinate.</p>
<p>Note, though, that because the z-coordinate of P is negative in our example (we will explain why this is always the case in the lesson from the Foundations of 3D Rendering section dedicated to the perspective projection matrix) when the x-coordinate is positive, the projected point&rsquo;s x-coordinate will become negative (similarly, if P.x is negative, P&rsquo;.x will become positive. The same problem happens with the y-coordinate). As a result, the image of the 3D object is mirrored both vertically and horizontally, which is different from the effect we want. Thus, to avoid this problem, we will divide the P.x and P.y coordinates with -P.z instead, preserving the sign of the x and y coordinates. We finally get:</p>

<span class="math align-center">$$
\begin{array}{l}
P'.x = {P.x \over -P.z}\\
P'.y = {P.y \over -P.z}.
\end{array}
$$</span><p>We now have a method to compute the actual positions of the corners as they appear on the surface of the canvas. These are the two-dimensional coordinates of the points projected on the canvas. Let&rsquo;s update our basic program to compute these coordinates:</p>
<div class="wrap-code highlight"><pre tabindex="0"><code>typedef float Point[3];
int main()
{
    Point corners[8] = {
         { 1, -1, -5},
         { 1, -1, -3},
         { 1,  1, -5},
         { 1,  1, -3},
         {-1, -1, -5},
         {-1, -1, -3},
         {-1,  1, -5},
         {-1,  1, -3}
    };

    for (int i = 0; i &amp;lt; 8; ++i) {
        // divide the x and y coordinates by the z coordinate to 
        // project the point on the canvas
        float x_proj = corners[i][0] / -corners[i][2];
        float y_proj = corners[i][1] / -corners[i][2];
        printf(&#34;projected corner: %d x:%f y:%f\n&#34;, i, x_proj, y_proj);
    }

    return 0;
}</code></pre></div><p><a href="#R-image-a2b13f557937bb80241c265659654e88" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-2/../assets/frustum.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a2b13f557937bb80241c265659654e88"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-2/../assets/frustum.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 9:</strong> <em>in this example, the canvas is 2 units along the x-axis and 2 units along the y-axis. You can change the dimension of the canvas if you wish. By making it bigger or smaller, you will see more or less of the scene.</em></p>
<p>The size of the canvas itself is also arbitrary. It can also be a square or a rectangle. In our example, we made it two units wide in both dimensions, which means that the x and y coordinates of any points lying on the canvas are contained in the range -1 to 1 (Figure 9).</p>
<blockquote>
<details>
Question: what happens if any of the projected point coordinates is not in this range if, for > instance, x' equals -1.1? <br><br>
The point is not visible; it lies outside the boundary of the canvas.<br>
</details>
</blockquote>
<p>At this point, we say that the projected point coordinates are in <strong>screen space</strong> (the space of the screen, where screen and canvas in this context our synonymous). But they are not easy to manipulate because they can either be negative or positive, and we need to know what they refer to with respect to, for example, the dimension of your computer screen (if we want to display these dots on the screen). For this reason, we will first normalize them, which means we convert them from whatever range they were initially into the range [0,1]. In our case, because we need to map the coordinates from -1,1 to 0,1, we can write:</p>
<div class="wrap-code highlight"><pre tabindex="0"><code>float x_proj_remap = (1 + x_proj) / 2;
float y_proj_remap = (1 + y_proj) / 2;</code></pre></div><p>The coordinates of the projected points are now in the range of 0,1. Such coordinates are said to be defined in NDC space, which stands for <strong>Normalized Device Coordinates</strong>. This is convenient because regardless of the original size of the canvas (or screen), which can be different depending on the settings you used, we now have all points&rsquo; coordinates defined in a common space. The term <strong>normalize</strong> is ubiquitous. You somehow remap values from whatever range they were initially into the range [0,1]. Finally, we generally define point coordinates with regard to the dimensions of the final image, which, as you may know, or not, is defined in terms of pixels. A digital image is nothing else than a two-dimensional array of pixels (as is your computer screen).</p>
<p>A 512x512 image is a digital image having 512 rows of 512 pixels; if you prefer to see it the other way around, 512 columns of 512 vertically aligned pixels. Since our coordinates are already normalized, all we need to do to express them in terms of pixels is to multiply these NDC coordinates by the image dimension (512). Here, our canvas being square, we will also use a square image:</p>
<div class="wrap-code highlight"><pre tabindex="0"><code>#include &lt;cstdlib&gt; 
#include &lt;cstdio&gt; 

typedef float Point[3];

int main()
{
    Point corners[8] = {
         { 1, -1, -5},
         { 1, -1, -3},
         { 1,  1, -5},
         { 1,  1, -3},
         {-1, -1, -5},
         {-1, -1, -3},
         {-1,  1, -5},
         {-1,  1, -3}
    };

    const unsigned int image_width = 512, image_height = 512;

    for (int i = 0; i &lt; 8; ++i) {
        // divide the x and y coordinates by the z coordinate to 
        // project the point on the canvas
        float x_proj = corners[i][0] / -corners[i][2];
        float y_proj = corners[i][1] / -corners[i][2];
        float x_proj_remap = (1 + x_proj) / 2;
        float y_proj_remap = (1 + y_proj) / 2;
        float x_proj_pix = x_proj_remap * image_width;
        float y_proj_pix = y_proj_remap * image_height;
        printf(&#34;corner: %d x:%f y:%f\n&#34;, i, x_proj_pix, y_proj_pix);
    }

    return 0;
}</code></pre></div><p>The resulting coordinates are said to be in raster space (XX, what does raster mean, please explain). Our program is still limited because it doesn&rsquo;t create an image of the box, but if you compile it and run it with the following commands (copy/paste the code in a file and save it as box.cpp):</p>
<div class="wrap-code highlight"><pre tabindex="0"><code>c++ box.cpp
./a.out
corner: 0 x:307.200012 y:204.800003
corner: 1 x:341.333344 y:170.666656
corner: 2 x:307.200012 y:307.200012
corner: 3 x:341.333344 y:341.333344
corner: 4 x:204.800003 y:204.800003
corner: 5 x:170.666656 y:170.666656
corner: 6 x:204.800003 y:307.200012
corner: 7 x:170.666656 y:341.333344&lt;/div&gt;</code></pre></div><p>You can use a paint program to create an image (set its size to 512x512) and add dots at the pixel coordinates you computed with the program. Then connect the dots to form the edges of the box, and you will get an actual image of the box (as shown in the video below). Pixel coordinates are integers, so you will need to round off the numbers given by the program.</p>
<iframe class="video" src="//www.youtube.com/embed/BiQJxdoL4K8" frameborder="0" width="800" height="450"></iframe>
<h2 id="what-have-we-learned">What Have We Learned?</h2>
<ul>
<li>
<p>We first need to describe three-dimensional objects using things such as vertices and topology (information about how these vertices are connected to form polygons or faces) before we can produce an image of the 3D scene (a scene is a collection of objects).</p>
</li>
<li>
<p>That rendering is the process by which an image of a 3D scene is created. No matter which technique you use to create 3D models (there are quite a few), rendering is a necessary step to &lsquo;see&rsquo; any 3D virtual world.</p>
</li>
<li>
<p>From this simple exercise, it is apparent that mathematics (more than programming) is essential in making an image with a computer. A computer is merely a tool to speed up the computation, but the rules used to create this image are pure mathematics. Geometry plays a vital role in this process, mainly to handle objects&rsquo; transformations (scale, rotation, translation) but also provide solutions to problems such as computing angles between lines or finding out the intersection between a line and other simple shapes (a plane, a sphere, etc.).</p>
</li>
<li>
<p>In conclusion, computer graphics is mostly mathematics applied to a computer program whose purpose is to generate an image (photo-real or not) at the quickest possible speed (and the accuracy that computers are capable of).</p>
</li>
<li>
<p>Modeling includes all techniques used to create 3D models. Modeling techniques will be discussed in the Geometry/Modeling section.</p>
</li>
<li>
<p>While static models are acceptable, it is also possible to animate them over time. This means that an image of the model at each time step needs to be rendered (you can translate, rotate or scale the box a little between each consecutive image by animating the corners&rsquo; coordinates or applying a transformation matrix to the model). More advanced animation techniques can be used to simulate the deformation of the skin by bones and muscles. But all these techniques share that geometry (the faces making up the models) is deformed over time. Hence, as the introduction suggests, time is also essential in CGI. Check the Animation section to learn about this topic.</p>
</li>
<li>
<p>One particular field overlaps both animation and modeling. It includes all techniques used to <strong>simulate</strong> the motion of objects in a realistic manner. A vast area of computer graphics is devoted to simulating the motion of fluids (water, fire, smoke), fabric, hair, etc. The laws of physics are applied to 3D models to make them move, deform or break like they would in the real world. Physics simulations are generally very computationally expensive, but they can also run in real-time (depending on the scene&rsquo;s complexity you simulate).</p>
</li>
<li>
<p>Rendering is also a computationally expensive task. How expensive depends on how much geometry your scene is made up of and how photo-real you want the final image to be. In rendering, we differentiate two modes, an <strong>offline</strong> and a <strong>real-time</strong> rendering mode. Real-time is used (it&rsquo;s a requirement) for video games, in which the content of the 3D scenes needs to be rendered at least 30 frames per second (generally, 60 frames a second is considered a standard). The GPU is a processor specially designed to render 3D scenes at the quickest possible speed. Offline rendering is commonly used in producing CGI for films where real-time is not required (images are precomputed and stored before being displayed at 24 or 30, or 60 fps). It may take a few seconds to hours before one single image is complete. Still, it handles far more geometry and produces higher-quality images than real-time rendering. However, real-time or offline rendering tends to overlap more these days, with video games pushing the amount of geometry they can handle and quality and offline rendering engines trying to take advantage of the latest advancements in the field of CPU technology to improve their performances significantly.</p>
</li>
</ul>
<p>Well, we/you learned a lot!</p>
<h2 id="where-should-i-start">Where Should I Start?</h2>
<p>We hope the simple box example got you hooked, but this introduction&rsquo;s primary goal is to underline geometry&rsquo;s role in computer graphics. Of course, it&rsquo;s not only about geometry, but many problems can be solved with geometry. Most computer graphics books start with a chapter on geometry, which is always a bit discouraging because you need to study a lot before you can get to making fun stuff. However, we recommend you read the lesson on <a href="../../../lessons/mathematics-physics-for-computer-graphics/geometry/">Geometry</a> before anything else. We will talk and learn about <strong>points</strong>, <strong>vectors</strong>, and <strong>normals</strong>. We will learn about <strong>coordinate systems</strong> and, more importantly, about <strong>matrices</strong>. Matrices are used extensively to handle rotation, scaling, and/or translation; generally, to handle <strong>transformations</strong>. These concepts are used everywhere throughout all computer graphics literature, so you must study them first.</p>
<p>Many (most?) CG books provide a poor introduction to geometry may be because the authors assume that readers already know about it or that it&rsquo;s better to read books devoted to this particular topic. Our lesson on geometry is different. It&rsquo;s extensive,  relevant to your daily production work, and explains everything using simple words. We strongly recommend you start your journey into computer graphics programming by reading this lesson first.</p>
<h2 id="what-should-i-read-next">What Should I Read Next?</h2>
<p>Learning computer graphics programming with rendering is generally more accessible and more fun. That beginners section was written for people who are entirely new to computer graphics programming. So keep reading the lesson from this section in chronological order if your goal is to proceed further.</p>

            <footer class="footline">
            </footer>
          </article>

          <article class="default">
            <header class="headline">
            </header>
<h1 id="rendering-an-image-of-a-3d-scene-an-overview">Rendering an Image of a 3D Scene: an Overview</h1>

<h2 id="it-all-starts-with-a-computer-and-a-computer-screen">It All Starts with a Computer and a Computer Screen</h2>
<h3 id="introduction">Introduction</h3>
<p>The lesson <a href="#introduction-to-raytracing-a-simple-method-for-creating-3d-images">Introduction to Raytracing: A Simple Method for Creating 3D Images</a> provided you with a quick introduction to some important concepts in rendering and computer graphics in general, as well as the source code of a small ray tracer (with which we rendered a scene containing a few spheres). Ray tracing is a very popular technique for rendering a 3D scene (mostly because it is easy to implement and also a more natural way of thinking of the way light propagates in space, as quickly explained in lesson 1), however other methods exist. In this lesson, we will look at what rendering means, what sort of problems we need to solve to render an image of a 3D scene as well as quickly review the most important techniques that were developed to solve these problems specifically; our studies will be focused on the <strong>ray tracing</strong> and <strong>rasterization</strong> method, two popular algorithms used to solve the visibility problem (finding out which objects making up the scene is visible through the camera). We will also look at shading, the step in which the appearance of the objects as well as their brightness is defined.</p>
<h3 id="it-all-start-with-a-computer-and-a-computer-screen">It All Start with a Computer (and a Computer Screen)</h3>
<p><a href="#R-image-12f12423c722c31cc98d784d1fd26030" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/hello.jpeg" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-12f12423c722c31cc98d784d1fd26030"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/hello.jpeg" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>The journey in the world of computer graphics starts&hellip; with a computer. It might sound strange to start this lesson by stating what may seem obvious to you, but it is so obvious that we do take this for granted and never think of what it means when it comes to making images with a computer. More than a computer, what we should be concerned about is how we display images with a computer: the computer screen. Both the computer and the computer screen have something important in common. They work with <strong>discrete structures</strong> to the contrary of the world around us, which is made of continuous structures (at least at the macroscopic level). These discrete structures are the <strong>bit</strong> for the computer and the <strong>pixel</strong> for the screen. Let&rsquo;s take a simple example. Take a thread in the real world. It is indivisible. But the representation of this thread onto the surface of a computer screen requires to &ldquo;cut&rdquo; or &ldquo;break&rdquo; it down into small pieces called <strong>pixels</strong>. This idea is illustrated in figure 1.</p>
<p><a href="#R-image-2ce501ad1cb1b4977e1e4179e4a38e99" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/discrete.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-2ce501ad1cb1b4977e1e4179e4a38e99"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/discrete.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 1:</strong> <em>in the real world, everything is &ldquo;continuous&rdquo;. But in the world of computers, an image is made of discrete blocks, the pixels.</em></p>
<p><a href="#R-image-6393bb0cccf51f39ebd03dde236aebb5" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/discrete2.gif" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-6393bb0cccf51f39ebd03dde236aebb5"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/discrete2.gif" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 2:</strong> <em>the process of representing an object on the surface of a computer can be seen as if a grid was laid out on the surface of the object. Every pixel of that grid overlapping the object is filled in with the color of the underlying object. But what happens when the object only partially overlaps the surface of a pixel? Which color should we fill the pixel with?</em></p>
<p>In computing, the process of actually converting any continuous object (a continuous function in mathematics, a digital image of a thread) is called <strong>discretization</strong>. Obvious? Yes and yet, most problems if not all problems in computer graphics come from the very nature of the technology a computer is based on: 0, 1, and pixels.</p>
<p>You may still think &ldquo;who cares?&rdquo;. For someone watching a video on a computer, it&rsquo;s probably not very important indeed. But if you have to create this video, this is probably something you should care about. Think about this. Let&rsquo;s imagine we need to represent a sphere on the surface of a computer screen. Let&rsquo;s look at a sphere and apply a grid on top of it. The grid represents the pixels your screen is made of (figure 2). The sphere overlaps some of the pixels completely. Some of the pixels are also empty. However, some of the pixels have a problem. The sphere overlaps them only partially. In this particular case, what should we fill the pixel with: the color of the background or the color of the object?</p>
<p>Intuitively you might think &ldquo;if the background occupies 35% of the pixel area, and the object 75%, let&rsquo;s assign a color to the pixel which is composed of the background color for 35% and of the object color for 75%&rdquo;. This is pretty good reasoning, but in fact, you just moved the problem around. How do you compute these areas in the first place anyway? One possible solution to this problem is to subdivide the pixel into sub-pixels and count the number of sub-pixels the background overlaps and assume all over sub-pixels are overlapped by the object. The area covered by the background can be computed by taking the number of sub-pixels overlapped by the background over the total number of sub-pixels.</p>
<p><a href="#R-image-a007901c63e1b76e1e2a90e69e3e4b26" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/supersampling.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a007901c63e1b76e1e2a90e69e3e4b26"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/supersampling.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 4:</strong> <em>to approximate the color of a pixel which is both overlapping a shape and the background, the surface can be subdivided into smaller cells. The pixel&rsquo;s color can be found by computing the number of cells overlapping the shape multiplied by the shape&rsquo;s color plus the number of cells overlapping the background multiplied by the background color, divided by the entire number of cells. However, no matter how small the cells are, some of them will always overlap both the shape and the background.</em></p>
<p>However, no matter how small the sub-pixels are, there will always be some of them overlapping both the background and the object. While you might get a pretty good approximation of the object and background coverage that way (the smaller the sub-pixels the better the approximation), it will always just be an approximation. Computers can only <strong>approximate</strong>. Different techniques can be used to compute this approximation (subdividing the pixel into sub-pixels is just one of them), but what we need to remember from this example, is that a lot of the problems we will have to solve in computer sciences and computer graphics, comes from having to &ldquo;simulate&rdquo; the world which is made of continuous structures with discrete structures. And having to go from one to the other raises all sorts of complex problems (or maybe simple in their comprehension, but complex in their resolution).</p>
<p>Another way of solving this problem is also obviously to increase the resolution of the image. In other words, to represent the same shape (the sphere) using more pixels. However, even then, we are limited by the resolution of the screen.</p>
<p>Images and screens using a two-dimensional array of pixels to represent or display images are called raster graphics and raster displays respectively. The term <strong>raster</strong> more generally defines a grid of x and y coordinates on a display space. We will learn more about rasterization, in the chapter on perspective projection.</p>
<p>As suggested, the main issue with representing images of objects with a computer is that the object shapes need to be &ldquo;broken&rdquo; down into discrete surfaces, the pixels. Computers more generally can only deal with discrete data, but more importantly, the definition with which numbers can be defined in the memory of the computer is limited by the number of bits used to encode these numbers. The number of colors for example that you can display on a screen is limited by the number of bits used to encode RGB values. In the early days of computers, a single bit was used to encode the &ldquo;brightness&rdquo; of pixels on the screen. When the bit had the value 0 the pixel was black and when it was 1, the pixel would be white. The first generation of computers used color displays, encoded color using a single byte or 8 bits. With 8 bits (3 bits for the red channel, 3 bits for the green channel, and 2 bits for the blue channel) you can only define 256 distinct colors (2^3 * 2^3 * 2^2). What happens then when you want to display a color which is not one of the colors you can use? The solution is to find the closest possible matching color from the palette to the color you ideally want to display and display this matching color instead. This process is called color quantization.</p>
<p><a href="#R-image-93018bc1f83b31793a016ce5a394080d" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/posterisation.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-93018bc1f83b31793a016ce5a394080d"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/posterisation.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 5:</strong> <em>our eyes can perceive very small color variations. When too few bits are used to encode colors, banding occurs (right).</em></p>
<p>The problem with color quantization is that when we don&rsquo;t have enough colors to accurately sample a continuous gradation of color tones, continuous gradients appear as a series of discrete steps or bands of color. This effect is called banding (it&rsquo;s also known under the term posterization or false contouring).</p>
<p>There&rsquo;s no need to care about banding so much these days (the most common image formats use 32 bits to encode colors. With 32 bits you can display about 16 million distinct colors), however, keep in mind that fundamentally, colors and pretty much any other continuous function that we may need to represent in the memory of a computer, have to be broken down into a series of discrete or single <strong>quantum</strong> values for which precision is limited by the number of bits used to encode these values.</p>
<p><a href="#R-image-f4c20b13ba70c60898f00e294de1a5af" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/teapot-in-a-pixel.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f4c20b13ba70c60898f00e294de1a5af"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/teapot-in-a-pixel.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 6:</strong> <em>the shape of objects smaller than a pixel can&rsquo;t be accurately captured by a digital image.</em></p>
<p>Finally, having to break down a continuous function into discrete values may lead to what&rsquo;s known in signal processing and computer graphics as <strong>aliasing</strong>. The main problem with digital images is that the amount of details you can capture depends on the image resolution. The main issue with this is that small details (roughly speaking, details smaller than a pixel) can&rsquo;t be captured by the image accurately. Imagine for example that you want to take a photograph with a digital camera of a teapot that is so far away though that the object is smaller than a pixel in the image (figure 6). A pixel is a discrete structure thus we can only fill it up with a constant color. If in this example, we fill it up with the teapot&rsquo;s color (assuming the teapot has a constant color which is probably not the case if it&rsquo;s shaded), your teapot will only show up as a dot in the image: you failed to capture the teapot&rsquo;s shape (and shading). In reality, aliasing is far more complex than that, but you should know about the term and know for now and should keep in mind that by the very nature of digital images (because pixels are discrete elements), an image of a given resolution can only accurately represent objects of a given size. We will explain what the relationship between the objects size and the image resolution is in the lesson on Aliasing (which you can find in the Mathematics and Physic of Computer Graphics section).</p>
<blockquote>
<details>
 Images are just a collection of pixels. As mentioned before, when an image of the real world is stored in a digital image, shapes are broken down into discrete structures, the pixels. The main drawback of raster images (and raster screens) is that the resolution of the images we > can store or display is limited by the image or the screen resolution (its dimension in pixels).  Zooming in doesn't reveal more details in the image. <strong>Vector graphics</strong> were designed to address this issue. With vector graphics, you do not store pixels but represent the shape of objects (and their colors) using mathematical expressions. That way, rather than being limited by the image resolution, the shapes defined in the file can be rendered on the fly at  the desired resolution, producing an image of the object's shapes that is always perfectly  sharp.
<p><a href="#R-image-aaee75f7e9f42da14e6f8b152218c1e7" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/VectorBitmapExample.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-aaee75f7e9f42da14e6f8b152218c1e7"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/VectorBitmapExample.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
</details>
</blockquote>
<p>To summarize, computers work with quantum values when in fact, processes from the real world that we want to simulate with computers, are generally (if not always) continuous (at least at the macroscopic and even microscopic scale). And in fact, this is a very fundamental issue that is causing all sorts of very puzzling problems, to which a very large chunk of computer graphics research and theory is devoted.</p>
<blockquote>
<details>
Another field of computer graphics in which the discrete representation of the world is a particular issue is fluid simulation. The flow of fluids by their very nature is a continuous process, but to simulate the motion of fluids with a computer, we need to divide space into "discrete" structures generally small cubes called cells.
</details>
</blockquote>
<h2 id="and-it-follows-with-a-3d-scene">And It Follows With a 3D Scene</h2>
<p>Before we can speak about rendering, we need to consider what we are going to render, and what we are looking at. If you have nothing to look at, there is nothing to render.</p>
<p>The real world is made of objects having a very wild variety of shapes, appearances, and structures. For example, what&rsquo;s the difference between smoke, a chair, and water making up the ocean? In computer graphics, we generally like to see objects as either being solid or not. However, in the real world, the only thing that differentiates the two is the density of matter making up these objects. Smoke is made of molecules loosely connected and separated by a large amount of empty space, while wood making up a chair is made of molecules tightly packed into the smallest possible space. In CG though, we generally just need to define the object&rsquo;s external shape (we will speak about how we render non-solid objects later on in this lesson). How do we do that?</p>
<p>In the previous lesson, <a href="../../../lessons/3d-basic-rendering/get-started/">Where Do I Start? A Gentle Introduction to Computer Graphics Programming</a>, we already introduced the idea that defining shape within the memory of a computer, we needed to start defining the concept of point in 3D space. Generally, a point is defined as three floats within the memory of a computer, one for each of the three-axis of the Cartesian coordinate system: the x-, y- and z-axis. From here, we can simply define several points in space and connect them to define a surface (a polygon). Note that polygons should always be coplanar which means that all points making up a face or polygon should lie on the same plane. With three points, you can create the simplest possible shape of all: a <strong>triangle</strong>. You will see triangles used everywhere especially in ray-tracing because many different techniques have been developed to efficiently compute the intersection of a line with a triangle. When faces or polygons have more than three points (also called vertices), it&rsquo;s not uncommon to convert these faces into triangles, a process called <strong>triangulation</strong>.</p>
<p><a href="#R-image-858972fcfc9156380f2f3fe87161f996" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/triangle.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-858972fcfc9156380f2f3fe87161f996"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/triangle.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 1:</strong> <em>the basic brick of all 3D objects is a triangle. A triangle can be created by connecting (in 2D or 3D) 3 points or vertices to each other. More complex shapes can be created by assembling triangles.</em></p>
<p>We will explain later in this lesson, why converting geometry to triangles is a good idea. But the point here is that the simplest possible surface or object you can create is a triangle, and while a triangle on its own is not very useful, you can though create more complex shapes by assembling triangles. In many ways, this is what modeling is about. The process is very similar to putting bricks together to create more complex shapes and surfaces.</p>
<p><a href="#R-image-fb00ac2851e8d138e21dcd855a87354f" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/segment.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-fb00ac2851e8d138e21dcd855a87354f"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/segment.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 2:</strong> <em>to approximate a curved surface we sample the curve along the path of the curve and connect these samples.</em></p>
<p><a href="#R-image-7b051db4d5ffc41d33ff7ab274e14455" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/tesselation.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7b051db4d5ffc41d33ff7ab274e14455"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/tesselation.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 3:</strong> <em>you can use more triangles to improve the curvature of surfaces, but the geometry will become heavier to render.</em></p>
<p>The world is not polygonal!</p>
<p>Most people new to computer graphics often ask though, how can curved surfaces be created from triangles, when a triangle is a flat and angular surface. First, the way we define the surface of objects in CG (using triangles or polygons) is a very crude representation of reality. What may seem like a flat surface (for example the surface of a wall) to our eyes, is generally an incredibly complex landscape at the microscopic level. Interestingly enough, the microscopic structure of objects has a great influence on their appearance, not on their overall shape. Something worth keeping in mind. But to come back to the main question, using triangles or polygons is indeed not the best way of representing curved surfaces. It gives a faceted look to objects, a little bit like a cut diamond (this facet look can be slightly improved with a technique called <strong>smooth shading</strong>, but smooth shading is just a trick we will learn about when we go to the lessons on shading). If you draw a smooth curve, you can approximate this curve by placing a few points along this curve and connecting these points with straight lines (which we call segments). To improve this approximation you can simply reduce the size of the segment (make them smaller) which is the same as creating more points along the curve. The process of actually placing points or vertices along a smooth surface is called <strong>sampling</strong> (the process of converting a smooth surface to a triangle mesh is called <strong>tessellation</strong>. We will explain further in this chapter how smooth surfaces can be defined). Similarly, with 3D shapes, we can create more and smaller triangles to better approximate curved surfaces. Of course, the more geometry (or triangles) we create, the longer it will take to render this object. This is why the art of rendering is often to find a tradeoff between the amount of geometry you use to approximate the curvature of an object and the time it takes to render this 3D model. The amount of geometric detail you put in a 3D model also depends on how close you will see this model in your image. The closer you are to the object, the more details you may want to see. Dealing with model complexity is also a very large field of research in computer graphics (a lot of research has been done to find automatic/adaptive ways of adjusting the number of triangles an object is made of depending on its distance to the camera or the curvature of the object).</p>
<blockquote>
<details>
In other words, it is impossible to render a perfect circle or a perfect sphere with polygons or triangles. However, keep in mind that computers work on discrete structures, as do monitors. There is no reason for a renderer to be able to perfectly render shapes like circles if they'll just be displayed using a raster screen in the end. The solution (which has been around for decades now) is simply to use triangles that are smaller than a pixel, at which point no one looking at the monitor can tell that your basic primitive is a triangle. This idea has been used very widely in high-quality rendering software such as Pixar's RenderMan, and in the past decade, it has appeared in real-time applications as well (as part of the tessellation process).
</details>
</blockquote>
<p><a href="#R-image-01674c48b4e9a51e9b6c034209d0c087" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/bezierpatch.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-01674c48b4e9a51e9b6c034209d0c087"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/bezierpatch.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 4:</strong> <em>a Bezier patch and its control points which are represented in this image by the orange net. Note how the resulting surface is not passing through the control points or vertices (excepted at the edge of the surface which is a property of Bezier patches actually).</em></p>
<p><a href="#R-image-25b9813e59d88fa5ea2349863d239513" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/subdivision.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-25b9813e59d88fa5ea2349863d239513"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/subdivision.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 5:</strong> <em>a cube turned into a sphere (almost a sphere) using the subdivision surface algorithm. The idea behind this algorithm is to create a smoother version of the original mesh by recursively subdividing it.</em></p>
<p>Polygonal meshes are easy which is why they are popular (most objects you see in CG feature films or video games are defined that way: as an assembly of polygons or triangles) however as suggested before, they are not great to model curved or organic surfaces. This became a particular issue when computers started to be used to design manufactured objects such as cars (CAD). NURBS or Subdivision surfaces were designed to address this particular shortcoming. They are based on the idea that points only define a control mesh from which a perfect curved surface can be computed mathematically. The surface itself is purely the result of an equation thus it can not be rendered directly (nor is the control mesh which is only used as an input to the algorithm). It needs to be sampled, similarly to the way we sampled the curve earlier on (the points forming the base or input mesh are usually called control points. One of the characteristics of these techniques is that the resulting surface, in general, does not pass through these control points). The main advantage of this approach is that you need fewer points (fewer compared to the number of points required to get a smooth surface with polygons) to control the shape of a perfectly smooth surface, which can then be converted to a triangular mesh smoother than the original input control mesh. While it is possible to create curved surfaces with polygons, editing them is far more time-consuming (and still less accurate) than when similar shapes can be defined with just a few points as with NURBS and Subdivision surfaces. If they are superior, why are they not used everywhere? They almost are. They are (slightly) more expansive to render than polygonal meshes because a polygonal mesh needs to be generated from the control mesh first (it takes an extra step), which is why they are not always used in video games (but many game engines such as the Cry Engine implement them), but they are in films. NURBS are slightly more difficult to manipulate overall than polygonal meshes. This is why artists generally use subdivision surfaces instead, but they are still used in design and CAD, where a high degree of precision is needed. Nurbs and Subdivisions surfaces will be studied in the Geometry section, however, in a further lesson in this section, we will learn about Bezier curves and surfaces (to render the Utah teapot), which in a way, are quite similar to NURBS.</p>
<blockquote>
<details>
NURBS and Subdivision surfaces are not similar. NURBS are indeed defined by a mathematical equation. They are part of a family of surfaces called parametric surfaces (see below). Subdivision surfaces are more the result of a 'process' applied to the input mesh, to smooth its surface by recursively subdividing it. Both techniques are detailed in the Geometry section.
</details>
</blockquote>
<p><a href="#R-image-7155d8af4e9cf906d0e4959e93da3b0f" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/volume.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7155d8af4e9cf906d0e4959e93da3b0f"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/volume.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 6:</strong> <em>to represent fluids such as smoke or liquids, we need to store information such as the volume density in the cells of a 3D grid.</em></p>
<p>In most cases, 3D models are generated by hand. By hand, we mean that someone creates vertices in 3D space and connects them to make up the faces of the object. However, it is also possible to use simulation software to generate geometry. This is generally how you create water, smoke, or fire. Special programs simulate the way fluids move and generate a polygon mesh from this simulation. In the case of smoke or fire, the program will not generate a surface but a 3D dimensional grid (a rectangle or a box that is divided into equally spaced cells also called <strong>voxels</strong>). Each cell of this grid can be seen as a small volume of space that is either empty or occupied by smoke. Smoke is mostly defined by its density which is the information we will store in the cell. Density is just a float, but since we deal with a 3D grid, a 512x512x512 grid already consumes about 512Mb of memory (and we may need to store more data than just density such as the smoke or fire temperature, its color, etc.). The size of this grid is 8 times larger each time we double the grid resolution (a 1024x1024x1024 requires 4Gb of storage). Fluid simulation is computationally intensive, the simulation generates very large files, and rendering the volume itself generally takes more time than rendering solid objects (we need to use a special algorithm known as ray-marching which we will briefly introduce in the next chapters). In the image above (figure 6), you can see a screenshot of a 3D grid created in Maya.</p>
<p>When ray tracing is used, it is not always necessary to convert an object into a polygonal representation to render it. Ray tracing requires computing the intersection of rays (which are simply lines) with the geometry making up the scene. Finding if a line (a ray) intersects a geometrical shape, can sometimes be done mathematically. This is either possible because:</p>
<ul>
<li>
<p>a <strong>geometric solution</strong> or,</p>
</li>
<li>
<p>an <strong>algebraic solution</strong> exists to the ray-object intersection test. This is generally possible when the shape of the object can be defined mathematically, with an equation. More generally, you can see this equation, as a function representing a surface (such as the surface of a sphere) overall space. These surfaces are called <strong>implicit surfaces</strong> (or algebraic surfaces) because they are defined implicitly, by a function. The principle is very simple. Imagine you have two equations:</p>

<span class="math align-center">$$
\begin{array}{l}
y = 2x + 2\\
y = -2x.\\
\end{array}
$$</span><p><a href="#R-image-eb6ae0cf19723916a3504d62c148322c" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/equation.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-eb6ae0cf19723916a3504d62c148322c"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/equation.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>You can see a plot of these two equations in the adjacent image. This is an example of a <a href="http://en.wikipedia.org/wiki/System_of_linear_equations" target="_blank">system of linear equations</a>. If you want to find out if the two lines defined by these equations meet in one point (which you can see as an intersection), then they must have one x for which the two equations give the same y. Which you can write as:</p>

<span class="math align-center">$$
2x + 2 = -2x.
$$</span><p>Solving for x, you get:</p>

<span class="math align-center">$$
\begin{array}{l}
4x + 2 = 0\\
4x = -2\\
x = -\dfrac{1}{2}\\ 
\end{array}
$$</span><p>Because a ray can also be defined with an equation, the two equations, the equation of the ray and the equation defining the shape of the object, can be solved like any other system of linear equations. If a solution to this system of linear equations exists, then the ray intersects the object.</p>
</li>
</ul>
<p>A very good and simple example of a shape whose intersection with a ray can be found using the geometric and algebraic method is a sphere. You can find both methods explained in the lesson <a href="../../../lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/">Rendering Simple Shapes</a>.</p>
<blockquote>
<details>
_What is the difference between parametric and implict surfaces_
Earlier on in the lesson, we mentioned that NURBS and Subdivision surfaces were also somehow defined mathematically. While this is true, there is a difference between NURBS and implicit surfaces (Subdivision surface can also be considered as a separate case, in which the base mesh is processed to produce a smoother and higher resolution mesh). NURBS are defined by what we call a parametric equation, an equation that is the function of one or several parameters. In 3D, the general form of this equation can be defined as follow: 

<span class="math align-center">$$
f(u,v) = (x(u,v), y(u,v), z(u,v)).
$$</span><p>The parameters u and v are generally in the range of 0 to 1. An implicit surface is defined by a polynomial which is a function of three variables: x, y, and z.</p>

<span class="math align-center">$$
p(x, y, z) = 0.
$$</span><p>For example, a sphere of radius R centered at the origin is defined parametrically with the following equation:</p>

<span class="math align-center">$$
f(\theta, \phi) = (\sin(\theta)\cos(\phi), \sin(\theta)\sin(\phi), \cos(\theta)).
$$</span><p>Where the parameters u and v are actually being replaced in this example by (\theta) and (\phi) respectively and where (0 \leq \theta \leq \pi) and (0 \leq \phi \leq 2\pi). The same sphere defined implicitly has the following form:</p>

<span class="math align-center">$$
x^2 + y^2 + z^2 - R^2 = 0.
$$</span></details>
</blockquote>
<p><a href="#R-image-3e253703ed48021f6f5317095028a488" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/metaball.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-3e253703ed48021f6f5317095028a488"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/metaball.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 7:</strong> <em>metaballs are useful to model organic shapes.</em></p>
<p><a href="#R-image-7e5b46d96cbb6b9162b908ec1e098548" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/boolean.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7e5b46d96cbb6b9162b908ec1e098548"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/boolean.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 8:</strong> <em>example of constructive geometry. The volume defined by the sphere was removed from the cube. You can see the two original objects on the left, and the resulting shape on the right.</em></p>
<p>Implicit surfaces are very useful in modeling but are not very common (and certainly less common than they used to be). It is possible to use implicit surfaces to create more complex shapes (implicit primitives such as spheres, cubes, cones, etc. are combined through boolean operations), a technique called <a href="http://en.wikipedia.org/wiki/Constructive_solid_geometry" target="_blank">constructive solid geometry</a> (or CSG). <a href="http://en.wikipedia.org/wiki/Metaballs" target="_blank">Metaballs</a> (invented in the early 1980s by Jim Blinn) is another form of implicit geometry used to create organic shapes.</p>
<p>The problem though with implicit surfaces is that they are not easy to render. While it&rsquo;s often possible to ray trace them directly (we can compute the intersection of a ray with an implicit surface using an algebraic approach, as explained earlier), they first need to be converted to a mesh otherwise. The process of converting an implicit surface to a mesh is not as straightforward as with NURBS or Subdivision surface and requires a special algorithm such as the <a href="http://en.wikipedia.org/wiki/Marching_cubes" target="_blank">marching cube</a> algorithm (proposed by Lorensen and Cline in 1987). It can also potentially lead to creating heavy meshes.</p>
<p>Check the section on Geometry, to read about these different topics in detail.</p>
<h3 id="triangle-as-the-rendering-primitive">Triangle as the Rendering Primitive</h3>
<p>In this series of lessons, we will study an example of an implicit surface with the ray-sphere intersection test. We will also see an example of a parametric surface, with the Utah teapot, which is using Bezier surfaces. However, in general, most rendering APIs choose the solution of actually converting the different geometry types to a triangular mesh and render the triangular mesh instead. This has several advantages. Supporting several geometry types such as polygonal meshes, implicitly or parametric surfaces requires writing a ray-object routine for each supported surface type. This is not only more code to write (with the obvious disadvantages it may have), but it is also difficult if you make this choice, to make these routines work in a general framework, which often results in downgrading the performance of the render engine.</p>
<p>Keep in mind that rendering is more than just rendering 3D objects. It also needs to support many features such as motion blur, displacement, etc. Having to support many different geometry surfaces, means that each one of these surfaces needs to work with the entire set of supported features, which is much harder than if all surfaces are converted to the same rendering primitive, and if we make all the features work for this one single primitive only.</p>
<p>You also generally get better performances if you limit your code to rendering one primitive only because you can focus all your efforts to render this one single primitive very efficiently. Triangles have generally been the preferred choice for ray tracing. A lot of research has been done in finding the best possible (fastest/least instructions, least memory usage, and most stable) algorithm to compute the intersection of a ray with a triangle. However, other rendering APIs such as OpenGL also render triangles and triangles only, even though they don&rsquo;t use the ray tracing algorithm. Modern GPUs in general, are designed and optimized to perform a single type of rendering based on triangles. Someone (humorously) wrote on this topic:</p>
<blockquote>
<p>Because current GPUs are designed to work with triangles, people use triangles and so GPUs only need to process triangles, and so they&rsquo;re designed to process only triangles.</p>
</blockquote>
<p>Limiting yourself to rendering one primitive only, allows you to build common operations directly into the hardware (you can build a component that is extremely good at performing these operations). Generally, triangles are nice to work with for plenty of reasons (including those we already mentioned). They are always coplanar, they are easy to subdivide into smaller triangles yet they are indivisible. The maths to interpolate texture coordinates across a triangle are also simple (something we will be using later to apply a texture to the geometry). This doesn&rsquo;t mean that a GPU could not be designed to render any other kind of primitives efficiently (such as quads).</p>
<blockquote>
<details>
_Can I use quads instead of triangles?_
The triangle is not the only possible primitive used for rendering. The quad can also be used. Modeling or surfacing algorithms such as those that generate subdivision surfaces only work with quads. This is why quads are commonly found in 3D models. Why wasting time triangulating these models if we could render quads as efficiently as triangles? It happens that even in the context of ray-tracing, using quads can sometimes be better than using triangles (in addition to not requiring a triangulation which is a waste when the model is already made out of quads as just suggested). Ray-tracing quads will be addressed in the advanced section on ray-tracing.
</details>
</blockquote>
<h3 id="a-3d-scene-is-more-than-just-geometry">A 3D Scene Is More Than Just Geometry</h3>
<p>Typically though a 3D scene is more than just geometry. While geometry is the most important element of the scene, you also need a camera to look at the scene itself. Thus generally, a scene description also includes a camera. And a scene without any light would be black, thus a scene also needs lights. In rendering, all this information (the description of the geometry, the camera, and the lights) is contained within a file called the scene file. The content of the 3D scene can also be loaded into the memory of a 3D package such as Maya or Blender. In this case, when a user clicks on the render button, a special program or plugin will go through each object contained in the scene, each light, and export the whole lot (including the camera) directly to the renderer. Finally, you will also need to provide the renderer with some extra information such as the resolution of the final image, etc. These are usually called global render settings or options.</p>
<h3 id="summary">Summary</h3>
<p>What you should remember from this chapter is that we first need to consider what a scene is made of before considering the next step, which is to create an image of that 3D scene. A scene needs to contain three things: geometry (one or several 3D objects to look at), lights (without which the scene will be black), and a camera, to define the point of view from which the scene will be rendered. While many different techniques can be used to describe geometry (polygonal meshes, NURBS, subdivision surfaces, implicit surfaces, etc.) and while each one of these types may be rendered directly using the appropriate algorithm, it is easier and more efficient to only support one rendering primitive. In ray tracing and on modern GPUs, the preferred rendering primitive is the triangle. Thus, generally, geometry will be converted to triangular meshes before the scene gets rendered.</p>
<h2 id="an-overview-of-the-rendering-process-visibility-and-shading">An Overview of the Rendering Process: Visibility and Shading</h2>
<p>An image of a 3D scene can be generated in multiple ways, but of course, any way you choose should produce the same image for any given scene. In most cases, the goal of rendering is to create a photo-realistic image (non-photorealistic rendering or NPR is also possible). But what does it mean, and how can this be achieved? Photorealistic means essentially that we need to create an image so &ldquo;real&rdquo; that it looks like a photograph or (if photography didn&rsquo;t exist) that it would look like reality to our eyes (like the reflection of the world off the surface of a mirror). How do we do that? By understanding the laws of physics that make objects appear the way they do, and simulating these laws on the computer. In other words, rendering is nothing else than simulating the laws of physics responsible for making up the world we live in, as it appears to us. Many laws are contributing to making up this world, but fewer contribute to how it looks. For example, gravity, which plays a role in making objects fall (gravity is used in solid-body simulation), has little to do with the way an orange looks like. Thus, in rendering, we will be interested in what makes objects look the way they do, which is essentially the result of the way light propagates through space and interacts with objects (or matter more precisely). This is what we will be simulating.</p>
<h3 id="perspective-projection-and-the-visibility-problem">Perspective Projection and the Visibility Problem</h3>
<p>But first, we must understand and reproduce how objects look to our eyes. Not so much in terms of their appearance but more in terms of their shape and their size with respect to their distance to the eye. The human eye is an optical system that converges light rays (light reflected from an object) to a focus point.</p>
<p><a href="#R-image-0da5388f677e45f20dd3f175dc622e8c" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/perspective1.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-0da5388f677e45f20dd3f175dc622e8c"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/perspective1.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 1:</strong> <em>the human eye is an optical system that converges light rays (light reflected from an object) to a focus point. As a result, by geometric construction, objects which are further away from our eyes, do appear smaller than those which are at close distance.</em></p>
<p>As a result, by geometric construction, objects which are further away from our eyes, appear smaller than those which are at a close distance (assuming all objects have the same size). Or to say it differently, an object appears smaller as we move away from it. Again this is the pure result of the way our eyes are designed. But because we are accustomed to seeing the world that way, it makes sense to produce images that have the same effect: something called the <strong>foreshortening effect</strong>. Cameras and photographic lenses were designed to produce images of that sort. More than simulating the laws of physics, photorealistic rendering, is also about simulating the way our visual system works. We need to produce images of the world on a flat surface, similar to the way images are created in our eyes (which is mostly the result of the way our eyes are designed - we are not too sure about how it works in the brain but this is not important for us).</p>
<p>How do we do that? A basic method consists of tracing lines from the corner of objects to the eye and finding the intersection of these lines with the surface of an imaginary canvas (a flat surface on which the image will be drawn, such as a sheet of paper or the surface of the screen) perpendicular to the line of sight (Figure 2).</p>
<p><a href="#R-image-895dae4c875acf854fadf832e45dafa4" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/perspective2.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-895dae4c875acf854fadf832e45dafa4"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/perspective2.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 2:</strong> <em>to create an image of the box, we trace lines from the corners of the object to the eye. We then connect the points where these lines intersect an imaginary plane (the canvas) to recreate the edges of the cube. This is an example of perspective projection.</em></p>
<p>These intersection points can then be connected, to recreate the edges of the objects. The process by which a 3D point is projected onto the surface of the canvas (by the process we just described) is called <strong>perspective projection</strong>. Figure 3 shows what a box looks like when this technique is used to &ldquo;trace&rdquo; an image of that object on a flat surface (the canvas).</p>
<p><a href="#R-image-248cb29136deceaae7e9e3e52958259c" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/perspective3.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-248cb29136deceaae7e9e3e52958259c"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/perspective3.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 3:</strong> <em>image of a cube created using perspective projection.</em></p>
<p>This sort of rendering in computer graphics is called a wireframe because only the edges of the objects are drawn. This image though is not photo-real. If the box was opaque, the front faces of the box (at most three of these faces) should occlude or hide the rear ones, which is not the case in this image (and if more objects were in the scene, they would potentially occlude each other). Thus, one of the problems we need to figure out in rendering is not only how we should be projecting the geometry onto the scene, but also how we should determine which part of the geometry is visible and which part is hidden, something known as the visibility problem (determining which surfaces and parts of surfaces are not visible from a certain viewpoint). This process in computer graphics is known under many names: <strong>hidden surface elimination</strong>, <strong>hidden surface determination</strong> (also known as hidden surface removal, <strong>occlusion culling</strong>, and <strong>visible surface determination</strong>. Why so many names? Because this is one of the first major problems in rendering, and for this particular reason, a lot of research was made in this area in the early ages of computer graphics (and a lot of different names were given to the different algorithms that resulted from this research). Because it requires finding out whether a given surface is hidden or visible, you can look at the problem in two different ways: do I design an algorithm that looks for hidden surfaces (and remove them), or do I design one in which I focus on finding the visible ones. Of course, this should produce the same image at the end but can lead to designing different algorithms (in which one might be better than the others).</p>
<p>The visibility problem can be solved in many different ways, but they generally fall within two main categories. In historical-chronological order:</p>
<ul>
<li>Rasterization,</li>
<li>Ray-tracing.</li>
</ul>
<p>Rasterization is not a common name, but for those of you who are already familiar with hidden surface elimination algorithms, it includes the z-buffer and painter&rsquo;s algorithms among others. Almost all graphics cards (GPUs) use an algorithm from this category (likely z-buffering). Both methods will be detailed in the next chapter.</p>
<h3 id="shading">Shading</h3>
<p>Even though we haven&rsquo;t explained how the visibility problem can be solved, let&rsquo;s assume for now that we know how to flatten a 3D scene onto a flat surface (using perspective projection) and determine which part of the geometry is visible from a certain viewpoint. This is a big step towards generating a photorealistic image but what else do we need? Objects are not only defined by their shape but also by their appearance (this time not in terms of how big they appear on the scene, but in terms of their look, color, texture, and how bright they are). Furthermore, objects are only visible to the human eye because light is bouncing off their surface. How can we define the appearance of an object? The appearance of an object can be defined as the way the material this object is made of, interacts with light itself. Light is emitted by light sources (such as the sun, a light bulb, the flame of a candle, etc.) and travels in a straight line. When it comes in contact with an object, two things might happen to it. It can either be absorbed by the object or it can be reflected in the environment. When light is reflected off the surface of an object, it keeps traveling (potentially in a different direction than the direction it came from initially) until it either comes in contact with another object (in which case the process repeats, light is either absorbed or reflected) or reach our eyes (when it reaches our eyes, the photoreceptors the surface of the eye is made of convert light into an electrical signal which is sent to the brain).</p>
<p><a href="#R-image-72b5543e0323f8c1ecd7e0e9b015db14" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/lemon.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-72b5543e0323f8c1ecd7e0e9b015db14"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/lemon.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 4:</strong> <em>an object appears yellow under white light because it absorbs most of the blue light and reflects green and red light which combined to form a yellow color.</em></p>
<ul>
<li><strong>Absorption</strong> gives objects their unique color. White light (check the lesson on color in the section Introduction to Computer Graphics) is composed of all colors making up the visible spectrum. When white light strikes an object, some of these light colors are absorbed while others are reflected. Mixed, these reflected colors define the color of the object. Under sunlight, if an object appears yellow, you can assume that it absorbs blue light and reflects a combination of red and green light, which combined form the yellow color. A black object absorbs all light colors. A white object reflects them all. The color of an object is unique to the way the material this object is made of absorbs light (it is a unique property of that material).</li>
<li><strong>Reflection</strong>. We already know that an object reflects light colors which it doesn&rsquo;t absorb, but in which direction is this light reflected? It happens that the answer to this question is both simple and very complex. At the object level, light behaves no differently than a tennis ball when it bounces back from the surface of a solid object. It simply travels along a direction similar to the direction it came in but flipped around a vector perpendicular to the orientation of the surface at the impact point. In computer graphics, we call this direction a <strong>normal</strong>: the outgoing direction is a <strong>reflection</strong> of the incoming direction with respect to the normal. At the atomic level, when a photon interacts with an atom, the photon can either be absorbed or re-emitted by the atom in any new random direction. The re-emission of a photon by an atom is called <strong>scattering</strong>. We will speak about this term again in a very short while.</li>
</ul>
<p>In CG, we generally won&rsquo;t try to simulate the way light interacts with atoms, but the way it behaves at the object level. However, things are not that simple. Because if the maths involved in computing the new direction of a tennis ball bouncing off the surface of an object are simple, the problem is that surfaces at the microscopic level (not the atomic level) are generally not flat at all, which causes light to bounce in all sort of (almost random in some cases) directions. From the distance we generally look at common objects (a car, a pillow, a fruit), we don&rsquo;t see the microscopic structure of objects, although it has a considerable impact on the way it reflects light and thus the way they look. However, we are not going to represent objects at the microscopic level, for obvious reasons (the amount of geometry needed would simply not fit within the memory of any conventional or non-conventional for that matter, computer). What do we do then? The solution to this problem is to come up with another mathematical model, for simulating the way light interacts with any given material at the microscopic level. This, in short, is the role played by what we call a <strong>shader</strong> in computer graphics. A shader is an implementation of a mathematical model designed to simulate the way light interacts with matter at the microscopic level.</p>
<h3 id="light-transport">Light Transport</h3>
<p>Rendering is mostly about simulating the way light travels in space. Light is emitted from light sources, and is reflected off the surface of objects, and some of that light eventually reaches our eyes. This is how and why we see objects around us. As mentioned in the introduction to ray tracing, it is not very efficient to follow the path of light from a light source to the eye. When a photon hits an object, we do not know the direction this photon will have after it has been reflected off the surface of the object. It might travel towards the eyes, but since the eye is itself very small, it is more likely to miss it. While it&rsquo;s not impossible to write a program in which we simulate the transport of light as it occurs in nature (this method is called <strong>forward tracing</strong>), it is, as mentioned before, never done in practice because of its inefficiency.</p>
<p><a href="#R-image-53105ff1e1d2120f97c313e6e5b02902" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/lighttransport.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-53105ff1e1d2120f97c313e6e5b02902"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/lighttransport.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 5:</strong> <em>in the real world, light travel travels from light sources (the sun, light bulbs, the flame of a candle, etc.) to the eye. This is called forward tracing (left). However, in computer graphics and rendering, it&rsquo;s more efficient to simulate the path of light the other way around, from the eye to the object, to the light source. This is called backward tracing.</em></p>
<p>A much more efficient solution is to follow the path of light, the other way around, from the eye to the light source. Because we follow the natural path of light backward, we call this approach <strong>backward tracing</strong>.</p>
<p>Both terms are sometimes swapped in the CG literature. Almost all renderers follow light from the eye to the emission source. Because in computer graphics, it is the &lsquo;default&rsquo; implementation, some people prefer to call this method, forward tracing. However, in Scratchapixel, we will use forward for when light goes from the source to the eye, and backward when we follow its path the other way around.</p>
<p>The main point here is that rendering is for the most part about simulating the way light propagates through space. This is not a simple problem, not because we don&rsquo;t understand it well, but because if we were to simulate what truly happens in nature, there would be so many photons (or light particles) to follow the path of, that it would take a very long time to get an image. Thus in practice, we follow the path of very few photons instead, just to keep the render time down, but the final image is not as accurate as it would be if the paths of all photons were simulated. Finding a good tradeoff between photo-realism and render time is the crux of rendering. In rendering, a light transport algorithm is an algorithm designed to simulate the way light travels in space to produce an image of a 3D scene that matches &ldquo;reality&rdquo; as closely as possible.</p>
<p>When light bounces off a diffuse surface and illuminates other objects around it, we call this effect <strong>indirect diffuse</strong>. Light can also be reflected off the surface of shiny objects, creating caustics (the disco ball effect). Unfortunately, it is very hard to come up with an algorithm capable of simulating all these effects at once (using a single light transport algorithm to simulate them all). It is in practice, often necessary to simulate these effects independently.</p>
<p>Light transport is central to rendering and is a very large field of research.</p>
<h3 id="summary-1">Summary</h3>
<p>In this chapter, we learned that rendering can essentially be seen as an essential two steps process:</p>
<ul>
<li>The perspective projection and visibility problem on one hand,</li>
<li>And the simulation of light (light transport) as well the simulation of the appearance of objects (shading) on the other.</li>
</ul>
<blockquote>
<details>
Have you ever heard the term **graphics or rendering pipeline**? The term is more often used in the context of real-time rendering APIs (such as OpenGL, DirectX, or Metal). The rendering process as explained in this chapter can be decomposed into at least two steps, visibility, and shading. Both steps though can be decomposed into smaller steps or stages (which is the term more commonly used). Steps or stages are generally executed in sequential order (the input of any given stage generally depends on the output of the preceding stage). This sequence of stages forms what we call the rendering pipeline.
</details>
</blockquote>
<p>You must always keep this distinction in mind. When you study a particular technique always try to think whether it relates to one or the other. Most lessons from this section (and the advanced rendering section) fall within one of these categories:</p>
<p><a href="#R-image-9d99deffd71784c524f55f8c1babb2c2" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/20240216115455.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-9d99deffd71784c524f55f8c1babb2c2"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/20240216115455.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>We will briefly detail both steps in the next chapters.</p>
<h2 id="perspective-projection">Perspective Projection</h2>
<p>In the previous chapter, we mentioned that the rendering process could be looked at as a two steps process:</p>
<ul>
<li>projecting 3D shapes on the surface of a canvas and determining which part of these surfaces are visible from a given point of view,</li>
<li>simulating the way light propagates through space, which combined with a description of the way light interacts with the materials objects are made of, will give these objects their final appearance (their color, their brightness, their texture, etc.).</li>
</ul>
<p>In this chapter, we will only review the first step in more detail, and more precisely explain how each one of these problems (projecting the objects&rsquo; shape on the surface of the canvas and the visibility problem) is typically solved. While many solutions may be used, we will only look at the most common ones. This is just an overall presentation. Each method will be studied in a separate lesson and an implementation of these algorithms provided (in a self-contained C++ program).</p>
<h3 id="going-from-3d-to-2d-the-projection-matrix">Going from 3D to 2D: the Projection Matrix</h3>
<p><a href="#R-image-015d6c3300f2145690f2cc4ba3a9e9b7" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/perspective4.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-015d6c3300f2145690f2cc4ba3a9e9b7"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/perspective4.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 1:</strong> <em>to create an image of a cube, we just need to extend lines from the corners of the object towards the eye and find the intersection of these lines with a flat surface (the canvas) perpendicular to the line of sight.</em></p>
<p>An image is just a representation of a 3D scene on a flat surface: the surface of a canvas or the screen. As explained in the previous chapter, to create an image that looks like reality to our brain, we need to simulate the way an image of the world is formed in our eyes. The principle is quite simple. We just need to extend lines from the corners of the object towards the eye and find the intersection of these lines with a flat surface perpendicular to the line of sight. By connecting these points to draw the edges of the object, we get a <strong>wireframe</strong> representation of the scene.</p>
<blockquote>
<details>
It is important to note, that this sort of construction is in a way a completely arbitrary way of flattening a three-dimensional world onto a two-dimensional surface. The technique we just described gives us what is called in drawing, a one-point perspective projection, and this is generally how we do things in CG because this is how the eyes and also cameras work (cameras were designed to produce images similar to the sort of images our eyes create). But in the art world, nothing stops you from coming up with totally different rules. You can in particular get images with several (two, three, four) points perspective.
</details>
</blockquote>
<p>One of the main important visual properties of this sort of projection is that an object gets smaller as it moves further away from the eye (the rear edges of a box are smaller than the front edges). This effect is called <strong>foreshortening</strong>.</p>
<p><a href="#R-image-d9113ed514911886ed1339b10f29fd07" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/frustum2.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d9113ed514911886ed1339b10f29fd07"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/frustum2.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 2:</strong> the line of sight passes through the center of the canvas.</p>
<p><a href="#R-image-50c031dbe921f24c2aab21dd66593b68" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/frustum1.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-50c031dbe921f24c2aab21dd66593b68"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/frustum1.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 3:</strong> <em>the size of the canvas can be changed. Making it smaller reduces the field of view.</em></p>
<p>There are two important things to note about this type of projection. First, the eye is in the center of the canvas. In other words, the line of sight always passes through the middle of the image (figure 2). Note also that the size of the canvas itself is something we can change. We can more easily understand what the impact of changing the size of the canvas has if we draw the viewing frustum (figure 3). The <strong>frustum</strong> is the pyramid defined by tracing lines from each corner of the canvas toward the eye, and extending these lines further down into the scene (as far as the eye can see). It is also referred to as the viewing frustum or viewing volume. You can easily see that the only objects visible to the camera are those which are contained within the volume of that pyramid. By changing the size of the canvas we can either extend that volume or make it smaller. The larger the volume the more of the scene we see. If you are familiar with the concept of focal length in photography, then you will have recognized that this has the same effect as changing the focal length of photographic lenses. Another way of saying this is that by changing the size of the canvas, we change the field of view.</p>
<p><a href="#R-image-e09e372b29777bf018d0394df113f827" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/ortho.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-e09e372b29777bf018d0394df113f827"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/ortho.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 4:</strong> <em>when the canvas becomes infinitesimally small, the lines of the frustum become orthogonal to the canvas. We then get what we call an orthographic projection. The game SimCity uses a form of orthographic view which gives it a unique look.</em></p>
<p>Something interesting happens when the canvas becomes infinitesimally small: the lines forming the frustum, end up parallel to each other (they are orthogonal to the canvas). This is of course impossible in reality, but not impossible in the virtual world of a computer. In this particular case, you get what we call an <strong>orthographic projection</strong>. It&rsquo;s important to note that orthographic projection is a form of perspective projection, only one in which the size of the canvas is virtually zero. This has for effect to cancel out the <strong>foreshortening effect</strong>: the size of the edges of objects are preserved when projected to the screen.</p>
<p><a href="#R-image-f518a9a186b32485a572bb275bd2d992" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/projection.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f518a9a186b32485a572bb275bd2d992"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/projection.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 5:</strong> <em>P&rsquo; is the projection of P on the canvas. The coordinates of P&rsquo; can easily be computed using the property of similar triangles.</em></p>
<p>Geometrically, computing the intersection point of these lines with the screen is incredibly simple. If you look at the adjacent figure (where P is the point projected onto the canvas, and P&rsquo; is this projected point), you can see that the angle \(\angle ABC\) and \(\angle AB&rsquo;C&rsquo;\) is the same. A is defined as the eye, AB is the distance of the point P along the z-axis (P&rsquo;s z-coordinate), and BC is the distance of the point P along the y-axis (P&rsquo;s y coordinate). B&rsquo;C&rsquo; is the y coordinate of P&rsquo;, and AB&rsquo; is the z-coordinate of P&rsquo; (and also the distance of the eye to the canvas). When two triangles have the same angle, we say that they are <strong>similar</strong>. Similar triangles have an interesting property: the ratio of the lengths of their corresponding sides is constant. Based on this property, we can write that:</p>

<span class="math align-center">$$
{ BC \over AB } = { B'C' \over AB' }
$$</span><p>If we assume that the canvas is located 1 unit away from the eye (in other words that AB&rsquo; equals 1 (this is purely a convention to simplify this demonstration), and if we substitute AB, BC, AB&rsquo; and B&rsquo;C&rsquo; with their respective points&rsquo; coordinates, we get:</p>

<span class="math align-center">$$
{ BC \over AB } = { B'C' \over 1 } \rightarrow P'.y = { P.y \over P.z }.
$$</span><p>In other words, to find the y-coordinate of the projected point, you simply need to divide the point y-coordinate by its z-coordinate. The same principle can be used to compute the x coordinate of P&rsquo;:</p>

<span class="math align-center">$$
P'.x = { P.x \over P.z }.
$$</span><p>This is a very simple yet extremely important relationship in computer graphics, known as the <strong>perspective divide</strong> or z-divide (if you were on a desert island and needed to remember something about computer graphics, that would probably be this equation).</p>
<p>In computer graphics, we generally perform this operation using what we call a <strong>perspective projection matrix</strong>. As its name indicates, it&rsquo;s a matrix that when applied to points, projects them to the screen. In the next lesson, we will explain step by step how and why this matrix works, and learn how to build and use it.</p>
<p>But wait! The problem is that whether you need the perspective projection depends on the technique you use to sort out the visibility problem. Anticipating what we will learn in the second part of this chapter, algorithms for solving the visibility problem come into two main categories:</p>
<ul>
<li>Rasterization,</li>
<li>Ray-tracing.</li>
</ul>
<p>Algorithms of the first category rely on projecting P onto the screen to compute P&rsquo;. For these algorithms, the perspective projection matrix is therefore needed. In ray tracing, rather than projecting the geometry onto the screen, we trace a ray passing through P&rsquo; and look for P. We don&rsquo;t need to project P anymore with this approach since we already know P&rsquo;, which means that in ray tracing, the perspective projection is technically not needed (and therefore never used).</p>
<blockquote>
<details>
We will study the two algorithms in detail in the next chapters and the next lessons. However, it is important to understand the difference between the two and how they work at this point. As explained before, the geometry needs to be projected onto the surface of the canvas. To do so, P is projected along an "implicit" line (implicit because we never really need to build this line as we need to with ray tracing) connecting P to the eye. You can see the process as if you were moving a point along that line from P to the eye until it lies on the canvas. That point would be P'. In this approach, you know P, but you don't know P'. You compute it using the projection approach. But you can also look at the problem the other way around. You can wonder whether, for any point on the canvas (say P' - which by default we will assume is in the center of the pixel), there is a point P on the surface of the geometry that projects onto P'. The solution to this problem is to explicitly this time create a ray from the eye to P', extend or project this ray down into the scene, and find out if this ray intersects any 3D geometry. If it does, then the intersection point is P. Hopefully, you can now see more distinctively the difference between rasterization (we know P, we compute P') and ray tracing (we know P', we look for P).
</details>
</blockquote>
<p>The advantage of the rasterization approach over ray tracing is mainly speed. Computing the intersection of rays with geometry is a computationally expensive operation. This intersection time also grows linearly with the amount of geometry contained in the scene, as we will see in one of the next lessons. On the other hand, the projection process is incredibly simple, relies on basic math operations (multiplications, divisions, etc.), and can be aggressively optimized (especially if special hardware is designed for this purpose which is the case with GPUs). Graphics cards are almost all using an algorithm based on the rasterization approach (which is one of the reasons they can render 3D scenes so quickly, at interactive frame rates). When real-time rendering APIs such as OpenGL or DirectX are used, the projection matrix needs to be dealt with. Even if you are only interested in ray tracing, you should know about it for at least a historical reason: it is one of the most important techniques in rendering and the most commonly used technique for producing real-time 3D computer graphics. Plus, it is likely at some point that you will have to deal with the GPU anyway, and real-time rendering APIs do not compute this matrix for you. You will have to do it yourself.</p>
<blockquote>
<details>
The concept of rasterization is really important in rendering. As we learned in this chapter, the projection of P onto the screen can be computed by dividing the point's coordinates x and y by the point's z-coordinate. As you may guess, all initial coordinates are real numbers - floats for instance - thus P' coordinates are also real numbers. However pixel coordinates need to be integers, thereby, to store the color of P's in the image, we will need to convert its coordinates to pixel coordinates - in other words from floats to integers. We say that the point's coordinates are converted from screen space to raster space. More information can be found on this process in the lesson on rays and cameras.
</details>
</blockquote>
<p>The next three lessons are devoted to studying the construction of the orthographic and perspective matrix, and how to use them in OpenGL to display images and 3D geometry.</p>
<h2 id="the-visibility-problem">The Visibility Problem</h2>
<p>We already explained what the visibility problem is in the previous chapters. To create a photorealistic image, we need to determine which part of an object is visible from a given viewpoint. The problem is that when we project the corners of the box for example and connect the projected points to draw the edges of the box, all faces of the box are visible. However, in reality, only the front faces of the box would be visible, while the rear ones would be hidden.</p>
<p>In computer graphics, you can solve this problem using principally two methods: <strong>ray tracing</strong> and <strong>rasterization</strong>. We will quickly explain how they work. While it&rsquo;s hard to know whether one method is older than the other, rasterization was far more popular in the early days of computer graphics. Ray tracing is notoriously more computationally expensive (and uses more memory) than rasterization, and thus is far slower in comparison. Computers back then were so slow (and had so little memory), that rendering images using ray tracing was not considered a viable option, at least in a production environment (to produce films for example). For this reason, almost every renderer used rasterization (ray tracing was generally limited to research projects). However, for reasons we will explain in the next chapter, ray tracing is way better than rasterization when it comes to simulating effects such as reflections, soft shadows, etc. In summary, it&rsquo;s easier to create photo-realistic images with ray tracing, only it takes longer compared to rendering geometry using rasterization which in turn, is less adapted than ray tracing to simulate realistic shading and light effects. We will explain why in the next chapter. Real-time rendering APIs and GPUs are generally using rasterization because speed in real-time is obviously what determines the choice of the algorithm. What was true for ray tracing in the 80s and 90s is however not true today. Computers are now so powerful, that ray tracing is used by probably every offline renderer today (at least, they propose a hybrid approach in which both algorithms are implemented). Why? Because again it&rsquo;s the easiest way of simulating important effects such as sharp and glossy reflections, soft shadows, etc. As long as the speed is not an issue, it is superior in many ways to rasterization (making ray tracing work efficiently though still requires a lot of work). Pixar&rsquo;s PhotoRealistic RenderMan, the renderer Pixar developed to produce many of its first feature films (Toys Story, Nemo, Bug&rsquo;s Life) was based on a rasterization algorithm (the algorithm is called REYES; it stands for Renders Everything You Ever Saw. It is by far considered one of the best visible surface determination algorithms ever conceived - The GPU rendering pipeline has many similarities with REYES). But their current renderer called RIS is now a pure ray tracer. Introducing ray tracing allowed the studio to greatly push the realism and complexity of the images it produced over the years.</p>
<h3 id="rasterisation-to-solve-the-visibility-problem-how-does-it-work">Rasterisation to Solve the Visibility Problem: How Does it Work?</h3>
<p>We hopefully clearly explained already the difference between rasterization and ray tracing (read the previous chapter). However let&rsquo;s repeat, that we can look at the rasterization approach as if we were moving a point along a line connecting P, a point on the surface of the geometry, to the eye until it &ldquo;lies&rdquo; on the surface of the canvas. Of course, this line is only implicit, we never really need to construct it, but this is how intuitively we can interpret the projection process.</p>
<p><a href="#R-image-0d27419e5ce0d584f4d1b9bcec1234b3" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/projection3.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-0d27419e5ce0d584f4d1b9bcec1234b3"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/projection3.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 1:</strong> the projection process can be seen as if the point we want to project was moved down along a line connecting the point or the vertex itself to the eye. We can stop moving the point along that line when it lies on the plane of the canvas. Obviously, we don&rsquo;t &ldquo;slide&rdquo; the point along this line explicitly, but this is how the projection process can be interpreted.</p>
<p><a href="#R-image-fcfe4e00b20b0f113636962e2e46da62" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/projection2.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-fcfe4e00b20b0f113636962e2e46da62"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/projection2.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 2:</strong> <em>several points in the scene may project to the same point on the scene. The point visible to the camera is the one closest to the eye along the ray on which all points are aligned.</em></p>
<p>Remember that what we need to solve here is the visibility problem. In other words, there might be situations in which several points in the scene, P, P1, P2, etc. project onto the same point P&rsquo; onto the canvas (remember that the canvas is also the surface of the screen). However, the only point that is visible through the camera is the point along the line connecting the eye to all these points, which is the closest to the eye, as shown in Figure 2.</p>
<p>To solve the visibility problem, we first need to express P&rsquo; in terms of its position in the image: what are the coordinates of the pixel in the image, P&rsquo; falls onto? Remember that the projection of a point to the surface of the canvas gives another point P&rsquo; whose coordinates are real. However, P&rsquo; also necessarily falls within a given pixel of our final image. So how do we go from expressing P&rsquo;s in terms of their position on the surface of the canvas, to defining it in terms of their position in the final image (the coordinates of the pixel in the image, P&rsquo; falls onto)? This involves a simple change of coordinate systems.</p>
<ul>
<li>The coordinate system in which the point is originally defined is called <strong>screen space</strong> (or image space). It is defined by an origin that is located in the center of the canvas. All axes of this two-dimensional coordinate system have unit length (their length is 1). Note that the x or y coordinate of any point defined in this coordinate system can be negative if it lies to the left of the x-axis (for the x-coordinate) or below the y-axis (for the y-coordinate).</li>
<li>The coordinate system in which points are defined with respect to the grid formed by the pixels of the image, is called <strong>raster space</strong>. Its origin is generally located in the upper-left corner of the image. Its axes also have unit length and a pixel is considered to be one unit length in this coordinate system. Thus, the actual size of the canvas in this coordinate system is given by the image&rsquo;s vertical (height) and horizontal (width) dimensions (which are expressed in terms of pixels).</li>
</ul>
<p><a href="#R-image-3f97ae5cf36a4ceab9ad0299b2258510" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/screentoraster.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-3f97ae5cf36a4ceab9ad0299b2258510"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/screentoraster.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 3:</strong> <em>computing the coordinate of a point on the canvas in terms of pixel values, requires to transform the points&rsquo; coordinates from screen to NDC space, and NDC space to raster space.</em></p>
<p>Converting points from screen space to raster space is simple. Because the coordinates P&rsquo; expressed in raster space can only be positive, we first need to normalize P&rsquo;s original coordinates. In other words, convert them from whatever range they are originally in, to the range [0, 1] (when points are defined that way, we say they are defined in NDC space. NDC stands for Normalized Device Coordinates). Once converted to NDC space, converting the point&rsquo;s coordinates to raster space is trivial: just multiply the normalized coordinates by the image dimensions, and round the number off to the nearest integer value (pixel coordinates are always round numbers, or integers if you prefer). The range P&rsquo; coordinates are originally in, depends on the size of the canvas in screen space. For the sake of simplicity, we will just assume that the canvas is two units long in each of the two dimensions (width and height), which means that P&rsquo; coordinates in screen space, are in the range [-1, 1]. Here is the pseudo-code to convert P&rsquo;s coordinates from screen space to raster space:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">int</span> <span class="n">width</span> <span class="o">=</span> <span class="mi">64</span><span class="p">,</span> <span class="n">height</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>  <span class="c1">//dimension of the image in pixels 
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1"></span><span class="n">Vec3f</span> <span class="n">P</span> <span class="o">=</span> <span class="n">Vec3f</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">Vec2f</span> <span class="n">P_proj</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">P_proj</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">P</span><span class="p">.</span><span class="n">x</span> <span class="o">/</span> <span class="n">P</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>  <span class="c1">//-0.1 
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="c1"></span><span class="n">P_proj</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">P</span><span class="p">.</span><span class="n">y</span> <span class="o">/</span> <span class="n">P</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>  <span class="c1">//0.2 
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="c1">// convert from screen space coordinates to normalized coordinates
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1"></span><span class="n">Vec2f</span> <span class="n">P_proj_nor</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="n">P_proj_nor</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">P_proj</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>  <span class="c1">//(-0.1 + 1) / 2 = 0.45 
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1"></span><span class="n">P_proj_nor</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">P_proj</span><span class="p">.</span><span class="n">y</span> <span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>  <span class="c1">//(1 - 0.2) / 2 = 0.4 
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1">// finally, convert to raster space
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="c1"></span><span class="n">Vec2i</span> <span class="n">P_proj_raster</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="n">P_proj_raster</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">P_proj_nor</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">width</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="n">P_proj_raster</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">P_proj_nor</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">height</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">P_proj_raster</span><span class="p">.</span><span class="n">x</span> <span class="o">==</span> <span class="n">width</span><span class="p">)</span> <span class="n">P_proj_raster</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">P_proj_raster</span><span class="p">.</span><span class="n">y</span> <span class="o">==</span> <span class="n">height</span><span class="p">)</span> <span class="n">P_proj_raster</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">height</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> 
</span></span></code></pre></div><p>This conversion process is explained in detail in the lesson <a href="../../../lessons/3d-basic-rendering/3d-viewing-pinhole-camera/">3D Viewing: the Pinhole Camera Model</a>.</p>
<p>There are a few things to notice in this code. First that the original point P, the projected point in screen space, and NDC space all use the Vec3f or Vec2f types in which the coordinates are defined as real (floats). However, the final point in raster space uses the Vec2i type in which coordinates are defined as integers (the coordinate of a pixel in the image). Arrays in programming, are 0-indexed, thereby, the coordinates of a point in raster point should never be greater than the width of the image minus one or the image height minus one. However, this may happen when P&rsquo;s coordinates in screen space are exactly 1 in either dimension. The code checks this case (lines 14-15) and clamps the coordinates to the right range if it happens. Also, the origin of the NDC space coordinate is located in the lower-left corner of the image, but the origin of the raster space system is located in the upper-left corner (see figure 3). Therefore, the y coordinate needs to be inverted when converted from NDC to raster space (check the difference between lines 8 and 9 in the code).</p>
<p>But why do we need this conversion? To solve the visibility problem we will use the following method:</p>
<ul>
<li>
<p>Project all points onto the screen.</p>
<ul>
<li>
<p>For each projected point, convert P&rsquo;s coordinates from screen space to raster space.</p>
</li>
<li>
<p>Find the pixel the point maps to (using the projected point raster coordinates), and store the distance of that point to the eye, in a special list of points (called the depth list), maintained by that pixel.</p>
</li>
</ul>
</li>
</ul>
<blockquote>
  <details>
  _You say, project all points onto the screen. How do we find these points in the first place?"_
  Very good question. Technically, we would break down the triangles or the polygons objects are made of, into smaller geometry elements no bigger than a pixel when projected onto the screen. In real-time APIs (OpenGL, DirectX, Vulkan, Metal, etc.) this is what we generally refer to as fragments. Check the lesson on the REYES algorithm in this section to learn how this works in more detail.
  </details>  
</blockquote>
<ul>
<li>At the end of the process, sort the points in the list of each pixel, by order of increasing distance. As a result of this process, the point visible for any given pixel in the image is the first point from that pixel&rsquo;s list.</li>
</ul>
<blockquote>
<details>
_Why do points need to be sorted according to their depth?_
The list needs to be sorted because points are not necessarily ordered in depth when projected onto the screen. Assuming you insert points by adding them at the top of the list, you may project a point B further from the eye than a point A, after you projected A. In which case B will be the first point in the list, even though its distance to the eye, is greater than the distance to A. Thus sorting is required.
</details>
</blockquote>
<p>An algorithm based on this approach is called a <strong>depth sorting algorithm</strong> (a self-explanatory name). <strong>The concept of depth ordering is the base of all rasterization algorithms</strong>. Quite a few exist among the most famous of which are:</p>
<ul>
<li>the z-buffering algorithm. This is probably the most commonly used one from this category. The REYES algorithm which we present in this section implements the z-buffer algorithm. It is very similar to the technique we described in which points on the surfaces of objects (objects are subdivided into very small surfaces or fragments which are then projected onto the screen), are projected onto the screen and stored into depth lists.</li>
<li>the Painter algorithm</li>
<li>Newell&rsquo;s algorithm</li>
<li>&hellip; (list to be extended)</li>
</ul>
<p>Keep in mind that while this may sound like old fashion to you, all graphics cards are using one implementation of the z-buffer algorithm, to produce images. These algorithms (at least z-buffering) are still commonly used today.</p>
<blockquote>
<details>
Why do we need to keep a list of points? Storing the point with the shortest distance to the eye shouldn't require storing all the points in a list. Indeed, you could very well do the following thing:
<ul>
<li>For each pixel in the image, set the variable z to infinity.</li>
<li>For each point in the scene.
<ul>
<li>Project the point and compute its raster coordinates</li>
<li>If the distance from the current point to the eye z&rsquo; is smaller than the distance z stored in the pixel the point projects to, then update z with z&rsquo;. If z&rsquo; is greater than z, then the point is located further away from the point currently stored for that pixel.</li>
</ul>
</li>
</ul>
<p>You can see that, you can get the same result without having to store a list of visible points and sorting them out at the end. So why did we use one? We used one because, in our example, we just assume that all points in the scene were opaque. But what happens if they are not fully opaque? If several semi-transparent points project to the same pixel, they may be visible throughout each other. In this particular case, it is necessary to keep track of all the points visible through that particular pixel, sort them out by distance, and use a special compositing technique (we will learn about this in the lesson on the REYES algorithm) to blend them correctly.</p>
</details>
</blockquote>
<h3 id="ray-tracing-to-solve-the-visibility-problem-how-does-it-work">Ray Tracing to Solve the Visibility Problem: How Does It Work?</h3>
<p><a href="#R-image-328e9f8ef973e34401bf6d3c58e432de" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/raytracing.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-328e9f8ef973e34401bf6d3c58e432de"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/raytracing.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 4:</strong> <em>in raytracing, we explicitly trace rays from the eye down into the scene. If the ray intersects some geometry, the pixel the ray passes through takes the color of the intersected object.</em></p>
<p>With rasterization, points are projected onto the screen to find their respective position on the image plane. But we can look at the problem the other way around. Rather than going from the point to the pixel, we can start from the pixel and convert it into a point on the image plane (we take the center of the pixel and convert its coordinates defined in raster space to screen space). This gives us P&rsquo;. We can then trace a ray starting from the eye, passing through P&rsquo;, and extend it down into the scene (by default we will assume that P&rsquo; is the center of the pixel). If we find that the ray intersects an object, then we know that the point of intersection P is the point visible through that pixel. In short, ray tracing is a method to solve the point&rsquo;s visibility problem, by the mean of explicitly tracing rays from the eye down into the scene.</p>
<p>Note that in a way, ray tracing and rasterization are a reflection of each other. They are based on the same principle, but ray tracing is going from the eye to the object, while rasterization goes from the object to the eye. While they make it possible to find which point is visible for any given pixel in the image (they give the same result in that respect), implementing them requires solving very different problems. Ray tracing is more complicated in a way because it requires solving the ray-geometry intersection problem. Do we even have a way of finding the intersection of a ray with geometry? While it might be possible to find a way of computing whether or not a ray intersects a sphere, can we find a similar method to compute the intersection of a ray with a cone for instance? And what about another shape, and what about NURBS, subdivision surfaces, and implicit surfaces? As you can see, ray tracing can be used as long as a technique exists to compute the intersection of a ray with any type of geometry a scene might contain (or your renderer might support).</p>
<p>Over the years, a lot of research was put into efficient ways of computing the intersection of rays with the simplest of all possible shapes - the triangle - but also directly ray tracing other types of geometry: NURBS, implicit surfaces, etc. However, one possible alternative to supporting all geometry types is to convert all geometry to a single geometry representation before the rendering process starts, and have the renderer only test the intersection of rays with that one geometry representation. Because triangles are an ideal rendering primitive, most of the time, all geometry is converted to triangles meshes, which means that rather than implementing a ray-object intersection test per geometry type, you only need to test for the intersection of rays with triangles. This has many advantages:</p>
<ul>
<li>First as suggested before, the triangle has many properties that make it very attractive as a geometry primitive. It&rsquo;s co-planar, a triangle is indivisible (as creating more faces by connecting the existing vertices, as you would for faces having at least four or more vertices), but it can easily be subdivided into more triangles. Finally, the math for computing the barycentric coordinates of a triangle (which is used in texturing) is simple and robust.</li>
<li>Because triangles are a good geometry primitive, a lot of research was done to find the best possible ray-triangle intersection test. What is a good ray triangle intersection algorithm? It needs to be fast (get to the result using as few operations as possible). It needs to use the least memory possible (some algorithms are more memory-hungry than others because they require storing precomputed variables on the triangle geometry). And it also needs to be robust (floating-point arithmetic issues are hard to avoid).</li>
<li>From a coding point of view, supporting one single routine is far more advantageous than having to code many routines to handle all geometry types. Supporting triangles only simplifies the code in many places but also allows to design code that works best with triangles in general. This is particularly true when it comes to acceleration structures. Computing the intersection of rays with geometry is by far the most expensive operation in a ray tracer. The time it takes to test the intersection with all geometry in the scene grows linearly with the amount of geometry the scene contains. As soon as the scene contains even just hundreds of such primitives it becomes necessary to implement strategies to quickly discard sections of the scene, which we know have no chances to be intersected by the ray, and test for only subsections of the scene that the ray will potentially intersect. These strategies save a considerable amount of time and are generally based on acceleration structures. We will study acceleration structures in the section devoted to ray tracing techniques. Also, it&rsquo;s worth noticing that specially designed hardware has been already built in the past, to handle the ray-triangle intersection test specifically, allowing complex scenes to run near real-time using ray tracing. It&rsquo;s quite obvious that in the future, graphics cards will natively support the ray-triangle intersection test and that video games will evolve towards ray tracing.</li>
</ul>
<h3 id="comparing-rasterization-and-ray-tracing">Comparing rasterization and ray-tracing</h3>
<p><a href="#R-image-ef68de0230b1ea74d331e78514f26c94" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/gridaccel.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-ef68de0230b1ea74d331e78514f26c94"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/gridaccel.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 5:</strong> <em>the principle of acceleration structure consists of dividing space into sub-regions. As the ray travels from one sub-region to the next, we only need to check for a possible intersection with the geometry contained in the current sub-region. Instead of testing all the objects in the scene, we can only test for those contained in the sub-regions the ray passes through. This leads to potentially saving a lot of ray-geometry intersection tests which are costly.</em></p>
<p>We already talked a few times about the difference between ray tracing and rasterization. Why would you choose one or the other? As mentioned before, to sort the visibility problem, rasterization is faster than ray tracing. Why is that? Converting geometry to make it work with the rasterization algorithm takes eventually some time, but projecting the geometry itself is very fast (it just takes a few multiplications, additions, and divisions). In comparison, computing the intersection of a ray with geometry requires far more instructions and is, therefore, more expensive. The main difficulty with ray tracing is that render time increases linearly with the amount of geometry the scene contains. Because we have to check whether any given ray intersects any of the triangles in the scene, the final cost is then the number of triangles multiplied by the cost of a single ray-triangle intersection test. Hopefully, this problem can be alleviated by the use of an <strong>acceleration structure</strong>. The idea behind acceleration structures is that space can be divided into subspaces (for instance you can divide a box containing all the geometry to form a grid - each cell of that grid represents a sub-space of the original box) and that objects can be sorted depending on the sub-space they fall into. This idea is illustrated in figure 5.</p>
<p>If these sub-spaces are significantly larger than the objects&rsquo; average size, then it is likely that a subspace will contain more than one object (of course it all depends on how they are organized in space). Instead of testing all objects in the scene, we can first test if a ray intersects a given subspace (in other words, if it passes through that sub-space). If it does, we can then test if the ray intersects any of the objects it contains, but if it doesn&rsquo;t, we can then skip the ray-intersection test for all these objects. This leads to only testing a subset of the scene&rsquo;s geometry, which is saving time.</p>
<p>If acceleration structures can be used to accelerate ray tracing then isn&rsquo;t ray tracing superior to rasterization? Yes and no. First, it is still generally slower, but using an acceleration structure raises a lot of new problems.</p>
<ul>
<li>First building this structure takes time, which means the render can&rsquo;t start until it&rsquo;s built: this generally never takes more than a few seconds, but, if you intend to use ray tracing in a real-time application, then these few seconds are already too much (the acceleration structures needs to be built for every rendered frame if the geometry changes from frame to frame).</li>
<li>Second, an acceleration structure potentially takes a lot of memory. This all depends on the scene complexity, however, because a good chunk of the memory needs to be used for the acceleration structure, this means that less is available for doing other things, particularly storing geometry. In practice, this means you can potentially render less geometry with ray tracing than with rasterization.</li>
<li>Finally finding a good acceleration structure is very difficult. Imagine that you have one triangle on one side of the scene and all the other triangles stuck together in a very small region of space. If we build a grid for this scene many of the cells will be empty but the main problem is that when a ray traverses the cell containing the cluster of triangles, we will still need to perform a lot of intersection tests. Saving one test over the hundreds that may be required, is negligible and clearly shows that a grid as an acceleration structure for that sort of scene is not a good choice. As you can see, the efficiency of the acceleration structure depends very much on the scene, and the way objects are scattered: are object smalls or large, is it a mix of small and large objects, are objects uniformly distributed over space or very unevenly distributed? Is the scene a combination of any of these options?</li>
</ul>
<p><a href="#R-image-87de6a5356bc654fff9c7f730f74e6a8" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/gridaccel2.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-87de6a5356bc654fff9c7f730f74e6a8"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/gridaccel2.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Many different acceleration structures have been proposed and they all have as you can guess strengths and weaknesses, but of course, some of them are more popular than others. You will find many lessons devoted to this particular topic in the section devoted to Ray Tracing Techniques.</p>
<p>From reading all this you may think that all problems are with ray tracing. Well, ray tracing is popular for a reason. First, in its principle, it is incredibly simple to implement. We showed in the first lesson of this section that a very basic raytracer can be written in no more than a few hundred lines of code. In reality, we could argue that it wouldn&rsquo;t take much more code to write a renderer based on the rasterization algorithm, but still, the concept of ray tracing seems to be easier to code, as maybe it is a more natural way of thinking of the process of making an image of a 3D scene. But far more importantly, it happens that if you use ray tracing, computing effects such as reflection or soft shadow which play a critical role in the photo-realism of an image, are just straightforward to simulate in ray tracing, and very hard to simulate if you use rasterization. To understand why, we first need to look at shading and light transport in more detail, which is the topic of our next chapter.</p>
<blockquote>
<p>Rasterization is fast but needs cleverness to support complex visual effects. Ray tracing supports complex visual effects but needs cleverness to be fast - David Luebke (NVIDIA).</p>
</blockquote>
<blockquote>
<p>With rasterization it is easy to do it very fast, but hard to make it look good. With ray tracing it is easy to make it look good, but very hard to make it fast.</p>
</blockquote>
<h3 id="summary-2">Summary</h3>
<p>In this chapter, we only look at using ray tracing and rasterization as two possible ways of solving the visibility problem. Rasterisation is still the method by which graphics cards render 3D scenes. Rasterisation is still faster compared to ray tracing when it comes to using one algorithm or the other to solve the visibility problem. You can accelerate ray tracing through with an acceleration structure, however, acceleration structures come with their own set of issues: it&rsquo;s hard to find a good acceleration structure, one that performs well regardless of the scene configuration (number of primitives to render, their sizes and their distribution in space). They also require extra memory and building them takes time.</p>
<p>It is important to appreciate that at this stage, ray tracing does not have any definite advantages over rasterization. However, ray tracing is better than rasterization to simulate light or shading effects such as soft shadows or reflections. When we say better we mean that is more straightforward to simulate them with ray tracing than it is with rasterization, which doesn&rsquo;t mean at all these effects can&rsquo;t be simulated with rasterization. It just generally only requires more work. We insist on this point because there is a common misbelief regarding the fact that effects such as reflections for example can&rsquo;t be done with rasterization, which is why ray tracing is used. It is simply not true. However, one might think about using a hybrid approach in which rasterization is used for the visibility surface elimination step, and ray tracing is used for shading, the second step of the rendering process, but having to implement both systems in the same applications requires more work than just using one unified framework. And since ray tracing makes it easier to simulate things such as reflections, then most people prefer to use ray tracing to solve the visibility problem as well.</p>
<h2 id="a-light-simulator">A Light Simulator</h2>
<p>We finished the last chapter on the idea that ray-tracing was better than rasterization to simulate important and common shading and lighting effects (such as reflections, soft shadows, etc.). Not being able to simulate these effects, simply means your image will lack the photo-realism we strive for. But before we dive into this topic further, let&rsquo;s have a look at some images from the real world to better understand what these effects are.</p>
<h3 id="reflection">Reflection</h3>
<p><a href="#R-image-efcfb1a3a55d05fa70c7ad5571a2cc43" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/reflection.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-efcfb1a3a55d05fa70c7ad5571a2cc43"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/reflection.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>When light comes in contact with a perfect mirror-like surface, it is reflected into the environment in a predictable direction. This new direction can be computed using the <strong>law of reflection</strong>. This law states that, like a tennis ball bouncing off the floor, a light ray changes direction when it comes in contact with a surface, and that the outgoing or <strong>reflected direction</strong> of this ray is a reflection of the incoming or <strong>incident direction</strong> about the normal at the point of incidence. A more formal way of defining the law of reflection is to say that a reflected ray always comes off the surface of a material at an angle equal to the angle at which the incoming ray hit the surface. This is illustrated in the image on the right, where you can see that the angle between the normal and the incident vector, is equal to the angle between the normal and the outgoing vector. Note that even though we used a water surface in the picture as an example of a reflective surface, water and glass are pretty poor mirrors compared to metals particularly.</p>
<h3 id="transparency">Transparency</h3>
<p><a href="#R-image-d9deb05d8d8548761ac36fa884689a7f" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/transparency.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d9deb05d8d8548761ac36fa884689a7f"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/transparency.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><a href="#R-image-977d895505e1e370bd3a924ce6f9c34e" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/transparent-raygraph.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-977d895505e1e370bd3a924ce6f9c34e"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/transparent-raygraph.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>In the case of transparent objects (imagine a pane of glass for example), light is reflected and refracted. The term &ldquo;transmitted&rdquo; is also often used in place of &ldquo;refracted&rdquo;, but the terms mean two slightly different things. By transmitted we mean, a fraction of the incident light enters the object on one side and leaves the object on the other side (which is why we see objects through a window). However, as soon as it comes in contact with the surface of a transparent object, light changes direction, and this is what we call refraction. It is the effect of light rays being bent as they travel from one transparent medium such as air to another such as water or glass (it doesn&rsquo;t matter if it goes from air to water or water to air, light rays are still being bent in one way or another). As with reflection, the refraction direction can be computed using <strong>Snell&rsquo;s law</strong>. The amount of light reflected and refracted is given by the <strong>Fresnel&rsquo;s equation</strong>. These two equations are very important in rendering. The graph on the right, shows a primary ray going through a block of glass. The ray is refracted, then travels through the glass, is refracted again when it leaves the glass, and eventually hits the surface below it. If that surface was an object, then this is what we would see through the glass.</p>
<h3 id="glossy-or-specular-reflection">Glossy or Specular Reflection</h3>
<p><a href="#R-image-b9ea85dc15dfa5d8214b0f6f009c43c2" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/glossyreflection.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b9ea85dc15dfa5d8214b0f6f009c43c2"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/glossyreflection.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><a href="#R-image-d26d181efec9ad570c54d022a817f350" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/specular-raygraph.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d26d181efec9ad570c54d022a817f350"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/specular-raygraph.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>A glossy reflection is a material that is not perfectly reflective (like a mirror) nor perfectly diffuse. It is somewhere in between, where this &ldquo;in-between&rdquo; can either be anywhere between almost perfectly reflective (as in the case of a mirror-like surface) and almost perfectly diffuse. The glossiness of a surface is also sometimes referred to as its <strong>roughness</strong> (the two terms are antonymous) and <strong>specular reflection</strong> is often used instead of glossy reflection. You will often come across these two terms in computer graphics. Why do we speak of roughness then? To behave like a mirror, the surface of an object needs to be perfectly smooth. While many objects may appear flat and smooth in appearance (with the naked eye), looking at their surface under a microscope, reveals a very complex structure, which is not flat or smooth at all. In computer graphics we often like to describe rough surfaces, using the image of a surface made of lots of microfacets, where each one of these microfacets is oriented in a slightly different direction and acts on its own as a perfect mirror. As you can see in the adjacent image, when light bounces off from one of these facets, it is reflected in a slightly different direction than the mirror direction. The amount of variation between the mirror direction and the ray outgoing direction depends on how strongly the facets deviate from an ideally smooth surface. The stronger the deviation, the greater the difference, on average, between the ideal reflection direction and the actual reflection direction. Visually, rather than having a perfect image of the environment reflected off of a mirror-like surface, this image is slightly deformed (or blurred if you prefer). We have all seen how ripples caused by a pebble thrown into the water, change the sharp image reflected by a perfectly still water surface. Glossy reflections are similar to that: a perfect reflection deformed or blurred by the microscopic irregularities of the surface.</p>
<p>In computer graphics, we often speak of <strong>scattering</strong>. Because rather than being all reflected in the same direction, rays are scattered in a range of directions around the mirror direction (as shown in the last image on the right).</p>
<h3 id="diffuse-reflection">Diffuse Reflection</h3>
<p><a href="#R-image-c95962ed1de4c8a3986665bed613d41c" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/diffusereflection.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c95962ed1de4c8a3986665bed613d41c"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/diffusereflection.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>On the other extreme of a perfectly reflective surface, is the concept of diffuse surfaces. When we talked about specular reflection, we mentioned that light rays were scattered around the mirror direction. But for diffuse surfaces, rays are scattered even more, in fact so much, that they are reflected in all sorts of random directions. Incident light is equally spread in every direction above the point of incidence and as a result, a diffuse surface appears equally bright from all viewing directions (again that&rsquo;s because the incident light is equally spread in every direction as a result of being strongly scattered). Two things can cause a surface to be diffuse: the surface can either be very rough or made up of small structures (such as crystals). In the latter case, rays get trapped in these structures and are reflected and refracted by them a great number of times before they leave the surface. Each reflection or refraction with one of these structures changes the light direction, and it happens so many times that when they finally leave the surface, rays have a random direction. What we mean by random is that the outgoing direction does not correlate whatsoever with the incident direction. Or to put it differently, the direction of incidence does not affect the light rays&rsquo; outing directions (which is not the case of specular surfaces), which is another interesting property of diffuse surfaces.</p>
<h3 id="subsurface-scattering">Subsurface Scattering</h3>
<p><a href="#R-image-f3c872a69e236a96a9b056f0d9e229c0" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/subsurface.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f3c872a69e236a96a9b056f0d9e229c0"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/subsurface.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Subsurface scattering is the technical term for translucency. Translucent surfaces in a way are surfaces that are not completely opaque nor completely transparent. But in fact, the reason why objects are translucent has little to do with transparency. The effect is visible when wax, a small object made out of jade or marble, or when a thin layer of organic material (skin, leaves) is strongly illuminated from the back. Translucency is the effect of light traveling through the material, changing directions along it is way until and leaving the object in a different location and a different direction than the point and direction of incidence. Subsurface scattering is rather complex to simulate.</p>
<h3 id="indirect-diffuse">Indirect Diffuse</h3>
<p><a href="#R-image-30f34ca3a3879e9a4a5abfc2e961f312" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/indirectdiffuse.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-30f34ca3a3879e9a4a5abfc2e961f312"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/indirectdiffuse.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Some surfaces of the ornamental object in the center of the adjacent image, are not facing any direct light at all. They are not facing the sun and they are not facing up to the sky either (which we can look at as a very large light source). And yet, they are not completely black. How come? This happens because the floor which is directly illuminated by the sun, bounces light back into the environment and some of that light eventually illuminates parts of the object which are not receiving any direct light from the sun. Because the surface receives light emitted by light sources such as the sun indirectly (through other surfaces), we speak of indirect lighting.</p>
<h3 id="indirect-specular-or-caustics">Indirect Specular or Caustics</h3>
<p><a href="#R-image-19579e45a22fa88aec1d2f9d4f260b7b" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/caustics.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-19579e45a22fa88aec1d2f9d4f260b7b"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/caustics.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Similarly to the way diffuse objects reflect light that illuminates other objects in their surroundings, reflective objects too can indirectly illuminate other objects by redirecting light to other parts of their environment. Lenses or waves at the surface of the water also focus light rays within singular lines or patterns which we call caustics (we are familiar with the dancing pattern of light at the bottom of a pool exposed to sunlight). Caustics are also frequently seen when light is reflected off of the mirrors making up the surface of disco balls, reflected off of the surface of windows in summer, or when a strong light shines upon a glass object.</p>
<h3 id="soft-shadows">Soft Shadows</h3>
<p><a href="#R-image-b62aad1a2939ed8af4b224128dec3e7a" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/softshadows.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b62aad1a2939ed8af4b224128dec3e7a"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/softshadows.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Most of the effects we described so far have something to do with the object&rsquo;s material properties. Soft shadows on the other hand have nothing to do with materials. Simulating them is only a geometric problem involving the objects and light sources&rsquo; shape, size, and location in space.</p>
<p>Don&rsquo;t worry if you are curious about knowing and understanding how all these effects can be simulated. We will study them all in due time. At this point of the lesson, it&rsquo;s only important to look at some images of the real world, and analyze what lighting/shading effects we can observe in these images so that we can reproduce them later on.</p>
<blockquote>
<p>Remember from this chapter, that a diffuse surface appears equally bright from all viewing directions, but a specular surface&rsquo;s brightness varies with the viewing direction (if you move around a mirror, the image you see in the mirror will change). We say that diffuse interaction is <strong>view-independent</strong> while specular interaction is <strong>view-dependent</strong>.</p>
</blockquote>
<h3 id="light-transport-and-shading-two-related-but-different-problems">Light Transport and Shading: Two Related But Different Problems</h3>
<p>The other reason why we have been quickly reviewing these effects is for you to realize two things:</p>
<ul>
<li>
<p>The appearance of objects, only depends on the way light interacts with matter and travels through space.</p>
</li>
<li>
<p>All these effects can be broadly divided into two categories:</p>
<ul>
<li>Some effects relate to the way objects appear.</li>
<li>Some effects relate to how much light an object receives.</li>
</ul>
<p>In the former category, you can add reflection, transparency, specular reflection, diffuse reflection, and subsurface scattering. In the latter, you can add indirect diffuse, indirect specular, and soft shadows. The first category could relate to what we call <strong>shading</strong> (what gives an object its appearance), while the second can relate to what we call <strong>light transport</strong> (how is light transported from the surface to surface as a result of interacting with different materials).</p>
<p>In shading, we study the way light interacts with matter (or the other way around). In other words, it looks at everything that happens to light from the moment it reaches an object, to the moment it leaves it.</p>
<p>Light transport is the study of what happens to light when it bounces from surface to surface. How is it reflected from various surfaces? How does the nature of this reflection change with the type of material light is reflected from (diffuse, specular, etc.)? Where does light go? Is it blocked by any geometry on its way to another surface? What effect does the shape of that blocker have on the amount of light an object receives? More generally, light transport is interested in the <strong>paths</strong> light rays are to follow as they travel from a light source to the eye (which we call flight paths).</p>
</li>
</ul>
<p>Note that the boundary between shading and light transport is very thin. In the real world, there would be no distinction to be made. It&rsquo;s all about light traveling and taking different paths depending on the object it encounters along its way from the light source to the eye. But, it is convenient in computer graphics to make the distinction between the two because they can&rsquo;t be simulated efficiently using the same approach. Let&rsquo;s explain.</p>
<p>If we could replicate the world in our computer program down to the atom, and code some basic rules to define the way light interacts with these atoms, we would just have to wait for light to bounce around until it reaches our eye, to generate a perfect image of the world. Creating such a program would be ideal but unfortunately, it can&rsquo;t be done with our current technology. Even if you had enough memory to model the world at the atomic level, you&rsquo;d not have enough computing power to simulate the path of the zillions of light particles (photons) traveling around us and interacting a zillions times with matter almost instantaneously before it reaches the eye, in anything less than an infinite amount of time. Therefore, a different approach is required. What we do instead is look at what takes the most time in the process. Well clearly, light traveling in straight paths from one surface to another is pretty basic, while what happens when light reaches a surface and interacts with it, is complex (and is what would take the most time to simulate).</p>
<p>Thus, in computer graphics, we artificially make a distinction between shading and light transport. The art of shading is to design mathematical models that approximate the way light interacts with matter, at a fraction of the time it would take if these interactions were to be physically simulated. On the other hand, we can afford to simulate the path of light rays as they go from one surface to another, as nothing complex happens to them on their way. This distinction allows designing strategies adapted to solving both problems (shading and light transport) independently.</p>
<p>Simulating light transport is easier than simulating the interaction of light with matter, though, we didn&rsquo;t say it was easy. Some types of inter-reflection are notably hard to simulate (caustics, for instance, we will explain why in the next chapter), and while designing good mathematical models to emulate the way light interacts with surfaces is hard, designing a good light transport algorithm can be challenging on its own (as we will see in the next chapter).</p>
<h3 id="global-illumination">Global illumination</h3>
<p>But let&rsquo;s step back a little. While you may think (it&rsquo;s often a misconception) that most surfaces are visible because they receive light directly from a light source, there are about as many situations (if not many more) in which, light only appears visible as a result of being illuminated indirectly by other surfaces. Look around you and just compare the number of objects or roughly the ratio between the areas which are directly exposed to a light source (the sun, artificial lights, etc.), over areas that are not exposed directly to a light source and receive light reflected by another surface. Indirect lighting plays such an important part in the world as we see it, that if you don&rsquo;t simulate it, it will be hard to make your images look photo-real. When in rendering we can simulate both direct lighting and indirect lighting effects, we speak of <strong>global illumination</strong>. Ideally, in lighting, and rendering more generally, we want to simulate every possible lighting scenario. A scenario is defined by the shape of the object contained in the scene, its material, how many lights are in the scene, their type (is it the sun, is it a light bulb, a flame), their shape, and finally how objects are scattered throughout space (which influences how light travels from surface to surface).</p>
<p>In CG, we make a distinction between direct and indirect lighting. If you don&rsquo;t simulate indirect lighting you can still see objects in the scene due to direct lighting, but if you don&rsquo;t simulate direct lighting, then obviously the image will be black (in the old days, direct lighting was also used to be called local illumination in contrast to global illumination which is the illumination of surfaces by other surfaces). But why wouldn&rsquo;t we simulate indirect lighting anyway?</p>
<p>Essentially because it&rsquo;s slow and/or not necessarily easy to do. As we will explain in detail in the next chapter, light can interact with many surfaces before it reaches the eye. If we consider ray tracing, for now, we also explained that what is the most expensive to compute in ray tracing is the ray-geometry intersection test. The more interactions between surfaces you have to simulate, the slower the render. With direct lighting, you only need to find the intersection between the primary or camera or eye rays (the rays traced from the camera) and the geometry in the scene, and then cast a ray from each one of these intersections to the lights in the scene (this ray is called a shadow ray). And this is the least we need to produce an image (we could ignore shadows, but shadows are a very important visual clue that helps us figure out where objects are in space, particularly in relation to each other. It also helps to recognize objects&rsquo; shapes, etc.). If we want to simulate indirect lighting, many more rays need to be cast into the scene to &ldquo;gather&rdquo; information about the amount of light that bounces off the surface of other objects in the scene. Simulating indirect lighting in addition to direct lighting requires not twice as many rays (if you compare that number with the number of rays used to simulate direct lighting), but <a href="http://en.wikipedia.org/wiki/Order_of_magnitude" target="_blank">orders of magnitude</a> more (to get a visually and accurate good result). And since the ray-object intersect test is expensive, as mentioned before, the more rays, the slower the render. To make things worse, note that when we compute indirect lighting we cast new rays from a point P in the scene to gather information about the amount of light reflected by other surfaces towards P. What&rsquo;s interesting is that this actually requires that we compute the amount of light arriving at these other surfaces as well, which means that for each one of the surfaces we need to compute the amount of light reflected towards P, and we also need to compute direct and indirect lighting, which means spawning even more rays. As you may have noticed, this effect is recursive. This is again why indirect lighting is a potentially very expensive effect to simulate. It is not making your render twice as long but many times longer.</p>
<p>Why is it difficult? It&rsquo;s pretty straightforward if you use ray tracing (but eventually expensive). Ray tracing as we will explain in the next paragraph is a pretty natural way of thinking and simulating the way light flows in the natural world. It&rsquo;s easy from a simulation point of view because it offers a simple way to &ldquo;gather&rdquo; information about light reflected off of surfaces in the scene. If your system supports the ability to compute the intersection of rays with geometry, then you can use it to either solve the visibility problem or simulate direct and indirect lighting. However, if you use rasterization, how do you gather that information? It&rsquo;s a common misbelief to think that you need ray-tracing to simulate indirect lighting, but this is not true. Many alternatives to ray tracing for simulating indirect lighting exist (point cloud-based, photon maps, virtual point lights, shadow maps, etc. <strong>Radiosity</strong> is another method to compute global illumination. It&rsquo;s not very much used anymore these days but was very popular in the 80s early 90s); these methods also have their advantages and can be in some situations, a good (if not better) alternative to ray tracing. However again, the &ldquo;easy&rdquo; way is to use ray tracing if your system supports it.</p>
<p>As mentioned before, ray tracing can be slow compared to some other methods when it comes to simulating indirect lighting effects. Furthermore, while ray tracing is appealing in many ways, it also has its own set of issues (besides being computationally expensive). Noise for example is one of them. Interestingly, some of the alternative methods to ray tracing we talked about simulate indirect lighting and produce noise-free images (often at the expense of being biased though - we will explain what that term means in the lesson on Monte Carlo ray tracing but in short, it means that mathematically we know that the solution computed by these algorithms doesn&rsquo;t converge to the true solution (as it should), which is not the case with Monte Carlo ray tracing.</p>
<p>Furthermore, we will show in the next chapter devoted to light transport that some lighting effects are very difficult to simulate because, while it&rsquo;s more efficient in rendering to simulate the path of light from the eye back to light sources, in some specific cases, it happens that this approach is not efficient at all. We will show what these cases are in the next chapter, but within the context of the problem at hand here, it means that naive &ldquo;backward&rdquo; ray tracing is just not the solution to everything: while being efficient at simulating direct lighting and indirect diffuse effects, it is not a very efficient way of simulating other specific lighting effects such as indirect specular reflections (we will show why in the next chapter). In other words, unless you decide that brute force is okay (you generally do until you realize it&rsquo;s not practical to work with), you will quickly realize that &ldquo;naive&rdquo; backward ray tracing is clearly not the solution to everything, and potentially look for alternative methods. Photon maps are a good example of a technique designed to efficiently simulate caustics (a mirror reflecting light onto a diffuse surface for example — which is a form of indirect specular reflection) which are very hard or computationally expensive to simulate with ray tracing.</p>
<h3 id="why-is-ray-tracing-better-than-rasterization-is-it-better">Why is ray-tracing better than rasterization? Is it better?</h3>
<p>We already provided some information about this question in the previous paragraph. Again, ray-tracing is a more natural way of simulating how light flows in the real world so in a way, yes it&rsquo;s simply the most natural, and straightforward approach to simulating lighting, especially compared to other methods such as rasterization. And rather than dealing with several methods to solve the visibility problem and lighting, ray tracing can be used for both, which is another great advantage. All you need to do in a way is come up with the most possible efficient way of computing the intersection of rays with geometry, and keep re-using that code to compute whatever you need, whether visibility or lighting. Simple, easy. if you use rasterization for the visibility, you will need another method to compute global illumination. So while it&rsquo;s not impossible to compute GI (global illumination) if you don&rsquo;t use ray tracing, not doing so though requires a mismatch of techniques which is clearly less elegant (and primarily why people prefer to use ray tracing only).</p>
<p>Now, as suggested, ray tracing is not a miraculous solution though. It comes with its own set of issues. A naive implementation of ray tracing is simple. One that is efficient, requires a lot of hard work. Ray tracing is still computationally expensive and even if computers today are far more powerful than ten years ago, the complexity of the scene we render has also dramatically increased, and render times are still typically very long (see the note below).</p>
<blockquote>
<details>
This is called Blinn's Law or the paradox of increasing performance. "What is Blinn's Law? Most of you are familiar with Moore's law which states that the number of transistors on a chip will double approximately every two years. This means that anyone using a computer will have access to increased performance at a predictable rate. For computer graphics, potential benefits relative to increasing computational power are accounted for with this concept. The basic idea behind Blinn's law is that if an animation studio invests ten hours of computation time per frame of animation today, they will invest ten hours per frame ten years from now, regardless of any advances in processing power." ([courtesy of www.boxtech.com](http://boxxblogs.blogspot.co.uk)).
<p><a href="#R-image-4ad52e9c3ff9ead0f5c2ab797df8d006" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/blinnlaw.jpg" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-4ad52e9c3ff9ead0f5c2ab797df8d006"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/blinnlaw.jpg" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
</details>
</blockquote>
<p>So you still need to aggressively optimize your code, to make it practical to work with (especially if you use it in a production environment). But if you put the technical problems aside for a moment, the main drawback of ray tracing is the noise (the technical term is variance) it introduces in the image and the difficulty of simulating some lighting effects such as caustics when you use backward ray tracing (tracing the rays back from the eye to the source). One way of solving both issues is brute force: simply use more rays to improve the quality of the simulation, however, the more rays you use the more expensive the image. Thus again, a lot of research in rendering went (and still goes) into finding solutions to these two particular problems. Light transport algorithms as we will explain in the next chapter, are algorithms exploring the different ways in which light transport can be simulated. And as we will see, ray tracing can also be combined with some other techniques to make it more efficient to simulate some lighting effects which are very hard (as in very expensive) to simulate with ray tracing alone.</p>
<p>To conclude, there&rsquo;s very little doubt though, that, all rendering solutions will ultimately migrate to ray-tracing at some point or another, including real-time technology and video games. It is just a matter of time. The most recent generation of GPUs supports hardware accelerated ray-tracing already (e.g. RTX) with real-time or near real-time (interactive) framerate. The framerate still depends on scene complexity (number of triangles/quads, number of lights, etc.)</p>
<h2 id="light-transport-1">Light Transport</h2>
<blockquote>
<p>It&rsquo;s neither simple nor complicated, but it is often misunderstood.</p>
</blockquote>
<h3 id="light-transport-2">Light Transport</h3>
<p>In a typical scene, light is likely to bounce off of the surface of many objects before it reaches the eye. As explained in the <a href="../../../lessons/3d-basic-rendering/rendering-3d-scene-overview/light-simulator">previous chapter</a>, the direction in which light is reflected depends on the material type (is it diffuse, specular, etc.), thus light paths are defined by all the successive materials the light rays interact with on their way to the eye.</p>
<p><a href="#R-image-2bbcc80f346ce80966d7aa5f630390d9" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/lightpath.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-2bbcc80f346ce80966d7aa5f630390d9"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/lightpath.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 1:</strong> <em>light paths.</em></p>
<p>Imagine a light ray emitted from a light source, reflected off of a diffuse surface, then a mirror surface, then a diffuse surface again and then reaching the eye. If we label, the light L, the diffuse surface D, the specular surface S (a mirror reflection can be seen as an ideal specular reflection, one in which the roughness of the surface is 0) and the eye E, the light path in this particular example is LDSDE. Of course, you can imagine all sorts of possible combinations; this path can even be an &ldquo;infinitely&rdquo; long string of Ds and Ss. The one thing that all these rays will have in common, is an L at the start and an E at the end. The shortest possible light path is LE (you look directly at something that emits light). If light rays bounce off the surface only once, which using the light path notation could be expressed as either LSE or LDE, then we have a case of direct lighting (direct specular or direct diffuse). Direct specular is what you have when the sun is reflected off of a water surface for instance. If you look at the reflection of a mountain in the lake, you are more likely to have an LDSE path (assuming the mountain is a diffuse surface), etc. In this case, we speak of indirect lighting.</p>
<p>Researcher Paul Heckbert introduced the concept of labeling paths that way in a paper published in 1990 and entitled &ldquo;Adaptive Radiosity Textures for Bidirectional Ray Tracing&rdquo;. It is not uncommon to use regular expressions to describe light paths compactly. For example, any combination of reflection off the surface of a diffuse or specular surface can be written as: L(D|S)<em>E. In <a href="http://en.wikipedia.org/wiki/Regular_expression" target="_blank">Regex</a> (the abbreviation for regular expression), (a|b)</em> denotes the set of all strings with no symbols other than &ldquo;a&rdquo; and &ldquo;b&rdquo;, including the empty string: {&quot;&quot;, &ldquo;a&rdquo;, &ldquo;b&rdquo;, &ldquo;aa&rdquo;, &ldquo;ab&rdquo;, &ldquo;ba&rdquo;, &ldquo;bb&rdquo;, &ldquo;aaa&rdquo;, &hellip;}.</p>
<p><a href="#R-image-fba8cfc9ae1b9d50504e50a28f44fb1f" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/shadow2.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-fba8cfc9ae1b9d50504e50a28f44fb1f"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/shadow2.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 2:</strong> <em>to compute direct lighting, we just need to cast a shadow ray from P to the light source. If the ray is blocked by an object on its way to the light, then P is in shadow.</em></p>
<p><a href="#R-image-b456cf455416900f52d3719dd2324b90" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/indirect-lighting.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b456cf455416900f52d3719dd2324b90"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/indirect-lighting.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 3:</strong> <em>to compute indirect lighting, we need to spawn secondary rays from P and check if these rays intersect other surfaces in the scene. If they do, we need to compute both indirect and direct lighting at these intersection points and return the amount of computed light to P. Note that this is a recursive process: each time a secondary ray hits a surface we need to compute both direct lighting and indirect lighting at the intersection point on this surface, which means spawning more secondary rays, etc.</em></p>
<p>At this point, you may think, &ldquo;this is all good, but how does that relate to rendering?&rdquo;. As mentioned several times already in this lesson and the previous one, in the real world, light goes from light sources to the eye. But only a fraction of the rays emitted by light sources reaches the eye. Therefore, rather than simulating light path from the source to the eye, a more efficient approach is to start from the eye, and walk back to the source.</p>
<p>This is what we typically do in ray tracing. We trace a ray from the eye (we generally call the <strong>eye ray</strong>, <strong>primary ray</strong>, or <strong>camera ray</strong>) and check whether this ray intersects any geometry in the scene. If it does (let&rsquo;s call P, the point where the ray intersects the surface), we then need to do two things: compute how much light arrives at P from the light sources (direct lighting), and how much light arrives at P indirectly, as a result of light being reflected by other surfaces in the scene (indirect lighting).</p>
<ul>
<li>To compute the direct contribution of light to the illumination of P, we trace a ray from P to the source. If this ray intersects another object on its way to the light, then P is in the shadow of this light (which is why we sometimes call these rays <strong>shadow rays</strong>). This is illustrated in figure 2.</li>
<li>Indirect lighting comes from other objects in the scene reflecting light towards P, whether as a result of these objects reflecting light from a light source or as a result of these objects reflecting light which is itself bouncing off of the surface of other objects in the scene. In ray tracing, indirect illumination is computed by spawning new rays, called <strong>secondary rays</strong> from P into the scene (figure 3). Let&rsquo;s explain in more detail how and why this works.</li>
</ul>
<p>If these secondary rays intersect other objects or surfaces in the scene, then it is reasonable to assume, that light travels along these rays from the surfaces they intersect to P. We know that the amount of light reflected by a surface depends on the amount of light arriving on the surface as well as the viewing direction. Thus to know how much light is reflected towards P along any of these secondary rays, we need to:</p>
<ul>
<li>Compute the amount of light arriving at the point of intersection between the secondary ray and the surface.</li>
<li>Measure how much of that light is reflected by that surface to P, using the secondary ray direction as our viewing direction.</li>
</ul>
<blockquote>
<details>
Remember that specular reflection is view-dependent: how much light is reflected by a specular surface depends on the direction from which you are looking at the reflection. Diffuse reflection though is view-independent: the amount of light reflected by a diffuse surface doesn't change with direction. Thus unless diffuse, a surface doesn't reflect light equally in all directions.
</details>
</blockquote>
<p>Computing how much light arrives at a point of intersection between a secondary ray and a surface, is no different than computing how much light arrives at P. Computing how much light is reflected in the ray direction towards P, depends on the surface properties, and is generally done in what we call a <strong>shader</strong>. We will talk about shaders in the next chapter.</p>
<blockquote>
<details>
Other surfaces in the scene potentially reflect light to P. We don't know which one and light can come from all possible directions above the surface at P (light can also come from underneath the surface if the object is transparent or translucent -- but we will ignore this case for now). However, because we can't test every single possible direction (it would take too long) we will only test a few directions instead. The principle is the same as when you want to measure for instance the average height of the adult population of a given country. There might be too many people in this population to compute that number exactly, however, you can take a sample of that population, let's say maybe a few hundreds or thousands of individuals, measure their height, make an average (sum up all the numbers and divide by the size of your sample), and get that way, an approximation of the actual average adult height of the entire population. It's only an approximation, but hopefully, it should be close enough to the real number (the bigger the sample, the closer the approximation to the exact solution). We do the same thing in rendering. We only sample a few directions and assume that their average result, is a good approximation of the actual solution. If you heard about the term **Monte Carlo** before and particularly **Monte Carlo ray tracing**, that's what this technique is all about. Shooting a few rays to approximate the exact amount of light arriving at a point. The downside is that the result is only an approximation. The bright side is that we get a result for a problem that is otherwise not tractable (e.i. it is impossible to compute exactly within any amount of reasonable finite time).
</details>
</blockquote>
<p>Computing indirect illumination is a <strong>recursive</strong> process. Secondary rays are generated from P, which in turn generate new intersection points, from which other secondary rays are generated, and so on. We can count the number of times light is reflected from surfaces from the light source until it reaches P. If light bounces off the surface of objects only once before it gets to P we have&hellip; one bounce of indirect illumination. Two bounces, light bounces off twice, three bounces, three times, etc.</p>
<p><a href="#R-image-d03390289e3630b50235ed0929063905" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/indirect-bounce.gif" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d03390289e3630b50235ed0929063905"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/indirect-bounce.gif" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 4:</strong> <em>computing indirect lighting is a recursive process. Each time a secondary ray hits a surface, new rays are spawned to compute indirect lighting at the intersection point.</em></p>
<p>The number of times light bounces off the surface of objects can be infinite (imagine a situation for example in which a camera is inside a box illuminated by a light on the ceiling? rays would keep bouncing off the walls forever). To avoid this situation, we generally stop spawning secondary rays after a certain number of bounces (typically 1, 2, or 3). Note though that as a result of setting a limit to the number of bounces, P is likely to look darker than it actually should (since any fraction of the total amount of light emitted by a light source that took more bounces than the limit to arrive at P, will be ignored). If we set the limit to two bounces for instance, then we ignore the contribution of all the other bounces above (third, fourth, etc.). However luckily enough, each time light bounces off of the surface of an object, it loses a little bit of its energy. This means that as the number of bounces increases, the contribution of these bounces to the indirect illumination of a point decreases. Thus, there is a point after which you might consider that computing one more bounce makes such a little difference to the image, that it doesn&rsquo;t justify the amount of time it takes to simulate it.</p>
<blockquote>
<details>
If we decide, for example, to spawn 32 rays each time we intersect a surface to compute the amount of indirect lighting (and assuming each one of these rays intersects a surface in the scene), then on our first bounce we have 32 secondary rays. Each one of these secondary rays generates another 32 secondary rays. Which makes already a total of 1024 rays. After three bounces we generated a total of 32768 rays! If ray tracing is used to compute indirect lighting, it generally becomes quickly very expensive because the number of rays grows exponentially as the number of bounces increases. This is often referred to as the curse of ray tracing.
</details>
</blockquote>
<p><a href="#R-image-ccde4bb1dd55e5b69808a99247c73565" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/shadow.gif" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-ccde4bb1dd55e5b69808a99247c73565"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/shadow.gif" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Figure 5: when we compute direct lighting, we need to cast a shadow ray from the point where the primary ray intersected geometry to each light source in the scene. If this shadow ray intersects another object &ldquo;on its way to the light source&rdquo;, then this point is in shadow.</p>
<p>This long explanation is to show you, that the principle of actually computing the amount of light impinging upon P whether directly or indirectly is simple, especially if we use the ray-tracing approach. The only sacrifice to physical accuracy we made so far, is to put a cap on the maximum number of bounces we compute, which is necessary to ensure that the simulation will not run forever. In computer graphics, this algorithm is known as <strong>unidirectional path tracing</strong> (it belongs to a larger category of light transport algorithms known as path tracing). This is the simplest and most basic of all <strong>light transport models</strong> based on ray tracing (it also goes by the name of classic ray tracing or Whitted style ray tracing). It&rsquo;s called unidirectional, because it only goes in one direction, from the eye to the light source. The part &ldquo;path tracing&rdquo; is pretty straightforward: it&rsquo;s all about tracing light paths through the scene.</p>
<blockquote>
<p>Classic ray tracing generates a picture by tracing rays from the eye into the scene, recursively exploring specularly reflected and transmitted directions, and tracing rays toward point light sources to simulate shadows. (Paul S. Heckbert - 1990 in &ldquo;Adaptive Radiosity Textures for Bidirectional Ray Tracing&rdquo;)</p>
</blockquote>
<p>This method was originally proposed by <strong>Appel</strong> in 1986 (&ldquo;Some Techniques for Shading Machine Rendering of Solids&rdquo;) and later developed by <strong>Whitted</strong> (An improved illumination model for shaded display - 1979).</p>
<blockquote>
<details>
When the algorithm was first developed, Appel and Whitted only considered the case of mirror surfaces and transparent objects. This is only because computing secondary rays (indirect lighting) for these materials require fewer rays than for diffuse surfaces. To compute the indirect reflection of a mirror surface, you only need to cast one single reflection ray into the scene. If the object is transparent, you need to cast one ray for the reflection and one ray for the refraction. However, when the surface is diffuse, to approximate the amount of indirect lighting at P, you need to cast many more rays (typically 16, 32, 64, 128 up to 1024 - this number though doesn't have a power of 2 but it usually is for reasons will explain in due time) distributed over the hemisphere oriented about the normal at the point of incidence. This is far more costly than just computing reflection and refraction (either one or two rays per shaded point), so their first developed their concept by using specular and transparent surfaces to start with as computers back then were very slow compared to today's standards; but extending their algorithm to indirect diffuse was, of course, straightforward.
</details>
</blockquote>
<p>Other techniques than ray tracing can be used to compute global illumination. Note though that ray tracing seems to be the most adequate way of simulating the way light spreads out in the real world. But things are not that simple. With unidirectional path tracing, for example, some light paths are more complicated to compute efficiently than others. This is particularly true of light paths involving specular surfaces illuminating diffuse surfaces (or any type of surfaces for that matter) indirectly. Let&rsquo;s take an example.</p>
<p><a href="#R-image-c86c7f0999dac3ac4068f20d3b4c7217" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/caustics2.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c86c7f0999dac3ac4068f20d3b4c7217"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/caustics2.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 6:</strong> <em>all light rays at point P come from the glass ball, but when secondary rays are spawned from P to compute indirect lighting, only a fraction of these rays will hit the ball. We fail to account for the fact that all light illuminating P is transmitted by the ball; the computation of the amount of indirect lighting arriving at P using backward tracing in this particular case, is likely to be quite inaccurate.</em></p>
<p>As you can see in the image above, in this particular situation, light emitted by the source at the top of the image, is refracted through a (transparent) glass ball which by the effect of refraction, concentrates all light rays towards a singular point on the plane underneath. This is what we call a caustic. Note that, no direct light arrives at P from the light source directly (P is in the &lsquo;shadow&rsquo; of the sphere). It all comes indirectly through the sphere by the mean of refraction and transmission. While it may seem more natural in this particular situation to trace light from the light source to the eye, considering that we decided to trace light rays the other way around, let&rsquo;s see what we get.</p>
<p>When it will come to computing how much light arrives at P indirectly if we assume that the surface at P is diffuse, then we will spawn a bunch of rays in random directions to check which surfaces in the scene redirect light towards P. But by doing so, we will fail to account for the fact that all light comes from the bottom surface of the sphere. So obviously we could maybe solve this problem by spawning all rays from P toward the sphere, but since our approach assumes we have no prior knowledge of how light travels from the light source to every single point in the scene, that&rsquo;s not something we can do (we have no prior knowledge that a light source is above the sphere and no reason to assume that this light is the light that contributes to the illumination of P via transmission and refraction). All we can do is spawn rays in random directions as we do with all other surfaces, which is how unidirectional path tracing works. One of these rays might actually hit the sphere and get traced back to the light source (but we don&rsquo;t even have a guarantee that even a single ray will hit the sphere since their directions are chosen randomly), however, this might only be one ray over maybe 10 or 20 or 100 we cast into the scene, thus we might miserably fail in this particular case to compute how much light arrives at P indirectly.</p>
<blockquote>
<details>
Isn't 1 ray over 10 or 20 enough? Yes and no. It's hard to explain the technique used here to "approximate" the indirect lighting component of the illumination of P but in short, it's based on probabilities and is very similar in a way to measuring an "approximation" of a given variable using a poll. For example, when you want to measure the average height of the adult population of a given country, you can't measure the height of every person making up that population. Instead, you just take a sample, a subset of that population, measure the average height of that sample and assume that this number is close enough to the actual average height of the entire population. While the theory behind this technique is not that simple (you need to prove that this approach is mathematically correct and not purely empirical), the concept is pretty simple to understand. We do the same thing here to approximate the indirect lighting component. We chose random directions, measure the amount of light coming from these directions, average the result, and assume the resulting number is an "approximation" of the actual amount of indirect light received by P. This technique is called Monte Carlo integration. It's a very important method in rendering and you will find it explained in great detail in a couple of lessons from the "Mathematics and Physics of Computer Graphics" section. If you want to understand why 1 ray over 20 secondary rays is not ideal in this particular case, you will need to read these lessons.
</details>
</blockquote>
<p>Using Heckbert light path&rsquo;s naming convention, we can say that paths of the kind LS+DE are generally hard to simulate in computer graphics using the basic approach of tracing back the path of light rays from the eye to the source (or unidirectional path tracing). In Regex, the + sign account for any sequences that match the element preceding the sign one or more times. For example, ab+c matches &ldquo;abc&rdquo;, &ldquo;abbc&rdquo;, &ldquo;abbbc&rdquo;, and so on, but not &ldquo;ac&rdquo;. What this means in our case, is that situations in which light is reflected off of the surface of one or more specular surfaces before it reaches a diffuse surface and then the eye (as in the example of the glass sphere), are hard to simulate using unidirectional path tracing.</p>
<p>What do we do then? This is where the art of light transport comes into play.</p>
<p>While being simple and thus very appealing for this reason, a naive implementation of tracing light paths to the eye is not efficient in some cases. It seems to work well when the scene is only made of diffuse surfaces but is problematic when the scene contains a mix of diffuse and specular surfaces (which is more often the case than not). So what do we do? Well, we do the same thing as we usually do when we have a problem. We search for a solution. And in this particular case, this leads to looking for developing strategies (or algorithms) that would work well to simulate all sorts of possible combinations of materials. We want a strategy in which LS+DE paths can be simulated as efficiently as LD+E paths. And since our default strategy doesn&rsquo;t work well in this case, we need to come up with new ones. This led obviously to the development of new <strong>light transport algorithms</strong> that are better than unidirectional path tracing to solve this light transport problem. More formally light transport algorithms are strategies (implemented in the form of algorithms) that attempt to propose a solution to the problem we just presented: solving efficiently any combination of any possible light path, or more generally light transport.</p>
<p>Light transport algorithms are not that many, but still, quite a few exist. And don&rsquo;t be misled. Nothing in the rules of coming up with the greatest light transport algorithm of all times, tells you that you have to use ray tracing to solve the problem. You have the choice of weapon. Many solutions use what we call a hybrid or multi-passes approach. <strong>Photon mapping</strong> is an example of such an algorithm. They require the pre-computation of some lighting information stored in specific data structures (a photon map or a point cloud generally for example), before actually rendering the final image. Difficult light paths are resolved more efficiently by taking advantage of the information stored in these structures. Remember that we said in the glass sphere example that we had no prior knowledge of the existence of the light above the sphere? Well, photon maps are a way of looking at the scene before it gets rendered and trying to get some prior knowledge about where light &ldquo;photons&rdquo; go before rendering the final image. It is based on that idea.</p>
<p>While being quite popular some years ago, these algorithms though are based on a multi-pass approach. In other words, you need to generate some extra data before you can render your final image. This is great if it helps to render images you couldn&rsquo;t render otherwise, but multi-passes rendering is a pain to manage, requires a lot of extra work, requires generally to store extra data on disk, and the process of actually rendering the image doesn&rsquo;t start before all the pre-computation steps are complete (thus you need to wait for a while before you can see something). As we said, for a long time they were popular because they made it possible to render things such as caustics which would have been too long to render with pure ray tracing, and that therefore, we generally ignored altogether. Thus having a technique to simulate them (no matter how painful it is to set up) is better than nothing. However, of course, a unified approach is better: one in which the multi-pass is not required and one which integrates smoothly with your existing framework. For example, if you use ray tracing (as your framework), wouldn&rsquo;t it be great to come up with an algorithm that only uses ray tracing, and never have to pre-compute anything? Well, it does exist.</p>
<p>Several algorithms have been developed around ray tracing and ray tracing only. Extending the concept of unidirectional path tracing, which we talked about above, we can use another algorithm known as bi-directional path tracing. It is based on the relatively simple idea, that for every ray you spawn from the eye into the scene, you can also spawn a ray from a light source into the scene, and then try to connect their respective paths through various strategies. An entire section of Scratchapixel is devoted to light transport and we will review in this section, some of the most important light transport algorithms, such as unidirectional path tracing, bi-directional path tracing, Metropolis light transport, instant radiosity, photon mapping, radiosity caching, etc.</p>
<h3 id="summary-3">Summary</h3>
<p>Probably one of the most common myths in computer graphics is that ray tracing is both the ultimate and only way to solve global illumination. While it may be the ultimate way in the sense that it offers a much more natural way of thinking about the way light travels in the real world, it also has its limitations, as we showed in this introduction, and it is certainly not the only way. You can broadly distinguish between two sorts of light transport algorithms:</p>
<ul>
<li>Those who are not using ray tracing such as photon or shadow mapping, radiosity, etc.</li>
<li>Those who are using ray tracing and ray tracing only.</li>
</ul>
<p>As long as the algorithm efficiently captures light paths that are difficult to capture with the traditional unidirectional path tracing algorithm, it can be viewed as one of the contendors to solve our LS+DE problem.</p>
<p>Modern implementations do tend to favor the light transport method solely based on ray tracing, simply because ray tracing is a more natural way to think about light propagation in a scene, and offers a unified approach to computing global illumination (one in which using auxiliary structures or systems to store light information is not necessary). Note though that while such algorithms do tend to be the norm these days in off-line rendering, real-time rendering systems are still very much based on the former approach (they are generally not designed to use ray tracing, and still rely on things such as shadow maps or light fields to compute direct and indirect illumination).</p>
<h2 id="shading-1">Shading</h2>
<p>While everything in the real world is the result of light interacting with matter, some of these interactions are too complex to simulate using the light transport approach. This is when shading kicks in.</p>
<p><a href="#R-image-f128230e088ef2696a248e3bc080efee" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/color-brightness.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f128230e088ef2696a248e3bc080efee"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/color-brightness.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 1:</strong> <em>if you look at two objects under the same lighting conditions if these objects seem to have the same color (same hue), but that one is darker than the other, then clearly, how bright they are is not the result of how much light falls on these objects, but more the result of how much light each one of these objects reflects into their environment.</em></p>
<p>As mentioned in the previous chapter, simulating the appearance of an object requires that we can compute the color and the brightness of each point on the surface of that object. Color and brightness are tightly linked with each other. You need to distinguish between the brightness of an object which is due to how much light falls on its surface, and the brightness of an object&rsquo;s color (also sometimes called the color&rsquo;s luminance). The brightness of color as well as its hue and saturation is a color property. If you look at two objects under the same lighting conditions, if these objects seem to have the same color (same <a href="http://en.wikipedia.org/wiki/Chromaticity" target="_blank">chromaticity</a>), but that one is darker than the other, then clearly, how bright they are is not the result of how much light falls on these objects, but more the result of how much light each one of these objects reflects into their environment. In other words, these two objects have the same color (the same chromaticity) but one reflects more light than the other (or to put it differently one absorbs more light than the other). The brightness (or luminance) of their color is different. In computer graphics, the characteristic color of an object is called <strong><a href="http://en.wikipedia.org/wiki/Albedo" target="_blank">albedo</a></strong>. The albedo of objects can be measured precisely.</p>
<blockquote>
<details>
Note that an object **can not** reflect more light than it receives (unless it emits light, which is the case of light sources). The color of an object can generally be computed (at least for diffuse surfaces) as the ratio of reflected light over the amount of incoming (white) light. Because an object can not reflect more light than it receives, this ratio is always lower than 1. This is why the colors of objects are always defined in the RGB system between 0 and 1 if you use float or 0 and 255 if you a byte to encode colors. Check the lesson on [Colors](/lessons/digital-imaging/colors/) to learn more about this topic. It's better to define this ratio as a percentage. For instance, if the ratio, the color, or the albedo (these different terms are interchangeable) is 0.18, then the object reflects 18% of the light it receives back in the environment.
</details>
</blockquote>
<p>If we defined the color of an object as the ratio of the amount of reflected light over the amount of light incident on the surface (as explained in the note above), that color can&rsquo;t be greater than one. This doesn&rsquo;t mean though that the amount of light incident and reflected off of the surface of an object can&rsquo;t be greater than one (it&rsquo;s only the ratio between the two that can&rsquo;t be greater than one). What we see with our eyes, is the amount of light incident on a surface, multiplied by the object&rsquo;s color. For example, if the energy of the light impinging upon the surface is 1000, and the color of the object is 0.5, then the amount of light reflected by the surface to the eye is 500 (this is wrong from the point of view of physics, but this is just for you to get the idea - in the lesson on shading and light transport, we will look into what this 1000 or 500 values mean in terms of physical units, and learn that it&rsquo;s more complicated than just multiplying the number of photons by 0.5 or whatever the albedo of the object is).</p>
<p>Thus assuming we know what the color of an object is, to compute the actual brightness of a point P on the surface of that object under some given lighting conditions (brightness as in the actual amount of light energy reflected by the surface to the eye and not as in the actual brightness or luminance of the object&rsquo;s albedo), we need to account for two things:</p>
<ul>
<li>How much light falls on the object at this point?</li>
<li>How much light is reflected at this point in the viewing direction?</li>
</ul>
<p>Remember again that for specular surfaces, the amount of light reflected by that surface depends on the angle of view. If you move around a mirror, the image you see in the mirror changes: the amount of light reflected towards you changes with the viewpoint.</p>
<p><a href="#R-image-e4ce691d2c24fbd6b49e985bd4aa9a57" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/shading1.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-e4ce691d2c24fbd6b49e985bd4aa9a57"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/shading1.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 2:</strong> <em>to compute the actual brightness of a point P on the surface of that object under some given lighting conditions, we need to account for two things, how much light falls on the object at this point and how much light is reflected at this point in the viewing direction. To compute how much light arrives upon P, we need to sum up the contribution of the light sources (direct lighting) and from other surfaces (indirect lighting).</em></p>
<p>Assuming we know what the color of the object is (its albedo), we then need to find how much light arrives at the point (let&rsquo;s call it P again), and how much is reflected in the viewing direction, the direction from P to the eye.</p>
<ul>
<li>The former problem requires &ldquo;collecting&rdquo; or <strong>gathering</strong> light above the surface at P, and is more of a light transport problem. We already explained in the previous chapter how this can be done. Rays can be traced directly to lights to compute direct lighting and secondary rays can be spawned from P to compute indirect lighting (the contribution of other surfaces to the illumination of P). However, while it seems essentially like a light transport problem, we will see in the lessons on Shading and Light Transport that the direction of these rays is defined by the surface type (is it diffuse or specular), and that shaders play a role in choosing the direction of these rays. Note also that, other methods than ray tracing can be used to compute both direct and indirect lighting.</li>
<li>The latter problem (how much light is reflected in a given direction) is far more complex and it will now be explained in more detail.</li>
</ul>
<p>First, you need to remember that light reflected in the environment by a surface, is the result of very complex interactions between light rays (or photons if you know what they are) with the material the object is made of. There are three important things to note at this point:</p>
<ul>
<li>These interactions are generally so complex that it is not practical to simulate them.</li>
<li>The amount of light reflected depends on the view direction. Surfaces generally don&rsquo;t reflect incident light equally in all directions. That&rsquo;s not true of perfectly diffuse surfaces (diffuse surfaces appear equally bright from all viewing directions,) but this is true of all specular surfaces and since most objects in the real world have a mix of diffuse and specular reflections anyway, more often than not, light is generally not reflected equally.</li>
<li>The amount of light redirected in the viewing direction, also depends on the incoming light direction. To compute how much light is reflected in the direction (\omega_v) (&ldquo;v&rdquo; here is used here for the view and (\omega) is the Greek letter omega), we also need to take into account the incoming lighting direction (\omega_i) (&ldquo;i&rdquo; stands for incident or incoming). The idea is illustrated in figure 3. Let&rsquo;s see what happens when the surface from which a ray is reflected, is a mirror. According to the law of reflection, the angle between the incident direction (\omega_i) of a light ray and the normal at the point of incidence, and the direction between the reflected or mirror direction (\omega_r) and the normal are the same. When the viewing direction (\omega_v) and the reflected direction (\omega_r) are the same (figure 3 - top), then we see the reflected ray (it enters the eye). However when (\omega_v) and (\omega_r) are different (figure 3 - bottom), then because the reflected ray doesn&rsquo;t travel towards the eye, the eye doesn&rsquo;t see it. Thus, how much light is reflected towards the eye depends on the incident light direction (\omega_i) (as explained before) as well as the viewing direction (\omega_v).</li>
</ul>
<p><a href="#R-image-74e9b83de50bdcebe64ff97132866f31" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/reflection2.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-74e9b83de50bdcebe64ff97132866f31"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/reflection2.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 3:</strong> <em>for mirror surfaces, if the reflected ray and the view direction are not the same, the reflected ray of light is not visible. The amount of light reflected is a function of the incoming light direction and the viewing direction.</em></p>
<blockquote>
<p><strong>Let&rsquo;s summarise</strong>. What do we know?</p>
<ul>
<li>It&rsquo;s too complex to simulate light-matter interactions (interactions happening at the microscopic and atomic levels). Thus, we need to come up with a different solution.</li>
<li>The amount of light reflected from a point varies with the view direction (\omega_v).</li>
<li>The amount of light reflected from a point for a given view direction (\omega_v), depends on the incoming light direction (\omega_i).</li>
</ul>
</blockquote>
<p><strong>Shading, which you can see as the part of the rendering process that is responsible for computing the amount of light reflected from surfaces to the eye (or other surfaces in the scene)</strong>, depends on at least two variables: where light comes from (the incident light direction (\omega_i)) and where it goes to (the outgoing or viewing direction, (\omega_v)). Where light comes from is independent of the surface itself, but how much light is reflected in a given direction, depends on the surface type: is it diffuse, or specular? As suggested before, gathering light arriving at the incident point is more of a light transport problem. But regardless of the technique used to gather the amount of light arriving at P, what we need, is to know where this light comes from, as in from which direction. The job of putting all these things together is done by what we call a <strong>shader</strong>. A shader can be seen as a program within your program, which is a kind of routine that takes an incident light direction and a view direction as input variables and returns the fraction of light the surface would reflect for these directions.</p>

<span class="math align-center">$$
\text{ ratio of reflected light = shader }(\omega_i, \omega_o)
$$</span><p>Simulating light-matter interactions to get a result is complex, but hopefully, the result of these numerous interactions is predictable and consistent, thus it can be approximated or modeled with mathematical functions. Where are these functions coming from? What are they? How are they found? We will answer these questions in the lessons devoted to shading. Let&rsquo;s only try to get an intuition of how and why this works for now.</p>
<p>The law of reflection for example which we introduced in a previous chapter, can be written as:</p>

<span class="math align-center">$$
\omega_r = \omega_i - 2(N \cdot \omega_i) N
$$</span><p>In plain English, it says that the reflection direction (\omega_r), can be computed as (\omega_i) minus two times the dot product between N (the surface normal at the point of incidence) and (\omega_i) (the incident light direction) multiplied by N. This equation has more to do with computing a direction than the amount of light reflected by the surface. However if for any given incident direction ((\omega_i)), you find out that (\omega_r) coincides with (\omega_v) (the view direction) then clearly, the ratio of reflected light for this particular configuration is 1 (figure 3 - top). If (\omega_r) and (\omega_v) are different though, then the amount of reflected light would be 0. To formalize this idea, you can write:</p>

<span class="math align-center">$$
\text {ratio of reflected light} = \begin{cases} 1 & \omega_r = \omega_o \\ 0 & \text{otherwise} \end{cases} 
$$</span><blockquote>
<details>
This is just an example. For perfectly mirror surfaces, we never proceed that way. The point here is to understand that if we can describe the behavior of light with equations, then we can find ways of computing how much light is reflected for any given set of incident and outgoing directions without having to run a complex and time-consuming simulation. This is really what shaders do: replacing complex light-matter interactions with a mathematical model, which is fast to compute. These models are not always very accurate nor physically plausible as we will soon see, but they are the most practical way of approximating the result of these interactions. Research in the field of shading is mostly about developing new mathematical models that match as closely as possible the way materials reflect light. As you may imagine this is a difficult task: it's challenging on its own, but more importantly, materials exhibit some very different behaviors thus it's generally impossible to simulate accurately all materials with one single model. Instead, it is often necessary to develop one model that works for example to simulate the appearance of cotton, one to simulate the appearance of silk, etc.
</details>
</blockquote>
<p>What about simulating the appearance of a diffuse surface? For diffuse surfaces, we know that light is reflected equally in all directions. The amount of light reflected towards the eye is thus the total amount of light arriving at the surface (at any given point) multiplied by the surface color (the <strong>fraction</strong> of the total amount of incident light the surface reflects in the environment), divided by some normalization factor that needs to be there for mathematical/physical accuracy reason, but this will be explained in details in the lessons devoted to shading. Note that for diffuse reflections, the incoming and outgoing light directions do not influence the amount of reflected light. But this is an exception in a way. For most materials, the amount of reflected light depends on (\omega_i) and (\omega_v).</p>
<p>The behavior of glossy surfaces is the most difficult to reproduce with equations. Many solutions have been proposed, the simplest (and easiest to implement in code) being the Phong specular model, which you may have heard about.</p>
<blockquote>
<details>
The Phong model computes the perfect mirror direction using the equation for the law of reflection which depends on the surface normal and the incident light direction. It then computes the deviation (or difference) raised to some exponent, between the actual view direction and the mirror direction (it takes the dot product between these two vectors) and assumes that the brightness of the surface at the point of incidence, is inversely proportional to this difference. The smaller the difference, the shinier the surface. The exponent parameter helps control the spread of the specular reflection (check the lessons from the Shading section to learn more about the Phong model).
</details>
</blockquote>
<p>However good models follow some well know properties that the Phong model doesn&rsquo;t have. One of these rules, for instance, is that the model <strong>conserves energy</strong>. The amount of light reflected in all directions shouldn&rsquo;t be greater than the total amount of incident light. If a model doesn&rsquo;t have this property (the Phong model doesn&rsquo;t have that property), then it would break the laws of physics, and while it might provide a visually pleasing result, it would not produce a physically plausible one.</p>
<blockquote>
<details>
Have you already heard the term **physically plausible rendering**? It designates a rendering system designed around the idea that all shaders and light transport models comply with the laws of physics. In the early age of computer graphics, speed and memory were more important than accuracy and a model was often considered to be good if it was fast and had a low memory footprint (at the expense of being accurate). But in our quest for photo-realism and because computers are now faster than they were when the first shading models were designed), we don't trade accuracy for speed anymore and use physically-based models wherever possible (even if they are slower than non-physically based models). The conservation of energy is one of the most important properties of a physically-based model. Existing physically based rendering engines can produce images of great realism.
</details>
</blockquote>
<p>Let&rsquo;s put these ideas together with some pseudo-code:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">Vec3f</span> <span class="nf">myShader</span><span class="p">(</span><span class="n">Vec3f</span> <span class="n">Wi</span><span class="p">,</span> <span class="n">Vec3f</span> <span class="n">Wo</span><span class="p">)</span> 
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="c1">// define the object&#39;s color, roughness, etc.
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1"></span>    <span class="p">...</span> 
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="c1">// do some mathematics to compute the ratio of light reflected
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="c1"></span>    <span class="c1">// by the surface for this pair of directions (incident and outgoing)
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1"></span>    <span class="p">...</span> 
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="k">return</span> <span class="n">ratio</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="p">}</span> 
</span></span><span class="line"><span class="ln">10</span><span class="cl"> 
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="n">Vec3f</span> <span class="nf">shadeP</span><span class="p">(</span><span class="n">Vec3f</span> <span class="n">ViewDirection</span><span class="p">,</span> <span class="n">Vec3f</span> <span class="n">Point</span><span class="p">,</span> <span class="n">Vec3f</span> <span class="n">SurfaceNormal</span><span class="p">)</span> 
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="n">Vec3f</span> <span class="n">totalAmountReflected</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">all</span> <span class="n">light</span> <span class="n">sources</span> <span class="n">above</span> <span class="n">P</span> <span class="p">[</span><span class="n">direct</span><span class="o">|</span><span class="n">indirect</span><span class="p">])</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln">15</span><span class="cl">        <span class="n">totalAmountReflected</span> <span class="o">+=</span> 
</span></span><span class="line"><span class="ln">16</span><span class="cl">            <span class="n">lightEnergy</span> <span class="o">*</span> 
</span></span><span class="line"><span class="ln">17</span><span class="cl">            <span class="n">shaderDiffuse</span><span class="p">(</span><span class="n">LightDirection</span><span class="p">,</span> <span class="n">ViewDirection</span><span class="p">)</span> <span class="o">*</span> 
</span></span><span class="line"><span class="ln">18</span><span class="cl">            <span class="n">dotProduct</span><span class="p">(</span><span class="n">SurfaceNormal</span><span class="p">,</span> <span class="n">LightDirection</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">19</span><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="ln">20</span><span class="cl"> 
</span></span><span class="line"><span class="ln">21</span><span class="cl">    <span class="k">return</span> <span class="n">totalAmountReflected</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">22</span><span class="cl"><span class="p">}</span> 
</span></span></code></pre></div><p>Notice how the code is separated into two main sections: a routine (line 11) to gather all light coming from all directions above P, and another routine (line 1), the shader, used to compute the fraction of light reflected by the surface for any given pair of incident and view direction. The loop (often called a light loop) is used, to sum up, the contribution of all possible light sources in the scene to the illumination of P. Each one of these light sources has a certain energy and of course, comes from a certain direction (the direction defined by the line between P and the light source position in space), thus all we need to do is send this information to the shader, with the view direction. The shader will return which fraction for that given light source direction is reflected towards the eye and then multiply the result of the shader with the amount of light produced by this light source. Summing up these results for all possible light sources in the scene gives the total amount of light reflected from P toward the eye (which is the result we are looking for).</p>
<p>Not that in the sum (line 18), there is a third term (a dot product between the normal and the light direction). This term is very important in shading and relates to what we call the <strong>cosine law</strong>. It will be explained in detail in the sections on Light Transport and Shading (you can also find information about it in the lesson on the Rendering Equation which you will find in this section). For now, you should just know that it is there to account for the way light energy is spread across the surface of an object, as the angle between the surface and the light source varies.</p>
<h3 id="conclusion">Conclusion</h3>
<p>There is a fine line between light transport and shading. As we will learn in the section on Light Transport, light transport algorithms will often rely on shaders, to find out in which direction they should spawn secondary rays to compute indirect lighting.</p>
<p>The two things you should remember from this chapter are, the definition of shading and what a shader is:</p>
<ul>
<li>
<p>Shading, is the part of the rendering process that is responsible for computing the amount of light reflected in any given viewing direction. In another word, it is where and when we give objects in the image their final appearance from a particular viewpoint, how they look, their color, their texture, their brightness, etc. <strong>Simulating the appearance of an object requires answering one question only: how much light does an object reflect (and in which directions), over the total amount it receives?</strong></p>
</li>
<li>
<p>Shaders are designed to answer this question. You can see a shader as some sort of black box to which you ask the question: &ldquo;if this object is made of wood, if this wood has this given color and this given roughness, if some quantity of light impinges upon this object from the direction (\omega_i), how much of that light would be reflected by this object back in the environment in the direction (\omega_v)?&rdquo;. The shader will answer this question. We like to describe it as a black box, not because what&rsquo;s happening inside that box is mysterious, but more because it can be seen as a separate entity in the rendering system (it serves only one function which is to answer the above question, and answering this question doesn&rsquo;t require the shader to have any over knowledge about the system than the surface property - its roughness, its color, etc. - and the incoming and outgoing direction being considered) which is why shaders in realtime APIs for example (such as OpenGL - but this often true of all rendering systems whether realtime or off-line) are written separately from the rest of your application.</p>
<p>What&rsquo;s happening in this box is not mysterious at all. What gives objects their unique appearance is the result of complex interactions between light particles (photons) and atoms objects are made of. Simulating these interactions is not practical. We observed though, that the result of these interactions is predictable and consistent, and we know that mathematics can be used to &ldquo;model&rdquo;, or represent, how the real world works. A mathematical model is never the same as the real thing, however, it is a convenient way of expressing a complex problem in a compact form, and can be used to compute the solution (or approximation) of a complex problem in a fraction of the time it would take to simulate the real thing. The science of shading is about developing such models to describe the appearance of objects, as a result of the way light interacts with them at the micro- and atomic scale. The complexity of these models depends on the type of surface we want to replicate the appearance of. Models to replicate the appearance of a perfectly diffuse and mirror-like surface are simple. Coming up with good models to replicate the look of glossy and translucent surfaces is a much harder task.</p>
<p>These models will be studied in the lessons from this section devoted to shading.</p>
</li>
</ul>
<blockquote>
<details>
In the past, techniques used to render 3D scenes in real-time were very much predefined by the API with little control given to the users to change them. Realtime technologies moved away from that paradigm to offer a more programmable pipeline in which each step of the rendering process is controlled by separate "programs" called "shaders". The current OpenGL APIs now support four of such "shaders": the vertex, the geometry, the tessellation, and the fragment shader. The shader in which the color of a point in the image is computed is the fragment shader. The other shaders have little to do with defining the object's look. You should be aware that the term "shader" is therefore generally used now in a broader sense.
</details>
</blockquote>
<h2 id="summary-and-other-considerations-about-rendering">Summary and Other Considerations About Rendering</h2>
<h3 id="summary-4">Summary</h3>
<p>We are not going to repeat what we explained already in the last chapters. Let&rsquo;s just make a list of the terms or concepts you should remember from this lesson:</p>
<ul>
<li>Computers deal with discrete structures which is an issue, as the shapes, we want to represent in images are continuous.</li>
<li>The triangle is a good choice of rendering primitive regardless of the method you use to solve the visibility problem (ray tracing or rasterization).</li>
<li>Rasterization is faster than ray tracing to solve the visibility process (and is the method used by GPUs), but it is easier to simulate global illumination effects with ray tracing. Plus, ray tracing can be used to both solve the visibility problem and shading. If you use rasterization, you need another algorithm or method to compute global illumination (but it is not impossible).</li>
<li>Ray tracing has its issues and challenges though. The ray-geometry intersection test is expensive and the render time increases linearly with the amount of geometry in the scene. Acceleration structures can be used to cut the render time down, but a good acceleration structure is hard to find (one that works well for all possible scene configurations). Ray tracing introduces noise in the image, a visual artifact that is hard to get rid of, etc.</li>
<li>If you decide to use ray tracing to compute shading and simulate global illumination effects, then you will need to simulate the different paths light rays take to get from light sources to the eye. This path depends on the type of surface the ray will interact with on its way to the eye: is the surface diffuse, specular, transparent, etc? There are different ways you can simulate these light paths. Simulating them accurately is important as they make it possible to reproduce lighting effects such as diffuse and specular inter-reflections, caustics, soft shadows, translucency, etc. A good light transport algorithm simulates all possible light paths efficiently.</li>
<li>While it&rsquo;s possible to simulate the transport of light rays from surface to surface, it&rsquo;s impossible to simulate the interaction of light with matter at the micro- and atomic scale. However, the result of these interactions is predictable and consistent. Thus we can attempt at simulating them using a mathematical function. A shader implements some mathematical model to approximate the way a given surface reflects light. The way a surface reflects light is the visual signature of that object. This is how and why we are capable of visually identifying what an object is made of: skin, wood, metal, fabric, plastic, etc., therefore, being able to simulate the appearance of any given material is of critical importance in the process of generating photo-realistic computer-generated images. Again this is the job of shaders.</li>
<li>There is a fine line between shaders and light transport algorithms. How secondary rays are spawned from the surface to compute indirect lighting effects (such as indirect specular and diffuse reflections) depends on the object material type: is the object diffuse, specular, etc? We will learn in the section on light transport, how shaders are used to generate these secondary rays.</li>
</ul>
<blockquote>
<details>
One of the things that we haven't talked about in the previous chapters is the difference between rendering on the CPU vs rendering on the GPU. Don't associate the term GPU with real-time rendering and the term CPU with offline rendering. Real-time and offline rendering have both very precise meanings and have nothing to do with the CPU or the GPU. We speak of **real-time** rendering when a scene can be rendered from 24 to 120 frames per second (24 to 30 fps is the minimum required to give the illusion of movement. A video game typically runs around 60 fps). Anything below 24 fps and above 1 frame per second is considered to be **interactive rendering**. When a frame takes from a few seconds to a few minutes or hours to render, we are then in the category of **offline rendering**. It is very well possible to achieve interactive or even real-time frame rates on the CPU. How much time it takes to render a frame depends essentially on the scene complexity anyway. A very complex scene can take more than a few seconds to render on the GPU. Our point here is that you should not associate GPU with real-time and CPU with offline rendering. These are different things. In the lessons of this section, we will learn how to use OpenGL to render images on the GPU, and we will implement the rasterization and the ray-tracing algorithm on the CPU. We will write a lesson dedicated to looking at the pros and cons of rendering on the GPU or the CPU.
</details>
</blockquote>
<blockquote>
<details>
The other thing we won't be talking about in this section is how rendering and **signal processing** relate to each other. This is a very important aspect of rendering, however, to understand this relationship you need to have solid foundations in signal processing which potentially also requires an understanding of Fourier analysis. We are planning to write a series of lessons on these topics once the basic section is complete. We think it's better to ignore this aspect of rendering if you don't have a good understanding of the theory behind it, rather than presenting it without being able to explain why and how it works.
</details>
</blockquote>
<p><a href="#R-image-d740814b3c9f4a030bf570b269085a41" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/lighteffect.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d740814b3c9f4a030bf570b269085a41"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-3/../assets/lighteffect.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 1:</strong> <em>we will also need to learn how to simulate depth of field (top) and motion blur (bottom).</em></p>
<p>Now that we have reviewed these concepts you know what you can expect to find in the different sections devoted to rendering, especially the sections on light transport, ray tracing, and shading. In the section on light transport, we will of course speak about the different ways global illumination effects can be simulated. In the section devoted to ray-tracing techniques, we will study techniques specific to ray tracing such as acceleration structures, ray differentials (don&rsquo;t worry if you don&rsquo;t know what the is for now), etc. In the section on shading, we will learn about what shaders are, we will study the most popular mathematical models developed to simulate the appearance of various materials.</p>
<p>We also talk about purely engineering topics such as multi-threading, multi-processing, or simply different ways the hardware can be used to accelerate rendering.</p>
<p>Finally and more importantly, if you are new to rendering and before you start reading any lessons from these advanced sections, we recommend that you read the next lessons from this section. You will learn about the most basic and important techniques used in rendering:</p>
<ul>
<li>How do the perspective and orthographic projections work? We will learn how to project points onto the surface of a &ldquo;virtual canvas&rdquo; using the perspective projection matrix to create images of 3D objects.</li>
<li>How does ray tracing work? How do we generate rays from the camera to generate an image?</li>
<li>How do we compute the intersection of a ray with a triangle?</li>
<li>How do we render more complex shapes than a simple triangle?</li>
<li>How do we render other basic shapes, such as spheres, disks, planes, etc?</li>
<li>How do we simulate things such as the motion blur of objects, or optical effects such as depth of field?</li>
<li>We will also learn more about the rasterization algorithm and learn how to implement the famous REYES algorithm.</li>
<li>We will also learn about shaders, we will learn about Monte-Carlo ray tracing, and finally texturing. Texturing is a technique used to add surface details to an object. A texture can be an image but also be generated procedurally.</li>
</ul>
<p>Ready?</p>

            <footer class="footline">
            </footer>
          </article>

          <article class="default">
            <header class="headline">
            </header>
<h1 id="computing-the-pixel-coordinates-of-a-3d-point">Computing the Pixel Coordinates of a 3D Point</h1>

<h2 id="perspective-projection">Perspective Projection</h2>
<h3 id="how-do-i-find-the-2d-pixel-coordinates-of-a-3d-point">How Do I Find the 2D Pixel Coordinates of a 3D Point?</h3>
<p>&ldquo;<strong>How do I find the 2D pixel coordinates of a 3D point?</strong>&rdquo; is one of the most common questions in 3D rendering on the Web. It is an essential question because it is the fundamental method to create an image of a 3D scene. In this lesson, we will use the term <strong>rasterization</strong> to describe the process of finding 2D pixel coordinates of 3D points. In its broader sense, Rasterization refers to converting 3D shapes into a raster image. A raster image, as explained in the <a href="../../../lessons/3d-basic-rendering/rendering-3d-scene-overview/">previous lesson</a>, is the technical term given to a digital image; it designates a two-dimensional array (or rectangular grid if you prefer) of pixels.</p>
<p>Don&rsquo;t be mistaken: different rendering techniques exist for producing images of 3D scenes. Rasterization is only one of them. Ray tracing is another. Note that all these techniques rely on the same concept to make that image: the idea of <strong>perspective projection</strong>. Therefore, for a given camera and a given 3D scene, all rendering techniques produce the same visual result; they use a different approach to produce that result.</p>
<p>Also, computing the 2D pixel coordinates of 3D points is only one of the two steps in creating a photo-realistic image. The other step is the process of shading, in which the color of these points will be computed to simulate the appearance of objects. You need more than just converting 3D points to pixel coordinates to produce a &ldquo;complete&rdquo; image.</p>
<p><a href="#R-image-76220ee03609e162762cac220bea9d61" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/xtree.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-76220ee03609e162762cac220bea9d61"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/xtree.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>To understand rasterization, you first need to be familiar with a series of essential techniques that we will also introduce in this chapter, such as:</p>
<ul>
<li>The concept of local vs. global coordinate system.</li>
<li>Learning how to interpret 4x4 matrices as coordinate systems.</li>
<li>Converting points from one coordinate system to another.</li>
</ul>
<p>Read this lesson carefully, as it will provide you with the fundamental tools that almost all rendering techniques are built upon.</p>
<p>We will use matrices in this lesson, so read the Geometry lesson if you are uncomfortable with coordinate systems and matrices.</p>
<p>We will apply the techniques studied in this lesson to render a <strong>wireframe</strong> image of a 3D object (adjacent image). The files of this program can be found in the source code chapter of the lesson, as usual.</p>
<h3 id="a-quick-refresher-on-the-perspective-projection-process">A Quick Refresher on the Perspective Projection Process</h3>
<p><a href="#R-image-45452759f39937e1f63cef8f1cca6a49" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/perspective4.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-45452759f39937e1f63cef8f1cca6a49"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/perspective4.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 1:</strong> <em>to create an image of a cube, we need to extend lines from the corners of the object towards the eye and find the intersection of these lines with a flat surface (the canvas) perpendicular to the line of sight.</em></p>
<p>We talked about the perspective projection process in quite a few lessons already. For instance, check out the chapter <a href="../../../lessons/3d-basic-rendering/rendering-3d-scene-overview/visibility-problem">The Visibility Problem</a> in the lesson &ldquo;Rendering an Image of a 3D Scene: an Overview&rdquo;. However, let&rsquo;s quickly recall what perspective projection is. In short, this technique can be used to create a 2D image of a 3D scene by projecting points (or vertices) that make up the objects of that scene onto the surface of a canvas.</p>
<p>We use this technique because it is similar to how the human eye works. Since we are used to seeing the world through our eyes, it&rsquo;s pretty natural to think that images created with this technique will also look natural and &ldquo;real&rdquo; to us. You can think of the human eye as just a &ldquo;point&rdquo; in space (Figure 2) (of course, the eye is not exactly a point; it is an optical system converging rays onto a small surface - the retina). What we see of the world results from light rays (reflected by objects) traveling to the eye and entering the eye. So again, one way of making an image of a 3D scene in computer graphics (CG) is to do the same thing: project vertices onto the surface of the canvas (or screen) as if the rays were sliding along straight lines that connect the vertices to the eye.</p>
<p>It is essential to understand that perspective projection is just an arbitrary way of representing 3D geometry onto a two-dimensional surface. This method is most commonly used because it simulates one of the essential properties of human vision called <strong>foreshortening</strong>: objects far away from us appear smaller than objects close by. Nonetheless, as mentioned in the Wikipedia article on <a href="https://en.wikipedia.org/wiki/Perspective_%28graphical%29" target="_blank">perspective</a>, it is essential to understand that the perspective projection is only an <strong>approximate representation</strong> of what the eye sees, represented on a flat surface (such as paper). The important word here is &ldquo;approximate&rdquo;.</p>
<p><a href="#R-image-ba9437e4e529e2162df1b569b9ad8c93" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/raystoeye.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-ba9437e4e529e2162df1b569b9ad8c93"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/raystoeye.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 2:</strong> among all light rays reflected by an object, some of these rays enter the eye, and the image we have of this object, is the result of these rays.</p>
<p><a href="#R-image-ee663557af37a2fcbb4af0bef7a0a33a" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/projection3.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-ee663557af37a2fcbb4af0bef7a0a33a"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/projection3.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 3:</strong> we can think of the projection process as moving a point down along the line that connects the point to the eye. We can stop moving the point along that line when the point lies on the plane of the canvas. We don&rsquo;t explicitly &ldquo;slide&rdquo; the point along this line, but this is how the projection process can be interpreted.</p>
<p>In the lesson mentioned above, we also explained how the world coordinates of a point located in front of the camera (and enclosed within the viewing frustum of the camera, thus visible to the camera) could be computed using a simple geometric construction based on one of the properties of similar triangles (Figure 3). We will review this technique one more time in this lesson. The equations to compute the coordinates of projected points can be conveniently expressed as a 4x4 matrix. The computation is simple but a series of operations on the original point&rsquo;s coordinates: this is what you will learn in this lesson. However, by expressing the computation as a matrix, you can reduce these operations to a single point-matrix multiplication. This approach&rsquo;s main advantage is representing this critical operation in such a compact and easy-to-use form. It turns out that the perspective projection process, and its associated equations, can be expressed in the form of a 4x4 matrix, as we will demonstrate in the lesson devoted to the <a href="../../../lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/">the perspective and orthographic projection matrices</a>. This is what we call the <strong>perspective projection matrix</strong>. Multiplying any point whose coordinates are expressed with respect to the <strong>camera coordinate system</strong> (see below) with this perspective projection matrix will give you the position (or coordinates) of that point on the canvas.</p>
<blockquote>
<details>
In CG, transformations are almost always linear. But it is essential to know that the perspective projection, which belongs to the more generic family of **projective transformation**, is a non-linear transformation. If you're looking for a visual explanation of which transformations are linear and which transformations are not, this [Youtube video](https://www.youtube.com/watch?v=kYB8IZa5AuE) does a good job.
</details>
</blockquote>
<p>Again, in this lesson, we will learn about computing the 2D pixel coordinates of a 3D point without using the perspective projection matrix. To do so, we will need to learn how to &ldquo;project&rdquo; a 3D point onto a 2D drawable surface (which we will call in this lesson a canvas) using some simple geometry rules. Once we understand the mathematics of this process (and all the other steps involved in computing these 2D coordinates), we will then be ready to study the construction and use of the perspective projection matrix: a matrix used to simplify the projection step (and the projection step only). This will be the topic of the next lesson.</p>
<h3 id="some-history">Some History</h3>
<p><a href="#R-image-fe7be1ee63aa771c2e842adae179d160" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/duerer.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-fe7be1ee63aa771c2e842adae179d160"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/duerer.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>The mathematics behind perspective projection started to be understood and mastered by artists towards the end of the fourteenth century and the beginning of the fifteenth century. Artists significantly contributed to educating others about the mathematical basis of perspective drawing through books they wrote and illustrated themselves. A notable example is &ldquo;The Painter&rsquo;s Manual&rdquo; published by Albrecht Dürer in 1538 (the illustration above comes from this book). Two concepts broadly characterize perspective drawing:</p>
<ul>
<li>Objects appear smaller as their distances to the viewer increase.</li>
<li><strong>Foreshortening</strong>: the impression, or optical illusion, that an object or a distance is smaller than it is due to being angled towards the viewer.</li>
</ul>
<p>Another rule in foreshortening states that vertical lines are parallel, while nonvertical lines converge to a perspective point, appearing shorter than they are. These effects give a sense of depth, which helps evaluate the distance of objects from the viewer. Today, the same mathematical principles are used in computer graphics to create a perspective view of a 3D scene.</p>
<h2 id="mathematics-of-computing-the-2d-coordinates-of-a-3d-point">Mathematics of Computing the 2D Coordinates of a 3D Point</h2>
<h3 id="finding-the-2d-pixel-coordinates-of-a-3d-point-explained-from-beginning-to-end">Finding the 2D Pixel Coordinates of a 3D Point: Explained from Beginning to End</h3>
<p>When a point or vertex is defined in the scene and is visible to the camera, the point appears in the image as a dot (or, more precisely, as a pixel if the image is digital). We already talked about the perspective projection process, which is used to convert the position of that point in 3D space to a position on the surface of the image. But this position is not expressed in terms of pixel coordinates. How do we find the final 2D pixel coordinates of the projected point in the image? In this chapter, we will review how points are converted from their original world position to their final raster position (their position in the image in terms of pixel coordinates).</p>
<blockquote>
<details>
The technique we will describe in this lesson is specific to the rasterization algorithm (the rendering technique used by GPUs to produce images of 3D scenes). If you want to learn how it is done in ray-tracing, check the lesson [Ray-Tracing: Generating Camera Rays](/lessons/3d-basic-rendering/ray-tracing-generating-camera-rays/).
</details>
</blockquote>
<h4 id="world-coordinate-system-and-world-space">World Coordinate System and World Space</h4>
<p>When a point is first defined in the scene, we say its coordinates are specified in <strong>world space</strong>: the coordinates of this point are described with respect to a global or world Cartesian coordinate system. The coordinate system has an origin, called the <strong>world origin</strong>, and the coordinates of any point defined in that space are described with respect to that origin (the point whose coordinates are [0,0,0]). Points are expressed in world space (Figure 4).</p>
<h4 id="4x4-matrix-visualized-as-a-cartesian-coordinate-system">4x4 Matrix Visualized as a Cartesian Coordinate System</h4>
<p>Objects in 3D can be transformed using any of the three operators: translation, rotation, and scale. Suppose you remember what we said in the lesson dedicated to <a href="../../../lessons/mathematics-physics-for-computer-graphics/geometry/">Geometry</a>. In that case, linear transformations (in other words, any combination of these three operators) can be represented by a 4x4 matrix. If you are not sure why and how this works, read the lesson on Geometry again and particularly the following two chapters: How Does Matrix Work <a href="../../../lessons/mathematics-physics-for-computer-graphics/geometry/how-does-matrix-work-part-1">Part 1</a> and <a href="../../../lessons/mathematics-physics-for-computer-graphics/geometry/how-does-matrix-work-part-2">Part 2</a>. Remember that the first three coefficients along the diagonal encode the scale (the coefficients c00, c11, and c22 in the matrix below), the first three values of the last row encode the translation (the coefficients c30, c31, and c32 — assuming you use the row-major order convention) and the 3x3 upper-left inner matrix encodes the rotation (the red, green and blue coefficients).</p>

<span class="math align-center">$$
\begin{bmatrix}
\color{red}{c_{00}}& \color{red}{c_{01}}&\color{red}{c_{02}}&\color{black}{c_{03}}\\
\color{green}{c_{10}}& \color{green}{c_{11}}&\color{green}{c_{12}}&\color{black}{c_{13}}\\
\color{blue}{c_{20}}& \color{blue}{c_{21}}&\color{blue}{c_{22}}&\color{black}{c_{23}}\\
\color{purple}{c_{30}}& \color{purple}{c_{31}}&\color{purple}{c_{32}}&\color{black}{c_{33}}\\
\end{bmatrix}
\begin{array}{l}
\rightarrow \quad \color{red} {x-axis}\\
\rightarrow \quad \color{green} {y-axis}\\
\rightarrow \quad \color{blue} {z-axis}\\
\rightarrow \quad \color{purple} {translation}\\
\end{array}
$$</span><p>When you look at the coefficients of a matrix (the actual numbers), it might be challenging to know precisely what the scaling or rotation values are because rotation and scale are combined within the first three coefficients along the diagonal of the matrix. So let&rsquo;s ignore scale now and only focus on rotation and translation.</p>
<p>As you can see, we have nine coefficients that represent a rotation. But how can we interpret what these nine coefficients are? So far, we have looked at matrices, but let&rsquo;s now consider what coordinate systems are. We will answer this question by connecting the two - matrices and coordinate systems.</p>
<p><a href="#R-image-9a67d7b0ccee43f0fcc9d9042a7d13e6" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/coordsys.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-9a67d7b0ccee43f0fcc9d9042a7d13e6"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/coordsys.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 4:</strong> <em>coordinate systems: translation and axes coordinates are defined with respect to the world coordinate system (a right-handed coordinate system is used).</em></p>
<p>The only Cartesian coordinate system we have discussed so far is the <strong>world coordinate system</strong>. This coordinate system is a convention used to define the coordinates [0,0,0] in our 3D virtual space and three unit axes that are orthogonal to each other (Figure 4). It&rsquo;s the <a href="https://en.wikipedia.org/wiki/Prime_meridian" target="_blank">prime meridian</a> of a 3D scene - any other point or arbitrary coordinate system in the scene is defined with respect to the world coordinate system. Once this coordinate system is defined, we can create other Cartesian coordinate systems. As with points, these coordinate systems are characterized by a position in space (a translation value) but also by three unit axes or vectors that are orthogonal to each other (which, by definition, are what Cartesian coordinate systems are). <strong>Both the position and the values of these three unit vectors are defined with respect to the world coordinate system</strong>, as depicted in Figure 4.</p>
<p>In Figure 4, the purple coordinates define the position. The coordinates of the x, y, and z axes are in red, green, and blue, respectively. These are the axes of an arbitrary coordinate system, which are all defined with respect to the world coordinate system. Note that the axes that make up this arbitrary coordinate system are unit vectors.</p>
<p>The upper-left 3x3 matrix inside our 4x4 matrix contains the coordinates of our arbitrary coordinate system&rsquo;s axes. We have three axes, each with three coordinates, which makes nine coefficients. If the 4x4 matrix stores its coefficients using the row-major order convention (this is the convention used by Scratchapixel), then:</p>
<ul>
<li>@@\rThe first three coefficients of the matrix&rsquo;s first row (c00, c01, c02) correspond to the coordinates of the coordinate system&rsquo;s x-axis.@@</li>
<li>@@\gThe first three coefficients of the matrix&rsquo;s second row (c10, c11, c12) are the coordinates of the coordinate system&rsquo;s y-axis.@@</li>
<li>@@\bThe first three coefficients of the matrix&rsquo;s third row (c20, c21, c22) are the coordinates of the coordinate system&rsquo;s z-axis.@@</li>
<li>@@\pThe first three coefficients of the matrix&rsquo;s fourth row (c30, c31, c32) are the coordinates of the coordinate system&rsquo;s position (translation values).@@</li>
</ul>
<p>For example, here is the transformation matrix of the coordinate system in Figure 4:</p>

<span class="math align-center">$$
\begin{bmatrix}
\color{red}{+0.718762}&\color{red}{+0.615033}&\color{red}{-0.324214}&0\\
\color{green}{-0.393732}&\color{green}{+0.744416}&\color{green}{+0.539277}&0\\
\color{blue}{+0.573024}&\color{blue}{-0.259959}&\color{blue}{+0.777216}&0\\
\color{purple}{+0.526967}&\color{purple}{+1.254234}&\color{purple}{-2.532150}&1\\
\end{bmatrix}
\begin{array}{l}
\rightarrow \quad \color{red} {x-axis}\\
\rightarrow \quad \color{green} {y-axis}\\
\rightarrow \quad \color{blue} {z-axis}\\
\rightarrow \quad \color{purple} {translation}\\
\end{array}
$$</span><blockquote>
<p>In conclusion, <strong>a 4x4 matrix represents a coordinate system</strong> (or, reciprocally, a 4x4 matrix can represent any Cartesian coordinate system). You must always see a 4x4 matrix as nothing more than a coordinate system and vice versa (we also sometimes speak of a &ldquo;local&rdquo; coordinate system about the &ldquo;global&rdquo; coordinate system, which in our case, is the world coordinate system).</p>
</blockquote>
<h4 id="local-vs-global-coordinate-system">Local vs. Global Coordinate System</h4>
<p><a href="#R-image-a8953d76195b836e13fc1a4cf1113ef0" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/localcoordsys.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a8953d76195b836e13fc1a4cf1113ef0"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/localcoordsys.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 5:</strong> <em>a global coordinate system, such as longitude and latitude coordinates, can be used to locate a house. We can also find a house using a numbering system in which the first house defines the origin of a local coordinate system. Note that the local coordinate system &ldquo;coordinate&rdquo; can also be described with respect to the global coordinate system (i.e., in terms of longitude/latitude coordinates).</em></p>
<p>Now that we have established how a 4x4 matrix can be interpreted (and introduced the concept of a local coordinate system) let&rsquo;s recall what local coordinate systems are used for. By default, the coordinates of a 3D point are defined with respect to the world coordinate system. The world coordinate system is just one among infinite possible coordinate systems. But we need a coordinate system to measure all things against by default, so we created one and gave it the special name of &ldquo;world coordinate system&rdquo; (it is a convention, like the Greenwich meridian: the meridian at which longitude is defined to be 0). Having one reference is good but not always the best way to track where things are in space. For instance, imagine you are looking for a house on the street. If you know that house&rsquo;s longitude and latitude coordinates, you can always use a GPS to find it. However, if you are already on the street where the house is situated, getting to this house using its number is more straightforward and quicker than using a GPS. A house number is a coordinate defined with respect to a reference: the first house on the street. In this example, the street numbers can be seen as a <strong>local coordinate system</strong>. In contrast, the longitude/latitude coordinate system can be seen as a <strong>global coordinate system</strong> (while the street numbers <em>can</em> be defined with respect to a global coordinate system, they are represented with their coordinates with respect to a local reference: the first house on the street). Local coordinate systems are helpful to &ldquo;find&rdquo; things when you put &ldquo;yourself&rdquo; within the frame of reference in which these things are defined (for example, when you are on the street itself). Note that the local coordinate system can be described with respect to the global coordinate system (for instance, we can determine its origin in terms of latitude/longitude coordinates).</p>
<p>Things are the same in CG. It&rsquo;s always possible to know where things are with respect to the world coordinate system. Still, to simplify calculations, it is often convenient to define things with respect to a local coordinate system (we will show this with an example further down). This is what &ldquo;local&rdquo; coordinate systems are used for.</p>
<p><a href="#R-image-86304403801939f69ddc84b4a67709e8" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/coordsys1.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-86304403801939f69ddc84b4a67709e8"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/coordsys1.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 6:</strong> <em>coordinates of a vertex defined with respect to the object&rsquo;s local coordinate system and to the world coordinate system.</em></p>
<p>When you move a 3D object in a scene, such as a 3D cube (but this is true regardless of the object&rsquo;s shape or complexity), transformations applied to that object (translation, scale, and rotation) can be represented by what we call a 4x4 transformation matrix (it is nothing more than a 4x4 matrix, but since it&rsquo;s used to change the position, scale and rotation of that object in space, we call it a transformation matrix). This 4x4 transformation matrix can be seen as the object&rsquo;s local frame of reference or local coordinate system. In a way, you don&rsquo;t transform the object but transform the local coordinate system of that object, but since the vertices making up the object are defined with respect to that local coordinate system, moving the coordinate system moves the object&rsquo;s vertices with it (see Figure 6). <strong>It&rsquo;s important to understand that we don&rsquo;t explicitly transform that coordinate system. We translate, scale, and rotate the object. A 4x4 matrix represents these transformations, and this matrix can be <em>visualized</em> as a coordinate system.</strong></p>
<h4 id="transforming-points-from-one-coordinate-system-to-another">Transforming Points from One Coordinate System to Another</h4>
<p>Note that even though the house is the same, the coordinates of the house, depending on whether you use its address or its longitude/latitude coordinates, are different (as the coordinates relate to the frame of reference in which the location of the house is defined). Look at the highlighted vertex in Figure 6. The coordinates of this vertex in the local coordinate system are [-0.5,0.5,-0.5]. But in &ldquo;world space&rdquo; (when the coordinates are defined with respect to the world coordinate system), the coordinates are [-0.31,1.44,-2.49]. <strong>Different coordinates, same point</strong>.</p>
<p>As suggested before, it is more convenient to operate on points when they are defined with respect to a local coordinate system rather than defined with respect to the world coordinate system. For instance, in the example of the cube (Figure 6), representing the cube&rsquo;s corners in local space is more accessible than in world space. But how do we convert a point or vertex from one coordinate system (such as the world coordinate space) to another coordinate system? Converting points from one coordinate system to another is a widespread process in CG, and the process is easy. Suppose we know the 4x4 matrix M that transforms a coordinate system A into a coordinate system B. In that case, if we transform a point whose coordinates are defined initially with respect to B with the <strong>inverse of M</strong> (we will explain next why we use the inverse of M rather than M), we get the coordinates of point P with respect to A.</p>
<p>Let&rsquo;s try an example using Figure 6. The matrix M that transforms the local coordinate system to which the cube is attached is:</p>

<span class="math align-center">$$
\begin{bmatrix}
\color{red}{+0.718762}&\color{red}{+0.615033}&\color{red}{-0.324214}&0\\
\color{green}{-0.393732}&\color{green}{+0.744416}&\color{green}{+0.539277}&0\\
\color{blue}{+0.573024}&\color{blue}{-0.259959}&\color{blue}{+0.777216}&0\\
\color{purple}{+0.526967}&\color{purple}{+1.254234}&\color{purple}{-2.532150}&1\\
\end{bmatrix}
$$</span><p><a href="#R-image-623c6842a4dab2302ec094b93e5cdbab" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/coordsys2.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-623c6842a4dab2302ec094b93e5cdbab"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/coordsys2.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 7:</strong> <em>to transform a point that is defined in the local coordinate system to world space, we multiply the point&rsquo;s local coordinates by M (in Figure 7a, the coordinate systems coincide; they have been shifted slightly to make them visible).</em></p>
<p>By default, the local coordinate system coincides with the world coordinate system (the cube vertices are defined with respect to this local coordinate system). This is illustrated in Figure 7a. Then, we apply the matrix M to the local coordinate system, which changes its position, scale, and rotation (this depends on the matrix values). This is illustrated in Figure 7b. So before we apply the transform, the coordinates of the highlighted vertex in Figures 6 and 7 (the purple dot) are the same in both coordinate systems (since the frames of reference coincide). But after the transformation, the world and local coordinates of the points are different (Figures 7a and 7b). To calculate the world coordinates of that vertex, we need to multiply the point&rsquo;s original coordinates by the <strong>local-to-world matrix</strong>: we call it <strong>local-to-world</strong> because it defines the coordinate system with respect to the world coordinate system. This is pretty logical! If you transform the local coordinate system and want the cube to move with this coordinate system, you want to apply the same transformation that was applied to the local coordinate system to the cube vertices. To do this, you multiply the cube&rsquo;s vertices by the local-to-world matrix (denoted (M) here for the sake of simplicity):</p>

<span class="math align-center">$$
P_{world} = P_{local} * M
$$</span><p>If you now want to go the other way around (to get the point &ldquo;local coordinates&rdquo; from its &ldquo;world coordinates&rdquo;), you need to transform the point world coordinates with the inverse of M:</p>

<span class="math align-center">$$P_{local} = P_{world} * M_{inverse}$$</span><p>Or in mathematical notation:</p>

<span class="math align-center">$$P_{local} = P_{world} * M^{-1}$$</span><p>As you may have guessed already, the inverse of M is also called the <strong>world-to-local</strong> coordinate system (it defines where the world coordinate system is with respect to the local coordinate system frame of reference):</p>

<span class="math align-center">$$
\begin{array}{l}
P_{world} = P_{local} * M_{local-to-world}\\
P_{local} = P_{world} * M_{world-to-local}.
\end{array}
$$</span><p>Let&rsquo;s check that it works. The coordinates of the highlighted vertex in local space are [-0.5,0.5,0.5] and in world space: [-0.31,1.44,-2.49]. We also know the matrix M (local-to-world). If we apply this matrix to the point&rsquo;s local coordinates, we should obtain the point&rsquo;s world coordinates:</p>

<span class="math align-center">$$
\begin{array}{l}
P_{world} = P_{local} * M\\
P_{world}.x = P_{local}.x * M_{00} + P_{local}.y * M_{10} + P_{local}.z * M_{20} + M_{30}\\
P_{world}.y = P_{local}.x * M_{01} + P_{local}.y * M_{11} + P_{local}.z * M_{22} + M_{31}\\
P_{world}.z = P_{local}.x * M_{02} + P_{local}.y * M_{12} + P_{local}.z * M_{22} + M_{32}\\
\end{array}
$$</span><p>Let&rsquo;s implement and check the results (you can use the code from the Geometry lesson):</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">Matrix44f</span> <span class="nf">m</span><span class="p">(</span><span class="mf">0.718762</span><span class="p">,</span> <span class="mf">0.615033</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.324214</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.393732</span><span class="p">,</span> <span class="mf">0.744416</span><span class="p">,</span> <span class="mf">0.539277</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.573024</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.259959</span><span class="p">,</span> <span class="mf">0.777216</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.526967</span><span class="p">,</span> <span class="mf">1.254234</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.53215</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">Vec3f</span> <span class="nf">Plocal</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">),</span> <span class="n">Pworld</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">m</span><span class="p">.</span><span class="n">multVecMatrix</span><span class="p">(</span><span class="n">Plocal</span><span class="p">,</span> <span class="n">Pworld</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="n">Pworld</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span></span></span></code></pre></div><p>The output is: <code>(-0.315792 1.4489 -2.48901)</code>.</p>
<p>Let&rsquo;s now transform the world coordinates of this point into local coordinates. Our implementation of the Matrix class contains a method to invert the current matrix. We will use it to compute the world-to-local transformation matrix and then apply this matrix to the point world coordinates:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">Matrix44f</span> <span class="nf">m</span><span class="p">(</span><span class="mf">0.718762</span><span class="p">,</span> <span class="mf">0.615033</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.324214</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.393732</span><span class="p">,</span> <span class="mf">0.744416</span><span class="p">,</span> <span class="mf">0.539277</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.573024</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.259959</span><span class="p">,</span> <span class="mf">0.777216</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.526967</span><span class="p">,</span> <span class="mf">1.254234</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.53215</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">m</span><span class="p">.</span><span class="n">invert</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">Vec3f</span> <span class="nf">Pworld</span><span class="p">(</span><span class="o">-</span><span class="mf">0.315792</span><span class="p">,</span> <span class="mf">1.4489</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.48901</span><span class="p">),</span> <span class="n">Plocal</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="n">m</span><span class="p">.</span><span class="n">multVecMatrix</span><span class="p">(</span><span class="n">Pworld</span><span class="p">,</span> <span class="n">Plocal</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="n">Plocal</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span></span></span></code></pre></div><p>The output is: <code>(-0.500004 0.499998 -0.499997)</code>.</p>
<p>The coordinates are not precisely (-0.5, 0.5, -0.5) because of some floating point precision issue and also because we&rsquo;ve truncated the input point world coordinates, but if we round it off to one decimal place, we get (-0.5, 0.5, -0.5) which is the correct result.</p>
<blockquote>
<p>At this point of the chapter, you should understand the difference between the world/global and local coordinate systems and how to transform points or vectors from one system to the other (and vice versa).</p>
<p>When we transform a point from the world to the local coordinate system (or the other way around), we often say that we go from <strong>world space</strong> to <strong>local space</strong>. We will use this terminology often.</p>
</blockquote>
<h4 id="camera-coordinate-system-and-camera-space">Camera Coordinate System and Camera Space</h4>
<p><a href="#R-image-009553dac800252f351414cd3ddea03c" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/camera.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-009553dac800252f351414cd3ddea03c"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/camera.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 8:</strong> <em>when you create a camera, by default, it is aligned along the world coordinate system&rsquo;s negative z-axis. This is a convention used by most 3D applications.</em></p>
<p><a href="#R-image-27d6b4377b6dbd8c0fe2d2929551788b" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/camera2.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-27d6b4377b6dbd8c0fe2d2929551788b"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/camera2.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 9:</strong> <em>transforming the camera coordinate system with the camera-to-world transformation matrix.</em></p>
<p>A camera in CG (and the natural world) is no different from any 3D object. When you take a photograph, you need to move and rotate the camera to adjust the viewpoint. So in a way, when you transform a camera (by translating and rotating it — note that scaling a camera doesn&rsquo;t make much sense), what you are doing is <strong>transforming a local coordinate system, which implicitly represents the transformations applied to that camera</strong>. In CG, we call this spatial reference system (the term spatial reference system or reference is sometimes used in place of the term coordinate system) the <strong>camera coordinate system</strong> (you might also find it called the eye coordinate system in other references). We will explain why this coordinate system is essential in a moment.</p>
<p>A camera is nothing more than a coordinate system. Thus, the technique we described earlier to transform points from one coordinate system to another can also be applied here to transform points from the world coordinate system to the camera coordinate system (and vice versa). We say that we transform points from <strong>world space to camera space</strong> (or camera space to world space if we apply the transformation the other way around).</p>
<p>However, cameras always point along the world coordinate system&rsquo;s negative z-axis. In Figure 8, you will see that the camera&rsquo;s z-axis is pointing in the opposite direction of the world coordinate system&rsquo;s z-axis (when the x-axis points to the right and the z-axis goes inward into the screen rather than outward).</p>
<blockquote>
<details>
Cameras point along the world coordinate system's negative z-axis so that when a point is converted from world space to camera space (and then later from camera space to screen space) if the point is to the left of the world coordinate system's y-axis, the point will also map to the left of the camera coordinate system's y-axis. In other words, we need the x-axis of the camera coordinate system to point to the right when the world coordinate system x-axis also points to the right; the only way you can get that configuration is by having the camera look down the negative z-axis.
</details>
</blockquote>
<p>Because of this, the sign of the z coordinate of points is inverted when we go from one system to the other. Keep this in mind, as it will play a role when we (finally) get to study the perspective projection matrix.</p>
<p>To summarize: if we want to convert the coordinates of a point in 3D from world space (which is the space in which points are defined in a 3D scene) to the space of a local coordinate system, we need to multiply the point world coordinates by the inverse of the local-to-world matrix.</p>
<h4 id="of-the-importance-of-converting-points-to-camera-space">Of the Importance of Converting Points to Camera Space</h4>
<p>This a lot of reading, but what for? We will now show that to &ldquo;project&rdquo; a point on the canvas (the 2D surface on which we will draw an image of the 3D scene), we will need to convert or transform points from the world to camera space. And here is why.</p>
<p><a href="#R-image-4f222b794019b90875c681b0bb391241" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/box-setup4.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-4f222b794019b90875c681b0bb391241"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/box-setup4.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 10:</strong> <em>the coordinates of the point P&rsquo;, the projection of P on the canvas, can be computed using simple geometry. The rectangle ABC and AB&rsquo;C&rsquo; are said to be similar (side view).</em></p>
<p>Let&rsquo;s recall that what we are trying to achieve is to compute P&rsquo;, the coordinates of a point P from the 3D scene on the surface of a canvas, which is the 2D surface where the image of the scene will be drawn (the canvas is also called the projection plane, or in CG, the <strong>image plane</strong>). If you trace a line from P to the eye (the origin of the camera coordinate system), P&rsquo; is the line&rsquo;s point of intersection with the canvas (Figure 10). When the point P coordinates are defined with respect to the camera coordinate system, computing the position of P&rsquo; is trivial. If you look at Figure 10, which shows a side view of our setup, you can see that by construction, we can trace two triangles (\triangle ABC) and (\triangle AB&rsquo;C&rsquo;), where:</p>
<ul>
<li>A is the eye.</li>
<li>B is the distance from the eye to point P along the camera coordinate system&rsquo;s z-axis.</li>
<li>C is the distance from the eye to P along the camera coordinate system&rsquo;s y-axis.</li>
<li>B&rsquo; is the distance from the eye to the canvas (for now, we will assume that this distance is 1, which will simplify our calculations).</li>
<li>C&rsquo; is the distance from the eye to P&rsquo; along the camera coordinate system y-axis.</li>
</ul>
<p>The triangles (\triangle ABC) and (\triangle AB&rsquo;C&rsquo;) are said to be similar (similar triangles have the same shape but different sizes). Similar triangles have an interesting property: the ratio between their adjacent and opposite sides is the same. In other words:</p>

<span class="math align-center">$${ BC \over AB } = { B'C' \over AB' }.$$</span><p>Because the canvas is 1 unit away from the origin, we know that AB&rsquo; equals 1. We also know the position of B and C, which are the z- (depth) and y-coordinate (height) of point P (assuming P&rsquo;s coordinates are defined in the camera coordinate system). If we substitute these numbers in the above equation, we get:</p>

<span class="math align-center">$${ P.y \over P.z } = { P'.y \over 1 }.$$</span><p>Where y&rsquo; is the y coordinate of P&rsquo;. Thus:</p>

<span class="math align-center">$$P'.y = { P.y \over P.z }.$$</span><p>This is one of computer graphics&rsquo; simplest and most fundamental relations, known as the z or perspective divide. The same principle applies to the x coordinate. The projected point&rsquo;s x coordinate (x&rsquo;) is the corner&rsquo;s x coordinate divided by its z coordinate:</p>

<span class="math align-center">$$P'.x = { P.x \over P.z }.$$</span><blockquote>
<p>We described this method several times in other lessons on the website, but we want to show here that <strong>to compute P&rsquo; using these equations, the coordinates of P should be defined with respect to the camera coordinate system. However, points from the 3D scene are defined initially with respect to the world coordinate system. Therefore, the first and foremost operation we need to apply to points before projecting them onto the canvas is to convert them from world space to camera space</strong>.</p>
</blockquote>
<p>How do we do that? Suppose we know the camera-to-world matrix (similar to the local-to-camera matrix we studied in the previous case). In that case, we can transform any point(whose coordinates are defined in world space) to camera space by multiplying this point by the camera-to-world inverse matrix (the world-to-camera matrix):</p>

<span class="math align-center">$$P_{camera} = P_{world} * M_{world-to-camera}.$$</span><p>Then at this stage, we can &ldquo;project&rdquo; the point on the canvas using the equations we presented before:</p>

<span class="math align-center">$$
\begin{array}{l}
P'.x = \dfrac{P_{camera}.x}{P_{camera}.z}\\
P'.y = \dfrac{P_{camera}.y}{P_{camera}.z}.
\end{array}
$$</span><p>Recall that cameras are usually oriented along the world coordinate system&rsquo;s negative z-axis. This means that when we convert a point from world space to camera space, the sign of the point&rsquo;s z-coordinate is necessarily reversed; it becomes negative if the z-coordinate was positive in world space, or it becomes positive if it was initially negative. <strong>Note that a point defined in camera space can only be visible if its z-coordinate is negative</strong> (take a moment to verify this statement). As a result, when the x- and y-coordinate of the original point are divided by the point&rsquo;s negative z-coordinate, the sign of the resulting projected point&rsquo;s x and y-coordinates is also reversed. This is a problem because a point that is situated to the right of the screen coordinate system&rsquo;s y-axis when you look through the camera or a point that appears above the horizontal line passing through the middle of the frame ends up either to the left of the vertical line or below the horizontal line once projected. The point&rsquo;s coordinates are mirrored. The solution to this problem is simple. We need to make the point&rsquo;s z-coordinate positive, which we can easily do by reversing its sign at the time that the projected point&rsquo;s coordinates are computed:</p>

<span class="math align-center">$$
\begin{array}{l}
P'.x = \dfrac{P_{camera}.x}{-P_{camera}.z}\\
P'.y = \dfrac{P_{camera}.y}{-P_{camera}.z}.
\end{array}
$$</span><p>To summarize: points in a scene are defined in the world coordinate space. However, to project them onto the surface of the canvas, we first need to convert the 3D point coordinates from world space to camera space. This can be done by multiplying the point world coordinates by the inverse of the camera-to-world matrix. Here is the code for performing this conversion:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">Matrix44f</span> <span class="nf">cameraToWorld</span><span class="p">(</span><span class="mf">0.718762</span><span class="p">,</span> <span class="mf">0.615033</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.324214</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.393732</span><span class="p">,</span> <span class="mf">0.744416</span><span class="p">,</span> <span class="mf">0.539277</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.573024</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.259959</span><span class="p">,</span> <span class="mf">0.777216</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.526967</span><span class="p">,</span> <span class="mf">1.254234</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.53215</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">Matrix4ff</span> <span class="n">worldToCamera</span> <span class="o">=</span> <span class="n">cameraToWorld</span><span class="p">.</span><span class="n">inverse</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">Vec3f</span> <span class="nf">Pworld</span><span class="p">(</span><span class="o">-</span><span class="mf">0.315792</span><span class="p">,</span> <span class="mf">1.4489</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.48901</span><span class="p">),</span> <span class="n">Pcamera</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="n">worldToCamera</span><span class="p">.</span><span class="n">multVecMatrix</span><span class="p">(</span><span class="n">Pworld</span><span class="p">,</span> <span class="n">Pcamera</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="n">Pcamera</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span></span></span></code></pre></div><p>We can now use the resulting point in camera space to compute its 2D coordinates on the canvas by using the perspective projection equations (dividing the point coordinates with the <strong>inverse</strong> of the point&rsquo;s z-coordinate).</p>
<h4 id="from-screen-space-to-raster-space">From Screen Space to Raster Space</h4>
<p><a href="#R-image-dbd7eab4f0029f0a7a6b81ac02aea0de" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/screen.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-dbd7eab4f0029f0a7a6b81ac02aea0de"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/screen.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 11:</strong> <em>the screen coordinate system is a 2D Cartesian coordinate system. It marks the center of the canvas. The image plane is infinite, but the canvas delimits the surface over which the image of the scene will be drawn onto. The canvas size can have any size. In this example, it is two units long in both dimensions (as with every Cartesian coordinate system, the screen coordinate system&rsquo;s axes have unit length).</em></p>
<p><a href="#R-image-7d7780a6311562dd47ee938dcf125190" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/frustum.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7d7780a6311562dd47ee938dcf125190"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/frustum.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 12:</strong> <em>in this example, the canvas is 2 units along the x-axis and 2 units along the y-axis. You can change the dimension of the canvas if you wish. By making it bigger or smaller, you will see more or less of the scene.</em></p>
<p>At this point, we know how to compute the projection of a point on the canvas. We first need to transform points from world space to camera space and divide the point&rsquo;s x- and y-coordinates by their respective z-coordinate. Let&rsquo;s recall that the canvas lies on what we call the <strong>image plane</strong> in CG. So you now have a point P&rsquo; lying on the image plane, which is the projection of P onto that plane. <strong>But in which space is the coordinates of P&rsquo; defined?</strong> Note that because point P&rsquo; lies on a plane, we are no longer interested in the z-coordinate of P.&rsquo; In other words, we don&rsquo;t need to declare P&rsquo; as a 3D point; a 2D point suffices (this is partially true. To solve the visibility problem, the rasterization algorithm uses the z-coordinates of the projected points. However, we will ignore this technical detail for now).</p>
<p><a href="#R-image-298f625f594c192268bd2666199586df" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/canvassize.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-298f625f594c192268bd2666199586df"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/canvassize.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 13:</strong> <em>changing the dimensions/size of the canvas changes the extent of a given scene that is imaged by the camera. In this particular example, two canvases are represented. On the smaller one, the triangle is only partially visible. On the larger one, the entire triangle is visible. Canvas size and field-of-view relate to each other.</em></p>
<p>Since P&rsquo; is a 2D point, it is defined with respect to a 2D coordinate system which in CG is called the <strong>image or screen coordinate system</strong>. This coordinate system marks the center of the canvas; the coordinates of any point projected onto the image plane refer to this coordinative system. 3D points with positive x-coordinates are projected to the right of the image coordinate system&rsquo;s y-axis. 3D points with positive y-coordinates are projected above the image coordinate system&rsquo;s x-axis (Figure 11). An image plane is a plane, so technically, it is infinite. But images are not infinite in size; they have a width and a height. Thus, we will cut off a rectangular shape centered around the image coordinate system, which we will define as the &ldquo;bounded region&rdquo; over which the image of the 3D scene will be drawn (Figure 11). You can see that this region is a canvas&rsquo;s paintable or drawable surface. The dimension of this rectangular region can be anything we want. Changing its size changes the extent of a given scene imaged by the camera (Figure 13). We will study the effect of the canvas size in the next lesson. In figures 12 and 14 (top), the canvas is 2 units long in each dimension (vertical and horizontal).</p>
<p>Any projected point whose absolute x- and y-coordinate is greater than half of the canvas&rsquo; width <strong>or</strong> half of the canvas&rsquo; height, respectively, is not visible in the image (the projected point is clipped).</p>

<span class="math align-center">$$
\text {visible} =
\begin{cases}
yes & |P'.x| \le {W \over 2} \text{ or }  |P'.y| \le {H \over 2}\\
no & \text{otherwise}
\end{cases}
$$</span><p>|a| in mathematics means the <a href="https://www.khanacademy.org/math/cc-sixth-grade-math/cc-6th-negative-number-topic/cc-6th-absolute-value/a/intro-to-absolute-value" target="_blank">absolute value</a> of a. The variables W and H are the width and height of the canvas.</p>
<p><a href="#R-image-de9264465c1966dd60647fd8d03782ae" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/canvascoordsys.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-de9264465c1966dd60647fd8d03782ae"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/canvascoordsys.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 14:</strong> <em>to convert P&rsquo; from screen space to raster space, we first need to go from screen space (top) to NDC space (middle), then NDC space to raster space (bottom). Note that the y-axis of the NDC coordinate system goes up but that the y-axis of the raster coordinate system goes down. This implies that we invert P&rsquo; y-coordinate when we go from NDC to raster space.</em></p>
<p>If the coordinates of P are real numbers (floats or doubles in programming), P&rsquo;s coordinates are also real numbers. If P&rsquo;s coordinates are within the canvas boundaries, then P&rsquo; is visible. Otherwise, the point is not visible, and we can ignore it. If P&rsquo; is visible, it should appear as a dot in the image. A dot in a digital image is a pixel. Note that pixels are also 2D points, only their coordinates are integers, and the coordinate system that these coordinates refer to is located in the upper-left corner of the image. Its x-axis points to the right (when the world coordinate system x-axis points to the right), and its y-axis points downwards (Figure 14). This coordinate system in computer graphics is called the <strong>raster coordinate system</strong>. A pixel in this coordinate system is one unit long in x and y. We need to convert P&rsquo; coordinates, defined with respect to the image or screen coordinate system, into pixel coordinates (the position of P&rsquo; in the image in terms of pixel coordinates). This is another change in the coordinate system; we say that we need to go from <strong>screen space to raster space</strong>. How do we do that?</p>
<p>The first thing we will do is remap P coordinates in the range [0,1]. This is mathematically easy. Since we know the dimension of the canvas, all we need to do is apply the following formulas:</p>

<span class="math align-center">$$
\begin{array}{l}
P'_{normalized}.x = \dfrac{P'.x + width / 2}{ width }\\
P'_{normalised}.y = \dfrac{P'.y + height / 2}{ height }
\end{array}
$$</span><p>Because the coordinates of the projected point P&rsquo; are now in the range [0,1], we say that the coordinates are normalized. For this reason, we also call the coordinate system in which the points are defined after normalization the <strong>NDC coordinate system</strong> or <strong>NDC space</strong>. NDC stands for <strong>Normalized Device Coordinate</strong>. The NDC coordinate system&rsquo;s origin is situated in the lower-left corner of the canvas. Note that the coordinates are still real numbers at this point, only they are now in the range [0,1].</p>
<p>The last step is simple. We need to multiply the projected point&rsquo;s x- and y-coordinates in NDC space by the actual image pixel width and image pixel height, respectively. This is a simple remapping of the range [0,1] to the range [0, Pixel Width] for the x-coordinate and [0,Pixel Height] for the y-coordinate, respectively. Since the pixel coordinates need to be integers, we need to round off the resulting numbers to the smallest following integer value (to do that, we will use the mathematical floor function; it rounds off a real number to its smallest next integer). After this final step, P&rsquo;s coordinates are defined in <strong>raster space</strong>:</p>

<span class="math align-center">$$
\begin{array}{l}
P'_{raster}.x = \lfloor{ P'_{normalized}.x * \text{ Pixel Width} }\rfloor\\
P'_{raster}.y = \lfloor{ P'_{normalized}.y * \text{Pixel Height} }\rfloor
\end{array}
$$</span><p>In mathematics, (\lfloor{a}\rfloor), denotes the <a href="https://en.wikipedia.org/wiki/Floor_and_ceiling_functions" target="_blank">floor function</a>. Pixel width and pixel height are the actual dimensions of the image in pixels. However, there is a small detail that we need to take care of. The y-axis in the NDC coordinate system points up, while in the raster coordinate system, the y-axis points down. Thus, to go from one coordinate system to the other, the y-coordinate of P&rsquo; also needs to be inverted. We can easily account for this by doing a small modification to the above equations:</p>

<span class="math align-center">$$
\begin{array}{l}
P'_{raster}.x = \lfloor{ P'_{normalized}.x * \text{ Pixel Width} }\rfloor\\
P'_{raster}.y = \lfloor{ (1 - P'_{normalized}.y) * \text{Pixel Height} }\rfloor
\end{array}
$$</span><p>In OpenGL, the conversion from NDC space to raster space is called the viewport transform. The canvas in this lesson is generally called the <strong>viewport</strong> in CG. However, the viewport means different things to different people. To some, it designates the &ldquo;normalized window&rdquo; of the NDC space. To others, it represents the window of pixels on the screen in which the final image is displayed.</p>
<p>Done! You have converted a point P defined in world space into a visible point in the image, whose pixel coordinates you have computed using a series of conversion operations:</p>
<ul>
<li>World space to camera space.</li>
<li>Camera space to screen space.</li>
<li>Screen space to NDC space.</li>
<li>NDC space to raster space.</li>
</ul>
<h3 id="summary">Summary</h3>
<p>Because this process is so fundamental, we will summarize everything that we&rsquo;ve learned in this chapter:</p>
<ul>
<li>Points in a 3D scene are defined with respect to the world coordinate system.</li>
<li>A 4x4 matrix can be seen as a &ldquo;local&rdquo; coordinate system.</li>
<li>We learned how to convert points from the world coordinate system to any local coordinate system.
<ul>
<li>If we know the local-to-world matrix, we can multiply the world coordinate of the point by the inverse of the local-to-world matrix (the world-to-local matrix).</li>
</ul>
</li>
<li>We also use 4x4 matrices to transform cameras. Therefore, we can also convert points from world space to camera space.</li>
<li>Computing the coordinates of a point from camera space onto the canvas can be done using perspective projection (camera space to image space). This process requires a simple division of the point&rsquo;s x- and y-coordinate by the point&rsquo;s z-coordinate. Before projecting the point onto the canvas, we need to convert the point from world space to camera space. The resulting projected point is a 2D point defined in image space (the z-coordinate can be discarded).</li>
<li>We then convert the 2D point in image space to Normalized Device Coordinate (NDC) space. In NDC space (image space to NDC space), the coordinates of the point are remapped to the range [0,1].</li>
<li>Finally, we convert the 2D point in NDC space to raster space. To do this, we must multiply the NDC point&rsquo;s x and y coordinates with the image width and height (in pixels). Pixel coordinates are integers rather than real numbers. Thus, they need to be rounded off to the smallest following integer when converting from NDC space to raster space. In the NDC coordinate system, the y-axis is located in the lower-left corner of the image and is pointing up. In raster space, the y-axis is located in the upper-left corner of the image and is pointing down. Therefore, the y-coordinates need to be inverted when converting from NDC to raster space.</li>
</ul>
<p><a href="#R-image-ba1553678bc48ded87d572e58b39f0b9" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/20240216151742.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-ba1553678bc48ded87d572e58b39f0b9"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/20240216151742.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<h3 id="code">Code</h3>
<p>The function converts a point from 3D world coordinates to 2D pixel coordinates. The function returns&rsquo; false&rsquo; if the point is not visible in the canvas. This implementation is quite naive, but we should have written it for efficiency. We wrote it, so that every step is visible and contained within a single function.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">bool</span> <span class="nf">computePixelCoordinates</span><span class="p">(</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    <span class="k">const</span> <span class="n">Vec3f</span> <span class="o">&amp;</span><span class="n">pWorld</span><span class="p">,</span> 
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="k">const</span> <span class="n">Matrix44f</span> <span class="o">&amp;</span><span class="n">cameraToWorld</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="k">const</span> <span class="kt">float</span> <span class="o">&amp;</span><span class="n">canvasWidth</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="k">const</span> <span class="kt">float</span> <span class="o">&amp;</span><span class="n">canvasHeight</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">imageWidth</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">imageHeight</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="n">Vec2i</span> <span class="o">&amp;</span><span class="n">pRaster</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="c1">// First, transform the 3D point from world space to camera space. 
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="c1"></span>    <span class="c1">// It is, of course inefficient to compute the inverse of the cameraToWorld
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="c1"></span>    <span class="c1">// matrix in this function. It should be done only once outside the function
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="c1"></span>    <span class="c1">// and the worldToCamera should be passed to the function instead. 
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="c1"></span>    <span class="c1">// We only compute the inverse of this matrix in this function ...
</span></span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="c1"></span>    <span class="n">Vec3f</span> <span class="n">pCamera</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="n">Matrix44f</span> <span class="n">worldToCamera</span> <span class="o">=</span> <span class="n">cameraToWorld</span><span class="p">.</span><span class="n">inverse</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">    <span class="n">worldToCamera</span><span class="p">.</span><span class="n">multVecMatrix</span><span class="p">(</span><span class="n">pWorld</span><span class="p">,</span> <span class="n">pCamera</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">
</span></span><span class="line"><span class="ln">19</span><span class="cl">    <span class="c1">// Coordinates of the point on the canvas. Use perspective projection.
</span></span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="c1"></span>    <span class="n">Vec2f</span> <span class="n">pScreen</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">    <span class="n">pScreen</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">pCamera</span><span class="p">.</span><span class="n">x</span> <span class="o">/</span> <span class="o">-</span><span class="n">pCamera</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">    <span class="n">pScreen</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">pCamera</span><span class="p">.</span><span class="n">y</span> <span class="o">/</span> <span class="o">-</span><span class="n">pCamera</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">
</span></span><span class="line"><span class="ln">24</span><span class="cl">    <span class="c1">// If the x- or y-coordinate absolute value is greater than the canvas width 
</span></span></span><span class="line"><span class="ln">25</span><span class="cl"><span class="c1"></span>    <span class="c1">// or height respectively, the point is not visible
</span></span></span><span class="line"><span class="ln">26</span><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">abs</span><span class="p">(</span><span class="n">pScreen</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">canvasWidth</span> <span class="o">||</span> <span class="n">std</span><span class="o">::</span><span class="n">abs</span><span class="p">(</span><span class="n">pScreen</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">canvasHeight</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">28</span><span class="cl">
</span></span><span class="line"><span class="ln">29</span><span class="cl">    <span class="c1">// Normalize. Coordinates will be in the range [0,1]
</span></span></span><span class="line"><span class="ln">30</span><span class="cl"><span class="c1"></span>    <span class="n">Vec2f</span> <span class="n">pNDC</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">31</span><span class="cl">    <span class="n">pNDC</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">pScreen</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">canvasWidth</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">canvasWidth</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">32</span><span class="cl">    <span class="n">pNDC</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">pScreen</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">canvasHeight</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">canvasHeight</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">33</span><span class="cl">
</span></span><span class="line"><span class="ln">34</span><span class="cl">    <span class="c1">// Finally, convert to pixel coordinates. Don&#39;t forget to invert the y coordinate
</span></span></span><span class="line"><span class="ln">35</span><span class="cl"><span class="c1"></span>    <span class="n">pRaster</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">floor</span><span class="p">(</span><span class="n">pNDC</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">imageWidth</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">36</span><span class="cl">    <span class="n">pRaster</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">floor</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">pNDC</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="n">imageHeight</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">37</span><span class="cl">
</span></span><span class="line"><span class="ln">38</span><span class="cl">    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">39</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">40</span><span class="cl">
</span></span><span class="line"><span class="ln">41</span><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(...)</span>
</span></span><span class="line"><span class="ln">42</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">43</span><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="ln">44</span><span class="cl">    <span class="n">Matrix44f</span> <span class="n">cameraToWorld</span><span class="p">(...);</span>
</span></span><span class="line"><span class="ln">45</span><span class="cl">    <span class="n">Vec3f</span> <span class="n">pWorld</span><span class="p">(...);</span>
</span></span><span class="line"><span class="ln">46</span><span class="cl">    <span class="kt">float</span> <span class="n">canvasWidth</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">canvasHeight</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">47</span><span class="cl">    <span class="kt">uint32_t</span> <span class="n">imageWidth</span> <span class="o">=</span> <span class="mi">512</span><span class="p">,</span> <span class="n">imageHeight</span> <span class="o">=</span> <span class="mi">512</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">48</span><span class="cl">
</span></span><span class="line"><span class="ln">49</span><span class="cl">    <span class="c1">// The 2D pixel coordinates of pWorld in the image if the point is visible
</span></span></span><span class="line"><span class="ln">50</span><span class="cl"><span class="c1"></span>    <span class="n">Vec2i</span> <span class="n">pRaster</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">51</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">computePixelCoordinates</span><span class="p">(</span><span class="n">pWorld</span><span class="p">,</span> <span class="n">cameraToWorld</span><span class="p">,</span> <span class="n">canvasWidth</span><span class="p">,</span> <span class="n">canvasHeight</span><span class="p">,</span> <span class="n">imageWidth</span><span class="p">,</span> <span class="n">imageHeight</span><span class="p">,</span> <span class="n">pRaster</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">52</span><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Pixel coordinates &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">pRaster</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">53</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">54</span><span class="cl">    <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">55</span><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cert</span> <span class="o">&lt;&lt;</span> <span class="n">Pworld</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; is not visible&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">56</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">57</span><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="ln">58</span><span class="cl">
</span></span><span class="line"><span class="ln">59</span><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">60</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>We will use a similar function in our example program (look at the source code chapter). To demonstrate the technique, we created a simple object in Maya (a tree with a star sitting on top) and rendered an image of that tree from a given camera in Maya (see the image below). To simplify the exercise, we triangulated the geometry. We then stored a description of that geometry and the Maya camera 4x4 transform matrix (the camera-to-world matrix) in our program.</p>
<p>To create an image of that object, we need to:</p>
<ul>
<li>Loop over each triangle that makes up the geometry.</li>
<li>Extract from the vertex list the vertices making up the current triangle.</li>
<li>Convert these vertices&rsquo; world coordinates to 2D pixel coordinates.</li>
<li>Draw lines connecting the resulting 2D points to draw an image of that triangle as viewed from the camera (we trace a line from the first point to the second point, from the second point to the third, and then from the third point back to the first point).</li>
</ul>
<p>We then store the resulting lines in an SVG file. The SVG format is designed to create images using simple geometric shapes such as lines, rectangles, circles, etc., described in XML. Here is how we define a line in SVG, for instance:</p>
<div class="wrap-code highlight"><pre tabindex="0"><code>&lt;line x1=&#34;0&#34; y1=&#34;0&#34; x2=&#34;200&#34; y2=&#34;200&#34; style=&#34;stroke:rgb(255,0,0);stroke-width:2&#34; /&gt;</code></pre></div><p>SVG files themselves can be read and displayed as images by most Internet browsers. Storing the result of our programs in SVG is very convenient. Rather than rendering these shapes ourselves, we can store their description in an SVG file and have other applications render the final image for us (we don&rsquo;t need to care for anything that relates to rendering these shapes and displaying the image to the screen, which is not apparent from a programming point of view).</p>
<p>The complete source code of this program can be found in the source code chapter. Finally, here is the result of our program (left) compared to a render of the same geometry from the same camera in Maya (right). As expected, the visual results are the same (you can read the SVG file produced by the program in any Internet browser).</p>
<p><a href="#R-image-70dea68a5108eb93f965ad3c1702315e" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/projexample.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-70dea68a5108eb93f965ad3c1702315e"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-4/../assets/projexample.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>Suppose you wish to reproduce this result in Maya. In that case, you will need to import the geometry (which we provide in the next chapter as an obj file), create a camera, set its angle of view to 90 degrees (we will explain why in the next lesson), and make the film gate square (by setting up the vertical and horizontal film gate parameters to 1). Set the render resolution to 512x512 and render from Maya. It would be best if you then exported the camera&rsquo;s transformation matrix using, for example, the following Mel command:</p>
<div class="wrap-code highlight"><pre tabindex="0"><code>getAttr camera1.worldMatrix;</code></pre></div><p>Set the camera-to-world matrix in our program with the result of this command (the 16 coefficients of the matrix). Compile the source code, and run the program. The impact exported to the SVG file should match Maya&rsquo;s render.</p>
<h3 id="what-else">What Else?</h3>
<p>This chapter contains a lot of information. Most resources devoted to the process focus their explanation on the perspective process. Still, they must remember to mention everything that comes before and after the perspective projection (such as the world-to-camera transformation or the conversion of the screen coordinates to raster coordinates). We aim for you to produce an actual result at the end of this lesson, which we could also match to a render from a professional 3D application such as Maya. We wanted you to have a complete picture of the process from beginning to end. However, dealing with cameras is slightly more complicated than what we described in this chapter. For instance, if you have used a 3D program before, you are probably familiar with the fact that the camera transform is not the only parameter you can change to adjust what you see in the camera&rsquo;s view. You can also vary, for example, its focal length. How the focal length affects the result of the conversion process is something we have yet to explain in this lesson. The near and far clipping planes associated with cameras also affect the perspective projection process, more notably the perspective and orthographic projection matrix. In this lesson, we assumed that the canvas was located one unit away from the camera coordinate system. However, this is only sometimes the case, which can be controlled through the near-clipping plane. How do we compute pixel coordinates when the distance between the camera coordinate system&rsquo;s origin and the canvas is different than 1? These unanswered questions will be addressed in the next lesson, devoted to 3D viewing.</p>
<h3 id="exercises">Exercises</h3>
<ul>
<li>Change the canvas dimension in the program (the <code>canvasWidth</code> and <code>canvasHeight</code> parameters). Keep the value of the two parameters equal. What happens when the values get smaller? What happens when they get bigger?</li>
</ul>
<p><a href="https://github.com/scratchapixel/code/tree/main/computing-pixel-coordinates-of-3d-point" target="_blank">Source Code (external link GitHub)</a></p>
<p>[Source Code (external link Gitee)](</p>

            <footer class="footline">
            </footer>
          </article>

          <article class="default">
            <header class="headline">
            </header>
<h1 id="3d-viewing-the-pinhole-camera-model">3D Viewing: the Pinhole Camera Model</h1>

<h2 id="how-a-pinhole-camera-works-part-1">How a pinhole camera works (part 1)</h2>
<h3 id="what-will-you-learn-in-this-lesson">What Will You Learn in this Lesson?</h3>
<p>In the previous lesson, we learned about some key concepts involved in the process of generating images, however, we didn&rsquo;t speak specifically about cameras. 3D rendering is not only about producing realistic images by the mean of perspective projection. It is also about being able to deliver images similar to that of real-world cameras. Why? Because when CG images are combined with live-action footage, images delivered by the renderer need to match images delivered by the camera with which that footage was produced. In this lesson, we will develop a camera model that allows us to simulate results produced by real cameras (we will use with real-world parameters to set the camera). To do so, we will first start to review how film and photographic cameras work.</p>
<p>More specifically, we will show in this lesson how to implement a camera model similar to that used in Maya and most (if not all) 3D applications (such as Houdini, 3DS Max, Blender, etc.). We will show the effect each control that you can find on a camera has on the final image and how to simulate these controls in CG. This lesson will answer all questions you may have about CG cameras such as what the film aperture parameter does and how the focal length parameter relates to the angle of view parameter.</p>
<p>While the optical laws involved in the process of generating images with a real-world camera are simple, they can be hard to reproduce in CG, not because they are complex but because they are essentially and potentially expensive to simulate. Hopefully, though you don&rsquo;t need very complex cameras to produce images. It&rsquo;s quite the opposite. You can take photographs with a very simple imaging device called a <strong>pinhole camera</strong> which is just a box with a small hole on one side and photographic film lying on the other. Images produced by pinhole cameras are much easier to reproduce (and less costly) than those produced with more sophisticated cameras, and for this reason, the pinhole camera is the model used by most (if not all) 3D applications and video games. Let&rsquo;s start to review how these cameras work in the real world and build a mathematical model from there.</p>
<blockquote>
<details>
It is best to understand the pinhole camera model which is the most commonly used camera model in CG, before getting to the topic of the perspective projection matrix that reuses concepts we will be studying in this lesson such as the camera angle of view, the clipping planes, etc.
</details>
</blockquote>
<h3 id="camera-obscura-how-is-an-image-formed">Camera Obscura: How is an Image Formed?</h3>
<p>Most algorithms we use in computer graphics simulate how things work in the real world. This is particularly true of virtual cameras which are fundamental to the process of creating a computer graphics image. The creation of an image in a real camera is pretty simple to reproduce with a computer. It mainly relies on simulating the way light travels in space and interacts with objects including camera lenses. The light-matter interaction process is highly complex but the laws of optics are relatively simple and can easily be simulated in a computer program. There are two main parts to the principle of photography:</p>
<ul>
<li>The process by which an image is stored on film or in a file.</li>
<li>The process by which this image is created in the camera.</li>
</ul>
<p>In computer graphics, we don&rsquo;t need a physical support to store an image thus simulating the photochemical processes used in traditional film photography won&rsquo;t be necessary (unless like the Maxwell renderer, you want to provide a realistic camera model but this is not necessary to get a basic model working).</p>
<p><a href="#R-image-91e07f9dec072671bd0dc5c225e14735" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/pinholeprinciple.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-91e07f9dec072671bd0dc5c225e14735"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/pinholeprinciple.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 1:</strong> <em>The pinhole camera and camera obscura principle illustrated in 1925, in The Boy Scientist.</em></p>
<p><a href="#R-image-63db0329370aecf08a350c29da40a145" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/cameraobscura.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-63db0329370aecf08a350c29da40a145"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/cameraobscura.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 2:</strong> <em>a camera obscura is a box with a hole on one side. Light passing through that hole forms an inverted image of the scene on the opposite side of the box.</em></p>
<p>Now let&rsquo;s talk about the second part of the photography process: how images are formed in the camera. The <strong>basic</strong> principle of the image creation process is very simple and shown in the reproduction of this illustration published in the early 20th century (Figure 1). In the setup from Figure 1, the first surface (in red) blocks light from reaching the second surface (in green). First, however, make a small hole (a pinhole). Light rays can then pass through the first surface at one point and, by doing so, form an (inverted) image of the candle on the other side (if you follow the path of the rays from the candle to the surface onto which the image of the candle is projected, you can see how the image is geometrically constructed). In reality, the image of the candle will be very hard to see because the amount of light emitted by the candle passing through point B is very small compared to the overall amount of light emitted by the candle itself (only a fraction of the light rays emitted by the flame or reflected off of the candle will pass through the hole).</p>
<p>A <a href="https://en.wikipedia.org/wiki/Camera_obscura" target="_blank">camera obscura</a> (which in Latin means dark room) works on the same principle. It is a lightproof box or room with a black interior (to prevent light reflections) and a tiny hole in the center on one end (Figure 2). Light passing through the hole forms an inverted image of the external scene on the opposite side of the box. This simple device led to the development of photographic cameras. You can perfectly convert your room into a camera obscura, as shown in this video from National Geographic (all rights reserved).</p>
<p><video src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/assets/Making-Your-Own-Room-With-a-View.mp4" width="600" height="450" controls="" preload="auto"></video></p>
<p>To perceive the projected image on the wall your eyes first need to adjust to the darkness of the room, and to capture the effect on a camera, long exposure times are needed (from a few seconds to half a minute). To turn your camera obscura into a <strong>pinhole camera</strong> all you need to do is put a piece of film on the face opposite the pinhole. If you wait long enough (and keep the camera perfectly still), light will modify the chemicals on the film and a latent image will form over time. The principle for a digital camera is the same but the film is replaced by a sensor that converts light into electrical charges.</p>
<h3 id="how-does-real-camera-work">How Does Real Camera Work?</h3>
<p>In a real camera, images are created when light falls on a surface that is sensitive to light (note that this is also true for the eye). For a film camera, this is the surface of the film and for a digital camera, this is the surface of a sensor (or CCD). Some of these concepts have been explained in the lesson <a href="../../../lessons/3d-basic-rendering/introduction-to-ray-tracing/">Introduction to Ray-Tracing</a>, but we will explain them again here briefly.</p>
<p><a href="#R-image-9d6aa35089c0b1f80805bf06c5093e1b" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/cameragen.gif" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-9d6aa35089c0b1f80805bf06c5093e1b"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/cameragen.gif" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 3:</strong> <em>in the real world, when the light from a light source reaches an object, it is reflected into the scene in many directions. However, only one ray goes in the direction of the camera and hits the film&rsquo;s surface or CCD.</em></p>
<p>In the real world, light comes from various light sources (the most important one being the sun). When light hits an object, it can either be absorbed or reflected into the scene. This phenomenon is explained in detail in the lesson devoted to light-matter interaction which you can find in the section Mathematics and Physics for Computer Graphics. When you take a picture, some of that reflected light (in the form of packets of photons) travels in the direction of the camera and passes through the pinhole to form a sharp image on the film or digital camera sensor. We have illustrated this process in Figure 3.</p>
<blockquote>
<details>
Many documents on how photographic film works can be found on the internet. Let's just mention that a film that is exposed to light doesn't generally directly create a visible image. It produces what we call a latent image (invisible to the eye) and we need to process the film with some chemicals in a darkroom to make it visible. If you remove the back door of a disposable camera and replace it with a translucent plastic sheet, you should be able to see the inverted image that is normally projected onto the film (as shown in the images below).
</details>
</blockquote>
<p><a href="#R-image-9e49f3f7cc71dbd478dc111ca8bf3d42" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/realcamera.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-9e49f3f7cc71dbd478dc111ca8bf3d42"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/realcamera.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<h3 id="pinhole-cameras">Pinhole Cameras</h3>
<p>The simplest type of camera we can find in the real world is the pinhole camera. It is a simple lightproof box with a very small hole in the front which is also called an <strong>aperture</strong> and some light-sensitive film paper laid inside the box on the side facing this pinhole. When you want to take a picture, you simply open the aperture to expose the film to light (to prevent light from entering the box, you keep a piece of opaque tape on the pinhole which you remove to take the photograph and put back afterward).</p>
<p><a href="#R-image-e2acb3cba0f768da601b4350487c63ba" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/pinholecam.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-e2acb3cba0f768da601b4350487c63ba"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/pinholecam.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 4:</strong> <em>principle of a pinhole camera. Light rays (which we have artificially colored to track their path better) converge at the aperture and form an inverted image of the scene at the back of the camera, on the film plane.</em></p>
<p>The principle of a pinhole camera is simple. Objects from the scene reflect light in all directions. The size of the aperture is so small that among the many rays that are reflected off at P, a point on the surface of an object in the scene, only one of these rays enter the camera (in reality it&rsquo;s never exactly one ray, but more a bundle of light rays or photons composing a very narrow beam of light). In Figure 3, we can see how one single light ray among the many reflected at P passes through the aperture. In Figure 4, we have colored six of these rays to track their path to the film plane more easily; notice one more time by following these rays how they form an image of the object rotated by 180 degrees. In geometry, the pinhole is also called the <strong>center of projection</strong>; all rays entering the camera converge to this point and diverge from it on the other side.</p>
<p>To summarize: light striking an object is reflected in random directions in the scene, but only one of these rays (or, more exactly, a bundle of these rays traveling along the same direction) enters the camera and strikes the film in one single point. <strong>To each point in the scene corresponds a single point on the film</strong>.</p>
<blockquote>
<details>
In the above explanation, we used the concept of point to describe what's happening locally at the surface of an object (and what's happening locally at the surface of the film); however, keep in mind that the surface of objects is continuous (at least at the macroscopic level) therefore the image of these objects on the surface of the film also appears as continuous.  
What we call a point for simplification, is a small area on the surface of an object or a small area on the surface of the film. It would be best to describe the process involved as an exchange of light energy between surfaces (the emitting surface of the object and the receiving surface or the film in our example), but for simplification, we will just treat these small surfaces as points for now.
</details>
</blockquote>
<p><a href="#R-image-41ecc1664dc7f5f5fcf543b1a87edace" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/pinholeaperture1.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-41ecc1664dc7f5f5fcf543b1a87edace"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/pinholeaperture1.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 5:</strong> <em>top, when the pinhole is small only a small set of rays are entering the camera. Bottom, when the pinhole is much larger, the same point from an object, appears multiple times on the film plane. The resulting image is blurred.</em></p>
<p><a href="#R-image-d3827c2db0e8b8bd94e1dd8798b0fb2d" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/cone.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d3827c2db0e8b8bd94e1dd8798b0fb2d"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/cone.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 6:</strong> <em>in reality, light rays passing through the pinhole can be seen as forming a small cone of light. Its size depends on the diameter of the pinhole (top). When the cones are too large, the disk of light they project on the film surface overlap, which is the cause of blur in images.</em></p>
<p>The size of the aperture matters. To get a fairly sharp image each point (or small area) on the surface of an object needs to be represented as one single point (another small area) on the film. As mentioned before, what passes through the hole is never exactly one ray but more a small set of rays contained within a cone of directions. The angle of this cone (or more precisely its <a href="https://en.wikipedia.org/wiki/Angular_diameter" target="_blank">angular diameter</a>) depends on the size of the hole as shown in Figure 6.</p>
<p><a href="#R-image-f447fb8d69b09256c0fbb1cd9ac0eb86" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/blur.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f447fb8d69b09256c0fbb1cd9ac0eb86"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/blur.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 7:</strong> <em>the smaller the pinhole, the sharper the image. When the aperture is too large, the image is blurred.</em></p>
<p><a href="#R-image-3ed08515784d0aaf99fa987e303756fc" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/confusion.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-3ed08515784d0aaf99fa987e303756fc"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/confusion.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 8:</strong> <em>circles of confusion are much more visible when you photograph bright small objects such as fairy lights on a dark background.</em></p>
<p>The smaller the pinhole, the smaller the cone and the sharper the image. However, a smaller pinhole requires a longer exposure time because as the hole becomes smaller, the amount of light passing through the hole and striking the film surface decreases. It takes a certain amount of light for an image to form on the surface of a photographic paper; thus, the less light it receives, the longer the exposure time. It won&rsquo;t be a problem for a CG camera, but for real pinhole cameras, a longer exposure time increases the risk of producing a blurred image if the camera is not perfectly still or if objects from the scene move. As a general rule, the shorter the exposure time, the better. There is a limit, though, to the size of the pinhole. When it gets very small (when the hole size is about the same as the light&rsquo;s wavelength), light rays are diffracted, which is not good either. For a shoe-box-sized pinhole camera, a pinhole of about 2 mm in diameter should produce optimum results (a good compromise between image focus and exposure time). Note that when the aperture is too large (Figure 5 bottom), a single point on the image, if you keep using the concept of point or discrete lines to represent light rays (for example, point A or B in Figure 5), appears multiple times on the image. A more accurate way of visualizing what&rsquo;s happening in that particular case is to imagine the footprints of the cones overlapping each over on the film (Figure 6 bottom). As the size of the pinhole increases, the cones become larger, and the amount of overlap increases. The fact that a point appears multiple times in the image (in the form of the cone&rsquo;s footprint or spot becoming larger on the film, which you can see as the color of the object at the light ray&rsquo;s origin being spread out on the surface of the film over a larger region rather than appearing as a singular point as it theoretically should) is what causes an image to be blurred (or out of focus). This effect is much more visible in photography when you take a picture of very small and bright objects on a dark background, such as fairy lights at night (Figure 8). Because they are small and generally spaced away from each other, the disks they generate on the picture (when the camera hole is too large) are visible. In photography, these disks (which are not always perfectly circular but explaining why is outside the scope of this lesson) are called <strong>circles of confusion</strong> or disks of confusion, blur circles, blur spots, etc. (Figure 8).</p>
<p>To better understand the image formation process, we created two short animations showing light rays from two disks passing through the camera&rsquo;s pinhole. In the first animation (Figure 9), the pinhole is small, and the image of the disks is sharp because each point on the object corresponds to a single point on the film.</p>
<p><a href="#R-image-b115622fb60a1503be51c253dfb5c80d" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/pinhole1.gif" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b115622fb60a1503be51c253dfb5c80d"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/pinhole1.gif" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 9:</strong> <em>animation showing light rays passing through the pinhole and forming an image on the film plane. The image of the scene is inverted.</em></p>
<p>The second animation (Figure 10) shows what happens when the pinhole is too large. In this particular case, each point on the object corresponds to multiple points on the film. The result is a blurred image of the disks.</p>
<p><a href="#R-image-51fbfacc1685328e7fde25ad2c03fc69" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/pinhole2.gif" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-51fbfacc1685328e7fde25ad2c03fc69"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/pinhole2.gif" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 10:</strong> <em>when the aperture or pinhole is too larger, a point from the geometry appears in multiple places on the film plane, and the resulting image is blurred.</em></p>
<p>In conclusion, to produce a sharp image we need to make the aperture of the pinhole camera as small as possible to ensure that only a narrow beam of photons coming from one single direction enters the camera and hits the film or sensor in one single point (or a surface as small as possible). The <strong>ideal pinhole camera</strong> has an aperture so small that only a single light ray enters the camera for each point in the scene. Such a camera can&rsquo;t be built in the real world though for reasons we already explained (when the hole gets too small, light rays are diffracted) but it can in the virtual world of computers (in which light rays are not affected by diffraction). Note that a renderer using an ideal pinhole camera to produce images of 3D scenes outputs perfectly sharp images.</p>
<p><a href="#R-image-719d7cc6ea42f222bacd09f736fa0ef1" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/gnome-dof.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-719d7cc6ea42f222bacd09f736fa0ef1"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/gnome-dof.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 11:</strong> <em>the lens of a camera causes the depth of field. Lenses can only focus objects at a given distance from the camera. Any objects whose distance to the camera is much smaller or greater than this distance will appear blurred in the image. Depth of field defines the distance between the nearest and the farthest object from the scene that appears &ldquo;reasonably&rdquo; sharp in the image. Pinhole cameras have an infinite depth of field, resulting in perfectly sharp images.</em></p>
<p>In photography, the term <strong>depth of field</strong> (or DOF) defines the distance between the nearest and the farthest object from the scene that appears &ldquo;reasonably&rdquo; sharp in the image. Pinhole cameras have an <strong>infinite depth of field</strong> (but lens cameras have a finite DOF). In other words, the sharpness of an object does not depend on its distance from the camera. Computer graphics images are most of the time produced using an ideal pinhole camera model, and similarly to real-world pinhole cameras, they have an infinite depth of field; all objects from the scene visible through the camera are rendered perfectly sharp. Computer-generated images have sometimes been criticized for being very clean and sharp; the use of this camera model has certainly a lot to do with it. Depth of field however can be simulated quite easily and a lesson from this section is devoted to this topic alone.</p>
<blockquote>
<details>
Very little light can pass through the aperture when the pinhole is very small, and long exposure times are required. It is a limitation if you wish to produce sharp images of moving objects or in low-light conditions. Of course, the bigger the aperture, the more light enters the camera; however, as explained before, this also produces blurred images. The solution is to place a lens in front of the aperture to focus the rays back into one point on the film plane, as shown in the adjacent figure. This lesson is only an introduction to pinhole cameras rather than a thorough explanation of how cameras work and the role of lenses in photography. More information on this topic can be found in the lesson from this section devoted to the topic of depth of field. However, as a note, and if you try to make the relation between how a pinhole camera and a modern camera works, it is important to know that lenses are used to make the aperture as large as possible, allowing more light to get in the camera and therefore reducing exposure times. The role of the lens is to cancel the blurry look of the image we would get if we were using a pinhole camera with a large aperture by refocusing light rays reflected off of the surface of objects to single points on the film. By combining the two, a large aperture and a lens, we get the best of both systems, shorter exposure times, and sharp images (however, the use of lenses introduces depth of field, but as we mentioned before, this won't be studied or explained in this lesson). The great thing about pinhole cameras, though, is that they don't require lenses and are, therefore, very simple to build and are also very simple to simulate in computer graphics.
<p><a href="#R-image-550d6b02489cf7a65dda106df344fab8" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/lens.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-550d6b02489cf7a65dda106df344fab8"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/lens.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
</details>
</blockquote>
<h2 id="how-a-pinhole-camera-works-part-2">How a pinhole camera works (part 2)</h2>
<p>In the first chapter of this lesson, we presented the principle of a pinhole camera. In this chapter, we will show that the size of the photographic film on which the image is projected and the distance between the hole and the back side of the box also play an important role in how a camera delivers images. One possible use of CGI is combining CG images with live-action footage. Therefore, we need our virtual camera to deliver the same type of images as those delivered with a real camera so that images produced by both systems can be composited with each other seamlessly. In this chapter, we will again use the pinhole camera model to study the effect of changing the film size and the distance between the photographic paper and the hole on the image captured by the camera. In the following chapters, we will show how these different controls can be integrated into our virtual camera model.</p>
<h3 id="focal-length-angle-of-view-and-field-of-view">Focal Length, Angle Of View, and Field of View</h3>
<p><a href="#R-image-17999ae931fb4e580594a0ec47a4a44e" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/zoom.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-17999ae931fb4e580594a0ec47a4a44e"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/zoom.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 1:</strong> <em>the sphere projected on the image plane becomes bigger as the image plane moves away from the aperture (or smaller when the image plane gets closer to the aperture). This is equivalent to zooming in and out.</em></p>
<p><a href="#R-image-b9854c335273032c4f1479dae6e95689" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/focallength.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b9854c335273032c4f1479dae6e95689"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/focallength.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 2:</strong> the focal length is the distance from the hole where light enters the camera to the image plane.</p>
<p><a href="#R-image-e0644baea0765d0d65d85da15e1b459c" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/focallength2.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-e0644baea0765d0d65d85da15e1b459c"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/focallength2.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 3:</strong> <em>focal length is one of the parameters that determines the value of the angle of view.</em></p>
<p>Similarly to real-world cameras, our camera model will need a mechanism to control how much of the scene we see from a given point of view. Let&rsquo;s get back to our pinhole camera. We will call the back face of the camera the face on which the image of the scene is projected, the <strong>image plane</strong>. Objects get smaller, and a larger portion of the scene is projected on this plane when you move it closer to the aperture: you <strong>zoom out</strong>. Moving the film plane away from the aperture has the opposite effect; a smaller portion of the scene is captured: you <strong>zoom in</strong> (as illustrated in Figure 1). This feature can be described or defined in two ways: distance from the film plane to the aperture (you can change this distance to adjust how much of the scene you see on film). This distance is generally referred to as the <strong>focal length</strong> or <strong>focal distance</strong> (Figure 2). Or you can also see this effect as varying the angle (making it larger or smaller) of the apex of a triangle defined by the aperture and the film edges (Figures 3 and 4). This angle is called the <strong>angle of view</strong> or <strong>field of view</strong> (or AOV and FOV, respectively).</p>
<p><a href="#R-image-7fbc1c37f0156d94343fda0611b30b14" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/fov.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7fbc1c37f0156d94343fda0611b30b14"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/fov.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 4:</strong> <em>the field of view can be defined as the angle of the triangle in the horizontal or vertical plane of the camera. The horizontal field of view varies with the width of the image plane, and the vertical field of view varies with the height of the image plane.</em></p>
<p><a href="#R-image-539f145ed85b665d0a6a1e513c2f6f31" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/angleofview.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-539f145ed85b665d0a6a1e513c2f6f31"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/angleofview.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 5:</strong> <em>we can use Pythagorean trigonometric identities to find AC if we know both</em> � <em>(which is half the angle of view) and AB (which is the distance from the eye to the canvas).</em></p>
<p>In 3D, the triangle defining how much we see of the scene can be expressed by connecting the aperture to the top and bottom edges of the film or to the left and right edges of the film. The first is the <strong>vertical field of view</strong>, and the second is the <strong>horizontal field of view</strong> (Figure 4). Of course, there&rsquo;s no convention here again; each rendering API uses its own. OpenGL, for example, uses a vertical FOV, while the RenderMan Interface and Maya use a horizontal FOV.</p>
<p>As you can see from Figure 3, there is a direct relation between the focal length and the angle of view. So if AB is the distance from the eye to the canvas (so far, we always assumed that this distance was equal to 1, but this won&rsquo;t always be the case, so we need to consider the generic case), AC is half the canvas size (either the width or the height of the canvas), and the angle (\theta) is half the angle of view. Because ABC is a right triangle, we can use <a href="https://en.wikipedia.org/wiki/Pythagorean_trigonometric_identity" target="_blank">Pythagorean trigonometric identities</a> to find AC if we know both (\theta) and AB:</p>

<span class="math align-center">$$
\begin{array}{l}
\tan(\theta) = \frac {BC}{AB} \\
BC = \tan(\theta) * AB \\
\text{Canvas Size } = 2 * \tan(\theta) * AB \\
\text{Canvas Size } = 2 * \tan(\theta) * \text{ Distance to Canvas }. 
\end{array}
$$</span><p>This is an important relationship because we now have a way of controlling the size of the objects in the camera&rsquo;s view by simply changing one parameter, the angle of view. As we just explained, changing the angle of view can change the extent of a given scene imaged by a camera, an effect more commonly referred to in photography as <strong>zooming in</strong> or <strong>out</strong>.</p>
<h3 id="film-size-matters-too">Film Size Matters Too</h3>
<p><a href="#R-image-ab1b2f703c0ceaa354ab6be902acb1d6" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/filmsize3.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-ab1b2f703c0ceaa354ab6be902acb1d6"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/filmsize3.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 6:</strong> <em>a larger surface (in blue) captures a larger extent of the scene than a smaller surface (in red). A relation exists between the size of the film and the camera angle of view. The smaller the surface, the smaller the angle of view.</em></p>
<p><a href="#R-image-c6e082455bc08e4998d2e5dbdbb117bb" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/filmsize4.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c6e082455bc08e4998d2e5dbdbb117bb"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/filmsize4.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 7:</strong> <em>if you use different film sizes but your goal is to capture the same extent of a scene, you need to adjust the focal length (in this figure denoted by A and B).</em></p>
<p>You can see, in Figure 6, that how much of the scene we capture also depends on the film (or sensor) size. In photography, film size or image sensor size matters. A larger surface (in blue) captures a larger extent of the scene than a smaller surface (in red). Thus, a relation also exists between the size of the film and the camera angle of view. The smaller the surface, the smaller the angle of view (Figure 6b).</p>
<p>Be careful. Confusion is sometimes made between film size and image quality. There is a relation between the two, of course. The motivation behind developing large formats, whether in film or photography, was mostly image quality. The larger the film, the more details and the better the image quality. However, note that if you use films of different sizes but always want to capture the same extent of a scene, you will need to adjust the focal length accordingly (as shown in Figure 7). That is why a 35mm camera with a 50mm lens doesn&rsquo;t produce the same image as a <a href="https://en.wikipedia.org/wiki/Large_format" target="_blank">large format</a> camera with a 50mm lens (in which the film size is about at least three times larger than a 35mm film). The focal length in both cases is the same, but because the film size is different, the angular extent of the scene imaged by the large format camera will be bigger than that of the 35mm camera. It is very important to remember that the size of the surface capturing the image (whether in digital or film) also determines the angle of view (as well as the focal length).</p>
<blockquote>
<details>
The terms **film back** or **film gate** technically designate two things slightly different, but they both relate to film size, which is why the terms are used interchangeably. The first term relates to the film holder, a device generally placed at the back of the camera to hold the film. The second term designates a rectangular opening placed in front of the film. By changing the gate size, we can change the area of the 35 mm film exposed to light. This allows us to change the film format without changing the camera or the film. For example, CinemaScope and Widescreen are formats shot on 35mm 4-perf film with a film gate. Note that film gates are also used with digital film cameras. The film gate defines the film aspect ratio.
<p><a href="#R-image-3dfaff249c7d63f8ae670848f6acd977" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/filmgate.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-3dfaff249c7d63f8ae670848f6acd977"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/filmgate.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>The 3D application Maya groups all these parameters in a Film Back section. For example, when you change the Film Gate parameter, which can be any predefined film format such as 35mm Academy (the most common format used in film) or any custom format, it will change the value of a parameter called Camera Aperture, which defines the horizontal and vertical dimension (in inch or mm) of the film. Under the Camera Aperture parameter, you can see the Film Aspect Ratio, which is the ratio between the &ldquo;physical&rdquo; width of the film and its height. See <a href="https://en.wikipedia.org/wiki/List_of_film_formats" target="_blank">list of film formats</a> for a table of available formats.</p>
<p><a href="#R-image-7467e36f200a50132d8b51ad504202e1" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/mayacamera.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7467e36f200a50132d8b51ad504202e1"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/mayacamera.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>At the end of this chapter, we will discuss the relationship between the film aspect ratio and the image aspect ratio.</p>
</details>
</blockquote>
<blockquote>
<p>It is important to remember that two parameters determine the angle of view: the focal length and the film size. The angle of view changes when you change either one of these parameters: the focal length or the film size.</p>
<ul>
<li>For a fixed film size, changing the focal length will change the angle of view. The longer the focal length, the narrower the angle of view.</li>
<li>For a fixed focal length, changing the film size will change the angle of view. The larger the film, the wider the angle of view.</li>
<li>If you wish to change the film size but keep the same angle of view, you will need to adjust the focal length accordingly.</li>
</ul>
</blockquote>
<p><a href="#R-image-c9ae29b898e2b594276c6dece176b585" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/filmformat.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c9ae29b898e2b594276c6dece176b585"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/filmformat.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 8:</strong> <em>70 mm (left) and 24x35 film (right).</em></p>
<p>Note that three parameters are inter-connected, the angle of view, the focal length, and the film size. With two parameters, we can always infer the third one. Knowing the focal length and the film size, you can calculate the angle of view. If you know the angle of view and the film size, you can calculate the focal length. The next chapter will provide the mathematical equations and code to calculate these values. Though in the end, note that we want the angle of view. If you don&rsquo;t want to bother with the code and the equations to calculate the angle of view from the film size and the focal length, you don&rsquo;t need to do so; you can directly provide your program with a value for the angle of view instead. However, in this lesson, our goal is to simulate a real physical camera. Thus, our model will effectively take into account both parameters.</p>
<blockquote>
<details>
The choice of a film format is generally a compromise between cost, the workability of the camera (the larger the film, the bigger the camera), and the image definition you need. The most common film format (known as the [135 camera film format](https://en.wikipedia.org/wiki/135_film)) used for still photography was (and still is) 36 mm (1.4 in) wide (this file format is better known for being 24 by 35 mm however the exact horizontal size of the image is 36 mm). The next larger size of film for still cameras is the medium format film which is larger than 35 mm (generally 6 by 7 cm), and the large format, which refers to any imaging format of 4 by 5 inches or larger. Film formats used in filmmaking also come in a large variety of sizes. Refrain from assuming though that because we now (mainly) use digital cameras, we should not be concerned by the size of the film anymore. Rather than the size of the film, it is the size of the sensor that we will be concerned about for digital cameras, and similarly to film, that size also defines the extent of the scene being captured. Not surprisingly, sensors you can find on high-end digital DLSR cameras (such as the Canon 1D or 5D) have the same size as the 135 film format: they are 36 mm wide and have a height of 24 mm (Figure 8).
</details>
</blockquote>
<h3 id="image-resolution-and-frame-aspect-ratio">Image Resolution and Frame Aspect Ratio</h3>
<p><strong>The size of a film (measured in inches or millimeters) is not to be confused with the number of pixels in a digital image</strong>. The film&rsquo;s size affects the angle of view, but the image resolution (as in the number of pixels in an image) doesn&rsquo;t. These two camera properties (how big is the image sensor and how many pixels fit on it) are independent of each other.</p>
<p><a href="#R-image-d995c725a53270d8a6082ed32eacbb7a" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/sensor.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d995c725a53270d8a6082ed32eacbb7a"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/sensor.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 9:</strong> <em>image sensor from a Leica camera. Its dimensions are 36 by 24 mm. Its resolution is 6000 by 4000 pixels.</em></p>
<p><a href="#R-image-ec1cbfcb8c4e1c47f31fe1f4dabb4ad7" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/imageaspectratio.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-ec1cbfcb8c4e1c47f31fe1f4dabb4ad7"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/imageaspectratio.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 10:</strong> <em>some common image aspect ratios (the first two examples were common in the 1990s. Today, most cameras or display systems support 2K or 4K image resolutions).</em></p>
<p>In digital cameras, the film is replaced by a sensor. An image sensor is a device that captures light and converts it into an image. You can think of the sensor as the electronic equivalent of film. The image quality depends not only on the size of the sensor but also on how many millions of pixels fit on it. It is important to understand that the film size is equivalent to the sensor size and that it plays the same role in defining the angle of view (Figure 9). However, the number of pixels fitting on the sensor, which defines the image resolution, has no effect on the angle and is a concept purely specific to digital cameras. Pixel resolution (how many pixels fit on the sensor) only determines how good images look and nothing else.</p>
<p>The same concept applies to CG images. We can calculate the same image with different image resolutions. These images will look the same (assuming a constant ratio of width to height), but those rendered using higher resolutions will have more detail than those rendered at lower resolutions. The resolution of the frame is expressed in terms of pixels. We will use the terms <strong>width</strong> and <strong>height resolution</strong> to denote the number of pixels our digital image will have along the horizontal and vertical dimensions. The image itself can be seen as a gate (both the image and the film gate define a rectangle), and for this reason, it is referred to in Maya as the <strong>resolution gate</strong>. At the end of this chapter, we will study what happens when the resolution and film gate <strong>relative size</strong> don&rsquo;t match.</p>
<p>One particular value we can calculate from the image resolution is the <strong>image aspect ratio</strong>, called in CG the <strong>device aspect ratio</strong>. Image aspect ratio is measured as:</p>

<span class="math align-center">$$\text{Image (or Device) Aspect Ratio} = { width \over height }$$</span><p>When the width resolution is greater than the height resolution, the image aspect ratio is greater than 1 (and lower than 1 in the opposite case). This value is important in the real world as most films or display devices, such as computer screens or televisions, have standard aspect ratios. The most common aspect ratios are:</p>
<ul>
<li><strong>4:3</strong>. It was the aspect ratio of old television systems and computer monitors until about 2003; It is still often the default setting on digital cameras. While it seems like an old aspect ratio, this might be true for television screens and monitors, but this is not true for film. The 35mm film format has an aspect ratio of 4:3 (the dimension of one frame is 0.980x0.735 inches).</li>
<li><strong>5:3</strong> and <strong>1.85:1</strong>. These are two very common standard image ratios used in film.</li>
<li><strong>16:9</strong>. It is the standard image ratio used by high-definition television, monitors, and laptops today (with a resolution of 1920x1080).</li>
</ul>
<blockquote>
<details>
The RenderMan Interface specifications set the default image resolution to 640 by 480 pixels, giving a 4:3 Image aspect ratio.
</details>
</blockquote>
<h3 id="canvas-size-and-image-resolution-mind-the-aspect-ratio">Canvas Size and Image Resolution: Mind the Aspect Ratio!</h3>
<p>Digital images have a particularity that physical film doesn&rsquo;t have. The aspect ratio of the sensor or the aspect ratio of what we called the canvas in the previous lesson (the 2D surface on which the image of a 3D scene is drawn) can be different from the aspect ratio of the digital image. You might think: &ldquo;why would we ever want that anyway?&rdquo;. Generally, indeed, this is something other than what we want, and we are going to show why. And yet it happens more often than not. Film frames are often scanned with a gate different than the gate they were shot with, and this situation also arises when working with <a href="https://en.wikipedia.org/wiki/Anamorphic_format" target="_blank">anamorphic formats</a> (we will explain what anamorphic formats are later in this chapter).</p>
<p><a href="#R-image-75c6a612303f13b4d96959690fe3295d" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/aspectratio.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-75c6a612303f13b4d96959690fe3295d"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/aspectratio.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 11:</strong> <em>if the image aspect ratio is different than the film size or film gate aspect ratio, the final image will be stretched in either x or y.</em></p>
<p>Before we consider the case of anamorphic format, let&rsquo;s first consider what happens when the canvas aspect ratio is different from the image or device aspect ratio. Let&rsquo;s take a simple example: what we called the canvas in the previous lesson is a square, and the image on the canvas is that of a circle. We will also assume that the coordinates of the lower-left and upper-right corners of the canvas are [-1,1] and [1,1], respectively. Recall that the process for converting pixel coordinates from screen space to raster space consists of first converting the pixel coordinates from screen space to NDC space and then NDC space to raster space. In this process, the NDC space is the space in which the canvas is remapped to a unit square. From there, this unit square is remapped to the final raster image space. Remapping our canvas from the range [-1,1] to the range [0,1] in x and y is simple enough. Note that both the canvas and the NDC &ldquo;screen&rdquo; are square (their aspect ratio is 1:1). Because the &ldquo;image aspect ratio&rdquo; is preserved in the conversion, the image is not stretched in either x or y (it&rsquo;s only squeezed down within a smaller &ldquo;surface&rdquo;). In other words, visually, it means that if we were to look at the image in NDC space, our circle would still look like a circle. Let&rsquo;s imagine now that the final image resolution in pixels is 640x480. What happens now? The image, which originally had a 1:1 aspect ratio in screen space, is now remapped to a raster image with a 4:3 ratio. Our circle will be stretched along the x-axis, looking more like an oval than a circle (as depicted in Figure 11). <strong>Not preserving the canvas aspect ratio and the raster image aspect ratio leads to stretching the image in either x or y</strong>. It doesn&rsquo;t matter if the NDC space aspect ratio is different from the screen and raster image aspect ratio. You can very well remap a rectangle to a square and then a square back to a rectangle. All that matters is that both rectangles have the same aspect ratio (obviously, stretching is something we want only if the effect is desired, as in the case of anamorphic format).</p>
<p>You may think again, &ldquo;why would that ever happen anyway?&rdquo;. Generally, it doesn&rsquo;t happen because, as we will see in the next chapter, the canvas aspect ratio is often directly computed from the image aspect ratio. Thus if your image resolution is 640x480, we will set the canvas aspect ratio to 4:3.</p>
<p><a href="#R-image-1ac1cc9732110e126626674c16bb227e" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/filmgate3.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-1ac1cc9732110e126626674c16bb227e"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/filmgate3.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 12:</strong> <em>when the resolution and film gates are different (top), you need to choose between two possible options. You can either fit the resolution gate within the film gate (middle) or the film gate within the resolution gate (bottom). Note that the renders look different.</em></p>
<p>However, you may calculate the canvas aspect ratio from the film size (called Film Aperture in Maya) rather than the image size and render the image with a resolution whose aspect ratio is different than that of the canvas. For example, the dimension of a 35mm film format (also known as academy) is 22mm in width and 16mm in height (these numbers are generally given in inches), and the ratio of this format is 1.375. However, a standard 2K scan of a full 35 mm film frame is 2048x1556 pixels, giving a device aspect ratio of 1.31. Thus, the canvas and the device aspect ratios are not the same in this case! What happens, then? Software like Maya offers different user strategies to solve this problem. No matter what, Maya will force at render time your canvas ratio to be the same as your device aspect ratio; however, this can be done in several ways:</p>
<ul>
<li>You can either force the resolution gate within the film gate. This is known as the <strong>Fill</strong> mode in Maya.</li>
<li>Or you can force the film gate within the resolution gate. This is known as the <strong>Overscan</strong> mode in Maya.</li>
</ul>
<p>Both modes are illustrated in Figure 12. Note that if the resolution gate and the film gate are the same, switching between those modes has no effect. However, when they are different, objects in the overscan mode appear smaller than in the fill mode. We will implement this feature in our program (see the last two chapters of this lesson for more detail).</p>
<p><a href="#R-image-1f79ee4ea8a81aa053f4c26c1273d025" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/filmgate2.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-1f79ee4ea8a81aa053f4c26c1273d025"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/filmgate2.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<blockquote>
<details>
What do we do in film production? The Kodak standard for scanning a frame from a 35mm film in 2K is 2048x1556, The resulting 1.31 aspect ratio is slightly lower than the actual film aspect ratio of a full aperture 35mm film, which is 1.33 (the dimension of the frame is 0.980x0.735 inches). This means that we scan slightly more of the film than what's strictly necessary for height (as shown in the adjacent image). Thus, if you set your camera aperture to "35mm Full Aperture", but render your CG renders at resolution 2048x1556 to match the resolution of your 2K scans, the resolution and film aspect ratio won't match. In this case, because the actual film gate fits within the resolution gate during the scanning process, you need to select the "Overscan" mode to render your CG images. This means you will render slightly more than you need at the frame's top and bottom. Once your CG images are rendered, you will be able to composite them to your 2K scan. But you will need to crop your composited images to 2048x1536 to get back to a 1.33 aspect ratio if required (to match the 35mm Full Aperture ratio). Another solution is scanning your 2K images to exactly 2048x1536 (1.33 aspect ratio), another common choice. That way, both the film gate and the resolution gate match.
</details>
</blockquote>
<blockquote>
<details>
The only exception to keeping the canvas and the image aspect ratio the same is when you work with **anamorphic formats**. The concept is simple. Traditional 35mm film cameras have a 1.375:1 gate ratio. To shoot with a widescreen ratio, you need to put a gate in front of the film (as shown in the adjacent image). What it means, though, is that part of the film is wasted. However, you can use a special lens called an anamorphic lens, which will compress the image horizontally so that it fits within as much of the 1.375:1 gate ratio as possible. When the film is projected, another lens stretches images back to their original proportions. The main benefit of shooting anamorphic is the increased resolution (since the image uses a larger portion of the film). Typically anamorphic lenses squeeze the image by a factor of two. For instance, Star Wars (1977) was filmed in a 2.35:1 ratio using an anamorphic camera lens. If you were to composite CG renders into Star Wars footage, you would need to set the resolution gate aspect ratio to ~4:3 (the lens squeezes the image by a factor of 2; if the image ratio is 2:35, then the film ratio is closer to 1.175), and the "film" aspect ratio (the canvas aspect ratio) to 2.35:1. In CG this is typically done by changing what we call the pixel aspect ratio. In Maya, there is also a parameter in the camera controls called Lens Squeeze Ratio, which has the same effect. But this is left to another lesson.
<p><a href="#R-image-dc05029828ed3efcbb3bb61c75858b35" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/anamorphic.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-dc05029828ed3efcbb3bb61c75858b35"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/anamorphic.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
</details>
</blockquote>
<h3 id="conclusion-and-summary-everything-you-need-to-know-about-cameras">Conclusion and Summary: Everything You Need to Know about Cameras</h3>
<p>What is important to remember from the last chapter is that all that matters at the end is the camera&rsquo;s angle of view. You can set its value directly to get the visual result you want.</p>
<blockquote>
<p>I want to combine real film footage with CG elements. The real footage is shot and loaded into Maya as an image plane. Now I want to set up the camera (manually) and create some rough 3D surroundings. I noted down a couple of camera parameters during the shooting and tried to feed them into Maya, but it didn&rsquo;t work out. For example, if I enter the focal length, the resulting view field is too big. I need to familiarize myself with the relationship between focal length, film gate, field of view, etc. How do you tune a camera in Maya to match a real camera? How should I tune a camera to match these settings?</p>
</blockquote>
<p>However, Suppose you wish to build a camera model to simulate physical cameras (the goal of the person we quoted above). In that case, you will need to compute the angle of view by considering the focal length and the film gate size. Many applications, such as Maya, expose these controls (the image below is a screenshot of Maya&rsquo;s UI showing the Render Settings and the Camera attributes). You now understand exactly why they are there, what they do and how to set their value to match the result produced by a real camera. If your goal is to combine CG images with live-action footage, you will need to know the following:</p>
<ul>
<li>
<p>The film gate size. This information is generally given in inches or mm. This information is always available in camera specifications.</p>
</li>
<li>
<p>The focal length. Remember that the angle of view depends on film size for a given focal length. In other words, if you set the focal length to a given value but change the film aperture, the object size will change in the camera&rsquo;s view.</p>
</li>
</ul>
<p><a href="#R-image-acd14b75511a3f3c66fc625bd9e393ab" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/mayacamcontrols.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-acd14b75511a3f3c66fc625bd9e393ab"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/mayacamcontrols.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>However, remember that the resolution gate ratio may differ from the film gate ratio, which you only want if you work with anamorphic formats. For example, suppose the resolution gate ratio of your scan is smaller than the film gate ratio. In that case, you will need to set the Fit Resolution Gate parameter to Overscan as with the example of 2K scans of 35mm full aperture film, whose ratio (1.316:1) is smaller than the actual frame ratio (1.375:1). You need to pay a great deal of attention to this detail if you want CG renders to match the footage.</p>
<p>Finally, the only time when the &ldquo;film gate ratio&rdquo; can be different from the &ldquo;resolution gate ratio&rdquo; is when you work with anamorphic formats (which is quite rare, though).</p>
<h3 id="whats-next">What&rsquo;s Next?</h3>
<p>We are now ready to develop a virtual camera model capable of producing images that match the output of real-world pinhole cameras. In the next chapter, we will show that the angle of view is the only thing we need if we use ray tracing. However, if we use the rasterization algorithm, we must compute the angle of view and the canvas size. We will explain why we need these values in the next chapter and how we can compute them in chapter four.</p>
<h2 id="a-virtual-pinhole-camera-model">A Virtual Pinhole Camera Model</h2>
<p>Our next step is to develop a virtual camera working on the same principle as a pinhole camera. More precisely, our goal is to create a camera model delivering images similar to those produced by a real pinhole camera. For example, if we take a picture of a given object with a pinhole camera, then when a 3D replica of that object is rendered with our virtual camera, the size and shape of the object in the CG render must match exactly the size and shape of the real object in the photograph. But before we start looking into the model itself, it is important to learn a few more things about computer graphics camera models.</p>
<p>First, the details:</p>
<ul>
<li>CG cameras have a near and far clipping plane. Objects closer than the near-clipping plane or farther than the far-clipping plane are invisible to the camera. This lets us can exclude some of a scene&rsquo;s geometry and render only certain portions of the scene. This is necessary for rasterization to work.</li>
<li>In this chapter, we will also see why in CG, the image plane is positioned in front of the camera&rsquo;s aperture rather than behind, as with real pinhole cameras. This plays an important role in how cameras are conventionally defined in CG.</li>
<li>Finally, we must look into how we can render a scene from any given viewpoint. We discussed this in the previous lesson, but this chapter will briefly cover this point.</li>
</ul>
<p>The important question we haven&rsquo;t looked into yet (asked and answered) is, &ldquo;studying real cameras to understand how they work is great, but how is the camera model being used to produce images?&rdquo;. We will show in this chapter that the answer to this question depends on whether we use the rasterization or ray-tracing rendering technique.</p>
<p>In this chapter, we will first review the points listed above one by one to give a complete &ldquo;picture&rdquo; of how cameras work in CG. Then, the virtual camera model will be introduced and implemented in a program in this lesson&rsquo;s next (and final) chapter.</p>
<h3 id="how-do-we-represent-cameras-in-the-cg-world">How Do We Represent Cameras in the CG World?</h3>
<p>Photographs produced by real-world pinhole cameras are upside down. This is happening because, as explained in the first chapter, the film plane is located behind the center of the projection. However, this can be avoided if the projection plane lies on the same side as the scene, as shown in Figure 1. In the real world, the image plane can&rsquo;t be located in front of the aperture because it will not be possible to isolate it from unwanted light, but in the virtual world of computers, constructing our camera that way is not a problem. Conceptually, by construction, this leads to seeing the hole of the camera (which is also the center of projection) as the actual position of the eye, and the image plane, the image that the eye is looking at.</p>
<p><a href="#R-image-64132cc7cc074d210bf1b5291e96ec3c" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/pinholecam1.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-64132cc7cc074d210bf1b5291e96ec3c"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/pinholecam1.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 1:</strong> <em>for our virtual camera, we can move the image plane in front of the aperture. That way, the projected image of the scene on the image plane is not inverted.</em></p>
<p>Defining our virtual camera that way shows us more clearly how constructing an image by following light rays from wherever point in the scene they are emitted from to the eye turns out to be a simple geometrical problem which was given the name of (as you know it now) <strong>perspective projection</strong>. Perspective projection is a method for building an image through this apparatus, a sort of pyramid whose apex is aligned with the eye, whose base defines the surface of a canvas on which the image of the 3D scene is &ldquo;projected&rdquo; onto.</p>
<h3 id="near-and-far-clipping-planes-and-the-viewing-frustum">Near and Far Clipping Planes and the Viewing Frustum</h3>
<p>The <strong>near</strong> and <strong>far clipping</strong> planes are virtual planes located in front of the camera and parallel to the image plane (the plane in which the image is contained). The location of each clipping plane is measured along the camera&rsquo;s line of sight (the camera&rsquo;s local z-axis). They are used in most virtual camera models and have no equivalent in the real world. Objects closer than the near-clipping plane or farther than the far-clipping plane are invisible to the camera. Scanline renderers using the z-buffer algorithm, such as OpenGL, need these clipping planes to control the range of depth values over which the objects&rsquo; depth coordinates are remapped when points from the scene are projected onto the image plane (and this is their primary if only function). Adjusting the near and far clipping planes without getting into too many details can also help resolve precision issues with this type of renderer. The next lesson will find more information on this problem known as z-fighting. In ray tracing, clipping planes are not required by the algorithm to work and are generally not used.</p>
<p><a href="#R-image-ff72f62d90d38e8feb9eac0f27a05ea9" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/frustum.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-ff72f62d90d38e8feb9eac0f27a05ea9"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/frustum.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 2:</strong> <em>any object contained within the viewing frustum is visible.</em></p>
<h3 id="the-near-clipping-plane-and-the-image-plane">The Near Clipping Plane and the Image Plane</h3>
<p><a href="#R-image-287e303b1f247bc6965288ab655d5ebf" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/clippingplanescanvas1.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-287e303b1f247bc6965288ab655d5ebf"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/clippingplanescanvas1.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 3:</strong> <em>the canvas can be positioned anywhere along the local camera z-axis. Note that its size varies with position.</em></p>
<p><a href="#R-image-8809ad0810e7948a0da779abf6bfc9c5" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/canvascoordinates5.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-8809ad0810e7948a0da779abf6bfc9c5"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/canvascoordinates5.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 4:</strong> <em>The canvas is positioned at the near-clipping plane in this example. The bottom-left and top-right coordinates of the canvas are used to determine whether a point projected on the canvas is visible to the camera.</em></p>
<p>The canvas (also called screen in other CG books) is the 2D surface (a bounded region of the image plane) onto which the scene&rsquo;s image is projected. In the previous lesson, we placed the canvas 1 unit away from the eye by convention. However, the position of the canvas along the camera&rsquo;s local z-axis doesn&rsquo;t matter. We only made that choice because it simplified the equations for computing the point&rsquo;s projected coordinates, but, as you can see in Figure 3, the projection of the geometry onto the canvas produces the same image regardless of its position. Thus you are not required to keep the distance from the eye to the canvas equal to 1. We also know that the viewing frustum is a truncated pyramid (the pyramid&rsquo;s base is defined by the far clipping plane, and the top is cut off by the near clipping plane). This volume defines the part of the scene that is visible to the camera. A common way of projecting points onto the canvas in CG is to remap points within the volume defined by the viewing frustum to the <strong>unit cube</strong> (a cube of side length 1). This technique is central to developing the perspective projection matrix, which is the topic of our next lesson. Therefore, we don&rsquo;t need to understand it for now. What is interesting to know about the perspective projection matrix in the context of this lesson, though, is that it works because the image plane is located near the clipping plane. We won&rsquo;t be using the matrix in this lesson nor studying it; however, in anticipation of the next lesson devoted to this topic, we will place the canvas at the near-clipping plane. Remember that this is an arbitrary decision and that unless you use a special technique, such as the perspective projection matrix that requires the canvas to be positioned at a specific location, it can be positioned anywhere along the camera&rsquo;s local z-axis.</p>
<p>From now on, and for the rest of this lesson, we will assume that the canvas (or screen or image plane) is positioned at the near-clipping plane. Remember that this is just an arbitrary decision and that the equations we will develop in the next chapter to project points onto the canvas work independently from its position along the camera&rsquo;s line of sight (which is also the camera z-axis). This setup is illustrated in Figure 4.</p>
<p>Remember that the distance between the eye and the canvas, the near-clipping plane, and the focal length are also different things. We will focus on this point more fully in the next chapter.</p>
<h3 id="computing-the-canvas-size-and-the-canvas-coordinates">Computing the Canvas Size and the Canvas Coordinates</h3>
<p><a href="#R-image-084262e5943cbac7dcd083e5081b519d" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/clippingplanes2.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-084262e5943cbac7dcd083e5081b519d"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/clippingplanes2.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 5:</strong> <em>side view of our camera setup. Objects closer than the near-clipping plane or farther than the far-clipping plane are invisible to the camera. The distance from the eye to the canvas is defined as the near-clipping plane. The canvas size depends on this distance (Znear) and the angle of view. A point is only visible to the camera if the projected point&rsquo;s x and y coordinates are contained within the canvas boundaries (in this example, P1 is visible because P1&rsquo; is contained within the limits of the canvas, while P2 is invisible).</em></p>
<p><a href="#R-image-074aeead71ebb74222777095150bea1f" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/clippingplanes1.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-074aeead71ebb74222777095150bea1f"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/clippingplanes1.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 6:</strong> <em>a point is only visible to the camera if the projected point x- and y-coordinates are contained within the canvas boundaries (in this example P1 is visible because P1&rsquo; is contained within the limits of the canvas, while P2 is invisible).</em></p>
<p><a href="#R-image-cb75886a72cd5e9fb6323ddb07ec518b" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/canvascoordinates6.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-cb75886a72cd5e9fb6323ddb07ec518b"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/canvascoordinates6.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 7:</strong> <em>the canvas coordinates are used to determine whether a point lying on the image plane is visible to the camera.</em></p>
<p>We insisted a lot in the previous section on the fact that the canvas could be anywhere along the camera&rsquo;s local z-axis because that position affects the canvas size. When the distance between the eye and the canvas decreases, the canvas gets smaller, and when that distance increases, it gets bigger. The bottom-left and top-right coordinates of the canvas are directly linked to the canvas size. Once we know the size, computing these coordinates is trivial, considering that the canvas (or screen) is centered on the origin of the image plane coordinate system. Why are these coordinates important? Because they can be used to easily check whether a point projected on the image plane lies within the canvas and is, therefore, visible to the camera. Two points are projected onto the canvas in figures 5, 6, and 7. One of them (P1&rsquo;) is within the canvas limits and visible to the camera. The other (P2&rsquo;) is outside the boundaries and is thus invisible. When we both know the canvas coordinates and the projected coordinates, testing if the point is visible is simple.</p>
<p>Let&rsquo;s see how we can mathematically compute these coordinates. In the second chapter of this lesson, we gave the equation to compute the canvas size (we will assume that the canvas is a square for now, as in figures 3, 4, and 6):</p>

<span class="math align-center">$$\text{Canvas Size} = 2 * \tan({\theta \over 2}) * \text{Distance to Canvas}$$</span><p><strong>Where (\theta) is the angle of view</strong> (hence the division by 2). Note that the vertical and horizontal angles of view are the same when the canvas is a square. Since the distance from the eye to the canvas is defined as the near clipping plane, we can write:</p>

<span class="math align-center">$$\text{Canvas Size} = 2 * \tan({\theta \over 2}) * Z_{near}.$$</span><p>Where (Z_{near}) is the distance between the eye and the near-clipping plane along the camera&rsquo;s local z-axis (Figure 5), since the canvas is centered on the image plane coordinate system&rsquo;s origin, computing the canvas&rsquo;s corner coordinates is trivial. But first, we need to divide the canvas size by 2 and set the sign of the coordinate based on the corner&rsquo;s position relative to the coordinate system&rsquo;s origin:</p>

<span class="math align-center">$$
\begin{array}{l}
\text{top} &=&&\dfrac{\text {canvas size}}{2}\\
\text{right} &=&&\dfrac{\text {canvas size}}{2}\\
\text{bottom} &=&-&\dfrac{\text {canvas size}}{2}\\
\text{left} &=&-&\dfrac{\text {canvas size}}{2}\\
\end{array}
$$</span><p>Once we know the canvas bottom-left and top-right canvas coordinates, we can then compare the projected point coordinates with these values (we, of course, first need to compute the coordinates of the point onto the image plane, which is positioned at the near clipping plane. We will learn how to do so in the next chapter). Points lie within the canvas boundary (and are therefore visible) if their x and y coordinates are either greater or equal and lower or equal than the canvas bottom-left and top-right canvas coordinates, respectively. The following code fragment computes the canvas coordinates and tests the coordinates of a point lying on the image plane against these coordinates:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">float</span> <span class="n">canvasSize</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">tan</span><span class="p">(</span><span class="n">angleOfView</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">Znear</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="kt">float</span> <span class="n">top</span> <span class="o">=</span> <span class="n">canvasSize</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="kt">float</span> <span class="n">bottom</span> <span class="o">=</span> <span class="o">-</span><span class="n">top</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="kt">float</span> <span class="n">right</span> <span class="o">=</span> <span class="n">canvasSize</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="kt">float</span> <span class="n">left</span> <span class="o">=</span> <span class="o">-</span><span class="n">right</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="c1">// compute projected point coordinates
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1"></span><span class="n">Vec3f</span> <span class="n">Pproj</span> <span class="o">=</span> <span class="p">...;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">Pproj</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">left</span> <span class="o">||</span> <span class="n">Pproj</span><span class="p">.</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">right</span> <span class="o">||</span> <span class="n">Pproj</span><span class="p">.</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">bottom</span> <span class="o">||</span> <span class="n">Pproj</span><span class="p">.</span><span class="n">y</span> <span class="o">&gt;</span> <span class="n">top</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="c1">// point outside canvas boundaries. It is not visible.
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="c1">// point inside canvas boundaries. Point is visible
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></div><h3 id="camera-to-world-and-world-to-camera-matrix">Camera to World and World to Camera Matrix</h3>
<p><a href="#R-image-a0d30b130c9d98d096ada123f6efa8b1" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/camera2.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a0d30b130c9d98d096ada123f6efa8b1"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/camera2.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 8:</strong> <em>transforming the camera coordinate system with the camera-to-word transformation matrix.</em></p>
<p>Finally, we need a method to produce images of objects or scenes from any viewpoint. We discussed this topic in the previous lesson, but we will cover it briefly in this chapter. CG cameras are similar to real cameras in that respect. However, in CG, we look at the camera&rsquo;s view (the equivalent of a real camera viewfinder) and move around the scene or object to select a viewpoint (&ldquo;viewpoint&rdquo; is the camera position in relation to the subject).</p>
<p>When a camera is created, by default, it is located at the origin and oriented along the negative z-axis (Figure 8). This orientation is explained in detail in the <a href="../../../lessons/3d-basic-rendering/computing-pixel-coordinates-of-3d-point/mathematics-computing-2d-coordinates-of-3d-points">previous lesson</a>. By doing so, the camera&rsquo;s local and world coordinate system&rsquo;s x-axis point in the same direction. Therefore, defining the camera&rsquo;s transformations with a 4x4 matrix is convenient. This 4x4 matrix which is no different from 4x4 matrices used to transform 3D objects, is called the <strong>camera-to-world</strong> transformation matrix (because it defines the camera&rsquo;s transformations with respect to the world coordinate system).</p>
<p>The camera-to-world transformation matrix is used differently depending on whether rasterization or ray tracing is being used:</p>
<ul>
<li>In rasterization, the inverse of the matrix (the world-to-camera 4x4 matrix) is used to convert points defined in world space to camera space. Once in camera space, we can perform a perspective divide to compute the projected point coordinates in the image plane. An in-depth description of this process can be found in the previous lesson.</li>
<li>In ray tracing, we build camera rays in the camera&rsquo;s default position (the rays&rsquo; origin and direction) and then transform them with the camera-to-world matrix. The full process is detailed in the &ldquo;Ray-Tracing: Generating Camera Rays&rdquo; lesson.</li>
</ul>
<p>Don&rsquo;t worry if you still need to understand how ray tracing works. We will study rasterization first and then move on to ray tracing next.</p>
<h3 id="understanding-how-virtual-cameras-are-used">Understanding How Virtual Cameras Are Used</h3>
<p>At this point of the lesson, we have explained almost everything there is to know about pinhole cameras and CG cameras. However, we still need to explain how images are formed with these cameras. The process depends on whether the rendering technique is rasterization or ray tracing. We are now going to consider each case individually.</p>
<p><a href="#R-image-88dcc67dc8becf51fe0256769cc88d6a" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/pinholecam3.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-88dcc67dc8becf51fe0256769cc88d6a"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/pinholecam3.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 9:</strong> <em>in the real world, when the light from a light source reaches an object, it is reflected into the scene in many directions. Only one ray goes in the camera&rsquo;s direction and strikes the film or sensor.</em></p>
<p><a href="#R-image-349e6e3f42fa993c002d6221aba5b3c2" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/pinholecam2.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-349e6e3f42fa993c002d6221aba5b3c2"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/pinholecam2.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 10:</strong> <em>each ray reflected off of the surface of an object and passing through the aperture, strikes a pixel.</em></p>
<p>Before we do so, let&rsquo;s briefly recall the principle of a pinhole camera again. When light rays emitted by a light source intersect objects from the scene, they are reflected off of the surface of these objects in random directions. For each point of the scene visible by the camera, only one of these reflected rays will pass through the aperture of the pinhole camera and strike the surface of the photographic paper (or film or sensor) in one unique location. If we divide the film&rsquo;s surface into a regular grid of pixels, what we get is a <strong>digital pinhole camera</strong>, which is essentially what we want our virtual camera to be (Figures 9 and 10).</p>
<p>This is how things work with a real pinhole camera. But how does it work in CG? In CG, cameras are built on the principle of a pinhole camera, but the image plane is in front of the center of projection (the aperture, which in our virtual camera model we prefer to call the eye), as shown in Figure 11. How the image is produced with this virtual pinhole camera model depends on the rendering technique. First, let&rsquo;s consider the two main visibility algorithms: rasterization and ray tracing.</p>
<h4 id="rasterization">Rasterization</h4>
<p><a href="#R-image-b836a91aa47efafb069222a6dac0915c" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/pinholecam4.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b836a91aa47efafb069222a6dac0915c"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/pinholecam4.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 11:</strong> <em>perspective projection of 3D points onto the image plane.</em></p>
<p><a href="#R-image-6c487e59ef6fbe79e83ff0e378387449" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/pinholecam5.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-6c487e59ef6fbe79e83ff0e378387449"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/pinholecam5.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 12:</strong> <em>perspective projection of a 3D point onto the image plane.</em></p>
<p>We will have to explain how the rasterization algorithm works in this chapter. To have a complete overview of the algorithm, you are invited to read the lesson devoted to the REYES algorithm, a popular rasterization algorithm. Next, we will examine how the pinhole camera model is used with this particular rendering technique. To do so, let&rsquo;s recall that each ray passing through the aperture of a pinhole camera strikes the film&rsquo;s surface in one location, which is eventually a pixel if we consider the case of digital images.</p>
<p>Let&rsquo;s take the case of one particular ray, R, reflected off of the surface of an object at O, traveling towards the eye in the direction D, passing through the aperture of the camera in A, and striking the image at the pixel location X (Figure 12). To simulate this process, all we need to do is compute in which pixel of an image any given light ray strikes the image and record the color of this light ray (the color of the object at the point where the ray was emitted from, which in the real world, is essentially the information carried by the light ray itself) at that pixel location in the image.</p>
<p>This is the same as calculating the pixel coordinates X of the 3D point O using perspective projection. In perspective projection, the position of a 3D point onto the image plane is found by computing the intersection of a line connecting the point to the eye with the image plane. The method for computing this point of intersection was described in detail in the <a href="../../../lessons/3d-basic-rendering/computing-pixel-coordinates-of-3d-point/mathematics-computing-2d-coordinates-of-3d-points">previous lesson</a>. In the next chapter; we will learn how to compute these coordinates when the canvas is positioned at an arbitrary distance from the eye (in the previous lesson, the distance between the eye and the canvas was always assumed to be equal to 1).</p>
<p>Don&rsquo;t worry too much if you need help understanding clearly how rasterization works at this point. As mentioned before, a lesson is devoted to this topic alone. The only thing you need to remember from that lesson is how we can &ldquo;project&rdquo; 3D points onto the image plane and compute the projected point pixel coordinates. Remember that this is the method that we will be using with rasterization. The projection process can be seen as an interpretation of the way an image is formed inside a pinhole camera by &ldquo;following&rdquo; the path of light rays from whether points they are emitted from in the scene to the eye and &ldquo;recording&rdquo; the position (in terms of pixel coordinates) where these light rays intersect the image plane. To do so, we first need to transform points from world space to camera space, perform a perspective divide on the points in camera space to compute their coordinates in screen space, then convert the points&rsquo; coordinates in screen space to NDC space, and finally convert these coordinates from NDC space to raster space. We used this method in the previous lesson to produce a wireframe image of a 3D object.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="n">each</span> <span class="n">point</span> <span class="n">in</span> <span class="n">the</span> <span class="n">scene</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    <span class="n">transform</span> <span class="n">a</span> <span class="n">point</span> <span class="n">from</span> <span class="n">world</span> <span class="n">space</span> <span class="n">to</span> <span class="n">camera</span> <span class="n">space</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="n">perform</span> <span class="n">perspective</span> <span class="nf">divide</span> <span class="p">(</span><span class="n">x</span><span class="o">/-</span><span class="n">z</span><span class="p">,</span> <span class="n">y</span><span class="o">/-</span><span class="n">z</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">point</span> <span class="n">lies</span> <span class="n">within</span> <span class="n">canvas</span> <span class="n">boundaries</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">        <span class="n">convert</span> <span class="n">coordinates</span> <span class="n">to</span> <span class="n">NDC</span> <span class="n">space</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">        <span class="n">convert</span> <span class="n">coordinates</span> <span class="n">from</span> <span class="n">NDC</span> <span class="n">to</span> <span class="n">raster</span> <span class="n">space</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">        <span class="n">record</span> <span class="n">point</span> <span class="n">in</span> <span class="n">the</span> <span class="n">image</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1">// connect projected points to recreate the object&#39;s edges
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="c1"></span><span class="p">...</span></span></span></code></pre></div><p>In this technique, the image is formed by a collection of &ldquo;points&rdquo; (these are not points, but conceptually, it is convenient to define where the light rays are reflected off the objects&rsquo; surface as points) projected onto the image. In other words, you start from the geometry, and you &ldquo;cast&rdquo; light paths to the eye, to find the pixel coordinates where these rays hit the image plane, and from the coordinates of these intersections points on the canvas, you can then find where they should be recorded in the digital image. So, in a way, the rasterization approach is &ldquo;object-centric&rdquo;.</p>
<h4 id="ray-tracing">Ray-Tracing</h4>
<p><a href="#R-image-3c684b442d4961bed683273d73c1ccbe" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/pinholecam6.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-3c684b442d4961bed683273d73c1ccbe"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/pinholecam6.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 13:</strong> <em>the direction of a light ray R can be defined by tracing a line from point O to the camera&rsquo;s aperture A or from the camera&rsquo;s aperture A to the pixel X, the pixel struck by the ray.</em></p>
<p><a href="#R-image-f621c452f16abfb5c8e00407445852d3" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/pinholecam7.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f621c452f16abfb5c8e00407445852d3"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/pinholecam7.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 14:</strong> <em>the ray-tracing algorithm can be described in three steps. First, we build a ray by tracing a line from the eye to the center of the current pixel. Then, we cast this ray into the scene and check if this ray intersects any geometry in the scene. If it does, we set the current pixel&rsquo;s color to the object&rsquo;s color at the intersection point. This process is repeated for each pixel in the image.</em></p>
<p>The way things work in ray tracing (with respect to the camera model) is the opposite of how the rasterization algorithm works. When a light ray R reflected off of the surface of an object passes through the aperture of the pinhole camera and hits the surface of the image plane, it hits a particular pixel X on the image, as described earlier. In other words, each pixel, X, in an image corresponds to a light ray, R, with a given direction, D, and a given origin O. Note that we do not need to know the ray&rsquo;s origin to define its direction. The ray&rsquo;s direction can be found by tracing a line from O (the point where the ray is emitted) to the camera&rsquo;s aperture A. It can also be defined by tracing a line from pixel X where the ray intersects the camera&rsquo;s aperture A (as shown in Figure 13). Therefore, if you can find the ray direction D by tracing a line from X (the pixel) to A (the camera&rsquo;s aperture), then you can extend this ray into the scene to find O (the origin of the light ray) as shown in Figure 14. This is the ray tracing principle (also called ray casting). We can produce an image by setting the pixel&rsquo;s colors with the color of the light rays&rsquo; respective points of origin. Due to the nature of the pinhole camera, each pixel in the image corresponds to one singular light ray that we can construct by tracing a line from the pixel to the camera&rsquo;s aperture. We then cast this ray into the scene and set the pixel&rsquo;s color to the color of the object the ray intersects (if any — the ray might not intersect any geometry indeed, in which case we set the pixel&rsquo;s color to black). This point of intersection corresponds to the point on the object&rsquo;s surface, from which the light ray was reflected off towards the eye.</p>
<p>Contrary to the rasterization algorithm, ray tracing is &ldquo;image-centric&rdquo;. Rather than following the natural path of the light ray, from the object to the camera (as we do with rasterization in a way), <strong>we follow the same path but in the other direction</strong>, from the camera to the object.</p>
<p>In our virtual camera model, rays are all emitted from the camera origin; thus, the aperture is reduced to a singular point (the center of projection); the concept of aperture size in this model doesn&rsquo;t exist. Our CG camera model behaves as an <strong>ideal pinhole camera</strong> because we consider that a single ray only passes through the aperture (as opposed to a beam of light containing many rays as with real pinhole cameras). This is, of course, impossible with a real pinhole camera. When the hole becomes too small, light rays are diffracted. With such an ideal pinhole camera, we can create perfectly sharp images. Here is the complete algorithm in pseudo-code:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="n">each</span> <span class="n">pixel</span> <span class="n">in</span> <span class="n">the</span> <span class="n">image</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    <span class="c1">// step 1
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="c1"></span>    <span class="n">build</span> <span class="n">a</span> <span class="n">camera</span> <span class="nl">ray</span><span class="p">:</span> <span class="n">trace</span> <span class="n">line</span> <span class="n">from</span> <span class="n">the</span> <span class="n">current</span> <span class="n">pixel</span> <span class="n">location</span> <span class="n">to</span> <span class="n">the</span> <span class="n">camera</span><span class="err">&#39;</span><span class="n">s</span> <span class="n">aperture</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="c1">// step 2
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="c1"></span>    <span class="n">cast</span> <span class="n">ray</span> <span class="n">into</span> <span class="n">the</span> <span class="n">scene</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="c1">// step 3
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">ray</span> <span class="n">intersects</span> <span class="n">an</span> <span class="n">object</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        <span class="n">set</span> <span class="n">the</span> <span class="n">current</span> <span class="n">pixel</span><span class="err">&#39;</span><span class="n">s</span> <span class="n">color</span> <span class="n">with</span> <span class="n">the</span> <span class="n">object</span><span class="err">&#39;</span><span class="n">s</span> <span class="n">color</span> <span class="n">at</span> <span class="n">the</span> <span class="n">intersection</span> <span class="n">point</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">        <span class="n">set</span> <span class="n">the</span> <span class="n">current</span> <span class="n">pixel</span><span class="err">&#39;</span><span class="n">s</span> <span class="n">color</span> <span class="n">to</span> <span class="n">black</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p><a href="#R-image-98bb992cb0dc8d2047363ea2f645542a" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/pinholecam8.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-98bb992cb0dc8d2047363ea2f645542a"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/pinholecam8.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 15:</strong> <em>the point visible to the camera is the point with the closest distance to the eye.</em></p>
<p>As explained in the first lesson, ray-tracing things are a bit more complex because any camera ray can intersect several objects, as shown in Figure 15. Of all these points, the point visible to the camera is the closest distance to the eye. Suppose you are interested in a quick introduction to the ray-tracing algorithm. In that case, you can read the <a href="../../../lessons/3d-basic-rendering/introduction-to-ray-tracing/">first lesson</a> of this section or keep reading the lessons from this section devoted to ray-tracing specifically.</p>
<p>Advanced: it may have come to your mind that several rays may be striking the image at the same pixel location. This idea is illustrated in the adjacent image. This happens all the time in the real world because the surfaces from which the rays are reflected are continuous. In reality, we have the projection of a continuous surface (the surface of an object) onto another continuous surface (the surface of a pixel). It is important to remember that a pixel in the physical world is not an ideal point but a surface receiving light reflected off from another surface. It would be more accurate to see the phenomenon (which we often do in CG) as <strong>an &ldquo;exchange&rdquo; or transport of light energy between surfaces</strong>. You can find information on this topic in lessons from the Mathematics and Physics of Compute Graphics (check the Mathematics of Shading and Monte Carlo Methods) as well as the lesson called Monte Carlo Ray Tracing and Path Tracing.</p>
<h3 id="whats-next-1">What&rsquo;s Next?</h3>
<p>We are finally ready to implement a pinhole camera model with the same controls as the controls you can find in software such as Maya. It will be followed as usual with the source code of a program capable of producing images matching the output of Maya.</p>
<h2 id="implementing-a-virtual-pinhole-camera">Implementing a Virtual Pinhole Camera</h2>
<h3 id="implementing-a-virtual-pinhole-camera-model">Implementing a Virtual Pinhole Camera Model</h3>
<p>In the last three chapters, we have learned everything there is to know about the pinhole camera model. This type of camera is the simplest to simulate in CG and is the model most commonly used by video games and 3D applications. As briefly mentioned in the first chapter, pinhole cameras, by their design, can only produce sharp images (without any depth of field). While simple and easy to implement, the model is also often criticized for not being able to simulate visual effects such as depth of field or lens flare. While some perceive these effects as visual artifacts, they play an important role in the aesthetic experiences of photographs and films. Simulating these effects is relatively easy (because it essentially relies on well-known and basic optical rules) but very costly, especially compared to the time it takes to render an image with a basic pinhole camera model. We will present a method for simulating depth of field in another lesson (which is still costly but less costly than if we had to simulate depth of field by following the path of light rays through the various optics of a camera lens).</p>
<p>In this chapter, we will use everything we have learned in the previous chapters about the pinhole camera model and write a program to implement this model. To convince you that this model works and that there is nothing mysterious or magical about how images are produced in software such as Maya. We will produce a series of images by changing different camera parameters in Maya and our program and compare the results. If all goes well, when the camera settings match, the two applications&rsquo; images should also match. Let&rsquo;s get started.</p>
<h3 id="implementing-an-ideal-pinhole-camera-model">Implementing an Ideal Pinhole Camera Model</h3>
<p>When we refer to the pinhole camera in the rest of this chapter, we will use the terms focal length and film size. Please distinguish them from the near-clipping plane and the canvas size terms. The former applies to the pinhole camera, and the latter applies to the virtual camera model only. However, they do relate to each other. Let&rsquo;s quickly explain again how.</p>
<p><a href="#R-image-05dd615e548a001ce6463e4be68ed155" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/clippingplanescanvas.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-05dd615e548a001ce6463e4be68ed155"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/clippingplanescanvas.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 1:</strong> <em>mathematically, the canvas can be anywhere we want along the line of sight. Its boundaries are defined as the intersection of the image plane with the viewing frustum.</em></p>
<p>The pinhole and virtual cameras must have the same viewing frustum to deliver the same image. The viewing frustum itself is defined by two and only two parameters: the point of convergence, the camera or eye origin (all these terms designate the same point), and the angle of view. We also learned in the previous chapters that the angle of view was defined by the film size and the focal length, two parameters of the pinhole camera.</p>
<h4 id="where-shall-the-canvasscreen-be">Where Shall the Canvas/Screen Be?</h4>
<p>In CG, once the viewing frustum is defined, we then need to define where is the virtual image plane going to be. Mathematically though, the canvas can be anywhere we want along the line of sight, as long as the surface on which we project the image is contained within the viewing frustum, as shown in Figure 1; it can be anywhere between the apex of the pyramid (obviously not the apex itself) and its base (which is defined by the far clipping plane) or even further if we wanted to.</p>
<blockquote>
<details>
**Don't mistake the distance between the eye (the center of projection) and the canvas for the focal length**. They are not the same. The **position of the canvas does not define how wide or narrow the viewing frustum is** (neither does the near clipping plane); the viewing frustum shape is only defined by the focal length and the film size (the combination of both parameters defines the angle of view and thus the magnification at the image plane). As for the near-clipping plane, it is just an arbitrary plane which, with the far-clipping plane, is used to "clip" geometry along the camera's local z-axis and remap points z-coordinates to the range [0,1]. Why and how the remapping is done is explained in the lesson on the REYES algorithm, a popular rasterization algorithm, and the next lesson is devoted to the perspective projection matrix.
</details>
</blockquote>
<p>When the distance between the eye and the image plane is equal to 1, it is convenient because it simplifies the equations to compute the coordinates of a point projected on the canvas. However, if we were making that choice, we wouldn&rsquo;t have the opportunity to study the generic (and slightly more complex) case in which the distance to the canvas is arbitrary. And since our goal on Scratchapixel is to learn how things work rather than make our life easier, let&rsquo;s skip this option and choose the generic case instead. For now, we decided to position the canvas at the near-clipping plane. Refrain from trying to make any sense as to why we decide to do so. It is only motivated by pedagogical reasons. The near-clipping plane is a parameter that the user can change by setting the image plane at the near-clipping plane; this forces us to study the equations for projecting points on a canvas located at an arbitrary distance from the eye. We are also cheating slightly because the way the perspective projection matrix works is based on implicitly setting up the image plane at the near-clipping plane. Thus by making this choice, we also anticipate what we will study in the next lesson. However, remember that <strong>where the canvas is positioned does not affect the output image</strong> (the image plane can be located between the eye and the near-clipping plane. Objects between the eye and the near clipping plane could still be projected on the image plane; equations for the perspective matrix would still work).</p>
<h4 id="what-will-our-program-do">What Will our Program Do</h4>
<p>In this lesson, we will create a program to generate a wireframe image of a 3D object by projecting the object&rsquo;s vertices onto the image plane. The program will be very similar to the one we wrote in the previous lesson; we will now extend the code to integrate the concept of focal length and film size. Film formats are generally rectangular, not square. Thus, our program will also output images with a rectangular shape. Remember that in chapter 2, we mentioned that the resolution gate aspect ratio, also called the device aspect ratio (the image width over its height), was not necessarily the same as the film gate aspect ratio (the film width over its height). In the last part of this chapter, we will also write some code to handle this case.</p>
<p>Here is a list of the parameters our pinhole camera model will require:</p>
<h4 id="intrinsic-parameters">Intrinsic Parameters</h4>
<p><a href="#R-image-291d9f322071456820c3d175b28b4c2f" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/table-1.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-291d9f322071456820c3d175b28b4c2f"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/table-1.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<h4 id="extrinsic-parameters">Extrinsic Parameters</h4>
<p><a href="#R-image-cb40abc4d75f659ac1cb13f602c8bafa" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/20240216172757.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-cb40abc4d75f659ac1cb13f602c8bafa"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/20240216172757.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>We will also need the following parameters, which we can compute from the parameters listed above:</p>
<p><a href="#R-image-5d7d3b975ad6bd158c4925fdfaf4fd6e" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/20240216172826.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-5d7d3b975ad6bd158c4925fdfaf4fd6e"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/20240216172826.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><a href="#R-image-df8b8be7b369afe9af3c8760ed9e9c3f" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/canvascoordinates.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-df8b8be7b369afe9af3c8760ed9e9c3f"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/canvascoordinates.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 2:</strong> <em>the bottom-left and top-right coordinates define the boundaries of the canvas. Any projected point whose x- and y-coordinates are contained within these boundaries are visible to the camera.</em></p>
<p><a href="#R-image-4942e1b9cf215507a95fda57c113b5ad" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/canvascoordinates2.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-4942e1b9cf215507a95fda57c113b5ad"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/canvascoordinates2.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 3:</strong> <em>the canvas size depends on the near-clipping plane and the horizontal angle of the field of view. We can easily infer the canvas&rsquo;s bottom-left and top-right coordinates from the canvas size.</em></p>
<p>Remember that when a 3D point is projected onto the image plane, we need to test the projected point x- and y-coordinates against the canvas coordinates to find out if the point is visible in the camera&rsquo;s view or not. Of course, the point can only be visible if it lies within the canvas limits. We already know how to compute the projected point coordinates using perspective divide. But we still need to know the canvas&rsquo;s bottom-left and top-right coordinates (Figure 2). How do we find these coordinates, then?</p>
<p>In almost every case, we want the canvas to be centered around the canvas coordinate system origin (Figures 2, 3, and 4). However, this is only sometimes or doesn&rsquo;t have to be the case. A stereo camera setup, for example, requires the canvas to be slightly shifted to the left or the right of the coordinate system origin. Therefore, this lesson will always assume that the canvas is centered on the image plane coordinate system origin.</p>
<p><a href="#R-image-f36867eb8f42ea799acfbb7d07d301e5" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/canvascoordinates3.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f36867eb8f42ea799acfbb7d07d301e5"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/canvascoordinates3.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 4:</strong> <em>computing the canvas bottom-left and top-right coordinates is simple when we know the canvas size.</em></p>
<p><a href="#R-image-c17e44d98c578f58fe0efa7ef75b8e27" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/angleofview1.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c17e44d98c578f58fe0efa7ef75b8e27"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/angleofview1.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 5:</strong> <em>vertical and horizontal angle of view.</em></p>
<p><a href="#R-image-b256d151fdc38d06de1009c774b73ca4" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/canvascoordinates4.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b256d151fdc38d06de1009c774b73ca4"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/canvascoordinates4.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 6:</strong> <em>the film aperture width and the focal length are used to calculate the camera&rsquo;s angle of view.</em></p>
<p>Computing the canvas or screen window coordinates is simple. Since the canvas is centered about the screen coordinate system origin, they are equal to half the canvas size. They are negative if they are either below or to the left of the y-axis and x-axis of the screen coordinate system, respectively (Figure 4). The canvas size depends on the angle of view and the near-clipping plane (since we decided to position the image plane at the near-clipping plane). The angle of view depends on the film size and the focal length. Let&rsquo;s compute each one of these variables.</p>
<p>Note, though, that the film format is more often rectangular than square, as mentioned several times. Thus the angular horizontal and vertical extent of the viewing frustum is different. So we will need the horizontal angle of view to compute the left and right coordinates and the vertical angle of view to compute the bottom and top coordinates.</p>
<h4 id="computing-the-canvas-coordinates-the-long-way">Computing the Canvas Coordinates: The Long Way</h4>
<p>Let&rsquo;s start with the horizontal angle of view. In the previous chapters, we introduced the equation to compute the angle of view. It can easily be done using trigonometric identities. If you look at the camera setup from the top, you can see that we can trace a right triangle (Figure 6). The adjacent and opposite sides of the triangles are known: they correspond to the focal length and half of the film&rsquo;s horizontal aperture. However, they must be defined in the same unit to be used in a trigonometric identity. Typically, film gate dimensions are defined in inches, and focal length is defined in millimeters. Generally, inches are converted into millimeters, but you can convert millimeters to inches if you prefer; the result will be the same. One inch corresponds to 25.4 millimeters. To find the horizontal angle of view, we will use a trigonometric identity that says that the tangent of an angle is the ratio of the length of the opposite side to the length of the adjacent side (equation 1):</p>

<span class="math align-center">$$
\begin{array}{l}
\tan({\theta_H \over 2}) & = & {A \over B} \\& = & \color{red}{\dfrac {\dfrac { (\text{Film Aperture Width} * 25.4) } { 2 } } { \text{Focal Length} }}.
\end{array}
$$</span><p>Where (\theta_H) is the horizontal angle of view, we can compute the canvas size now that we have theta. We know it depends on the angle of view and the near-clipping plane (because the canvas is positioned at the near-clipping plane). We will use the same trigonometric identity (Figure 6) to compute the canvas size (equation 2):</p>

<span class="math align-center">$$
\begin{array}{l}
\tan({\theta_H \over 2}) = {A \over B} =
\dfrac{\dfrac{\text{Canvas Width} } { 2 } } { Z_{near} }, \\
\dfrac{\text{Canvas Width} } { 2 } = \tan({\theta_H \over 2}) * Z_{near},\\
\text{Canvas Width}= 2 * \color{red}{\tan({\theta_H \over 2})} * Z_{near}.
\end{array}
$$</span><p>If we want to avoid computing the trigonometric function <code>tan()</code>, we can substitute the function on the right-hand side of equation 1:</p>

<span class="math align-center">$$
\begin{array}{l}
\text{Canvas Width}= 2 * \color{red}{\dfrac {\dfrac { (\text{Film Aperture Width} * 25.4) } { 2 } } { \text{Focal Length} }} * Z_{near}.
\end{array}
$$</span><p>To compute the right coordinate, we need to divide the whole equation by 2. We get:</p>

<span class="math align-center">$$
\begin{array}{l}
\text{right} = \color{red}{\dfrac {\dfrac { (\text{Film Aperture Width} * 25.4) } { 2 } } { \text{Focal Length} }} * Z_{near}.
\end{array}
$$</span><p>Computing the left is trivial. For example, here is a code fragment to compute the left and right coordinates:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">float</span> <span class="n">focalLength</span> <span class="o">=</span> <span class="mi">35</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1">// 35mm Full Aperture
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="c1"></span><span class="kt">float</span> <span class="n">filmApertureWidth</span> <span class="o">=</span> <span class="mf">0.980</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="kt">float</span> <span class="n">filmApertureHeight</span> <span class="o">=</span> <span class="mf">0.735</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="k">static</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">inchToMm</span> <span class="o">=</span> <span class="mf">25.4</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="kt">float</span> <span class="n">nearClippingPlane</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="kt">float</span> <span class="n">farClipingPlane</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="cp">#if 0</span><span class="c">
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="c">    // First method. Compute the horizontal angle of view first
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="c">    float angleOfViewHorizontal = 2 * atan((filmApertureWidth * inchToMm / 2) / focalLength);
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="c">    float right = tan(angleOfViewHorizontal / 2) * nearClippingPlane;
</span></span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="c"></span><span class="cp">#else
</span></span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="cp"></span>    <span class="c1">// Second method. Compute the right coordinate directly
</span></span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="c1"></span>    <span class="kt">float</span> <span class="n">right</span> <span class="o">=</span> <span class="p">((</span><span class="n">filmApertureWidth</span> <span class="o">*</span> <span class="n">inchToMm</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">focalLength</span><span class="p">)</span> <span class="o">*</span> <span class="n">nearClippingPlane</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">    <span class="kt">float</span> <span class="n">left</span> <span class="o">=</span> <span class="o">-</span><span class="n">right</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">
</span></span><span class="line"><span class="ln">22</span><span class="cl">    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Screen window left/right coordinates %f %f</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">
</span></span><span class="line"><span class="ln">24</span><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>We can use the same technique to compute the top and bottom coordinates, only this time; we need to compute the vertical angle of view ((\theta_V)):</p>

<span class="math align-center">$$
\tan({\theta_V \over 2}) = {A \over B} = \color{red}{\dfrac {\dfrac { (\text{Film Aperture Height} * 25.4) } { 2 } } { \text{Focal Length} }}.
$$</span><p>We can then find the equation for the top coordinate:</p>

<span class="math align-center">$$
\text{top} = \color{red}{\dfrac {\dfrac { (\text{Film Aperture Height} * 25.4) } { 2 } } { \text{Focal Length} }} * Z_{near}.
$$</span><p>Here is the code to compute all four coordinates:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="cp">#if 0</span><span class="c">
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c">    // First method. Compute the horizontal and vertical angle of view first
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="c">    float angleOfViewHorizontal = 2 * atan((filmApertureWidth * inchToMm / 2) / focalLength);
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="c">    float right = tan(angleOfViewHorizontal / 2) * nearClippingPlane;
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c">    float angleOfViewVertical = 2 * atan((filmApertureHeight * inchToMm / 2) / focalLength);
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="c">    float top = tan(angleOfViewVertical / 2) * nearClippingPlane;
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c"></span><span class="cp">#else
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="cp"></span>    <span class="c1">// Second method. Compute the right and top coordinates directly
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="c1"></span>    <span class="kt">float</span> <span class="n">right</span> <span class="o">=</span> <span class="p">((</span><span class="n">filmApertureWidth</span> <span class="o">*</span> <span class="n">inchToMm</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">focalLength</span><span class="p">)</span> <span class="o">*</span> <span class="n">nearClippingPlane</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="kt">float</span> <span class="n">top</span> <span class="o">=</span> <span class="p">((</span><span class="n">filmApertureHeight</span> <span class="o">*</span> <span class="n">inchToMm</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">focalLength</span><span class="p">)</span> <span class="o">*</span> <span class="n">nearClippingPlane</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="kt">float</span> <span class="n">left</span> <span class="o">=</span> <span class="o">-</span><span class="n">right</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="kt">float</span> <span class="n">bottom</span> <span class="o">=</span> <span class="o">-</span><span class="n">top</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">
</span></span><span class="line"><span class="ln">18</span><span class="cl">    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Screen window bottom-left, top-right coordinates %f %f %f %f</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">bottom</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">top</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><h4 id="computing-the-canvas-coordinates-the-quick-way">Computing the Canvas Coordinates: The Quick Way</h4>
<p>The code we wrote is working just fine. However, there is a slightly faster way of computing the canvas coordinates (which you will likely see being used in production code). The method consists of computing the vertical angle of view to get the bottom-top coordinates, and they multiply these coordinates by the film aspect ratio. Mathematically this is working because this comes back to writing:</p>

<span class="math align-center">$$
\begin{array}{l}
\text{right} & = & \text{top} * \dfrac{\text{Film Aperture Width}}{\text{Film Aperture Height}} \\
& = & \color{}{\dfrac {\dfrac { (\text{Film Aperture Height} * 25.4) } { 2 } } { \text{Focal Length} }} * Z_{near} * \dfrac{\text{Film Aperture Width}}{\text{Film Aperture Height}} \\
& = & \color{}{\dfrac {\dfrac { (\text{Film Aperture Width} * 25.4) } { 2 } } { \text{Focal Length} }} * Z_{near}.
\end{array}
$$</span><p>The following code shows how to implement this solution:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="kt">float</span> <span class="n">top</span> <span class="o">=</span> <span class="p">((</span><span class="n">filmApertureHeight</span> <span class="o">*</span> <span class="n">inchToMm</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">focalLength</span><span class="p">)</span> <span class="o">*</span> <span class="n">nearClippingPlane</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="kt">float</span> <span class="n">bottom</span> <span class="o">=</span> <span class="o">-</span><span class="n">top</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="kt">float</span> <span class="n">filmAspectRatio</span> <span class="o">=</span> <span class="n">filmApertureWidth</span> <span class="o">/</span> <span class="n">filmApertureHeight</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="kt">float</span> <span class="n">left</span> <span class="o">=</span> <span class="n">bottom</span> <span class="o">*</span> <span class="n">filmAspectRatio</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="kt">float</span> <span class="n">left</span> <span class="o">=</span> <span class="o">-</span><span class="n">right</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Screen window bottom-left, top-right coordinates %f %f %f %f</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">bottom</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">top</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><h4 id="does-it-work-checking-the-code">Does it Work? Checking the Code</h4>
<p><a href="#R-image-3bc8561e45e44075b4be3264134f2178" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/similartriangles1.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-3bc8561e45e44075b4be3264134f2178"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/similartriangles1.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 7:</strong> <em>P&rsquo; is the projection of P on the canvas.</em></p>
<p>Before we test the code, we need to make a slight change to the function that projects points onto the image plane. Remember that to compute the projected point coordinates; we use a property of similar triangles. For example, if A, B, A&rsquo; and B&rsquo; are the opposite and adjacent sides of two similar triangles, then we can write:</p>

<span class="math align-center">$$
\begin{array}{l}
{A \over B} = {A' \over B'} = {P.y \over P.z} = {P'.y \over Z_{near}}\\
P'.y = {P.y \over P.z } * Z_{near} 
\end{array}
$$</span><p>In the previous lesson, we positioned the canvas 1 unit away from the eye. Thus the near clipping plane was equal to 1, and it reduced the equation to a simple division of the point x- and y-coordinates by the point z-coordinate (in other words, we ignored \(Z_{near}\)). We will also test whether the point is visible in the function to compute the projected point coordinates. We will compare the Finally, projected point coordinates with the canvas coordinates. In the program, if any of the triangle&rsquo;s vertices are outside the canvas boundaries, we will draw the triangle in red (if you see a red triangle in the image, then at least one of its vertices lies outside the canvas). Here is an updated version of the function projecting points onto the canvas and computing the raster coordinates of a 3D point:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">bool</span> <span class="nf">computePixelCoordinates</span><span class="p">(</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    <span class="k">const</span> <span class="n">Vec3f</span> <span class="o">&amp;</span><span class="n">pWorld</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="k">const</span> <span class="n">Matrix44f</span> <span class="o">&amp;</span><span class="n">worldToCamera</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="k">const</span> <span class="kt">float</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="k">const</span> <span class="kt">float</span> <span class="o">&amp;</span><span class="n">l</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="k">const</span> <span class="kt">float</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="k">const</span> <span class="kt">float</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="k">const</span> <span class="kt">float</span> <span class="o">&amp;</span><span class="n">near</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="k">const</span> <span class="kt">uint32_t</span> <span class="o">&amp;</span><span class="n">imageWidth</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="k">const</span> <span class="kt">uint32_t</span> <span class="o">&amp;</span><span class="n">imageHeight</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="n">Vec2i</span> <span class="o">&amp;</span><span class="n">pRaster</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="n">Vec3f</span> <span class="n">pCamera</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="n">worldToCamera</span><span class="p">.</span><span class="n">multVecMatrix</span><span class="p">(</span><span class="n">pWorld</span><span class="p">,</span> <span class="n">pCamera</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="n">Vec2f</span> <span class="n">pScreen</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="n">pScreen</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">pCamera</span><span class="p">.</span><span class="n">x</span> <span class="o">/</span> <span class="o">-</span><span class="n">pCamera</span><span class="p">.</span><span class="n">z</span> <span class="o">*</span> <span class="n">near</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">    <span class="n">pScreen</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">pCamera</span><span class="p">.</span><span class="n">y</span> <span class="o">/</span> <span class="o">-</span><span class="n">pCamera</span><span class="p">.</span><span class="n">z</span> <span class="o">*</span> <span class="n">near</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">
</span></span><span class="line"><span class="ln">19</span><span class="cl">    <span class="n">Vec2f</span> <span class="n">pNDC</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">    <span class="n">pNDC</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">pScreen</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">r</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">    <span class="n">pNDC</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">pScreen</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">t</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">t</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">    <span class="n">pRaster</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">pNDC</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">imageWidth</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">    <span class="n">pRaster</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">pNDC</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="n">imageHeight</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">
</span></span><span class="line"><span class="ln">25</span><span class="cl">    <span class="kt">bool</span> <span class="n">visible</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">pScreen</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">l</span> <span class="o">||</span> <span class="n">pScreen</span><span class="p">.</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">r</span> <span class="o">||</span> <span class="n">pScreen</span><span class="p">.</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">b</span> <span class="o">||</span> <span class="n">pScreen</span><span class="p">.</span><span class="n">y</span> <span class="o">&gt;</span> <span class="n">t</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl">        <span class="n">visible</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">28</span><span class="cl">
</span></span><span class="line"><span class="ln">29</span><span class="cl">    <span class="k">return</span> <span class="n">visible</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">30</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>Here is a summary of the changes we made to the function:</p>
<ul>
<li>Lines 16 and 17: the result of the perspective divide is multiplied by the near-clipping plane.</li>
<li>Lines 20 and 21: to remap the point from screen space to NDC space, we divide the point x and y-coordinates in screen space by the canvas width and height, respectively.</li>
<li>Lines 26 and 27: the point coordinates in screen space are compared with the bottom-left, top-right canvas coordinates. If the point lies outside, we set the visible variable to false.</li>
</ul>
<p>The rest of the program (which you can find in the source code section) is similar to the previous program. We loop over all the triangles of the 3D model, convert the triangle&rsquo;s vertices coordinates to raster coordinates and store the result in an SVG file. Let&rsquo;s render a few images in Maya and with our program and check the results.</p>
<p><a href="#R-image-01dbb69dbb82748e9b7bf73f5053175e" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/cameraresults.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-01dbb69dbb82748e9b7bf73f5053175e"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/cameraresults.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p>As you can see, the results match. Maya and our program produce the same results (the size and position of the model in the images are consistent between applications). When the triangles overlap the canvas boundaries, they are red, as expected.</p>
<h4 id="when-the-resolution-gate-and-film-gate-ratio-dont-match">When the Resolution Gate and Film Gate Ratio Don&rsquo;t Match</h4>
<p>When the film gate aspect ratio and the resolution gate aspect ratio (also called device aspect ratio) are different, we need to decide whether we fit the resolution gate within the film gate or the other way around (the film gate is fit to match the resolution gate). Let&rsquo;s check what the different options are:</p>
<blockquote>
<details>
In the following text, when we say that the film gate matches the resolution gate, we only mean that they match in terms of relative size (otherwise, they couldn't be compared to each other since they are not expressed in the same units. The former is expressed in inches and the latter in pixels). Therefore, if we draw a rectangle to represent the film gate, for instance, then we will draw the resolution gate so that either the top and bottom of the left and right side of the resolution gate rectangle are aligned with the top and bottom or left and right side of the film gate rectangle respectively (this is what we did in Figure 8).
</details>
</blockquote>
<p><a href="#R-image-b1d0fc1a701507888bafd9c9ac42d99b" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/fitgateresolution3.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b1d0fc1a701507888bafd9c9ac42d99b"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-5/../assets/fitgateresolution3.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 8:</strong> <em>when the film gate aspect ratio and the resolution gate ratio don&rsquo;t match, we need to choose between four options.</em></p>
<ul>
<li><strong>Fill Mode</strong>: we fit the resolution gate within the film gate (the blue box is contained within the red box). We have to handle two cases:
<ul>
<li>Figure 8a: when the film aspect ratio is greater than the device aspect ratio, the canvas left, and right coordinates need to be scaled down to match the left and right coordinates of the resolution gate. This can be done by multiplying the left and right coordinates by the resolution aspect ratio over the film aspect ratio.</li>
<li>Figure 8c: when the film aspect ratio is lower than the device aspect ratio, the canvas top and bottom coordinates need to be scaled down to match the top and bottom coordinates of the resolution gate. This can be done by multiplying the top and bottom coordinates by the film aspect ratio over the resolution aspect ratio.</li>
</ul>
</li>
<li><strong>Overscan Mode</strong>: we fit the film gate within the resolution gate (the red box is contained within the blue box). We have to handle two cases:
<ul>
<li>Figure 8b: when the film aspect ratio is greater than the device aspect ratio, the canvas top and bottom coordinates need to be scaled up to match the resolution gate top and bottom coordinates. To do so, we multiply the canvas top and bottom coordinates by the film aspect ratio over the resolution aspect ratio.</li>
<li>Figure 8d: when the film aspect ratio is lower than the device aspect ratio, the canvas left, and right coordinates need to be scaled up to match the resolution gate top and bottom coordinates. To do so, we multiply the canvas top and bottom coordinates by the resolution aspect ratio over the film aspect ratio.</li>
</ul>
</li>
</ul>
<p>The following code fragment demonstrates how you can implement these four cases:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">float</span> <span class="n">xscale</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="kt">float</span> <span class="n">yscale</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="k">switch</span> <span class="p">(</span><span class="n">fitFilm</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="k">default</span><span class="o">:</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="k">case</span> <span class="nl">kFill</span><span class="p">:</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">filmAspectRatio</span> <span class="o">&gt;</span> <span class="n">deviceAspectRatio</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">            <span class="c1">// 8a
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1"></span>            <span class="n">xscale</span> <span class="o">=</span> <span class="n">deviceAspectRatio</span> <span class="o">/</span> <span class="n">filmAspectRatio</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">        <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">            <span class="c1">// 8c
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="c1"></span>            <span class="n">yscale</span> <span class="o">=</span> <span class="n">filmAspectRatio</span> <span class="o">/</span> <span class="n">deviceAspectRatio</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">        <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="k">case</span> <span class="nl">kOverscan</span><span class="p">:</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">filmAspectRatio</span> <span class="o">&gt;</span> <span class="n">deviceAspectRatio</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">            <span class="c1">// 8b
</span></span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="c1"></span>            <span class="n">yscale</span> <span class="o">=</span> <span class="n">filmAspectRatio</span> <span class="o">/</span> <span class="n">deviceAspectRatio</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">        <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">            <span class="c1">// 8d
</span></span></span><span class="line"><span class="ln">23</span><span class="cl"><span class="c1"></span>            <span class="n">xscale</span> <span class="o">=</span> <span class="n">deviceAspectRatio</span> <span class="o">/</span> <span class="n">filmAspectRatio</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl">        <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl">
</span></span><span class="line"><span class="ln">28</span><span class="cl"><span class="n">right</span> <span class="o">*=</span> <span class="n">xscale</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">29</span><span class="cl"><span class="n">top</span> <span class="o">*=</span> <span class="n">yscale</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">30</span><span class="cl"><span class="n">left</span> <span class="o">=</span> <span class="o">-</span><span class="n">right</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">31</span><span class="cl"><span class="n">bottom</span> <span class="o">=</span> <span class="o">-</span><span class="n">top</span><span class="p">;</span></span></span></code></pre></div><p>Check the next chapter to get the source code of the complete program.</p>
<h3 id="conclusion">Conclusion</h3>
<p>In this lesson, you have learned everything there is to know about simulating a pinhole camera in CG. In the process, we also learned how to project points onto the image plane and find if they are visible to the camera by comparing their coordinates to the canvas coordinates. The concepts learned in this lesson will be useful for studying the perspective projection matrix (the next lesson&rsquo;s topic), the REYES algorithm, a popular rasterization algorithm, and how images are formed in ray tracing.</p>

            <footer class="footline">
            </footer>
          </article>

          <article class="default">
            <header class="headline">
            </header>
<h1 id="rasterization-a-practical-implementation">Rasterization: a Practical Implementation</h1>

<h2 id="an-overview-of-the-rasterization-algorithm">An Overview of the Rasterization Algorithm</h2>
<h3 id="everything-you-wanted-to-know-about-the-rasterization-algorithm-but-were-afraid-to-ask">Everything You Wanted to Know About the Rasterization Algorithm (But Were Afraid to Ask!)</h3>
<p>The <strong>rasterization rendering technique</strong> is surely the most commonly used technique to render images of 3D scenes, and yet, that is probably the least understood and the least <strong>properly</strong> documented technique of all (especially compared to ray-tracing).</p>
<p>Why this is so, depends on different factors. First, it&rsquo;s a technique from the past. We don&rsquo;t mean to say the technique is obsolete, quite the contrary, but that most of the techniques that are used to produce an image with this algorithm, were developed somewhere between the 1960s and the early 1980s. In the world of computer graphics, this is middle-ages and the knowledge about the papers in which these techniques were developed tends to be lost. Rasterization is also the technique used by GPUs to produce 3D graphics. Hardware technology changed a lot since GPUs were first invented, but the fondamental techniques they implement to produce images haven&rsquo;t changed much since the early 1980s (the hardware changed, but the underlying pipeline by which an image is formed hasn&rsquo;t). In fact, these techniques are so fundamental and consequently so deeply integrated within the hardware architecture, that no one pays attention to them anymore (only people designing GPUs can tell what they do, and this is far from being a trivial task, but designing a GPU and understanding the principle of the rasterization algorithm are two different things; thus explaining the latter should not be that hard!).</p>
<p>Regardless, we thought it was urgent and important to correct this situation. With this lesson, we believe it to be the first resource that provides a clear and complete picture of the algorithm as well as a full practical implementation of the technique. If you found in this lesson the answers you have been desperately looking for anywhere else, please consider donating! This work is provided to you for free and requires many hours of hard work.</p>
<h3 id="introduction">Introduction</h3>
<p>Rasterization and ray tracing try to solve the visibility or hidden surface problem but in a different order (the visibility problem was introduced in the lesson <a href="../../../lessons/3d-basic-rendering/rendering-3d-scene-overview/visibility-problem">Rendering an Image of a 3D Scene, an Overview</a>). Both algorithms have in common that they essentially use techniques from geometry to solve that problem. In this lesson, we will describe briefly how the rasterization (you can write rasterization if you prefer UK English to US English) algorithm works. Understanding the principle is quite simple but implementing it requires to use of a series of techniques notably from the field of geometry, that you will also find explained in this lesson.</p>
<p>The program we will develop in this lesson to demonstrate how rasterization works in practice is important, because we will use it again in the next lessons to implement the ray-tracing algorithm as well. Having both algorithms implemented in the same program will allow us to more easily compare the output produced by the two rendering techniques (they should both produce the same result at least before shading is applied) and performances. It will be a great way to better understand the pros and cons of both algorithms.</p>
<h3 id="the-rasterization-algorithm">The Rasterization Algorithm</h3>
<p>There are not one but multiple rasterization algorithms, but to go straight to the point, let&rsquo;s say that all these different algorithms though are based upon the same overall principle. In other words, all these algorithms are just variants of the same idea. It is this idea or principle, we will refer to when we speak of rasterization in this lesson.</p>
<p>What is that idea? In the previous lessons, we already talked about the difference between rasterization and ray-tracing. We also suggested that the rendering process can essentially be decomposed into two main tasks: visibility and shading. Rasterization to say things quickly is essentially a method to solve the <strong>visibility problem</strong>. Visibility consists of being able to tell which parts of 3D objects are visible to the camera. Some parts of these objects can be bidden because they are either outside the camera&rsquo;s visible area or hidden by other objects.</p>
<p><a href="#R-image-dffed89a5375aa3ece818014d8f568df" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/../assets/raytracing-raster.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-dffed89a5375aa3ece818014d8f568df"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/../assets/raytracing-raster.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 1:</strong> <em>in ray tracing, we trace a ray passing through the center of each pixel in the image and then test if this ray intersects any geometry in the scene. If it an intersection is found, we set the pixel color with the color of the object the ray intersected. Because a ray may intersect several objects, we need to keep track of the closest intersection distance.</em></p>
<p>Solving this problem can be done in essentially two ways. You can either trace a ray through every pixel in the image to find out the distance between the camera and any object this ray intersects (if any). The object visible through that pixel is the object with the smallest intersection distance (generally denoted t). This is the technique used in ray tracing. Note that in this particular case, you create an image by looping over all pixels in the image, tracing a ray for each one of these pixels, and then finding out if these rays intersect any of the objects in the scene. In other words, the algorithm requires two main loops. The outer loop iterates over the pixel in the image, and the inner loop iterates over the objects in the scene:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="n">each</span> <span class="n">pixel</span> <span class="n">in</span> <span class="n">the</span> <span class="n">image</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    <span class="n">Ray</span> <span class="n">R</span> <span class="o">=</span> <span class="n">computeRayPassingThroughPixel</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="kt">float</span> <span class="n">tclosest</span> <span class="o">=</span> <span class="n">INFINITY</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="n">Triangle</span> <span class="n">triangleClosest</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">each</span> <span class="n">triangle</span> <span class="n">in</span> <span class="n">the</span> <span class="n">scene</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">        <span class="kt">float</span> <span class="n">thit</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">intersect</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">object</span><span class="p">,</span> <span class="n">thit</span><span class="p">))</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">             <span class="k">if</span> <span class="p">(</span><span class="n">thit</span> <span class="o">&lt;</span> <span class="n">closest</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">                 <span class="n">triangleClosest</span> <span class="o">=</span> <span class="n">triangle</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">10</span><span class="cl">             <span class="p">}</span> 
</span></span><span class="line"><span class="ln">11</span><span class="cl">        <span class="p">}</span> 
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">triangleClosest</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln">14</span><span class="cl">        <span class="n">imageAtPixel</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="n">triangleColorAtHitPoint</span><span class="p">(</span><span class="n">triangle</span><span class="p">,</span> <span class="n">tclosest</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="p">}</span> 
</span></span></code></pre></div><p>Note that in this example, the objects are considered to be made of triangles (and triangles only). Rather than iterating other objects, we just consider the objects as a pool of triangles and iterate other triangles instead. For reasons we have already explained in the previous lessons, the triangle is often used as the basic rendering primitive both in ray tracing and in rasterization (GPUs require the geometry to be triangulated).</p>
<p>Ray tracing is the first possible approach to solve the visibility problem. We say the technique is <strong>image-centric</strong> because we shoot rays from the camera into the scene (we start from the image) as opposed to the other way around, which is the approach we will be using in rasterization.</p>
<p><a href="#R-image-06d8a8c530d83ee787dc856b47ba68ae" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/../assets/raytracing-raster2.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-06d8a8c530d83ee787dc856b47ba68ae"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/../assets/raytracing-raster2.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 2:</strong> <em>rasterization can be roughly decomposed in two steps. We first project the 3D vertices making up triangles onto the screen using perspective projection. Then, we loop over all pixels in the image and test whether they lie within the resulting 2D triangles. If they do, we fill the pixel with the triangle&rsquo;s color.</em></p>
<p>Rasterization takes the opposite approach. To solve for visibility, it actually &ldquo;projects&rdquo; triangles onto the screen, in other words, we go from a 3D representation to a 2D representation of that triangle, using perspective projection. This can easily be done by projecting the vertices making up the triangle onto the screen (using perspective projection as we just explained). The next step in the algorithm is to use some technique to fill up all the pixels of the image that are covered by that 2D triangle. These two steps are illustrated in Figure 2. From a technical point of view, they are very simple to perform. The projection steps only require a perspective divide and a remapping of the resulting coordinates from image space to raster space, a process we already covered in the previous lessons. Finding out which pixels in the image the resulting triangles cover, is also very simple and will be described later.</p>
<p>What does the algorithm look like compared to the ray tracing approach? First, note that rather than iterating over all the pixels in the image first, in rasterization, in the outer loop, we need to iterate over all the triangles in the scene. Then, in the inner loop, we iterate over all pixels in the image and find out if the current pixel is &ldquo;contained&rdquo; within the &ldquo;projected image&rdquo; of the current triangle (figure 2). In other words, the inner and outer loops of the two algorithms are swapped.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="c1">// rasterization algorithm
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="n">each</span> <span class="n">triangle</span> <span class="n">in</span> <span class="n">scene</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="c1">// STEP 1: project vertices of the triangle using perspective projection
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1"></span>    <span class="n">Vec2f</span> <span class="n">v0</span> <span class="o">=</span> <span class="n">perspectiveProject</span><span class="p">(</span><span class="n">triangle</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">v0</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="n">Vec2f</span> <span class="n">v1</span> <span class="o">=</span> <span class="n">perspectiveProject</span><span class="p">(</span><span class="n">triangle</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">v1</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="n">Vec2f</span> <span class="n">v2</span> <span class="o">=</span> <span class="n">perspectiveProject</span><span class="p">(</span><span class="n">triangle</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">v2</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">each</span> <span class="n">pixel</span> <span class="n">in</span> <span class="n">image</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        <span class="c1">// STEP 2: is this pixel contained in the projected image of the triangle?
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">pixelContainedIn2DTriangle</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln">10</span><span class="cl">            <span class="n">image</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="n">triangle</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">color</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">11</span><span class="cl">        <span class="p">}</span> 
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>This algorithm is <strong>object-centric</strong> because we actually start from the geometry and walk our way back to the image as opposed to the approach used in ray tracing where we started from the image and walked our way back into the scene.</p>
<p>Both algorithms are simple in their principle, but they differ slightly in their complexity when it comes to implementing them and finding solutions to the different problems they require to solve. In ray tracing, generating the rays is simple but finding the intersection of the ray with the geometry can reveal itself to be difficult (depending on the type of geometry you deal with) and is also potentially computationally expensive. But let&rsquo;s ignore ray tracing for now. In the rasterization algorithm, we need to project vertices onto the screen which is simple and fast, and we will see that the second step which requires finding out if a pixel is contained within the 2D representation of a triangle has an equally simple geometric solution. In other words, computing an image using the rasterization approach relies on two very simple and fast techniques (the perspective process and finding out if a pixel lies within a 2D triangle). Rasterization is a good example of an &ldquo;elegant&rdquo; algorithm. The techniques it relies on have simple solutions; they are also easy to implement and produce predictable results. For all these reasons, the algorithm is very well suited for the GPU and is the rendering technique applied by GPUs to generate images of 3D objects (it can also easily be run in parallel).</p>
<p>In summary:</p>
<ul>
<li>Converting geometry to triangles makes the process simpler. If all primitives are converted to the triangle primitive, we can write fast and efficient functions to project triangles onto the screen and check if pixels lie within these 2D triangles</li>
<li>Rasterization is <strong>object-centric</strong>. We project geometry onto the screen and determine their visibility by looping over all pixels in the image.</li>
<li>It relies on mostly two techniques: projecting vertices onto the screen and finding out if a given pixel lies within a 2D triangle.</li>
<li>The rendering pipeline run on GPUs is based on the rasterization algorithm.</li>
</ul>
<blockquote>
<p>The fast rendering of 3D Z-buffered linearly interpolated polygons is a problem that is fundamental to state-of-the-art workstations. In general, the problem consists of two parts: 1) the 3D transformation, projection, and light calculation of the vertices, and 2) the rasterization of the polygon into a frame buffer. (A Parallel Algorithm for Polygon Rasterization, Juan Pineda - 1988)</p>
</blockquote>
<p>The term <strong>rasterization</strong> comes from the fact that polygons (triangles in this case) are decomposed in a way, into pixels, and as we know an image made of pixels is called a raster image. Technically this process is referred to as the <strong>rasterization of the triangles into an image of frame buffer</strong>.</p>
<blockquote>
<p>Rasterization is the process of determining which pixels are inside a triangle, and nothing more. (Michael Abrash in Rasterization on Larrabee)</p>
</blockquote>
<p>Hopefully, at this point of the lesson, you have understood the way the image of a 3D scene (made of triangles) is generated using the rasterization approach. Of course, what we described so far is the simplest form of the algorithm. First, it can be optimized greatly but furthermore, we haven&rsquo;t explained yet what happens when two triangles projected onto the screen overlap the same pixels in the image. When that happens, how do we define which one of these two (or more) triangles is visible to the camera? We will now answer these two questions.</p>
<blockquote>
<details>
What happens if my geometry is not made of triangles? Can I still use the rasterization algorithm? The easiest solution to this problem is to triangulate the geometry. Modern GPUs only render triangles (as well as lines and points) thus you are required to triangulate the geometry anyway. Rendering 3D geometry raises a series of problems that can be more easily resolved with triangles. You will understand why as we progress in the lesson.
</details>
</blockquote>
<h3 id="optimizing-2d-triangles-bounding-box">Optimizing: 2D Triangles Bounding Box</h3>
<p><a href="#R-image-6a3c5e8bc781abe714853c81d0242fa0" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/../assets/raytracing-raster3.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-6a3c5e8bc781abe714853c81d0242fa0"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/../assets/raytracing-raster3.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 3:</strong> <em>to avoid iterating over all pixels in the image, we can iterate over all pixels contained in the bounding box of the 2D triangle instead.</em></p>
<p>The problem with the naive implementation of the rasterization algorithm we gave so far, is that it requires in the inner loop to iterate over all pixels in the image, even though only a small number of these pixels may be contained within the triangle (as shown in figure 3). Of course, this depends on the size of the triangle on the screen. But considering we are not interested in rendering one triangle but an object made up of potentially from a few hundred to a few million triangles, it is unlikely that in a typical production example, these triangles will be very large in the image.</p>
<p><a href="#R-image-170901a4a8ff93092326af965a5f07dc" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/../assets/raytracing-raster4.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-170901a4a8ff93092326af965a5f07dc"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/../assets/raytracing-raster4.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 4:</strong> once the bounding box around the triangle is computed, we can loop over all pixels contained in the bounding box and test if they overlap the 2D triangle.</p>
<p>There are different ways of minimizing the number of tested pixels, but the most common one consists of computing the 2D bounding box of the projected triangle and iterating over the pixels contained in that 2D bounding box rather than the pixels of the entire image. While some of these pixels might still lie outside the triangle, at least on average, it can already considerably improve the performance of the algorithm. This idea is illustrated in figure 3.</p>
<p>Computing the 2D bounding box of a triangle is very simple. We just need to find the minimum and maximum x- and y-coordinates of the three vertices making up the triangle in raster space. This is illustrated in the following pseudo code:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="c1">// convert the vertices of the current triangle to raster space
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1"></span><span class="n">Vec2f</span> <span class="n">bbmin</span> <span class="o">=</span> <span class="n">INFINITY</span><span class="p">,</span> <span class="n">bbmax</span> <span class="o">=</span> <span class="o">-</span><span class="n">INFINITY</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">Vec2f</span> <span class="n">vproj</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span> 
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="n">vproj</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">projectAndConvertToNDC</span><span class="p">(</span><span class="n">triangle</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> 
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="c1">// coordinates are in raster space but still floats not integers
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1"></span>    <span class="n">vproj</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">x</span> <span class="o">*=</span> <span class="n">imageWidth</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="n">vproj</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">y</span> <span class="o">*=</span> <span class="n">imageHeight</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">vproj</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">bbmin</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="n">bbmin</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">vproj</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">x</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">vproj</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">bbmin</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="n">bbmin</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">vproj</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">y</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">vproj</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">bbmax</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="n">bbmax</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">vproj</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">x</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">vproj</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">y</span> <span class="o">&gt;</span> <span class="n">bbmax</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="n">bbmax</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">vproj</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">y</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="p">}</span> 
</span></span></code></pre></div><p>Once we calculated the 2D bounding box of the triangle (in raster space), we just need to loop over the pixel defined by that box. But you need to be very careful about the way you convert the raster coordinates, which in our code are defined as floats rather than integers. First, note that one or two vertices may be projected outside the boundaries of the canvas. Thus, their raster coordinates may be lower than 0 or greater than the image size. We solve this problem by clamping the pixel coordinates to the range [0, Image Width - 1] for the x coordinate, and [0, Image Height - 1] for the y coordinate. Furthermore, we will need to round off the minimum and maximum coordinates of the bounding box to the nearest integer value (note that this works fine when we iterate over the pixels in the loop because we initialize the variable to <code>xmim</code> or <code>ymin</code> and break from the loop when the variable x or y is lower or equal to <code>xmax</code> or <code>ymax</code>). All these tests need to be applied before using the final fixed point (or integer) bounding box coordinates in the loop. Here is the pseudo-code:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="p">...</span> 
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="n">uint</span> <span class="n">xmin</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nl">std</span><span class="p">:</span><span class="n">min</span><span class="p">(</span><span class="n">imageWidth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">floor</span><span class="p">(</span><span class="n">min</span><span class="p">.</span><span class="n">x</span><span class="p">)));</span> 
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">uint</span> <span class="n">ymin</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nl">std</span><span class="p">:</span><span class="n">min</span><span class="p">(</span><span class="n">imageHeight</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">floor</span><span class="p">(</span><span class="n">min</span><span class="p">.</span><span class="n">y</span><span class="p">)));</span> 
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">uint</span> <span class="n">xmax</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nl">std</span><span class="p">:</span><span class="n">min</span><span class="p">(</span><span class="n">imageWidth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">floor</span><span class="p">(</span><span class="n">max</span><span class="p">.</span><span class="n">x</span><span class="p">)));</span> 
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">uint</span> <span class="n">ymax</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nl">std</span><span class="p">:</span><span class="n">min</span><span class="p">(</span><span class="n">imageHeight</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">floor</span><span class="p">(</span><span class="n">max</span><span class="p">.</span><span class="n">y</span><span class="p">)));</span> 
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="n">y</span> <span class="o">=</span> <span class="n">ymin</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;=</span> <span class="n">ymin</span><span class="p">;</span> <span class="o">++</span><span class="n">y</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="n">xmin</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">xmax</span><span class="p">;</span> <span class="o">++</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        <span class="c1">// check of if current pixel lies in triangle
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">pixelContainedIn2DTriangle</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln">10</span><span class="cl">            <span class="n">image</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="n">triangle</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">color</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">11</span><span class="cl">        <span class="p">}</span> 
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="p">}</span> 
</span></span></code></pre></div><blockquote>
<details>
Note that production rasterizers use more efficient methods than looping over the pixels contained in the bounding box of the triangle. As mentioned, many of the pixels do not overlap the triangle, and testing if these pixel samples overlap the triangle is a waste. We won't study these more optimized methods in this lesson.
</details>
</blockquote>
<blockquote>
<details>
If you already studied this algorithm or studied how GPUs render images, you may have heard or read that the coordinates of projected vertices are sometimes converted from floating point to **fixed point numbers** (in other words integers). The reason behind this conversion is that basic operations such as multiplication, division, addition, etc. on fixed point numbers can be done very quickly (compared to the time it takes to do the same operations with floating point numbers). This used to be the case in the past and GPUs are still designed to work with integers at the rasterization stage of the rendering pipeline. However modern CPUs generally have FPUs (floating-point units) so if your program runs on the CPU, there is probably little to no advantage to using fixed point numbers (it actually might even run slower).
</details>
</blockquote>
<h3 id="the-image-or-frame-buffer">The Image or Frame-Buffer</h3>
<p>Our goal is to produce an image of the scene. We have two ways of visualizing the result of the program, either by displaying the rendered image directly on the screen or saving the image to disk, and using a program such as Photoshop to preview the image later on. But in both cases though, we somehow need to store the image that is being rendered while it&rsquo;s being rendered and for that purpose, we use what we call in CG an image or <strong>frame-buffer</strong>. It is nothing else than a two-dimensional array of colors that has the size of the image. Before the rendering process starts, the frame-buffer is created and the pixels are all set to black. At render time, when the triangles are rasterized, if a given pixel overlaps a given triangle, then we store the color of that triangle in the frame-buffer at that pixel location. When all triangles have been rasterized, the frame-buffer will contain the image of the scene. All that is left to do then is either display the content of the buffer on the screen or save its content to a file. In this lesson, we will choose the latter option.</p>
<blockquote>
<details>
In programming, there is no solution to display images on the screen that is cross-platform (which is a shame). For this reason, it is better to store the content of the image in a file and use a cross-platform application such as Photoshop or another image editing tool to view the image. Of course, the software you will be using to view the image needs to support the image format the image will be saved in. In this lesson, we will use the very simple PPM image file format.
</details>
</blockquote>
<h3 id="when-two-triangles-overlap-the-same-pixel-the-depth-buffer-or-z-buffer">When Two Triangles Overlap the Same Pixel: The Depth Buffer (or Z-Buffer)</h3>
<p>Keep in mind that the goal of the rasterization algorithm is to solve the visibility problem. To display 3D objects, it is necessary to determine which surfaces are visible. In the early days of computer graphics, two methods were used to solve the &ldquo;hidden surface&rdquo; problem (the other name for the visibility problem): the <strong>Newell algorithm</strong> and the <strong>z-buffer</strong>. We only mention the Newell algorithm for historical reasons but we won&rsquo;t study it in this lesson because it is not used anymore. We will only study the z-buffer method which is used by GPUs.</p>
<p><a href="#R-image-e9921b16a01733548787da24a6a10d63" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/../assets/raytracing-raster5.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-e9921b16a01733548787da24a6a10d63"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/../assets/raytracing-raster5.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 5:</strong> <em>when a pixel overlaps two triangles, we set the pixel color to the color of the triangle with the smallest distance to the camera.</em></p>
<p>There is one last thing though that we need to do to get a basic rasterizer working. We need to account for the fact that more than one triangle may overlap the same pixel in the image (as shown in figure 5). When this happens, how do we decide which triangle is visible? The solution to this problem is very simple. We will use what we call a <strong>z-buffer</strong> which is also called a <strong>depth buffer</strong>, two terms that you may have heard or read about already quite often. A z-buffer is nothing more than another two-dimensional array that has the same dimension as the image, however rather than being an array of colors, it is simply an array of floating numbers. Before we start rendering the image, we initialize each pixel in this array to a very large number. When a pixel overlaps a triangle, we also read the value stored in the z-buffer at that pixel location. As you maybe guessed, this array is used to store the distance from the camera to the nearest triangle that any pixel in the image overlaps. Since this value is initially set to infinity (or any very large number), then, of course, the first time we find that a given pixel X overlaps a triangle T1, the distance from the camera to that triangle is necessarily lower than the value stored in the z-buffer. What we do then, is replace the value stored for that pixel with the distance to T1. Next, when the same pixel X is tested and we find that it overlaps another triangle T2, we then compare the distance of the camera to this new triangle to the distance stored in the z-buffer (which at this point, stores to the distance to the first triangle T1). If this distance to the second triangle is lower than the distance to the first triangle, then T2 is visible and T1 is hidden by T2. Otherwise, T1 is hidden by T2, and T2 is visible. In the first case, we update the value in the z-buffer with the distance to T2 and in the second case, the z-buffer doesn&rsquo;t need to be updated since the first triangle T1 is still the closest triangle we found for that pixel so far. As you can see <strong>the z-buffer is used to store the distance of each pixel to the nearest object in the scene</strong> (we don&rsquo;t really use the distance, but we will give the details further in the lesson). In figure 5, we can see that the red triangle is behind the green triangle in 3D space. If we were to render the red triangle first, and the green triangle second, for a pixel that would overlap both triangles, we would have to store in the z-buffer at that pixel location, first a very large number (that happens when the z-buffer is initialized), then the distance to the red triangle and then finally the distance to the green triangle.</p>
<p>You may wonder how we find the distance from the camera to the triangle. Let&rsquo;s first look at an implementation of this algorithm in pseudo-code and we will come back to this point later (for now let&rsquo;s just assume the function pixelContainedIn2DTriangle computes that distance for us):</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="c1">// A z-buffer is just an 2D array of floats
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1"></span><span class="kt">float</span> <span class="n">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">float</span> <span class="p">[</span><span class="n">imageWidth</span> <span class="o">*</span> <span class="n">imageHeight</span><span class="p">];</span> 
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="c1">// initialize the distance for each pixel to a very large number
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">imageWidth</span> <span class="o">*</span> <span class="n">imageHeight</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> 
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="n">buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">INFINITY</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"> 
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="n">each</span> <span class="n">triangle</span> <span class="n">in</span> <span class="n">scene</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="c1">// project vertices
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1"></span>    <span class="p">...</span> 
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="c1">// compute bbox of the projected triangle
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="c1"></span>    <span class="p">...</span> 
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">y</span> <span class="o">=</span> <span class="n">ymin</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;=</span> <span class="n">ymin</span><span class="p">;</span> <span class="o">++</span><span class="n">y</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln">13</span><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="n">xmin</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">xmax</span><span class="p">;</span> <span class="o">++</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln">14</span><span class="cl">            <span class="c1">// check of if current pixel lies in triangle
</span></span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="c1"></span>            <span class="kt">float</span> <span class="n">z</span><span class="p">;</span>  <span class="c1">//distance from the camera to the triangle 
</span></span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">pixelContainedIn2DTriangle</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">))</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln">17</span><span class="cl">                <span class="c1">// If the distance to that triangle is lower than the distance stored in the
</span></span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="c1"></span>                <span class="c1">// z-buffer, update the z-buffer and update the image at pixel location (x,y)
</span></span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="c1"></span>                <span class="c1">// with the color of that triangle
</span></span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="c1"></span>                <span class="k">if</span> <span class="p">(</span><span class="n">z</span> <span class="o">&lt;</span> <span class="n">zbuffer</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">))</span> <span class="p">{</span> 
</span></span><span class="line"><span class="ln">21</span><span class="cl">                    <span class="n">zbuffer</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="n">z</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">22</span><span class="cl">                    <span class="n">image</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="n">triangle</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">color</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">23</span><span class="cl">                <span class="p">}</span> 
</span></span><span class="line"><span class="ln">24</span><span class="cl">            <span class="p">}</span> 
</span></span><span class="line"><span class="ln">25</span><span class="cl">        <span class="p">}</span> 
</span></span><span class="line"><span class="ln">26</span><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="ln">27</span><span class="cl"><span class="p">}</span> 
</span></span></code></pre></div><h3 id="whats-next">What&rsquo;s Next?</h3>
<p>This is only a very high-level description of the algorithm (figure 6) but this should hopefully already give you an idea of what we will need in the program to produce an image. We will need:</p>
<ul>
<li>An image-buffer (a 2D array of colors),</li>
<li>A depth-buffer (a 2D array of floats),</li>
<li>Triangles (the geometry making up the scene),</li>
<li>A function to project vertices of the triangles onto the canvas,</li>
<li>A function to rasterize the projected triangles,</li>
<li>Some code to save the content of the image buffer to disk.</li>
</ul>
<p><a href="#R-image-b1e013ee2d38851c7036d9dc264d1fc0" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/../assets/rasterization-schema.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b1e013ee2d38851c7036d9dc264d1fc0"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/../assets/rasterization-schema.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 6:</strong> <em>schematic view of the rasterization algorithm.</em></p>
<p>In the next chapter, we will see how are coordinates converted from camera to raster space. The method is of course identical to the one we studied and presented in the previous lesson, however, we will present a few more tricks along the way. In chapter three, we will learn how to rasterize triangles. In chapter four, we will study in detail how the z-buffer algorithm works. As usual, we will conclude this lesson with a practical example.</p>
<h2 id="the-projection-stage">The Projection Stage</h2>
<h3 id="quick-review">Quick Review</h3>
<p>In the previous chapter, we gave a high-level overview of the rasterization rendering technique. It can be decomposed into two main stages: first, the projection of the triangle&rsquo;s vertices onto the canvas, then the rasterization of the triangle itself. Rasterization means in this case, <strong>&ldquo;breaking apart&rdquo; the triangle&rsquo;s shape into pixels</strong> or <strong>raster element squares</strong>; this is what pixels used to be called in the past. In this chapter, we will review the first step. We have already described this method in the two previous lessons, thus we won&rsquo;t explain it here again. If you have any doubts about the principles behind perspective projection, check these lessons again. However, in this chapter, we will study a couple of new tricks related to projection that are going to be useful when we will get to the lesson on the perspective projection matrix. We will learn about a new method to remap the coordinates of the projected vertices from screen space to NDC space. We will also learn more about the role of the z-coordinate in the rasterization algorithm and how it should be handled at the projection stage.</p>
<p>Keep in mind as already mentioned in the previous chapter, that the goal of the rasterization rendering technique is to solve the visibility or hidden surface problem, which is to determine with parts of a 3D object are visible and which parts are hidden.</p>
<h3 id="projection-what-are-we-trying-to-solve">Projection: What Are We Trying to Solve?</h3>
<p>What are we trying to solve here at that stage of the rasterization algorithm? As explained in the previous chapter, the principle of rasterization is to find if pixels in the image overlap triangles. To do so, we first need to project triangles onto the canvas and then convert their coordinates from screen space to raster space. Pixels and triangles are then defined in the same space, which means that it becomes possible to compare their respective coordinates (we can check the coordinates of a given pixel against the raster-space coordinates of a triangle&rsquo;s vertices).</p>
<p>The goal of this stage is thus to convert the vertices making up triangles from camera space to raster space.</p>
<h3 id="projecting-vertices-mind-the-z-coordinate">Projecting Vertices: Mind the Z-Coordinate!</h3>
<p>In the previous two lessons, we mentioned that when we compute the raster coordinates of a 3D point what we need in the end are its x- and y-coordinates (the position of the 3D point in the image). As a quick reminder, recall that these 2D coordinates are obtained by dividing the x and y coordinates of the 3D point in camera space, by the point&rsquo;s respective z-coordinate (what we called the perspective divide), and then remapping the resulting 2D coordinates from screen space to NDC space and then NDC space to raster space. Keep in mind that because the image plane is positioned at the near-clipping plane, we also need to multiply the x- and y-coordinate by the near-clipping plane. Again, we explained this process in great detail in the previous two lessons.</p>

<span class="math align-center">$$
\begin{array}{l}
Pscreen.x = \dfrac{ near * Pcamera.x }{ -Pcamera.z }\\
Pscreen.y = \dfrac{ near * Pcamera.y }{ -Pcamera.z }\\
\end{array}
$$</span><p>Note that so far, we have been considering points in screen space as essentially 2D points (we didn&rsquo;t need to use the points&rsquo; z-coordinate after the perspective divide). From now on though, we will declare points in screen-space, as 3D points and set their z-coordinate to the camera-space points&rsquo; z-coordinate as follow:</p>

<span class="math align-center">$$
\begin{array}{l}
Pscreen.x = \dfrac{ near * Pcamera.x }{ -Pcamera.z }\\
Pscreen.y = \dfrac{ near * Pcamera.y }{ -Pcamera.z }\\
Pscreen.z = { -Pcamera.z }\\
\end{array}
$$</span><p>It is best at this point to set the projected point z-coordinate to the inverse of the original point z-coordinate, which as you know by now, is negative. Dealing with positive z-coordinates will make everything simpler later on (but this is not mandatory).</p>
<p><a href="#R-image-22b7ab3e159dfef961ffcf38dbfa80b0" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/../assets/rasterizer-z.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-22b7ab3e159dfef961ffcf38dbfa80b0"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/../assets/rasterizer-z.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 1:</strong> <em>when two vertices in camera space have the same 2D raster coordinates, we can use the original vertices z-coordinate to find out which one is in front of the other (and thus which one is visible).</em></p>
<p><strong>Keeping track of the vertex z-coordinate in camera space is needed to solve the visibility problem</strong>. Understanding why is easier if you look at Figure 1. Imagine two vertices v1 and v2 which when projected onto the canvas, have the same raster coordinates (as shown in Figure 1). If we project v1 before v2 then v2 will be visible in the image when it should be v1 (v1 is clearly in front of v2). However, if we store the z-coordinate of the vertices along with their 2D raster coordinates, we can use these coordinates to define which point is closest to the camera independently of the order in which the vertices are projected (as shown in the code fragment below).</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="c1">// project v2
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1"></span><span class="n">Vec3f</span> <span class="n">v2screen</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">v2screen</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">near</span> <span class="o">*</span> <span class="n">v2camera</span><span class="p">.</span><span class="n">x</span> <span class="o">/</span> <span class="o">-</span><span class="n">v2camera</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">v2screen</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">near</span> <span class="o">*</span> <span class="n">v2camera</span><span class="p">.</span><span class="n">y</span> <span class="o">/</span> <span class="o">-</span><span class="n">v2camera</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">v2screen</span><span class="p">.</span><span class="n">z</span> <span class="o">=</span> <span class="o">-</span><span class="n">v2cam</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="n">Vec3f</span> <span class="n">v1screen</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="n">v1screen</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">near</span> <span class="o">*</span> <span class="n">v1camera</span><span class="p">.</span><span class="n">x</span> <span class="o">/</span> <span class="o">-</span><span class="n">v1camera</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="n">v1screen</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">near</span> <span class="o">*</span> <span class="n">v1camera</span><span class="p">.</span><span class="n">y</span> <span class="o">/</span> <span class="o">-</span><span class="n">v1camera</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="n">v1screen</span><span class="p">.</span><span class="n">z</span> <span class="o">=</span> <span class="o">-</span><span class="n">v1camera</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="c1">// If the two vertices have the same coordinates in the image then compare their z-coordinate
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="n">v1screen</span><span class="p">.</span><span class="n">x</span> <span class="o">==</span> <span class="n">v2screen</span><span class="p">.</span><span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">v1screen</span><span class="p">.</span><span class="n">y</span> <span class="o">==</span> <span class="n">v2screen</span><span class="p">.</span><span class="n">y</span> <span class="o">&amp;&amp;</span> <span class="n">v1screen</span><span class="p">.</span><span class="n">z</span> <span class="o">&lt;</span> <span class="n">v2screen</span><span class="p">.</span><span class="n">z</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="c1">// if v1.z &lt; v2.z then store v1 in frame-buffer
</span></span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="c1"></span>    <span class="p">....</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p><a href="#R-image-13ff36e9db3ecd7834752a9889f2c1c1" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/../assets/rasterizer-z2.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-13ff36e9db3ecd7834752a9889f2c1c1"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/../assets/rasterizer-z2.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 2:</strong> <em>the points on the surface of triangles that a pixel overlaps can be computed by interpolating the vertices making up these triangles. See chapter 4 for more details.</em></p>
<p>What we want to render though are triangles, not vertices. So the question is, how does the method we just learned about apply to triangles? In short, we will use the triangle vertices coordinates to find the position of the point on the triangle that the pixel overlaps (and thus it&rsquo;s z-coordinate). This idea is illustrated in Figure 2. If a pixel overlaps two or more triangles, we should be able to compute the position of the points on the triangles that the pixel overlap, and use the z-coordinates of these points as we did with the vertices, to know which triangle is the closest to the camera. This method will be described in detail in <a href="../../../lessons/3d-basic-rendering/rasterization-practical-implementation/visibility-problem-depth-buffer-depth-interpolation">chapter 4 (The Depth Buffer. Finding the Depth Value of a Sample by Interpolation)</a>.</p>
<h3 id="screen-space-is-also-three-dimensional">Screen Space is Also Three-Dimensional</h3>
<p><a href="#R-image-366ae76f0672d9e4736b7a7d7320a99b" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/../assets/screen-space-3D.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-366ae76f0672d9e4736b7a7d7320a99b"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/../assets/screen-space-3D.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 3:</strong> <em>screen space is three-dimensional (middle image).</em></p>
<p>To summarize, to go from camera space to screen space (which is the process during which the perspective divide is happening), we need to:</p>
<ul>
<li>
<p>Perform the perspective divide: that is dividing the point in camera space x- and y-coordinate by the point z-coordinate.</p>

<span class="math align-center">$$
\begin{array}{l}
Pscreen.x = \dfrac{ near * Pcamera.x }{ -Pcamera.z }\\
Pscreen.y = \dfrac{ near * Pcamera.y }{ -Pcamera.z }\\
\end{array}
$$</span></li>
<li>
<p>But also set the projected point z-coordinate to the original point z-coordinate (the point in camera space).</p>

<span class="math align-center">$$
Pscreen.z = { -Pcamera.z }
$$</span></li>
</ul>
<p>Practically, this means that our projected point is not a 2D point anymore, but a 3D point. Or to say it differently, that screen space is not two- by three-dimensional. In his thesis <a href="http://en.wikipedia.org/wiki/Edwin_Catmull" target="_blank">Ed-Catmull</a> writes:</p>
<p>Screen-space is also three-dimensional, but the objects have undergone a perspective distortion so that an orthogonal projection of the object onto the x-y plane, would result in the expected perspective image (Ed-Catmull&rsquo;s Thesis, 1974).</p>
<p><a href="#R-image-845505105857ef4f5b915090a1815803" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/../assets/screen-space-3D2.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-845505105857ef4f5b915090a1815803"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/../assets/screen-space-3D2.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 4:</strong> <em>we can form an image of an object in screen space by projecting lines orthogonal (or perpendicular if you prefer) to the x-y image plane.</em></p>
<p>You should now be able to understand this quote. The process is also illustrated in Figure 3. First, the geometry vertices are defined in camera space (top image). Then, each vertex undergoes a perspective divide. That is, the vertex x- and y-coordinates are divided by their z-coordinate, but as mentioned before, we also set the resulting projected point z-coordinate to the inverse of the original vertex z-coordinate. This, by the way, infers a change of direction in the z-axis of the screen space coordinate system. As you can see, the z-axis is now pointing inward rather than outward (middle image in Figure 3). But the most important thing to notice is that the resulting object is a deformed version of the original object but a three-dimensional object. Furthermore what Ed-Catmull means when he writes &ldquo;an orthogonal projection of the object onto the x-y plane, would result in the expected perspective image&rdquo;, is that once the object is in screen space, if we trace lines perpendicular to the x-y image plane from the object to the canvas, then we get a perspective representation of that object (as shown in Figure 4). This is an interesting observation because it means that the image creation process can be seen as <strong>a perspective projection followed by an orthographic projection</strong>. Don&rsquo;t worry if you don&rsquo;t understand clearly the difference between perspective and orthographic projection. It is the topic of the next lesson. However, try to remember this observation, as it will become handy later.</p>
<h3 id="remapping-screen-space-coordinates-to-ndc-space">Remapping Screen Space Coordinates to NDC Space</h3>
<p>In the previous two lessons, we explained that once in screen space, the x- and y-coordinates of the projected points need to be remapped to NDC space. In the previous lessons, we also explained that in NDC space, points on the canvas had their x- and y-coordinates contained in the range [0,1]. In the GPU world though, coordinates in NDC space are contained in the range [-1,1]. Sadly, this is one of these conventions again, that we need to deal with. We could have kept the convention [0,1] but because GPUs are the reference when it comes to rasterization, it is best to stick to the way the term is defined in the GPU world.</p>
<p>You may wonder why we didn&rsquo;t use the [-1,1] convention in the first place then. For several reasons. Once because in our opinion the term &ldquo;normalize&rdquo; should always suggest that the value that is being normalized is in the range [0,1]. Also because it is good to be aware that several rendering systems use different conventions with respect to the concept of NDC space. The RenderMan specifications for example define NDC space as a space defined over the range [0,1].</p>
<p>Thus once the points have been converted from camera space to screen space, the next step is to remap them from the range [l,r] and [b,t] for the x- and y-coordinate respectively, to the range [-1,1]. The term l, r, b, and t relate to the left, right, bottom, and top coordinates of the canvas. By re-arranging the terms, we can easily find an equation that performs the remapping we want:</p>

<span class="math align-center">$$l < x < r$$</span><p>Where x here is the x-coordinate of a 3D point in screen space (remember that from now on, we will assume that points in screen space are three-dimensional as explained above). If we remove the term l from the equation we get:</p>

<span class="math align-center">$$0 < x - l < r - l$$</span><p>By dividing all terms by (r-l) we get:</p>

<span class="math align-center">$$
\begin{array}{l}
0 < \dfrac {(x - l)}{(r - l)} < \dfrac {(r - l)}{(r - l)} \\
0 < \dfrac {(x - l)}{(r  -l)} < 1 \\
\end{array}
$$</span><p>We can now develop the term in the middle of the equation:</p>

<span class="math align-center">$$0 < \dfrac {x}{(r  -l)} - \dfrac {l}{(r  -l)}< 1$$</span><p>We can now multiply all terms by 2:</p>

<span class="math align-center">$$0 < 2 * \dfrac {x}{(r  -l)} - 2 * \dfrac {l}{(r  -l)}< 2$$</span><p>We now remove 1 from all terms:</p>

<span class="math align-center">$$-1 < 2 * \dfrac {x}{(r  -l)} - 2 * \dfrac {l}{(r-l)} - 1 < 1$$</span><p>If we develop the terms and regroup them, we finally get:</p>

<span class="math align-center">$$
\begin{array}{l}
-1 < 2 * \dfrac {x}{(r  -l)} - 2 * \dfrac {l}{(r-l)} - \dfrac{(r-l)}{(r-l)}< 1 \\
-1 < 2 * \dfrac {x}{(r  -l)} + \dfrac {-2*l+l-r}{(r-l)} < 1 \\
-1 < 2 * \dfrac {x}{(r  -l)} + \dfrac {-l-r}{(r-l)} < 1 \\
-1 < \color{red}{\dfrac {2x}{(r  -l)}} \color{green}{- \dfrac {r + l}{(r-l)}} < 1\\
\end{array}
$$</span><p>This is a very important equation because the red and green terms of the equation in the middle of the formula will become the coefficients of the perspective projection matrix. We will study this matrix in the next lesson. But for now, we will just apply this equation <strong>to remap the x-coordinate of a point in screen space to NDC space</strong> (any point that lies on the canvas has its coordinates contained in the range [-1.1] when defined in NDC space). If we apply the same reasoning to the y-coordinate we get:</p>

<span class="math align-center">$$-1 < \color{red}{\dfrac {2y}{(t  - b)}} \color{green}{- \dfrac {t + b}{(t-b)}} < 1$$</span><h3 id="putting-things-together">Putting Things Together</h3>
<p>At the end of this lesson, we now can perform the first stage of the rasterization algorithm which you can decompose into two steps:</p>
<ul>
<li>
<p>Convert a point in camera space to screen space. It essentially projects a point onto the canvas, but keep in mind that we also need to store the original point z-coordinate. The point in screen-space is tree-dimensional and the z-coordinate will be useful to solve the visibility problem later on.</p>

<span class="math align-center">$$
\begin{array}{l}
Pscreen.x = \dfrac{ near * Pcamera.x }{ -Pcamera.z }\\
Pscreen.y = \dfrac{ near * Pcamera.y }{ -Pcamera.z }\\
Pscreen.z = { -Pcamera.z }\\
\end{array}
$$</span></li>
<li>
<p>We then convert the x- and y-coordinates of these points in screen space to NDC space using the following formulas:</p>

<span class="math align-center">$$
\begin{array}{l}
-1 < \color{}{\dfrac {2x}{(r  -l)}} \color{}{- \dfrac {r + l}{(r-l)}} < 1\\
-1 < \color{}{\dfrac {2y}{(t  - b)}} \color{}{- \dfrac {t + b}{(t-b)}} < 1
\end{array}
$$</span><p>Where l, r, b, t denote the left, right, bottom, and top coordinates of the canvas.</p>
</li>
</ul>
<p>From there, it is extremely simple to convert the coordinates to raster space. We just need to remap the x- and y-coordinates in NDC space to the range [0,1] and multiply the resulting number by the image width and height respectively (don&rsquo;t forget that in raster space the y-axis goes down while in NDC space it goes up. Thus we need to change y&rsquo;s direction during this remapping process). In code we get:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">float</span> <span class="n">nearClippingPlane</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1">// point in camera space
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="c1"></span><span class="n">Vec3f</span> <span class="n">pCamera</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">worldToCamera</span><span class="p">.</span><span class="n">multVecMatrix</span><span class="p">(</span><span class="n">pWorld</span><span class="p">,</span> <span class="n">pCamera</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="c1">// convert to screen space
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="c1"></span><span class="n">Vec2f</span> <span class="n">pScreen</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="n">pScreen</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">nearClippingPlane</span> <span class="o">*</span> <span class="n">pCamera</span><span class="p">.</span><span class="n">x</span> <span class="o">/</span> <span class="o">-</span><span class="n">pCamera</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="n">pScreen</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">nearClippingPlane</span> <span class="o">*</span> <span class="n">pCamera</span><span class="p">.</span><span class="n">y</span> <span class="o">/</span> <span class="o">-</span><span class="n">pCamera</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1">// now convert point from screen space to NDC space (in range [-1,1])
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1"></span><span class="n">Vec2f</span> <span class="n">pNDC</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="n">pNDC</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pScreen</span><span class="p">.</span><span class="n">x</span> <span class="o">/</span> <span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">l</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="n">l</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">l</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="n">pNDC</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pScreen</span><span class="p">.</span><span class="n">y</span> <span class="o">/</span> <span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">t</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="c1">// convert to raster space and set point z-coordinate to -pCamera.z
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="c1"></span><span class="n">Vec3f</span> <span class="n">pRaster</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="n">pRaster</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">pNDC</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">imageWidth</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="c1">// in raster space y is down so invert direction
</span></span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="c1"></span><span class="n">pRaster</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">pNDC</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">imageHeight</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="c1">// store the point camera space z-coordinate (as a positive value)
</span></span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="c1"></span><span class="n">pRaster</span><span class="p">.</span><span class="n">z</span> <span class="o">=</span> <span class="o">-</span><span class="n">pCamera</span><span class="p">.</span><span class="n">z</span><span class="p">;</span></span></span></code></pre></div><p>Note that the coordinates of points or vertices in raster space are still defined as floating point numbers here and not integers (which is the case for pixel coordinates).</p>
<h3 id="whats-next-1">What&rsquo;s Next?</h3>
<p>We now have projected the triangle onto the canvas and converted these projected vertices to raster space. Both the vertices of the triangle and the pixel live in the same coordinate system. We are now ready to loop over all pixels in the image and use a technique to find if they overlap a triangle. This is the topic of the next chapter.</p>
<h2 id="the-rasterization-stage">The Rasterization Stage</h2>
<h3 id="rasterization-what-are-we-trying-to-solve">Rasterization: What Are We Trying to Solve?</h3>
<p>Rasterization is the process by which a primitive is converted to a two-dimensional image. Each point of this image contains such information as color and depth. Thus, rasterizing a primitive consists of two parts. The first is to determine which squares of an integer grid in window coordinates are occupied by the primitive. The second is assigning a color and a depth value to each such square. (OpenGL Specifications)</p>
<p><a href="#R-image-09c738936dbd137c6113c35e2b720dd0" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/../assets/rasterization-triangle1.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-09c738936dbd137c6113c35e2b720dd0"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/../assets/rasterization-triangle1.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 1:</strong> <em>by testing, if pixels in the image overlap the triangle, we can draw an image of that triangle. This is the principle of the rasterization algorithm.</em></p>
<p>In the previous chapter, we learned how to perform the first step of the rasterization algorithm in a way, which is to project the triangle from 3D space onto the canvas. This definition is not entirely accurate in fact, since what we did was to transform the triangle from camera space to screen space, which as mentioned in the previous chapter, is also a three-dimensional space. However the x- and y-coordinates of the vertices in screen-space correspond to the position of the triangle vertices on the canvas, and by converting them from screen-space to NDC space and then finally from NDC-space to raster-space, what we get in the end are the vertices 2D coordinates in raster space. Finally, we also know that the z-coordinates of the vertices in screen-space hold the original z-coordinate of the vertices in camera space (inverted so that we deal with positive numbers rather than negative ones).</p>
<p>What we need to do next, is to loop over the pixel in the image and find out if any of these pixels overlap the &ldquo;projected image of the triangle&rdquo; (figure 1). In graphics APIs specifications, this test is sometimes called the <strong>inside-outside test</strong> or the <strong>coverage test</strong>. If they do, we then set the pixel in the image to the triangle&rsquo;s color. The idea is simple but of course, we now need to come up with a method to find if a given pixel overlaps a triangle. This is essentially what we will study in this chapter. We will learn about the method that is typically used in rasterization to solve this problem. It uses a technique known as the <strong>edge function</strong> which we are now going to describe and study. This edge function is also going to provide valuable information about the position of the pixel within the projected image of the triangle known as <strong>barycentric coordinates</strong>. Barycentric coordinates play an essential role in computing the actual depth (or the z-coordinate) of the point on the surface of the triangle that the pixel overlaps. We will also explain what barycentric coordinates are in this chapter and how they are computed.</p>
<p>At the end of this chapter, you will be able to produce a very basic rasterizer. In the next chapter, we will look into the possible issues with this very naive implementation of the rasterization algorithm. We will list what these issues are as well as study how they are typically addressed.</p>
<p>A lot of research has been done to optimize the algorithm. The goal of this lesson is not to teach you how to write or develop an optimized and efficient renderer based on the rasterization algorithm. The goal of this lesson is to teach the basic principles of the rendering technique. Don&rsquo;t think though that the techniques we present in these chapters are not used. They are used to some extent, but how they are implemented either on the GPU or in a CPU version of a production renderer, is just likely to be a highly optimized version of the same idea. What is truly important is to understand the principle and how it works in general. From there, you can study on your own the different techniques which are used to speed up the algorithm. But the techniques presented in this lesson are generic and make up the foundations of any rasterizer.</p>
<p>Keep in mind that drawing a triangle (since the triangle is a primitive we will use it in this case), is a two steps problem:</p>
<ul>
<li>We first need to find which pixels overlap the triangle.</li>
<li>We then need to define which colors should the pixels overlapping the triangle be set to, a process that is called <strong>shading</strong></li>
</ul>
<p>The rasterization stage deals essentially with the first step. The reason we say essentially rather than exclusively is that at the rasterization stage, we will also compute something called <strong>barycentric coordinates</strong> which to some extent, are used in the second step.</p>
<h3 id="the-edge-function">The Edge Function</h3>
<p>As mentioned above, they are several possible methods to find if a pixel overlaps a triangle. It would be good to document older techniques, but in this lesson, will only present the method that is generally used today. This method was presented by Juan Pineda in 1988 and a paper called &ldquo;<strong>A Parallel Algorithm for Polygon Rasterization</strong>&rdquo; (see references in the last chapter).</p>
<p><a href="#R-image-8df375bf361ed4472b75a5bbf3d9d309" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/../assets/rasterization-triangle2.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-8df375bf361ed4472b75a5bbf3d9d309"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/../assets/rasterization-triangle2.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 2:</strong> <em>the principle of Pineda&rsquo;s method is to find a function, so that when we test on which side of this line a given point is, the function returns a positive number when it is to the left of the line, a negative number when it is to the right of this line, and zero when the point is exactly on the line.</em></p>
<p><a href="#R-image-529e2eb7b21ebd86e560364bd39d2b71" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/../assets/rasterization-triangle3.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-529e2eb7b21ebd86e560364bd39d2b71"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/../assets/rasterization-triangle3.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 3:</strong> <em>points contained within the white area are all located to the right of all three edges of the triangle.</em></p>
<p>Before we look into Pineda&rsquo;s technique itself, we will first describe the principle of his method. Let&rsquo;s say that the edge of a triangle can be seen as a line splitting the 2D plane (the plane of the image) in two (as shown in figure 2). The principle of Pineda&rsquo;s method is to find a function which he called the <strong>edge function</strong>, so that when we test on which side of this line a given point is (the point P in figure 2), the function returns a negative number when it is to the left of the line, a positive number when it is to the right of this line, and zero when the point is exactly on the line.</p>
<p>In figure 2, we applied this method to the first edge of the triangle (defined by the vertices v0-v1. Be careful the order is important). If we now apply the same method to the two other edges (v1-v2 and v2-v0), we then can see that there is an area (the white triangle) within which all points are positive (figure 3). If we take a point within this area, then we will find that this point is to the right of all three edges of the triangle. If P is a point in the center of a pixel, we can then use this method to find if the pixel overlaps the triangle. If for this point, we find that the edge function returns a positive number for all three edges, then the pixel is contained in the triangle (or may lie on one of its edges). The function Pinada uses also happens to be linear which means that it can be computed incrementally but we will come back to this point later.</p>
<p>Now that we understand the principle, let&rsquo;s find out what that function is. The edge function is defined as (for the edge defined by vertices V0 and V1):</p>

<span class="math align-center">$$E_{01}(P) = (P.x - v0.x) * (V1.y - V0.y) - (P.y - V0.y) * (V1.x - V0.x).$$</span><p>As the paper mentions, this function has the useful property that its value is related to the position of the point (x,y) relative to the edge defined by the points V0 and V1:</p>
<ul>
<li>E(P) &gt; 0 if P is to the &ldquo;right&rdquo; side</li>
<li>E(P) = 0 if P is exactly on the line</li>
<li>E(P) &lt; 0 if P is to the &ldquo;left &quot; side</li>
</ul>
<p>This function is equivalent in mathematics to the magnitude of the cross products between the vector (v1-v0) and (P-v0). We can also write these vectors in a matrix form (presenting this as a matrix has no other interest than just neatly presenting the two vectors):</p>

<span class="math align-center">$$
\begin{vmatrix}
(P.x - V0.x) & (P.y - V0.y) \\
(V1.x - V0.x) & (V1.y - V0.y)
\end{vmatrix}
$$</span><p>If we write that 
<span class="math align-center">$A = (P-V0)$</span> and 
<span class="math align-center">$B = (V1 - V0)$</span>, then we can also write the vectors A and B as a 2x2 matrix:</p>

<span class="math align-center">$$
\begin{vmatrix}
 A.x & A.y \\ 
 B.x & B.y
\end{vmatrix}
$$</span><p>The <a href="http://en.wikipedia.org/wiki/Determinant#2.C2.A0.C3.97.C2.A02_matrices" target="_blank"><strong>determinant</strong></a> of this matrix can be computed as:</p>

<span class="math align-center">$$A.x * B.y - A.y * B.x.$$</span><p>If you now replace the vectors A and B with the vectors (P-V0) and (V1-V0) back again, you get:</p>

<span class="math align-center">$$(P.x - V0.x) * (V1.y - V0.y) - (P.y - V0.y) * (V1.x - V0.x).$$</span><p>Which as you can see, is similar to the edge function we have defined above. In other words, the edge function can either be seen as the determinant of the 2x2 matrix defined by the components of the 2D vectors (P-v0) and (v1-v0) or also as the magnitude of the cross product of the vectors (P-V0) and (V1-V0). Both the determinant and the magnitude of the cross-product of two vectors have the same geometric interpretation. Let&rsquo;s explain.</p>
<p><a href="#R-image-8c691258839cba144a3f11425f4b22f9" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/../assets/cross-product-anim.gif" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-8c691258839cba144a3f11425f4b22f9"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/../assets/cross-product-anim.gif" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 4:</strong> <em>the cross-product of vector B (blue) and A (red) gives a vector C (green) perpendicular to the plane defined by A and B (assuming the right-hand rule convention). The magnitude of vector C depends on the angle between A and B. It can either be positive or negative.</em></p>
<p><a href="#R-image-2f2096ffeea53d80e21229dc39ed1760" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/../assets/cross-product.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-2f2096ffeea53d80e21229dc39ed1760"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/../assets/cross-product.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 5:</strong> <em>the area of the parallelogram is the absolute value of the determinant of the matrix formed by the vectors A and B (or the magnitude of the cross-product of the two vectors B and A (assuming the right-hand rule convention).</em></p>
<p><a href="#R-image-c44fdd30fb4dd505d289db8ec60fd49f" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/../assets/cross-product1.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c44fdd30fb4dd505d289db8ec60fd49f"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/../assets/cross-product1.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 6:</strong> <em>the area of the parallelogram is the absolute value of the determinant of the matrix formed by the vectors A and B. If the angle</em> � <em>is lower than</em> � <em>then the &ldquo;signed&rdquo; area is positive. If the angle is greater than</em> � <em>then the &ldquo;signed&rdquo; area is negative. The angle is computed with respect to the Cartesian coordinates defined by the vectors A and D. They can be seen to separate the plane in two halves.</em></p>
<p><a href="#R-image-31b28323a75b4e867ed626754f5da137" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/../assets/cross-product2.gif" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-31b28323a75b4e867ed626754f5da137"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/../assets/cross-product2.gif" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 7:</strong> <em>P is contained in the triangle if the edge function returns a positive number for the three indicated pairs of vectors.</em></p>
<p>Understanding what&rsquo;s happening is easier when we look at the result of a cross-product between two 3D vectors (Figure 4). In 3D, the cross-product returns another 3D vector that is perpendicular (or orthonormal) to the two original vectors. But as you can see in Figure 4, the magnitude of that orthonormal vector also changes with the orientation of the two vectors with respect to each other. In Figure 4, we assume a right-hand coordinate system. When the two vectors A (red) and B (blue) are either pointing exactly in the same direction or opposite directions, the magnitude of the third vector C (in green) is zero. Vector A has coordinates (1,0,0) and is fixed. When vector B has coordinates (0,0,-1), then the green vector, vector C has coordinates (0,-1,0). If we were to find its &ldquo;signed&rdquo; magnitude, we would find that it is equal to -1. On the other hand, when vector B has coordinates (0,0,1), then C has coordinates (0,1,0) and its signed magnitude is equal to 1. In one case the &ldquo;signed&rdquo; magnitude is negative, and in the second case, the signed magnitude is positive. In fact, in 3D, the magnitude of a vector can be interpreted as the area of the parallelogram having A and B as sides as shown in Figure 5 (read the Wikipedia article on the <a href="http://en.wikipedia.org/wiki/Cross_product#Geometric_meaning" target="_blank">cross product</a> to get more details on this interpretation):</p>

<span class="math align-center">$$Area = || A \times B || = ||A|| ||B|| \sin(\theta).$$</span><p>An area should always be positive, though the sign of the above equation provides an indication of the orientation of the vectors A and B with respect to each other. When with respect to A, B is within the half-plane defined by vector A and a vector orthogonal to A (let&rsquo;s call this vector D; note that A and D form a 2D Cartesian coordinate system), then the result of the equation is positive. When B is within the opposite half plane, the result of the equation is negative (Figure 6). Another way of explaining this result is that the result is positive when the angle (\theta) is in the range (]0,\pi[) and negative when (\theta) is in the range (]\pi, 2\pi[). Note that when (\theta) is exactly equal to 0 or (\pi) then the cross-product or the edge function returns 0.</p>
<p>To find if a point is inside a triangle, all we care about really is the sign of the function we used to compute the area of the parallelogram. However, the area itself also plays an important role in the rasterization algorithm; it is used to compute the barycentric coordinates of the point in the triangle, a technique we will study next. The cross-product in 3D and 2D has the same geometric interpretation, thus the cross-product between two 2D vectors also returns the &ldquo;signed&rdquo; area of the parallelogram defined by the two vectors. The only difference is that in 3D, to compute the area of the parallelogram you need to use this equation:</p>

<span class="math align-center">$$Area = || A \\times B || = ||A|| ||B|| \\sin(\\theta),$$</span><p>while in 2D, this area is given by the cross-product itself (which as mentioned before can also be interpreted as the determinant of a 2x2 matrix):</p>

<span class="math align-center">$$Area = A.x * B.y - A.y * B.x.$$</span><p>From a practical point of view, all we need to do now is test the sign of the edge function computed for each edge of the triangle and another vector defined by a point and the first vertex of the edge (Figure 7).</p>

<span class="math align-center">$$
\begin{array}{l}
E_{01}(P) = (P.x - V0.x) * (V1.y - V0.y) - (P.y - V0.y) * (V1.x - V0.x),\\
E_{12}(P) = (P.x - V1.x) * (V2.y - V1.y) - (P.y - V1.y) * (V2.x - V1.x),\\
E_{20}(P) = (P.x - V2.x) * (V0.y - V2.y) - (P.y - V2.y) * (V0.x - V2.x).
\end{array}
$$</span><p>If all three tests are positive or equal to 0, then the point is inside the triangle (or lying on one of the edges of the triangle). If any one of the tests is negative, then the point is outside the triangle. In code we get:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">bool</span> <span class="nf">edgeFunction</span><span class="p">(</span><span class="k">const</span> <span class="n">Vec2f</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Vec3f</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">,</span> <span class="k">const</span> <span class="n">Vec2f</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="k">return</span> <span class="p">((</span><span class="n">c</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">a</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">a</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">a</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">a</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">gt</span><span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="kt">bool</span> <span class="n">inside</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="n">inside</span> <span class="o">&amp;=</span> <span class="n">edgeFunction</span><span class="p">(</span><span class="n">V0</span><span class="p">,</span> <span class="n">V1</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="n">inside</span> <span class="o">&amp;=</span> <span class="n">edgeFunction</span><span class="p">(</span><span class="n">V1</span><span class="p">,</span> <span class="n">V2</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="n">inside</span> <span class="o">&amp;=</span> <span class="n">edgeFunction</span><span class="p">(</span><span class="n">V2</span><span class="p">,</span> <span class="n">V0</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">inside</span> <span class="o">==</span> <span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="c1">// point p is inside triangles defined by vertices v0, v1, v2
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="c1"></span>    <span class="p">...</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><blockquote>
<details>
The edge function has the property of being linear. We refer you to the original paper if you wish to learn more about this property and how it can be used to optimize the algorithm. In short though, let's say that because of this property, the edge function can be run in parallel (several pixels can be tested at once). This makes the method ideal for hardware implementation. This explains partially why pixels on the GPU are generally rendered as a block of 2x2 pixels (pixels can be tested in a single cycle). Hint: you can also use SSE instructions and multi-threading to optimize the algorithm on the CPU.
</details>
</blockquote>
<h3 id="alternative-to-the-edge-function">Alternative to the Edge Function</h3>
<p>There are other ways than the edge function method to find if pixels overlap triangles, however as mentioned in the introduction of this chapter, we won&rsquo;t study them in this lesson. Just for reference though, the other common technique is called scanline rasterization. It is based on the Brenseham algorithm that is generally used to draw lines. GPUs use the edge method mostly because it is more generic than the scanline approach which is also more difficult to run in parallel than the edge method, but we won&rsquo;t provide more information on this topic in this lesson.</p>
<h3 id="be-careful-winding-order-matters">Be Careful! Winding Order Matters</h3>
<p><a href="#R-image-7c0b5188df241d1b442c1a78774e5fa4" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/../assets/winding.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7c0b5188df241d1b442c1a78774e5fa4"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/../assets/winding.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 8:</strong> <em>clockwise and counter-clockwise winding.</em></p>
<p>One of the things we have been talking about yet, but which has great importance in CG, is the order in which you declare the vertices making up the triangles. They are two possible conventions which you can see illustrated in Figure 8: <strong>clockwise</strong> or <strong>counter-clockwise ordering</strong> or <strong>winding</strong>. Winding is important because it essentially defines one important property of the triangle which is the orientation of its normal. Remember that the normal of the triangle can be computed from the cross product of the two vectors A=(V2-V0) and B=(V1-V0). Let&rsquo;s say that V0={0,0,0}, V1={1,0,0} and V2={0,-1,0} then (V1-V0)={1,0,0} and (V2-V0)={0,-1,0}. Let&rsquo;s now compute the cross-product of these two vectors:</p>

<span class="math align-center">$$
\begin{array}{l}
N = (V1-V0) \times (V2-V0)\\
N.x = a.y*b.z - a.z * b.y = 0*0 - 0*-1\\
N.y = a.z*b.x - a.x * b.z = 0*0 - 1*0\\
N.z = a.x*b.y - a.y * b.x = 1*-1 - 0*0 = -1\\
N=\{0,0,-1\}
\end{array}
$$</span><p>However if you declare the vertices in counter-clockwise order, then V0={0,0,0}, V1={0,-1,0} and V2={1,0,0}, (V1-V0)={0,-1,0} and (V2-V0)={1,0,0}. Let&rsquo;s compute the cross-product of these two vectors again:</p>

<span class="math align-center">$$
\begin{array}{l}
N = (V1-V0) \times (V2-V0)\\
N.x = a.y*b.z - a.z * b.y = 0*0 - 0*-1\\
N.y = a.z*b.x - a.x * b.z = 0*0 - 1*0\\
N.z = a.x*b.y - a.y * b.x = 0*0 - -1*1 = 1\\
N=\{0,0,1\}
\end{array}
$$</span><p><a href="#R-image-7d60bf430072ea9c89101e48c58c6dc6" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/../assets/winding1.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7d60bf430072ea9c89101e48c58c6dc6"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/../assets/winding1.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 9:</strong> <em>the ordering defines the orientation of the normal.</em></p>
<p><a href="#R-image-0971f4a3713e6d5a9f6a907f79192a43" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/../assets/rasterization-triangle4.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-0971f4a3713e6d5a9f6a907f79192a43"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/../assets/rasterization-triangle4.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 10:</strong> <em>the ordering defines if points inside the triangle are positive or negative.</em></p>
<p>As expected, the two normals are pointing in opposite directions. The orientation of the normal has great importance for lots of different reasons, but one of the most important ones is called <strong>face culling</strong>. Most rasterizers and even ray-tracer for that matter may not render triangles whose normal is facing away from the camera. This is called <a href="http://en.wikipedia.org/wiki/Back-face_culling" target="_blank">back-face culling</a>. Most rendering APIs such as OpenGL or DirectX give the option to turn back-face culling off, however, you should still be aware that vertex ordering plays a role in what&rsquo;s rendered, among many other things. And not surprisingly, the edge function is one of these other things. Before we get to explain why it matters in our particular case, let&rsquo;s say that there is no particular rule when it comes to choosing the order. In reality, so many details in a renderer implementation may change the orientation of the normal that you can&rsquo;t assume that by declaring vertices in a certain order, you will get the guarantee that the normal will be oriented a certain way. For instance, rather than using the vectors (V1-V0) and (V2-V0) in the cross-product, you could as have used (V0-V1) and (V2-V1) instead. It would have produced the same normal but flipped. Even if you use the vectors (V1-V0) and (V2-V0), <a href="../../../lessons/mathematics-physics-for-computer-graphics/geometry/math-operations-on-points-and-vectors">remember</a> that the order of the vectors in the cross-product changes the sign of the normal: 
<span class="math align-center">$A \times B=-B \times A$</span>. So the direction of your normal also depends on the order of the vectors in the cross-product. For all these reasons, don&rsquo;t try to assume that declaring vertices in one order rather than the other will give you one result or the other. What&rsquo;s important though, is that once you stick to the convention you have chosen. Generally, graphics APIs such as OpenGL and DirectX expect triangles to be declared in counter-clockwise order. We will also use counter-clockwise winding. Now let&rsquo;s see how ordering impacts the edge function.</p>
<p>Why does winding matter when it comes to the edge function? You may have noticed that since the beginning of this chapter, in all figures we have drawn the triangle vertices in clockwise order. We have also defined the edge function as:</p>

<span class="math align-center">$$
\begin{array}{l}
E_{AB}(P) &=& (P.x - A.x) * (B.y - A.y) - \\
&& (P.y - A.y) * (B.x - A.x)
\end{array}
$$</span><p>If we respect this convention, then points to the right of the line defined by the vertices A and B will be positive. For example, a point to, the right of V0V1, V1V2, or V2V0 would be positive. However, if we were to declare the vertices in counter-clockwise order, points to the right of an edge defined by vertices A and B would still be positive, but then they would be outside the triangle. In other words, points overlapping the triangle would not be positive but negative (Figure 10). You can potentially still get the code working with positive numbers with a small change to the edge function:</p>

<span class="math align-center">$$E_{AB}(P) = (A.x - B.x) * (P.y - A.y) - (A.y - B.y) * (P.x - A.x).$$</span><p>In conclusion, depending on the ordering convention you use, you may need to use one version of the edge function or the other.</p>
<h3 id="barycentric-coordinates">Barycentric Coordinates</h3>
<p><a href="#R-image-313fb71a1b9721f4ef90b8ec45ff942a" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/../assets/barycentric1.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-313fb71a1b9721f4ef90b8ec45ff942a"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/../assets/barycentric1.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 11:</strong> <em>the area of a parallelogram is twice the area of a triangle.</em></p>
<p>Computing barycentric coordinates are not necessary to get the rasterization algorithm working. For a naive implementation of the rendering technique, all you need is to project the vertices and use a technique like an edge function that we described above, to find if pixels are inside triangles. These are the only two necessary steps to produce an image. However, the result of the edge function which as we explained above, can be interpreted as the area of the parallelogram defined by vectors A and B can directly be used to compute these barycentric coordinates. Thus, it makes sense to study the edge function and the barycentric coordinates at the same time.</p>
<p>Before we get any further though, let&rsquo;s explain what these barycentric coordinates are. First, they come in a set of <b>three floating point numbers</b> which in this lesson, we will denote 
<span class="math align-center">$\lambda_0$</span>, 
<span class="math align-center">$\lambda_1$</span> and 
<span class="math align-center">$\lambda_2$</span>. Many different conventions exist but Wikipedia uses the greek letter lambda as well ((\lambda)) which is also used by other authors (the greek letter omega (\omega) is also sometimes used). This doesn&rsquo;t matter, you can call them the way you want. In short, the coordinates can be used to define any point on the triangle in the following manner:</p>

<span class="math align-center">$$P = \lambda_0 * V0 + \lambda_1 * V1 + \lambda_2 * V2.$$ </span><p>Where as usual, V0, V1, and V2 are the vertices of a triangle. These coordinates can take on any value, but for points that are inside the triangle (or lying on one of its edges) they can only be in the range [0,1] and the sum of the three coordinates is equal to 1. In other words:</p>

<span class="math align-center">$$\lambda_0 + \lambda_1 + \lambda_2 = 1, \text{ for } P \in \triangle{V0, V1, V2}.$$</span><p><a href="#R-image-13f87d1df5e65a59f68266a9ddc420d5" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/../assets/barycentric2.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-13f87d1df5e65a59f68266a9ddc420d5"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/../assets/barycentric2.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 12:</strong> <em>how do we find the color of P?</em></p>
<p>This is a form of interpolation if you want. They are also sometimes defined as <strong>weights</strong> for the triangle&rsquo;s vertices (which is why in the code we will denote them with the letter w). A point overlapping the triangle can be defined as &ldquo;a little bit of V0 plus a little bit of V1 plus a little bit of V2&rdquo;. Note that when any of the coordinates is 1 (which means that the others in this case are necessarily 0) then the point P is equal to one of the triangle&rsquo;s vertices. For instance if 
<span class="math align-center">$\lambda_2 = 1$</span> then P is equal to V2. Interpolating the triangle&rsquo;s vertices to find the position of a point inside the triangle is not that useful. But the method can also be used to interpolate across the surface of the triangle any quantity or variable that has been defined at the triangle&rsquo;s vertices. Imagine for instance that you have defined a color at each vertex of the triangle. Say V0 is red, V1 is green and V2 is blue (Figure 12). What you want to do, is find how these three colors interpolated across the surface of the triangle. If you know the barycentric coordinates of a point P on the triangle, then its color 
<span class="math align-center">$C_P$</span> (which is a combination of the triangle vertices&rsquo; colors) is defined as:</p>

<span class="math align-center">$$C_P = \lambda_0 * C_{V0} + \lambda_1 * C_{V1} + \lambda_2 * C_{V2}.$$ </span><p>This is a very handy technique that is going to be useful to shade triangles. Data associated with the vertices of triangles is called <strong>vertex attribute</strong>. This is a very common and very important technique in CG. <strong>The most common vertex attributes are colors, normals, and texture coordinates</strong>. What this means in practice, is that generally when you define a triangle you don&rsquo;t only pass on to the renderer the triangle vertices but also its associated vertex attributes. For example, if you want to shade the triangle you may need color and normal vertex attribute, which means that each triangle will be defined by 3 points (the triangle vertex positions), 3 colors (the color of the triangle vertices), and 3 normals (the normal of the triangle vertices). Normals too can be interpolated across the surface of the triangle. Interpolated normals are used in a technique called <a href="http://en.wikipedia.org/wiki/Gouraud_shading" target="_blank"><strong>smooth shading</strong></a> which was first introduced by Henri Gouraud. We will explain this technique later when we get to shading.</p>
<p>How do we find these barycentric coordinates? It turns out to be simple. As mentioned above when we presented the edge function, the result of the edge function can be interpreted as the area of the parallelogram defined by the vectors A and B. If you look at Figure 8, you can easily see that the area of the triangle defined by the vertices V0, V1, and V2, is just half of the area of the parallelogram defined by the vectors A and B. The area of the triangle is thus half the area of the parallelogram which we know can be computed by the cross-product of the two 2D vectors A and B:</p>

<span class="math align-center">$$Area_{\triangle{V0V1V2}}= {1 \over 2} {A \times B} = {1 \over 2}(A.x * B.y - A.y * B.x).$$</span><p><a href="#R-image-f485854f8a2ba6be85a59b45e357367f" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/../assets/barycentric3.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f485854f8a2ba6be85a59b45e357367f"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/../assets/barycentric3.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 13:</strong> connecting P to each vertex of the triangle forms three sub-triangles.</p>
<p>If the point P is inside the triangle, then you can see by looking at Figure 3, that we can draw three sub-triangles: V0-V1-P (green), V1-V2-P (magenta), and V2-V0-P (cyan). It is quite obvious that the sum of these three sub-triangle areas, is equal to the area of the triangle V0-V1-V2:</p>

<span class="math align-center">$$
\begin{array}{l}
Area_{\triangle{V0V1V2}} =&Area_{\triangle{V0V1P}} + \\& Area_{\triangle{V1V2P}} + \\& Area_{\triangle{V2V0P}}.
\end{array}
$$</span><p><a href="#R-image-cd712127f6bf0dab2c573e2bd510fab8" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/../assets/barycentric4.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-cd712127f6bf0dab2c573e2bd510fab8"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/../assets/barycentric4.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 14:</strong> <em>the values for</em> �0*,* �1 <em>and</em> �2 <em>depends on the position of P on the triangle.</em></p>
<p>Let&rsquo;s first try to intuitively get a sense of how they work. This will be easier hopefully if you look at Figure 14. Each image in the series shows what happens to the sub-triangle as a point P which is originally on the edge defined by the vertices V1-V2, moves towards V0. In the beginning, P lies exactly on the edge V1-V2. In a way, this is similar to a basic linear interpolation between two points. In other words, we could write:</p>

<span class="math align-center">$$P = \lambda_1 * V1 + \lambda_2 * V2$$</span><p>With 
<span class="math align-center">$\lambda_1 + \lambda_2 = 1$</span> thus 
<span class="math align-center">$\lambda_2 = 1 - \lambda_1$</span>. What&rsquo;s more interesting in this particular case is that if the generic equation for computing the position of P using barycentric coordinates is:</p>

<span class="math align-center">$$P = \lambda_0 * V0 + \lambda_1 * V1 + \lambda_2 * V2.$$ </span><p>Thus, it clearly shows that in this particular case, (\lambda_0) is equal to 0.</p>

<span class="math align-center">$$
\begin{array}{l}
P = \lambda_0 * V0 + \lambda_1 * V1 + \lambda_2 * V2,\\
P = 0 * V0 + \lambda_1 * V1 + \lambda_2 * V2,\\
P = \lambda_1 * V1 + \lambda_2 * V2.
\end{array}
$$</span><p>This is pretty simple. Note also that in the first image, the red triangle is not visible. Note also that P is closer to V1 than it is to V2. Thus, somehow, 
<span class="math align-center">$\lambda_1$</span> is necessarily greater than 
<span class="math align-center">$\lambda_2$</span>. Note also that in the first image, the green triangle is bigger than the blue triangle. So if we summarize: when the red triangle is not visible, 
<span class="math align-center">$\lambda_0$</span> is equal to 0. 
<span class="math align-center">$\lambda_1$</span> is greater than 
<span class="math align-center">$\lambda_2$</span> and the green triangle is bigger than the blue triangle. Thus somehow, there seems to be a relationship between the area of the triangles and the barycentric coordinates. Furthermore, the red triangle seems associated with 
<span class="math align-center">$\lambda_0$</span> the green triangle with 
<span class="math align-center">$\lambda_1$</span>, and the blue triangle with 
<span class="math align-center">$\lambda_2$</span>.</p>
<ul>
<li>
<span class="math align-center">$\lambda_0$</span> is proportional to the area of the red triangle,</li>
<li>
<span class="math align-center">$\lambda_1$</span> is proportional to the area of the green triangle,</li>
<li>
<span class="math align-center">$\lambda_2$</span> is proportional to the area of the blue triangle.</li>
</ul>
<p>Now, let&rsquo;s jump directly to the last image. In this case, P is equal to V0. This is only possible if 
<span class="math align-center">$\lambda_0$</span> is equal to 1 and the two other coordinates are equal to 0:</p>

<span class="math align-center">$$
\begin{array}{l}
P = \lambda_0 * V0 + \lambda_1 * V1 + \lambda_2 * V2,\\
P = 1 * V0 + 0 * V1 + 0 * V2,\\
P = V0.
\end{array}
$$</span><p><a href="#R-image-634690f75208dd5edfd2ffdcdf295b36" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/../assets/barycentric5.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-634690f75208dd5edfd2ffdcdf295b36"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/../assets/barycentric5.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 15:</strong> <em>to compute one of the barycentric coordinates, use the area of the triangle defined by P and the edge opposite to the vertex for which the barycentric coordinate needs to be computed.</em></p>
<p>Note also that in this particular case, the blue and green triangles have disappeared and that the area of the triangle V0-V1-V2 is the same as the area of the red triangle. This confirms our intuition that there is a relationship between the area of the sub-triangles and the barycentric coordinates. Finally, from the above observation we can also say that each barycentric coordinate is somehow related to the area of the sub-triangle defined by the edge directly opposite to the vertex the barycentric coordinate is associated with, and the point P. In other words (Figure 15):</p>
<ul>
<li>
<span class="math align-center">$\color{red}{\lambda_0}$</span> is associated with V0. The edge opposite V0 is V1-V2. V1-V2-P defines the red triangle.</li>
<li>
<span class="math align-center">$\color{green}{\lambda_1}$</span> is associated with V1. The edge opposite V1 is V2-V0. V2-V0-P defines the green triangle.</li>
<li>
<span class="math align-center">$\color{blue}{\lambda_2}$</span> is associated with V2. The edge opposite V2 is V0-V1. V0-V1-P defines the blue triangle.</li>
</ul>
<p>If you haven&rsquo;t noticed yet, the area of the red, green, and blue triangles are given by the respective edge functions that we have been using before to find if P is inside the triangle, divided by 2 (remember that the edge function itself gives the &ldquo;signed&rdquo; area of the parallelogram defined by the two vectors A and B, where A and B can be any of the three edges of the triangle):</p>

<span class="math align-center">$$
\begin{array}{l}
\color{red}{Area_{tri}(V1,V2,P)}=&{1\over2}E_{12}(P),\\
\color{green}{Area_{tri}(V2,V0,P)}=&{1\over2}E_{20}(P),\\
\color{blue}{Area_{tri}(V0,V1,P)}=&{1\over2}E_{01}(P).\\
\end{array}
$$</span><p>The barycentric coordinates can be computed as the ratio between the area of the sub-triangles and the area of the triangle V0V1V2:</p>

<span class="math align-center">$$\begin{array}{l}
\color{red}{\lambda_0 = \dfrac{Area(V1,V2,P) } {Area(V0,V1,V2)}},\\
\color{green}{\lambda_1 = \dfrac{Area(V2,V0,P)}{Area(V0,V1,V2)}},\\
\color{blue}{\lambda_2 = \dfrac{Area(V0,V1,P)}{Area(V0,V1,V2)}}.\\
\end{array}
$$</span><p>What the division by the triangle area does, essentially normalizes the coordinates. For example, when P has the same position as V0, then the area of the triangle V2V1P (the red triangle) is the same as the area of the triangle V0V1V2. Thus dividing one by the over gives 1, which is the value of the coordinate (\lambda_0). Since in this case, the green and blue triangles have area 0, (\lambda_1) and (\lambda_2) are equal to 0 and we get:</p>

<span class="math align-center">$$P = 1 * V0 + 0 * V1 + 0 * V2 = V0.$$</span><p>Which is what we expect.</p>
<p>To compute the area of a triangle we can use the edge function as mentioned before. This works for the sub-triangles as well as the main triangle V0V1V2. However the edge function returns the area of the parallelogram instead of the area of the triangle (Figure 8) but since the barycentric coordinates are computed as the ratio between the sub-triangle area and the main triangle area, we can ignore the division by 2 (this division which is in the numerator and the denominator cancel out):</p>

<span class="math align-center">$$\lambda_0 = \dfrac{Area_{tri}(V1,V2,P)}{Area_{tri}(V0,V1,V2)} = \dfrac{1/2 E_{12}(P)}{1/2E_{12}(V0)} =  \dfrac{E_{12}(P)}{E_{12}(V0)}.$$</span><p>Note that: ( E_{01}(V2) = E_{12}(V0) = E_{20}(V1) = 2 * Area_{tri}(V0,V1,V2)).</p>
<p>Let&rsquo;s see how it looks in the code. We were already computing the edge functions before to test if points were inside triangles. Only, in our previous implementation, we were just returning true or false depending on whether the result of the function was either positive or negative. To compute the barycentric coordinates, we need the actual result of the edge function. We can also use the edge function to compute the area (multiplied by 2) of the triangle. Here is a version of an implementation that tests if a point P is inside a triangle and if so, computes its barycentric coordinates:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">float</span> <span class="nf">edgeFunction</span><span class="p">(</span><span class="k">const</span> <span class="n">Vec2f</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Vec3f</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">,</span> <span class="k">const</span> <span class="n">Vec2f</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">a</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">a</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">a</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">a</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="kt">float</span> <span class="n">area</span> <span class="o">=</span> <span class="n">edgeFunction</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">);</span> <span class="c1">// area of the triangle multiplied by 2
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1"></span><span class="kt">float</span> <span class="n">w0</span> <span class="o">=</span> <span class="n">edgeFunction</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span> <span class="c1">// signed area of the triangle v1v2p multiplied by 2
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="c1"></span><span class="kt">float</span> <span class="n">w1</span> <span class="o">=</span> <span class="n">edgeFunction</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="n">v0</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span> <span class="c1">// signed area of the triangle v2v0p multiplied by 2
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1"></span><span class="kt">float</span> <span class="n">w2</span> <span class="o">=</span> <span class="n">edgeFunction</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span> <span class="c1">// signed area of the triangle v0v1p multiplied by 2
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="c1">// if point p is inside triangles defined by vertices v0, v1, v2
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="n">w0</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">w1</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">w2</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="c1">// barycentric coordinates are the areas of the sub-triangles divided by the area of the main triangle
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="c1"></span>    <span class="n">w0</span> <span class="o">/=</span> <span class="n">area</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="n">w1</span> <span class="o">/=</span> <span class="n">area</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="n">w2</span> <span class="o">/=</span> <span class="n">area</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>Let&rsquo;s try this code to produce an actual image.</p>
<blockquote>
<details>
We know that:

<span class="math align-center">$$\lambda_0 + \lambda_1 + \lambda_2 = 1.$$</span><p>We also know that we can compute any value across the surface of the triangle using the following equation:</p>

<span class="math align-center">$$Z = \lambda_0 * Z0 + \lambda_1 * Z1 + \lambda_0 * Z2.$$</span><p>The value that we interpolate in this case is Z which can be anything we want or as the name suggests, the z-coordinate of the triangle&rsquo;s vertices in camera space. We can re-write the first equation:</p>

<span class="math align-center">$$\lambda_0 = 1 - \lambda_1 - \lambda_2.$$</span><p>If we plug this equation in the equation to compute Z and simplify, we get:</p>

<span class="math align-center">$$Z = Z0 + \lambda_1(Z1 - Z0) + \lambda_2(Z2 - Z0).$$</span><p>(Z1 - Z0) and (Z2 - Z0) can generally be precomputed which simplifies the computation of Z to two additions and two multiplications. We mention this optimization because GPUs use it and people may mention it for this reason essentially.</p>
</details>
</blockquote>
<h3 id="interpolate-vs-extrapolate">Interpolate vs. Extrapolate</h3>
<p><a href="#R-image-3756fdd3c105d35b8660fd6de2a80e89" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/../assets/extrapolate.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-3756fdd3c105d35b8660fd6de2a80e89"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/../assets/extrapolate.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 16:</strong> <em>interpolation vs. extrapolation.</em></p>
<p>One thing worth noticing is that the computation of barycentric coordinates works independently from its position with respect to the triangle. In other words, the coordinates are valid if the point is inside our outside the triangle. When the point is inside, using the barycentric coordinates to evaluate the value of a vertex attribute is called interpolation, and when the point is outside, we speak of extrapolation. This is an important detail because in some cases, we will have to evaluate the value of a given vertex attribute for points that potentially don&rsquo;t overlap triangles. To be more specific, this will be needed to compute the derivatives of the triangle texture coordinates for example. These derivatives are used to filter textures properly. If you are interested in learning more about this particular topic we invite you to read the lesson on Texture Mapping. In the meantime, all you need to remember is that barycentric coordinates are valid even when the point doesn&rsquo;t cover the triangle. You also need to know about the difference between vertex attribute extrapolation and interpolation.</p>
<h3 id="rasterization-rules">Rasterization Rules</h3>
<p><a href="#R-image-0fe74915088de57dff56ca1178e69989" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/../assets/top-left.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-0fe74915088de57dff56ca1178e69989"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/../assets/top-left.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 17:</strong> <em>pixels may cover an edge shared by two triangles.</em></p>
<p><a href="#R-image-510106deb0c734ddf0ac49b890272fdf" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/../assets/top-left2.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-510106deb0c734ddf0ac49b890272fdf"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/../assets/top-left2.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 18:</strong> if the geometry is semi-transparent, a dark edge may appear where pixels overlap the two triangles.</p>
<p><a href="#R-image-a14c1217da2e5654edbc18ebb216b375" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/../assets/top-left3.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a14c1217da2e5654edbc18ebb216b375"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/../assets/top-left3.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 19:</strong> <em>top and left edges.</em></p>
<p>In some special cases, a pixel may overlap more than one triangle. This happens when a pixel lies exactly on an edge shared by two triangles as shown in Figure 17. Such a pixel would pass the coverage test for both triangles. If they are semi-transparent, a dark edge may appear where the pixels overlap the two triangles as a result of the way semi-transparent objects are combined (imagine two super-imposed semi-transparent sheets of plastic. The surface is more opaque and looks darker than the individual sheets). You would get something similar to what you can see in Figure 18, which is a darker line where the two triangles share an edge.</p>
<p>The solution to this problem is to come up with some sort of rule that guarantees that a pixel can never overlap twice two triangles sharing an edge. How do we do that? Most graphics APIs such as OpenGL and DirectX define something which they call the <strong>top-left rule</strong>. We already know the coverage test returns true if a point is either inside the triangle or if it lies on any of the triangle edges. What the top-left rule says though, is that the pixel or point is considered to overlap a triangle if it is either inside the triangle or lies on either a triangle&rsquo;s top edge or any edge that is considered to be a left edge. What is a top and theft edge? If you look at Figure 19, you can easily see what we mean by the top and left edges.</p>
<ul>
<li>A top edge is an edge that is perfectly horizontal and whose defining vertices are above the third one. Technically this means that the y-coordinates of the vector V[(X+1)%3]-V[X] are equal to 0 and that its x-coordinates are positive (greater than 0).</li>
<li>A left edge is essentially an edge that is going up. Keep in mind that in our case, vertices are defined in clockwise order. An edge is considered to go up if its respective vector V[(X+1)%3]-V[X] (where X can either be 0, 1, 2) has a positive y-coordinate.</li>
</ul>
<blockquote>
<details>
Of course, if you are using a counter-clockwise order, a top edge is an edge that is horizontal and whose x-coordinate is negative, and a left edge is an edge whose y-coordinate is negative.
</details>
</blockquote>
<p>In pseudo-code we have:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="c1">// Does it pass the top-left rule?
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1"></span><span class="n">Vec2f</span> <span class="n">v0</span> <span class="o">=</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">Vec2f</span> <span class="n">v1</span> <span class="o">=</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">Vec2f</span> <span class="n">v2</span> <span class="o">=</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="kt">float</span> <span class="n">w0</span> <span class="o">=</span> <span class="n">edgeFunction</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="kt">float</span> <span class="n">w1</span> <span class="o">=</span> <span class="n">edgeFunction</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="n">v0</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="kt">float</span> <span class="n">w2</span> <span class="o">=</span> <span class="n">edgeFunction</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="n">Vec2f</span> <span class="n">edge0</span> <span class="o">=</span> <span class="n">v2</span> <span class="o">-</span> <span class="n">v1</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="n">Vec2f</span> <span class="n">edge1</span> <span class="o">=</span> <span class="n">v0</span> <span class="o">-</span> <span class="n">v2</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="n">Vec2f</span> <span class="n">edge2</span> <span class="o">=</span> <span class="n">v1</span> <span class="o">-</span> <span class="n">v0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="kt">bool</span> <span class="n">overlaps</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">
</span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="c1">// If the point is on the edge, test if it is a top or left edge, 
</span></span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="c1">// otherwise test if  the edge function is positive
</span></span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="c1"></span><span class="n">overlaps</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">w0</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="p">((</span><span class="n">edge0</span><span class="p">.</span><span class="n">y</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">edge0</span><span class="p">.</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>  <span class="n">edge0</span><span class="p">.</span><span class="n">y</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="n">w0</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="n">overlaps</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">w1</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="p">((</span><span class="n">edge1</span><span class="p">.</span><span class="n">y</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">edge1</span><span class="p">.</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>  <span class="n">edge1</span><span class="p">.</span><span class="n">y</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="n">w1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="n">overlaps</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">w1</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="p">((</span><span class="n">edge2</span><span class="p">.</span><span class="n">y</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">edge2</span><span class="p">.</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>  <span class="n">edge2</span><span class="p">.</span><span class="n">y</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="n">w2</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">
</span></span><span class="line"><span class="ln">22</span><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">overlaps</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">    <span class="c1">// pixel overlap the triangle
</span></span></span><span class="line"><span class="ln">24</span><span class="cl"><span class="c1"></span>    <span class="p">...</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>This version is valid as a proof of concept but highly unoptimized. The key idea is to first check whether any of the values return by returned function is equal to 0 which means that the point lies on the edge. In this case, we test if the edge in question is a top-left edge. If it is, it returns true. If the value returned by the edge function is not equal to 0, we then return true if the value is greater than 0. We won&rsquo;t implement the top-left rule in the program provided with this lesson.</p>
<h3 id="putting-things-together-finding-if-a-pixel-overlaps-a-triangle">Putting Things Together: Finding if a Pixel Overlaps a Triangle</h3>
<p><a href="#R-image-3d40bed634472e83391c5f06b826c43d" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/../assets/raster2d.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-3d40bed634472e83391c5f06b826c43d"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/../assets/raster2d.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 20:</strong> <em>Example of vertex attribute linear interpolation using barycentric coordinates.</em></p>
<p>Let&rsquo;s test the different techniques we learned about in this chapter, in a program that produces an actual image. We will just assume that we have projected the triangle already (check the last chapter of this lesson for a complete implementation of the rasterization algorithm). We will also assign a color to each vertex of the triangle. Here is how the image is formed. We will loop over all the pixels in the image and test if they overlap the triangle using the edge function method. All three edges of the triangle are tested against the current position of the pixel, and if the edge function returns a positive number for all the edges then the pixel overlaps the triangle. We can then compute the pixel&rsquo;s barycentric coordinates and use these coordinates to shade the pixel by interpolating the color defined at each vertex of the triangle. The result of the frame-buffer is saved to a PPM file (that you can read with Photoshop). The output of the program is shown in Figure 20.</p>
<p>Note that one possible optimization for this program would be to loop over the pixels contained in the bounding box of the triangle. We haven&rsquo;t made this optimization in this version of the program but you can make it yourself if you wish (using the code from the previous chapters). You can also check the source code of this lesson (available in the last chapter).</p>
<p>Note also that in this version of the program, we move point P to the center of each pixel. You could as well use the pixel integer coordinates. You will find more details on this topic in the next chapter.</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="c1">// c++ -o raster2d raster2d.cpp
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1">// (c) www.scratchapixel.com
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="cp">#include &amp;ltcstdio&amp;gt
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="cp">#include &amp;ltcstdlib&amp;gt
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="cp">#include &amp;ltfstream&amp;gt
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="k">typedef</span> <span class="kt">float</span> <span class="n">Vec2</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="k">typedef</span> <span class="kt">float</span> <span class="n">Vec3</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">Rgb</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="kr">inline</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="kt">float</span> <span class="nf">edgeFunction</span><span class="p">(</span><span class="k">const</span> <span class="n">Vec2</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Vec2</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">,</span> <span class="k">const</span> <span class="n">Vec2</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="p">}</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">
</span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">    <span class="n">Vec2</span> <span class="n">v0</span> <span class="o">=</span> <span class="p">{</span><span class="mf">491.407</span><span class="p">,</span> <span class="mf">411.407</span><span class="p">};</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">    <span class="n">Vec2</span> <span class="n">v1</span> <span class="o">=</span> <span class="p">{</span><span class="mf">148.593</span><span class="p">,</span> <span class="mf">68.5928</span><span class="p">};</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">    <span class="n">Vec2</span> <span class="n">v2</span> <span class="o">=</span> <span class="p">{</span><span class="mf">148.593</span><span class="p">,</span> <span class="mf">411.407</span><span class="p">};</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">    <span class="n">Vec3</span> <span class="n">c0</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">    <span class="n">Vec3</span> <span class="n">c1</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">    <span class="n">Vec3</span> <span class="n">c2</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">    
</span></span><span class="line"><span class="ln">25</span><span class="cl">    <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">w</span> <span class="o">=</span> <span class="mi">512</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl">    <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">512</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl">    
</span></span><span class="line"><span class="ln">28</span><span class="cl">    <span class="n">Rgb</span> <span class="o">*</span><span class="n">framebuffer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Rgb</span><span class="p">[</span><span class="n">w</span> <span class="o">*</span> <span class="n">h</span><span class="p">];</span>
</span></span><span class="line"><span class="ln">29</span><span class="cl">    <span class="n">memset</span><span class="p">(</span><span class="n">framebuffer</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">,</span> <span class="n">w</span> <span class="o">*</span> <span class="n">h</span> <span class="o">*</span> <span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">30</span><span class="cl">    
</span></span><span class="line"><span class="ln">31</span><span class="cl">    <span class="kt">float</span> <span class="n">area</span> <span class="o">=</span> <span class="n">edgeFunction</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">32</span><span class="cl">    
</span></span><span class="line"><span class="ln">33</span><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&amp;</span><span class="n">lt</span> <span class="n">h</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">34</span><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span> <span class="n">w</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">35</span><span class="cl">            <span class="n">Vec2</span> <span class="n">p</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span> <span class="o">+</span> <span class="mf">0.5f</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mf">0.5f</span><span class="p">};</span>
</span></span><span class="line"><span class="ln">36</span><span class="cl">            <span class="kt">float</span> <span class="n">w0</span> <span class="o">=</span> <span class="n">edgeFunction</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">37</span><span class="cl">            <span class="kt">float</span> <span class="n">w1</span> <span class="o">=</span> <span class="n">edgeFunction</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="n">v0</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">38</span><span class="cl">            <span class="kt">float</span> <span class="n">w2</span> <span class="o">=</span> <span class="n">edgeFunction</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">39</span><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">w0</span> <span class="o">&amp;</span><span class="n">gt</span><span class="o">=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">w1</span> <span class="o">&amp;</span><span class="n">gt</span><span class="o">=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">w2</span> <span class="o">&amp;</span><span class="n">gt</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">40</span><span class="cl">                <span class="n">w0</span> <span class="o">/=</span> <span class="n">area</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">41</span><span class="cl">                <span class="n">w1</span> <span class="o">/=</span> <span class="n">area</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">42</span><span class="cl">                <span class="n">w2</span> <span class="o">/=</span> <span class="n">area</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">43</span><span class="cl">                <span class="kt">float</span> <span class="n">r</span> <span class="o">=</span> <span class="n">w0</span> <span class="o">*</span> <span class="n">c0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">w1</span> <span class="o">*</span> <span class="n">c1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">w2</span> <span class="o">*</span> <span class="n">c2</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="ln">44</span><span class="cl">                <span class="kt">float</span> <span class="n">g</span> <span class="o">=</span> <span class="n">w0</span> <span class="o">*</span> <span class="n">c0</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">w1</span> <span class="o">*</span> <span class="n">c1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">w2</span> <span class="o">*</span> <span class="n">c2</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="ln">45</span><span class="cl">                <span class="kt">float</span> <span class="n">b</span> <span class="o">=</span> <span class="n">w0</span> <span class="o">*</span> <span class="n">c0</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">w1</span> <span class="o">*</span> <span class="n">c1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">w2</span> <span class="o">*</span> <span class="n">c2</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span></span><span class="line"><span class="ln">46</span><span class="cl">                <span class="n">framebuffer</span><span class="p">[</span><span class="n">j</span> <span class="o">*</span> <span class="n">w</span> <span class="o">+</span> <span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)(</span><span class="n">r</span> <span class="o">*</span> <span class="mi">255</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">47</span><span class="cl">                <span class="n">framebuffer</span><span class="p">[</span><span class="n">j</span> <span class="o">*</span> <span class="n">w</span> <span class="o">+</span> <span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)(</span><span class="n">g</span> <span class="o">*</span> <span class="mi">255</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">48</span><span class="cl">                <span class="n">framebuffer</span><span class="p">[</span><span class="n">j</span> <span class="o">*</span> <span class="n">w</span> <span class="o">+</span> <span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)(</span><span class="n">b</span> <span class="o">*</span> <span class="mi">255</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">49</span><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="ln">50</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln">51</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">52</span><span class="cl">    
</span></span><span class="line"><span class="ln">53</span><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span> <span class="n">ofs</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">54</span><span class="cl">    <span class="n">ofs</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="s">&#34;./raster2d.ppm&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">55</span><span class="cl">    <span class="n">ofs</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;P6</span><span class="se">\n</span><span class="s">&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">w</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">h</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">255</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">56</span><span class="cl">    <span class="n">ofs</span><span class="p">.</span><span class="n">write</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">framebuffer</span><span class="p">,</span> <span class="n">w</span> <span class="o">*</span> <span class="n">h</span> <span class="o">*</span> <span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">57</span><span class="cl">    <span class="n">ofs</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">58</span><span class="cl">    
</span></span><span class="line"><span class="ln">59</span><span class="cl">    <span class="k">delete</span> <span class="p">[]</span> <span class="n">framebuffer</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">60</span><span class="cl">    
</span></span><span class="line"><span class="ln">61</span><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> 
</span></span><span class="line"><span class="ln">62</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>As you can see and in conclusion, we can say that the rasterization algorithm is in itself quite simple (and the basic implementation of this technique is quite easy as well).</p>
<h3 id="conclusion-and-whats-next">Conclusion and What&rsquo;s Next?</h3>
<p><a href="#R-image-c9c4a5c486ec4bcabbc9cabb48b29d34" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/../assets/barycentric6.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c9c4a5c486ec4bcabbc9cabb48b29d34"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/../assets/barycentric6.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 21:</strong> <em>barycentric coordinates are constant along lines parallel to an edge.</em></p>
<p>There are many interesting techniques and trivia related to the topic of barycentric coordinates but this lesson is just an introduction to the rasterization algorithm thus we won&rsquo;t go any further. One trivia that is interesting to know though, is that barycentric coordinates are constant along lines parallel to an edge (as shown in Figure 21).</p>
<p>In this lesson, we learned two important methods and various concepts.</p>
<ul>
<li>First, we learned about the edge function and how it can be used to find if a point P overlaps a triangle. The edge function is computed for each edge of the triangle, and a second vector is defined by the edge first vertex and another point P. If for all three edges, the function is positive, then point P overlaps the triangle.</li>
<li>Furthermore, we also learned that the result of the edge function can also be used to compute the barycentric coordinates of point P. These coordinates can be used to interpolate vertex data or vertex attributes across the surface of the triangle. They can be interpreted as weights for the various vertices. The most common vertex attribute is color, normal, and texture coordinates.</li>
</ul>
<h2 id="the-visibility-problem-the-depth-buffer-algorithm-and-depth-interpolation">The Visibility Problem, the Depth Buffer Algorithm and Depth Interpolation</h2>
<p>In the second chapter of this lesson, we learned that in the third coordinate of the projected point (the point in screen space) we store the original vertex z-coordinate (the z-coordinate of the point in camera space):</p>

<span class="math align-center">$$
\begin{array}{l}
P_{screen}.x = \dfrac{ near * P_{camera}.x }{ -P_{camera}.z}\\
P_{screen}.y = \dfrac{ near * P_{camera}.z }{ -P_{camera}.z}\\
P_{screen}.z = -P_{camera}.z\\
\end{array}
$$</span><p>Finding the z-coordinate of a point on the surface of the triangle is useful when a pixel overlaps more than one triangle. And the way we find that z-coordinate is by interpolating the original vertices z-coordinates using the barycentric coordinates that we learned about in the previous chapter. In other words, we can treat the z-coordinates of the triangle vertices as any other vertex attribute, and interpolate them the same way we interpolated colors in the previous chapter. Before we look into the details of how this z-coordinate is computed, let&rsquo;s start to explain why we need to do so.</p>
<h3 id="the-depth-buffer-or-z-buffer-algorithm-and-hidden-surface-removal">The Depth-Buffer or Z-Buffer Algorithm and Hidden Surface Removal</h3>
<p><a href="#R-image-fe541e6b2ce701c83c07cafd73941dc1" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/./assets/depth-buffer2.png?" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-fe541e6b2ce701c83c07cafd73941dc1"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/./assets/depth-buffer2.png?" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 1:</strong> <em>when a pixel overlaps a triangle, this pixel corresponds to a point on the surface of the triangle (noted P in this figure).</em></p>
<p><a href="#R-image-f6362ad465e1acbf34269bbfc97da377" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/./assets/depth-buffer1.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f6362ad465e1acbf34269bbfc97da377"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/./assets/depth-buffer1.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 2:</strong> <em>when a pixel overlaps several triangles, we can use the points on the triangle&rsquo;s z-coordinate to find which one of these triangles is the closest to the camera.</em></p>
<p>When a pixel overlaps a point, what we see through that pixel is a small area on the surface of a triangle, which for simplification we will reduce to a single point (denoted P in figure 1). Thus each pixel covering a triangle corresponds to a point on the surface of that triangle. Of course, if a pixel covers more than one triangle, we then have several of these points. The problem when this happens is to find which one of these points is visible. We have illustrated this concept in 2D in figure 2. We could test triangles from back to front (this technique would require sorting triangles by decreasing depth first) but this doesn&rsquo;t always work when triangle intersects each other (figure 2, bottom). The only reliable solution is to compute the depth of each triangle a pixel overlaps, and then compare these depth values to find out which one is the closest to the camera. If you look at figure 2, you can see that a pixel in the image overlaps two triangles in P1 and P2. However, the P1 z-coordinate (Z1) is lower than the P2 z-coordinate (Z2) thus we can deduce that P1 is in front of P2. Note that this technique is needed because triangles are tested in a &ldquo;random&rdquo; order. As mentioned before we could sort out triangles in decreasing depth order but this is not good enough. Generally, they are just tested in the order they are specified in the program, and for this reason, a triangle T1 that is closer to the camera can be tested before a triangle T2 that is further away. If we were not comparing these triangles&rsquo; depth, then we would end up in this case seeing the triangle which was tested last (T2) when in fact we should be seeing T1. As mentioned many times before, this is called the <strong>visibility problem</strong> or <strong>hidden surface problem</strong>. Algorithms for ordering objects so that they are drawn correctly are called visible surface algorithms or hidden surface removal algorithms. The depth-buffer or z-buffer algorithm that we are going to study next belongs to this category of algorithms.</p>
<p>One solution to the visibility problem is to use a <strong>depth-buffer</strong> or <strong>z-buffer</strong>. A depth-buffer is nothing more than a two-dimensional array of floats that has the same dimension as the frame-buffer and that is used to store the depth of the object as the triangles are being rasterized. When this array is created, we initialize each pixel in the array with a very large number. If we find that a pixel overlaps the current triangle, we do as follows:</p>
<ul>
<li>We first compute the z-coordinate or depth of the point on the triangle that the pixel overlaps.</li>
<li>We then compare that current triangle depth with the value stored in the depth buffer for that pixel.</li>
<li>If we find that the value stored in the depth-buffer is greater than the depth of the point on the triangle, then the new point is closer to the observer or the camera than the point stored in the depth buffer at that pixel location. The value stored in the depth-buffer is then replaced with the new depth, and the frame-buffer is updated with the current triangle color. On the other hand, if the value stored in the depth-buffer is smaller than the current depth sample, then the triangle that the pixel overlaps is hidden by the object whose depth is currently stored in the depth-buffer.</li>
</ul>
<p>Note that once all triangles have been processed, the depth-buffer contains &ldquo;some sort&rdquo; of image, that represents the &ldquo;distance&rdquo; between the visible parts of the objects in the scene and the camera (this is not a distance but the z-coordinate of each point visible through the camera). The depth buffer is essentially useful to solve the visibility problem, however, it can also be used in post-processing to do things such as 2D depth of field, adding fog, etc. All these effects are better done in 3D but applying them in 2D is often faster but the result is not always as accurate as what you can get in 3D.</p>
<p>Here is an implementation of the depth-buffer algorithm in pseudo-code:</p>
<div class="wrap-code highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">float</span> <span class="o">*</span><span class="n">depthBuffer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">float</span> <span class="p">[</span><span class="n">imageWidth</span> <span class="o">*</span> <span class="n">imageHeight</span><span class="p">];</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1">// Initialize depth-buffer with a very large number
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&amp;</span><span class="n">lt</span> <span class="n">imageHeight</span><span class="p">;</span> <span class="o">++</span><span class="n">y</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&amp;</span><span class="n">lt</span> <span class="n">imageWidth</span><span class="p">;</span> <span class="o">++</span><span class="n">x</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">        <span class="n">depthBuffer</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">INFINITY</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="n">each</span> <span class="n">triangle</span> <span class="n">in</span> <span class="n">the</span> <span class="n">scene</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="c1">// Project triangle vertices
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1"></span>    <span class="p">...</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="c1">// Compute 2D triangle bounding-box
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="c1"></span>    <span class="p">...</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">y</span> <span class="o">=</span> <span class="n">bbox</span><span class="p">.</span><span class="n">min</span><span class="p">.</span><span class="n">y</span><span class="p">;</span> <span class="n">y</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">=</span> <span class="n">bbox</span><span class="p">.</span><span class="n">max</span><span class="p">.</span><span class="n">y</span><span class="p">;</span> <span class="o">++</span><span class="n">y</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">x</span> <span class="o">=</span> <span class="n">bbox</span><span class="p">.</span><span class="n">min</span><span class="p">.</span><span class="n">x</span><span class="p">;</span> <span class="n">x</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">=</span> <span class="n">bbox</span><span class="p">.</span><span class="n">max</span><span class="p">.</span><span class="n">x</span><span class="p">;</span> <span class="o">++</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">           <span class="k">if</span> <span class="p">(</span><span class="n">pixelOverlapsTriangle</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">                <span class="c1">// Compute the z-coordinate of the point on the triangle surface
</span></span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="c1"></span>                <span class="kt">float</span> <span class="n">z</span> <span class="o">=</span> <span class="n">computeDepth</span><span class="p">(...);</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">                <span class="c1">// Current point is closest than object stored in depth/frame-buffer
</span></span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="c1"></span>                <span class="k">if</span> <span class="p">(</span><span class="n">z</span> <span class="o">&amp;</span><span class="n">lt</span> <span class="n">depthBuffer</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">                     <span class="c1">// Update depth-buffer with that depth
</span></span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="c1"></span>                     <span class="n">depthBuffer</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">z</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">                     <span class="n">frameBuffer</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">triangleColor</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">        <span class="p">}</span> 
</span></span><span class="line"><span class="ln">25</span><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="ln">26</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><h3 id="finding-z-by-interpolation">Finding Z by Interpolation</h3>
<p><a href="#R-image-8dfcf1edd862c4fcc37183c875fbc0cc" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/./assets/interpolate-depth.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-8dfcf1edd862c4fcc37183c875fbc0cc"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/./assets/interpolate-depth.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 3:</strong> <em>can we find the depth of P by interpolating the z coordinates of the triangles vertices z-coordinates using barycentric coordinates?</em></p>
<p><a href="#R-image-1ad8918d8e88772029f0d89bc8fa7dfa" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/./assets/depth-interpolation1.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-1ad8918d8e88772029f0d89bc8fa7dfa"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/./assets/depth-interpolation1.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 4:</strong> <em>finding the y-coordinate of a point by linear interpolation.</em></p>
<p>Hopefully, the principle of the depth-buffer is simple and easy to understand. All we need to do now is explained how depth values are computed. First, let&rsquo;s repeat one more time what that depth value is. When a pixel overlaps a triangle, it overlaps a small surface on the surface of the triangle, which as mentioned in the introduction we will reduce to a point for simplification (point P in figure 1). What we want to find here, is this point z-coordinate. As also mentioned earlier in this chapter, if we know the triangle vertices&rsquo; z-coordinate (which we do, they are stored in the projected point z-coordinate), all we need to do is interpolate these coordinates using P&rsquo;s barycentric coordinates (figure 4):</p>

<span class="math align-center">$$P.z = \lambda_0 * V0.z + \lambda_1 * V1.z + \lambda_2 * V2.z.$$</span><p>Technically this sounds reasonable, though unfortunately, it doesn&rsquo;t work. Let&rsquo;s see why. The problem is not in the formula itself which is perfectly fine. The problem is that once the vertices of a triangle are projected onto the canvas (once we have performed the perspective divide), then z, the value we want to interpolate, doesn&rsquo;t vary linearly anymore across the surface of the 2D triangle. This is easier to demonstrate with a 2D example.</p>
<p>The secret lies in figure 4. Imagine that we want to find the &ldquo;image&rdquo; of a line defined in 2D space by two vertices V0 and V1. The canvas is represented by the horizontal green line. This line is one unit away (along the z-axis) from the coordinate system origin. If we trace lines from V0 and V1 to the origin, then we intersect the green lines in two points (denoted V0&rsquo; and V1&rsquo; in the figure). The z-coordinate of this point is 1 since they lie on the canvas which is 1 unit away from the origin. The x-coordinate of the points can easily be computed using perspective projection. We just need to divide the original vertex x-coordinates by their z-coordinate. We get:</p>

<span class="math align-center">$$
\begin{array}{l}
V0'.x = \dfrac{V0.x}{V0.z} = \dfrac{-4}{2} = -2,\\
V1'.x = \dfrac{V1.x}{V1.z} = \dfrac{2}{5} = 0.4.
\end{array}
$$</span><p>The goal of the exercise is to find the z-coordinate of P, a point on the line defined by V0 and V1. In this example, all we know about P is the position of its projection P&rsquo;, on the green line. The coordinates of P&rsquo; are {0,1}. The problem is similar to trying to find the z-coordinate of a point on the triangle that a pixel overlaps. In our example, P&rsquo; would be the pixel and P would be the point on the triangle that the pixel overlaps. What we need to do now, is compute the &ldquo;barycentric coordinate&rdquo; of P&rsquo; with respect to V0&rsquo; and V1&rsquo;. Let&rsquo;s call the resulting value 
<span class="math align-center">$\lambda$</span>. Like our triangle barycentric coordinates, 
<span class="math align-center">$\lambda$</span> is also in the range [0,1]. To find 
<span class="math align-center">$\lambda$</span>, we just need to take the distance between V0&rsquo; and P&rsquo; (along the x-axis), and divide this number by the distance between V0&rsquo; and V1&rsquo;. If linearly interpolating the z-coordinates of the original vertices V0 and V1 using 
<span class="math align-center">$\lambda$</span> to find the depth of P works, then we should get the number 4 (we can easily see by just looking at the illustration that the coordinates of P are {0,4}). Let&rsquo;s first compute 
<span class="math align-center">$\lambda$</span>:</p>

<span class="math align-center">$$\lambda=\dfrac{P'x - V0'.x}{V1'.x - V0'.x} = \dfrac{0--2}{0.4--2}= \dfrac{2}{2.4} = 0.833.$$</span><p>If we now linearly interpolate V0 and V1 z-coordinate to find the P z-coordinate we get:</p>

<span class="math align-center">$$P.z = V0.z * (1-\lambda) + V1.z * \lambda\ = 2 * 1.666 + 5 * 0.833 = 4.5.$$</span><p>This is not the value we expect! Interpolating the original vertices z-coordinates, using P&rsquo;s &ldquo;barycentric coordinates&rdquo; or (\lambda) in this example, to find P z-coordinate doesn&rsquo;t work. Why? The reason is simple. <b>Perspective projection preserves lines but does not preserve distances</b>. It&rsquo;s quite easy to see in figure 4, that the ratio of the distance between V0 and P over the distance between V0 and V1 (0.666) is not the same as the ratio of the distance between V0&rsquo; and P&rsquo; over the distance between V0&rsquo; and V1&rsquo; (0.833). If (\lambda) was equal to 0.666 it would work fine, but here is the problem, it&rsquo;s equal to 0.833 instead! So, how do we find the z-coordinate of P?</p>
<p>The solution to the problem is to compute the inverse of the P z-coordinate by interpolating the inverse of the vertices V0 and V1 z-coordinates using \(\lambda\). In other words, the solution is:</p>

<span class="math align-center">$$\dfrac{1}{P.z} = \color{purple}{\dfrac{1}{V0.z} * (1-\lambda) + \dfrac{1}{V1.z} * \lambda}.$$</span><p>Let&rsquo;s check that it works:</p>

<span class="math align-center">$$\dfrac{1}{P.z} = \dfrac{1}{V0.z} * (1-\lambda) + \dfrac{1}{V1.z} * \lambda = \dfrac{1}{2} * (1-2/2.4)+ \dfrac{1}{5} * (2/2.4) = 0.25.$$</span><p>If now take the inverse of this result, we get for P z-coordinate the value 4. Which is the correct result! As mentioned before, the solution is to linearly interpolate the vertex&rsquo;s z-coordinates using barycentric coordinates, and invert the resulting number to find the depth of P (its z-coordinate). In the case of our triangle, the formula is:</p>

<span class="math align-center">$$\dfrac{1}{P.z} = \dfrac{1}{V0.z} * \lambda_0 + \dfrac{1}{V1.z} * \lambda_1 + \dfrac{1}{V2.z} * \lambda_2.$$</span><p><a href="#R-image-879b11bfd877b86ddb64dde27f1eecc2" class="lightbox-link"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/./assets/perspective-correct.png" alt="" class="figure-image bg-white border lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-879b11bfd877b86ddb64dde27f1eecc2"><img src="../../../computer_graphics/classic_tutorial/raytracing_tutorial/scratchapixel/scratchapixel-chapter-6/./assets/perspective-correct.png" alt="" class="lightbox-image bg-white border lightbox noshadow" loading="lazy"></a></p>
<p><strong>Figure 5:</strong> <em>perspective projection preserves lines but not distances.</em></p>
<p>Let&rsquo;s now look into this problem more formally. Why do we need to interpolate the vertex&rsquo;s inverse z-coordinates? The formal explanation is a bit complicated and you can skip it if you want. Let&rsquo;s consider a line in camera space defined by two vertices whose coordinates are denoted 
<span class="math align-center">$(X_0,Z_0)
$</span> and 
<span class="math align-center">$(X_1,Z_1)$</span>. The projection of these vertices on the screen is denoted 
<span class="math align-center">$S_0$</span> and 
<span class="math align-center">$S_1$</span> respectively (in our example, we will assume that the distance between the camera origin and the canvas is 1 as shown in figure 5). Let&rsquo;s call S a point on the line defined by (S_0) and (S_1). S has a corresponding point P on the 2D line whose coordinates are (X,Z = 1) (we assume in this example that the screen or the vertical line on which the points are projected is 1 unit away from the coordinate system origin). Finally, the parameters (t) and (q) are defined such that:</p>

<span class="math align-center">$$
\begin{array}{l}
P = P_0 * (1-t) + P_1 * t,\\
S = S_0 * (1-q) + S_1 * q.\\
\end{array}
$$</span><p>Which we can also write as:</p>

<span class="math align-center">$$
\begin{array}{l}
P = P_0 + t * (P_1 - P_0),\\
S = S_0 + q * (S_1 - S_0).\\
\end{array}
$$</span><p>The (X,Z) coordinates of point P can thus be computed by interpolation (equation 1):</p>

<span class="math align-center">$$(X,Z) = (X_0 + t * (X_1 - X_0), Z_0 + t * (Z_1 - Z_0)).$$</span><p>Similarly (equation 2):</p>

<span class="math align-center">$$S = S_0 + q * (S_1 - S_0).$$</span><p>S is a 1D point (it has been projected on the screen) thus it has no z-coordinate. S can also be computed as:</p>

<span class="math align-center">$$S = \dfrac{X}{Z}.$$</span><p>Therefore:</p>

<span class="math align-center">$$Z = \dfrac{X}{S}.$$</span><p>If we replace the numerator with equation 1 and the denominator with equation 2, then we get (equation 3):</p>

<span class="math align-center">$$Z = \dfrac{\color{red}{X_0} + t * (\color{green}{X_1} - \color{red}{X_0})}{S_0 + q * (S_1 - S_0)}$$</span><p>We also have:</p>

<span class="math align-center">$$\begin{array}{l}
S_0 = \dfrac{X_0}{Z_0},\\
S_1 = \dfrac{X_1}{Z_1}.
\end{array}$$</span><p>Therefore (equation 4):</p>

<span class="math align-center">$$\begin{array}{l}
\color{red}{X_0 = S_0 * Z_0},\\
\color{green}{X_1 = S_1 * Z_1}.
\end{array}
$$</span><p>If now replace 
<span class="math align-center">$X_0$</span> and 
<span class="math align-center">$X_1$</span> in equation 3 with equation 4, we get (equation 5):</p>

<span class="math align-center">$$Z = \dfrac{\color{red}{S_0 * Z_0} + t * (\color{green}{S_1 * Z_1} - \color{red}{S_0 * Z_0})}{S_0 + q * (S_1 - S_0)}$$</span><p>Remember from equation 1 that (equation 6):</p>

<span class="math align-center">$$Z = Z_0 + t * (Z_1 - Z_0).$$</span><p>If we combine equations 5 and 6 we get:</p>

<span class="math align-center">$$Z_0 + t * (Z_1 - Z_0) = \dfrac{\color{red}{S_0 * Z_0} + t * (\color{green}{S_1 * Z_1} - \color{red}{S_0 * Z_0})}{S_0 + q * (S_1 - S_0)}.$$</span><p>Which can be simplified to:</p>

<span class="math align-center">$$
\begin{array}{l}
(Z_0 + t (Z_1 - Z_0))(S_0 + q(S_1 - S_0))=S_0Z_0 + t(S_1Z_1 - S_0Z_0),\\
Z_0S_0 + Z_0q(S_1 - S_0)+t(Z_1 - Z_0)S_0+t (Z_1 - Z_0)q(S_1 - S_0)=S_0Z_0 + t (S_1Z_1 - S_0Z_0),\\
t[(Z_1 - Z_0)S_0 + (Z_1 - Z_0)q(S_1 - S_0) -(S_1Z_1 - S_0Z_0)] =-qZ_0(S_1 - S_0),\\
t[Z_1S_0 - Z_0S_0 + (Z_1 - Z_0)q(S_1 - S_0) - S_1Z_1 + S_0Z_0] =-qZ_0(S_1 - S_0),\\
t(S_1 - S_0)[Z_1 - q(Z_1 - Z_0)]=qZ_0(S_1 - S_0),\\
t[qZ_0 +(1-q)Z_1]=qZ_0.
\end{array}
$$</span><p>We can now express the parameter 
<span class="math align-center">$t$</span> in terms of 
<span class="math align-center">$q$</span>:</p>

<span class="math align-center">$$t=\dfrac{qZ_0}{qZ_0 +(1-q)Z_1}.$$</span><p>If we substitute for t in equation 6, we get:</p>

<span class="math align-center">$$
\begin{array}{l}
Z &= Z_0 + t * (Z_1 - Z_0) = Z_0 + \dfrac{qZ_0(Z_1 - Z_0)}{qZ_0 +(1-q)Z_1},\\
&= \dfrac{qZ_0^2 + (1-q)Z_0Z_1 + qZ_0Z_1 - qZ_0^2}{qZ_0 +(1-q)Z_1},\\
&= \dfrac{Z_0Z_1}{qZ_0 +(1-q)Z_1},\\
&= \dfrac{1}{\dfrac{q}{Z_1} + \dfrac{(1-q)}{Z_0}},\\
&= \dfrac{1}{\dfrac{1}{Z_0} +q (\dfrac{1}{Z1} - \dfrac{1}{Z_0})}.\\
\end{array}
$$</span><p>And from there you can write:</p>

<span class="math align-center">$$\begin{array}{l}
\dfrac{1}{Z} &= \dfrac{1}{Z_0} +q (\dfrac{1}{Z1} - \dfrac{1}{Z_0}) = \color{purple}{\dfrac{1}{Z_0}(1-q) + \dfrac{1}{Z_1}q}.
\end{array}
$$</span><p>Which is the formula we wanted to end up with.</p>
<blockquote>
<details>
You can use a different approach to explain the depth interpolation issue (but we prefer the one above). You can see the triangle (in 3D or camera space) lying on a plane. The plane equation is (equation 1):

<span class="math align-center">$$AX + BY + CZ = D.$$</span><p>We know that:</p>

<span class="math align-center">$$
\begin{array}{l}
X_{screen} = \dfrac{X_{camera}}{Z_{camera}},\\
Y_{screen} = \dfrac{Y_{camera}}{Z_{camera}}.\\
\end{array}
$$</span><p>Thus:</p>

<span class="math align-center">$$
\begin{array}{l}
X_{camera} = X_{screen}Z_{camera},\\
Y_{camera} = Y_{screen}Z_{camera}.
\end{array}
$$</span><p>If we substitute these two equations in equation 1 and solve for (Z_{camera}), we get:</p>

<span class="math align-center">$$
\begin{array}{l}
AX_{screen}Z_{camera} + BY_{screen}Z_{camera} + CZ_{camera} = D,\\
Z_{camera}(AX_{screen} + BY_{screen} + C) = D,\\
\dfrac{D}{Z_{camera}} = AX_{screen} + BY_{screen} + C,\\
\dfrac{1}{Z_{camera}} = \dfrac{A}{D}X_{screen} + \dfrac{B}{D}Y_{screen} + \dfrac{C}{D},\\
\dfrac{1}{Z_{camera}} = {A'}X_{screen} + {B'}Y_{screen} + {C'},\\
\end{array}
$$</span><p>With: 
<span class="math align-center">$A'=\dfrac{A}{D}$</span>, 
<span class="math align-center">$B'=\dfrac{B}{D}$</span>, 
<span class="math align-center">$C'=\dfrac{C}{D}$</span>.</p>
<p>What this equation shows is that (1/Z_{camera}) is an affine function of (X_{camera}) and (Y_{camera}) which can be interpolated linearly across the surface of the projected triangle (the triangle in screen, NDC or raster space).</p>
</details>
</blockquote>
<h3 id="other-visible-surface-algorithms">Other Visible Surface Algorithms</h3>
<p>As mentioned in the introduction, the z-buffer algorithm belongs to the family of hidden surface removal or visible surface algorithms. These algorithms can be divided into two categories: the <strong>object space</strong> and <strong>image space algorithms</strong>. The <a href="http://en.wikipedia.org/wiki/Painter%27s_algorithm" target="_blank">&ldquo;painter&rsquo;s&rdquo; algorithm</a> which we haven&rsquo;t talked about in this lesson belongs to the former, while the z-buffer algorithm belongs to the latter type. The concept behind the painter&rsquo;s algorithm is roughly to paint or draw objects from back to front. This technique requires objects to be sorted in depth. As explained earlier in this chapter, first objects are passed down to the renderer in arbitrary order, and then when two triangles intersect each other, it becomes difficult to figure out which one is in front of the other (thus deciding which one should be drawn first). This algorithm is not used anymore but the z-buffer is very common (GPUs use it).</p>

            <footer class="footline">
            </footer>
          </article>

          </section>
          </section>
        </div>
      </main>
    </div>
    <script src="../../../js/clipboard.min.js?1708235003" defer></script>
    <script src="../../../js/perfect-scrollbar.min.js?1708235003" defer></script>
    <script>
      function useMathJax( config ){
        if( !Object.assign ){
          
          return;
        }
        window.MathJax = Object.assign( window.MathJax || {}, {
          loader: {
            load: ['[tex]/mhchem']
          },
          startup: {
            elements: [
              '.math'
            ]
          },
          tex: {
            inlineMath: [
              ['$', '$'], 
              ['\\(', '\\)']
            ]
          },
          options: {
            enableMenu: false 
          }
        }, config );
      }
      useMathJax( JSON.parse("{}") );
    </script>
    <script id="MathJax-script" async src="../../../js/mathjax/tex-mml-chtml.js?1708235003"></script>
    <script src="../../../js/theme.js?1708235003" defer></script>
  </body>
</html>
